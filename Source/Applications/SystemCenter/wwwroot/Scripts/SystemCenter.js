/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"SystemCenter": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171":"vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171","AssetGroup~ByAssetGroup":"AssetGroup~ByAssetGroup","AssetGroup":"AssetGroup","ByAssetGroup":"ByAssetGroup","Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard":"Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard","Asset~ByAsset~Location~Meter~NewMeterWizard":"Asset~ByAsset~Location~Meter~NewMeterWizard","Asset~ByAsset":"Asset~ByAsset","ByAsset":"ByAsset","Asset~Company~Customer~Location~Meter":"Asset~Company~Customer~Location~Meter","Asset":"Asset","Location":"Location","Meter":"Meter","NewMeterWizard":"NewMeterWizard","Customer":"Customer","ByLocation":"ByLocation","ByCustomer":"ByCustomer","ByMeter":"ByMeter","ByUser~User":"ByUser~User","ByUser":"ByUser","User":"User","ConfigurationHistory":"ConfigurationHistory","UserStatistics":"UserStatistics","vendors~ByCompany~Company":"vendors~ByCompany~Company","Company":"Company","ByCompany":"ByCompany"}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							var error = new Error('Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')');
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "Scripts/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./TSX/SystemCenter/SystemCenter.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/extends.js":
/*!********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*************************************************************************************************************************/
/*! exports provided: createNextState, current, createSelector, MiddlewareArray, configureStore, createAction, createAsyncThunk, createEntityAdapter, createImmutableStateInvariantMiddleware, createReducer, createSerializableStateInvariantMiddleware, createSlice, findNonSerializableValue, getDefaultMiddleware, getType, isImmutableDefault, isPlain, nanoid, unwrapResult, __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MiddlewareArray", function() { return MiddlewareArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureStore", function() { return configureStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAction", function() { return createAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAsyncThunk", function() { return createAsyncThunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEntityAdapter", function() { return createEntityAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createImmutableStateInvariantMiddleware", function() { return createImmutableStateInvariantMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReducer", function() { return createReducer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSerializableStateInvariantMiddleware", function() { return createSerializableStateInvariantMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSlice", function() { return createSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNonSerializableValue", function() { return findNonSerializableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultMiddleware", function() { return getDefaultMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImmutableDefault", function() { return isImmutableDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPlain", function() { return isPlain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nanoid", function() { return nanoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unwrapResult", function() { return unwrapResult; });
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immer */ "../../node_modules/immer/dist/immer.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createNextState", function() { return immer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "current", function() { return immer__WEBPACK_IMPORTED_MODULE_0__["current"]; });

/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux */ "../../node_modules/redux/es/redux.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["__DO_NOT_USE__ActionTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["applyMiddleware"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["bindActionCreators"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["combineReducers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["compose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["createStore"]; });

/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! reselect */ "../../node_modules/reselect/es/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSelector", function() { return reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"]; });

/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ "../../node_modules/redux-thunk/es/index.js");








function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * @public
 */

var composeWithDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
  if (arguments.length === 0) return undefined;
  if (typeof arguments[0] === 'object') return redux__WEBPACK_IMPORTED_MODULE_1__["compose"];
  return redux__WEBPACK_IMPORTED_MODULE_1__["compose"].apply(null, arguments);
};

/**
 * Returns true if the passed value is "plain" object, i.e. an object whose
 * protoype is the root `Object.prototype`. This includes objects created
 * using object literals, but not for instance for class instances.
 *
 * @param {any} value The value to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(value) {
  if (typeof value !== 'object' || value === null) return false;
  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
}

function getTimeMeasureUtils(maxDelay, fnName) {
  var elapsed = 0;
  return {
    measureTime: function measureTime(fn) {
      var started = Date.now();

      try {
        return fn();
      } finally {
        var finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded: function warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
      }
    }
  };
}
/**
 * @public
 */

var MiddlewareArray =
/*#__PURE__*/
function (_Array) {
  _inheritsLoose(MiddlewareArray, _Array);

  function MiddlewareArray() {
    return _Array.apply(this, arguments) || this;
  }

  var _proto = MiddlewareArray.prototype;

  _proto.concat = function concat() {
    var _Array$prototype$conc;

    for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
      arr[_key] = arguments[_key];
    }

    return _construct(MiddlewareArray, (_Array$prototype$conc = _Array.prototype.concat).call.apply(_Array$prototype$conc, [this].concat(arr)));
  };

  _proto.prepend = function prepend() {
    for (var _len2 = arguments.length, arr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      arr[_key2] = arguments[_key2];
    }

    if (arr.length === 1 && Array.isArray(arr[0])) {
      return _construct(MiddlewareArray, arr[0].concat(this));
    }

    return _construct(MiddlewareArray, arr.concat(this));
  };

  return MiddlewareArray;
}(
/*#__PURE__*/
_wrapNativeSuper(Array));

var isProduction = "development" === 'production';
var prefix = 'Invariant failed'; // Throw an error if the condition fails
// Strip out error messages for production
// > Not providing an inline default argument for message as the result is smaller

function invariant(condition, message) {
  if (condition) {
    return;
  } // Condition not passed
  // In production we strip the message but still throw


  if (isProduction) {
    throw new Error(prefix);
  } // When not in production we allow the message to pass through
  // *This block will be removed in production builds*


  throw new Error(prefix + ": " + (message || ''));
}

function stringify(obj, serializer, indent, decycler) {
  return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}

function getSerialize(serializer, decycler) {
  var stack = [],
      keys = [];
  if (!decycler) decycler = function decycler(_, value) {
    if (stack[0] === value) return '[Circular ~]';
    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
  };
  return function (key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
      if (~stack.indexOf(value)) value = decycler.call(this, key, value);
    } else stack.push(value);

    return serializer == null ? value : serializer.call(this, key, value);
  };
}
/**
 * The default `isImmutable` function.
 *
 * @public
 */


function isImmutableDefault(value) {
  return typeof value !== 'object' || value === null || typeof value === 'undefined';
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations: function detectMutations() {
      return _detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}

function trackProperties(isImmutable, ignorePaths, obj, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }

  if (path === void 0) {
    path = [];
  }

  var tracked = {
    value: obj
  };

  if (!isImmutable(obj)) {
    tracked.children = {};

    for (var key in obj) {
      var childPath = path.concat(key);

      if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {
        continue;
      }

      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }

  return tracked;
}

function _detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }

  if (sameParentRef === void 0) {
    sameParentRef = false;
  }

  if (path === void 0) {
    path = [];
  }

  var prevObj = trackedProperty ? trackedProperty.value : undefined;
  var sameRef = prevObj === obj;

  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path: path
    };
  }

  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  } // Gather all keys from prev (tracked) and after objs


  var keysToDetect = {};
  Object.keys(trackedProperty.children).forEach(function (key) {
    keysToDetect[key] = true;
  });
  Object.keys(obj).forEach(function (key) {
    keysToDetect[key] = true;
  });
  var keys = Object.keys(keysToDetect);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var childPath = path.concat(key);

    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {
      continue;
    }

    var result = _detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);

    if (result.wasMutated) {
      return result;
    }
  }

  return {
    wasMutated: false
  };
}
/**
 * Creates a middleware that checks whether any state was mutated in between
 * dispatches or during a dispatch. If any mutations are detected, an error is
 * thrown.
 *
 * @param options Middleware options.
 *
 * @public
 */


function createImmutableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  if (false) {}

  var _options = options,
      _options$isImmutable = _options.isImmutable,
      isImmutable = _options$isImmutable === void 0 ? isImmutableDefault : _options$isImmutable,
      ignoredPaths = _options.ignoredPaths,
      _options$warnAfter = _options.warnAfter,
      warnAfter = _options$warnAfter === void 0 ? 32 : _options$warnAfter,
      ignore = _options.ignore; // Alias ignore->ignoredPaths, but prefer ignoredPaths if present

  ignoredPaths = ignoredPaths || ignore;
  var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
  return function (_ref) {
    var getState = _ref.getState;
    var state = getState();
    var tracker = track(state);
    var result;
    return function (next) {
      return function (action) {
        var measureUtils = getTimeMeasureUtils(warnAfter, 'ImmutableStateInvariantMiddleware');
        measureUtils.measureTime(function () {
          state = getState();
          result = tracker.detectMutations(); // Track before potentially not meeting the invariant

          tracker = track(state);
          !!result.wasMutated ?  true ? invariant(false, "A state mutation was detected between dispatches, in the path '" + (result.path || []).join('.') + "'.  This may cause incorrect behavior. (https://redux.js.org/troubleshooting#never-mutate-reducer-arguments)") : undefined : void 0;
        });
        var dispatchedAction = next(action);
        measureUtils.measureTime(function () {
          state = getState();
          result = tracker.detectMutations(); // Track before potentially not meeting the invariant

          tracker = track(state);
          result.wasMutated && (!!result.wasMutated ?  true ? invariant(false, "A state mutation was detected inside a dispatch, in the path: " + (result.path || []).join('.') + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/troubleshooting#never-mutate-reducer-arguments)") : undefined : void 0);
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  };
}

/**
 * Returns true if the passed value is "plain", i.e. a value that is either
 * directly JSON-serializable (boolean, number, string, array, plain object)
 * or `undefined`.
 *
 * @param val The value to check.
 *
 * @public
 */

function isPlain(val) {
  return typeof val === 'undefined' || val === null || typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number' || Array.isArray(val) || isPlainObject(val);
}
/**
 * @public
 */

function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
  if (path === void 0) {
    path = [];
  }

  if (isSerializable === void 0) {
    isSerializable = isPlain;
  }

  if (ignoredPaths === void 0) {
    ignoredPaths = [];
  }

  var foundNestedSerializable;

  if (!isSerializable(value)) {
    return {
      keyPath: path.join('.') || '<root>',
      value: value
    };
  }

  if (typeof value !== 'object' || value === null) {
    return false;
  }

  var entries = getEntries != null ? getEntries(value) : Object.entries(value);
  var hasIgnoredPaths = ignoredPaths.length > 0;

  for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _ref2 = _ref,
        property = _ref2[0],
        nestedValue = _ref2[1];
    var nestedPath = path.concat(property);

    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {
      continue;
    }

    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath.join('.'),
        value: nestedValue
      };
    }

    if (typeof nestedValue === 'object') {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);

      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }

  return false;
}
/**
 * Creates a middleware that, after every state change, checks if the new
 * state is serializable. If a non-serializable value is found within the
 * state, an error is printed to the console.
 *
 * @param options Middleware options.
 *
 * @public
 */

function createSerializableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  if (false) {}

  var _options = options,
      _options$isSerializab = _options.isSerializable,
      isSerializable = _options$isSerializab === void 0 ? isPlain : _options$isSerializab,
      getEntries = _options.getEntries,
      _options$ignoredActio = _options.ignoredActions,
      ignoredActions = _options$ignoredActio === void 0 ? [] : _options$ignoredActio,
      _options$ignoredActio2 = _options.ignoredActionPaths,
      ignoredActionPaths = _options$ignoredActio2 === void 0 ? ['meta.arg'] : _options$ignoredActio2,
      _options$ignoredPaths = _options.ignoredPaths,
      ignoredPaths = _options$ignoredPaths === void 0 ? [] : _options$ignoredPaths,
      _options$warnAfter = _options.warnAfter,
      warnAfter = _options$warnAfter === void 0 ? 32 : _options$warnAfter;
  return function (storeAPI) {
    return function (next) {
      return function (action) {
        if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {
          return next(action);
        }

        var measureUtils = getTimeMeasureUtils(warnAfter, 'SerializableStateInvariantMiddleware');
        measureUtils.measureTime(function () {
          var foundActionNonSerializableValue = findNonSerializableValue(action, [], isSerializable, getEntries, ignoredActionPaths);

          if (foundActionNonSerializableValue) {
            var keyPath = foundActionNonSerializableValue.keyPath,
                value = foundActionNonSerializableValue.value;
            console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, '\nTake a look at the logic that dispatched this action: ', action, '\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)', '\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)');
          }
        });
        var result = next(action);
        measureUtils.measureTime(function () {
          var state = storeAPI.getState();
          var foundStateNonSerializableValue = findNonSerializableValue(state, [], isSerializable, getEntries, ignoredPaths);

          if (foundStateNonSerializableValue) {
            var keyPath = foundStateNonSerializableValue.keyPath,
                value = foundStateNonSerializableValue.value;
            console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
          }
        });
        measureUtils.warnIfExceeded();
        return result;
      };
    };
  };
}

function isBoolean(x) {
  return typeof x === 'boolean';
}

function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
/**
 * Returns any array containing the default middleware installed by
 * `configureStore()`. Useful if you want to configure your store with a custom
 * `middleware` array but still keep the default set.
 *
 * @return The default middleware used by `configureStore()`.
 *
 * @public
 */

function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$thunk = _options.thunk,
      thunk = _options$thunk === void 0 ? true : _options$thunk,
      _options$immutableChe = _options.immutableCheck,
      immutableCheck = _options$immutableChe === void 0 ? true : _options$immutableChe,
      _options$serializable = _options.serializableCheck,
      serializableCheck = _options$serializable === void 0 ? true : _options$serializable;
  var middlewareArray = new MiddlewareArray();

  if (thunk) {
    if (isBoolean(thunk)) {
      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"]);
    } else {
      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"].withExtraArgument(thunk.extraArgument));
    }
  }

  if (true) {
    if (immutableCheck) {
      /* PROD_START_REMOVE_UMD */
      var immutableOptions = {};

      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }

      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
      /* PROD_STOP_REMOVE_UMD */
    }

    if (serializableCheck) {
      var serializableOptions = {};

      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }

      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
  }

  return middlewareArray;
}

var IS_PRODUCTION = "development" === 'production';
/**
 * A friendly abstraction over the standard Redux `createStore()` function.
 *
 * @param config The store configuration.
 * @returns A configured Redux store.
 *
 * @public
 */

function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();

  var _ref = options || {},
      _ref$reducer = _ref.reducer,
      reducer = _ref$reducer === void 0 ? undefined : _ref$reducer,
      _ref$middleware = _ref.middleware,
      middleware = _ref$middleware === void 0 ? curriedGetDefaultMiddleware() : _ref$middleware,
      _ref$devTools = _ref.devTools,
      devTools = _ref$devTools === void 0 ? true : _ref$devTools,
      _ref$preloadedState = _ref.preloadedState,
      preloadedState = _ref$preloadedState === void 0 ? undefined : _ref$preloadedState,
      _ref$enhancers = _ref.enhancers,
      enhancers = _ref$enhancers === void 0 ? undefined : _ref$enhancers;

  var rootReducer;

  if (typeof reducer === 'function') {
    rootReducer = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer = Object(redux__WEBPACK_IMPORTED_MODULE_1__["combineReducers"])(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }

  var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_1__["applyMiddleware"].apply(void 0, typeof middleware === 'function' ? middleware(curriedGetDefaultMiddleware) : middleware);
  var finalCompose = redux__WEBPACK_IMPORTED_MODULE_1__["compose"];

  if (devTools) {
    finalCompose = composeWithDevTools(_extends({
      // Enable capture of stack traces for dispatched Redux actions
      trace: !IS_PRODUCTION
    }, typeof devTools === 'object' && devTools));
  }

  var storeEnhancers = [middlewareEnhancer];

  if (Array.isArray(enhancers)) {
    storeEnhancers = [middlewareEnhancer].concat(enhancers);
  } else if (typeof enhancers === 'function') {
    storeEnhancers = enhancers(storeEnhancers);
  }

  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return Object(redux__WEBPACK_IMPORTED_MODULE_1__["createStore"])(rootReducer, preloadedState, composedEnhancer);
}

function createAction(type, prepareAction) {
  function actionCreator() {
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, arguments);

      if (!prepared) {
        throw new Error('prepareAction did not return an object');
      }

      return _extends({
        type: type,
        payload: prepared.payload
      }, 'meta' in prepared && {
        meta: prepared.meta
      }, {}, 'error' in prepared && {
        error: prepared.error
      });
    }

    return {
      type: type,
      payload: arguments.length <= 0 ? undefined : arguments[0]
    };
  }

  actionCreator.toString = function () {
    return "" + type;
  };

  actionCreator.type = type;

  actionCreator.match = function (action) {
    return action.type === type;
  };

  return actionCreator;
}
function isFSA(action) {
  return isPlainObject(action) && typeof action.type === 'string' && Object.keys(action).every(isValidKey);
}

function isValidKey(key) {
  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1;
}
/**
 * Returns the action type of the actions created by the passed
 * `createAction()`-generated action creator (arbitrary action creators
 * are not supported).
 *
 * @param action The action creator whose action type to get.
 * @returns The action type used by the action creator.
 *
 * @public
 */


function getType(actionCreator) {
  return "" + actionCreator;
}

function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function addCase(typeOrActionCreator, reducer) {
      if (true) {
        /*
         to keep the definition by the user in line with actual behavior,
         we enforce `addCase` to always be called before calling `addMatcher`
         as matching cases take precedence over matchers
         */
        if (actionMatchers.length > 0) {
          throw new Error('`builder.addCase` should only be called before calling `builder.addMatcher`');
        }

        if (defaultCaseReducer) {
          throw new Error('`builder.addCase` should only be called before calling `builder.addDefaultCase`');
        }
      }

      var type = typeof typeOrActionCreator === 'string' ? typeOrActionCreator : typeOrActionCreator.type;

      if (type in actionsMap) {
        throw new Error('addCase cannot be called with two reducers for the same action type');
      }

      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher: function addMatcher(matcher, reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error('`builder.addMatcher` should only be called before calling `builder.addDefaultCase`');
        }
      }

      actionMatchers.push({
        matcher: matcher,
        reducer: reducer
      });
      return builder;
    },
    addDefaultCase: function addDefaultCase(reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error('`builder.addDefaultCase` can only be called once');
        }
      }

      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}

function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }

  var _ref = typeof mapOrBuilderCallback === 'function' ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer],
      actionsMap = _ref[0],
      finalActionMatchers = _ref[1],
      finalDefaultCaseReducer = _ref[2];

  return function (state, action) {
    if (state === void 0) {
      state = initialState;
    }

    var caseReducers = [actionsMap[action.type]].concat(finalActionMatchers.filter(function (_ref2) {
      var matcher = _ref2.matcher;
      return matcher(action);
    }).map(function (_ref3) {
      var reducer = _ref3.reducer;
      return reducer;
    }));

    if (caseReducers.filter(function (cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }

    return caseReducers.reduce(function (previousState, caseReducer) {
      if (caseReducer) {
        if (Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraft"])(previousState)) {
          // If it's already a draft, we must already be inside a `createNextState` call,
          // likely because this is being wrapped in `createReducer`, `createSlice`, or nested
          // inside an existing draft. It's safe to just pass the draft to the mutator.
          var draft = previousState; // We can assume this is already a draft

          var result = caseReducer(draft, action);

          if (typeof result === 'undefined') {
            return previousState;
          }

          return result;
        } else if (!Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraftable"])(previousState)) {
          // If state is not draftable (ex: a primitive, such as 0), we want to directly
          // return the caseReducer func and not wrap it with produce.
          var _result = caseReducer(previousState, action);

          if (typeof _result === 'undefined') {
            throw Error('A case reducer on a non-draftable value must not return undefined');
          }

          return _result;
        } else {
          // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather
          // than an Immutable<S>, and TypeScript cannot find out how to reconcile
          // these two types.
          return Object(immer__WEBPACK_IMPORTED_MODULE_0__["default"])(previousState, function (draft) {
            return caseReducer(draft, action);
          });
        }
      }

      return previousState;
    }, state);
  };
}

function getType$1(slice, actionKey) {
  return slice + "/" + actionKey;
}
/**
 * A function that accepts an initial state, an object full of reducer
 * functions, and a "slice name", and automatically generates
 * action creators and action types that correspond to the
 * reducers and state.
 *
 * The `reducer` argument is passed to `createReducer()`.
 *
 * @public
 */


function createSlice(options) {
  var name = options.name,
      initialState = options.initialState;

  if (!name) {
    throw new Error('`name` is a required option for createSlice');
  }

  var reducers = options.reducers || {};

  var _ref = typeof options.extraReducers === 'undefined' ? [] : typeof options.extraReducers === 'function' ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers],
      _ref$ = _ref[0],
      extraReducers = _ref$ === void 0 ? {} : _ref$,
      _ref$2 = _ref[1],
      actionMatchers = _ref$2 === void 0 ? [] : _ref$2,
      _ref$3 = _ref[2],
      defaultCaseReducer = _ref$3 === void 0 ? undefined : _ref$3;

  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function (reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type = getType$1(name, reducerName);
    var caseReducer;
    var prepareCallback;

    if ('reducer' in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }

    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });

  var finalCaseReducers = _extends({}, extraReducers, {}, sliceCaseReducersByType);

  var reducer = createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
  return {
    name: name,
    reducer: reducer,
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName
  };
}

function getInitialEntityState() {
  return {
    ids: [],
    entities: {}
  };
}
function createInitialStateFactory() {
  function getInitialState(additionalState) {
    if (additionalState === void 0) {
      additionalState = {};
    }

    return Object.assign(getInitialEntityState(), additionalState);
  }

  return {
    getInitialState: getInitialState
  };
}

function createSelectorsFactory() {
  function getSelectors(selectState) {
    var selectIds = function selectIds(state) {
      return state.ids;
    };

    var selectEntities = function selectEntities(state) {
      return state.entities;
    };

    var selectAll = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectIds, selectEntities, function (ids, entities) {
      return ids.map(function (id) {
        return entities[id];
      });
    });

    var selectId = function selectId(_, id) {
      return id;
    };

    var selectById = function selectById(entities, id) {
      return entities[id];
    };

    var selectTotal = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectIds, function (ids) {
      return ids.length;
    });

    if (!selectState) {
      return {
        selectIds: selectIds,
        selectEntities: selectEntities,
        selectAll: selectAll,
        selectTotal: selectTotal,
        selectById: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectEntities, selectId, selectById)
      };
    }

    var selectGlobalizedEntities = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectEntities);
    return {
      selectIds: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectIds),
      selectEntities: selectGlobalizedEntities,
      selectAll: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectAll),
      selectTotal: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectTotal),
      selectById: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectGlobalizedEntities, selectId, selectById)
    };
  }

  return {
    getSelectors: getSelectors
  };
}

function createSingleArgumentStateOperator(mutator) {
  var operator = createStateOperator(function (_, state) {
    return mutator(state);
  });
  return function operation(state) {
    return operator(state, undefined);
  };
}
function createStateOperator(mutator) {
  return function operation(state, arg) {
    function isPayloadActionArgument(arg) {
      return isFSA(arg);
    }

    var runMutator = function runMutator(draft) {
      if (isPayloadActionArgument(arg)) {
        mutator(arg.payload, draft);
      } else {
        mutator(arg, draft);
      }
    };

    if (Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraft"])(state)) {
      // we must already be inside a `createNextState` call, likely because
      // this is being wrapped in `createReducer` or `createSlice`.
      // It's safe to just pass the draft to the mutator.
      runMutator(state); // since it's a draft, we'll just return it

      return state;
    } else {
      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather
      // than an Immutable<S>, and TypeScript cannot find out how to reconcile
      // these two types.
      return Object(immer__WEBPACK_IMPORTED_MODULE_0__["default"])(state, runMutator);
    }
  };
}

function selectIdValue(entity, selectId) {
  var key = selectId(entity);

  if ( true && key === undefined) {
    console.warn('The entity passed to the `selectId` implementation returned undefined.', 'You should probably provide your own `selectId` implementation.', 'The entity that was passed:', entity, 'The `selectId` implementation:', selectId.toString());
  }

  return key;
}

function createUnsortedStateAdapter(selectId) {
  function addOneMutably(entity, state) {
    var key = selectIdValue(entity, selectId);

    if (key in state.entities) {
      return;
    }

    state.ids.push(key);
    state.entities[key] = entity;
  }

  function addManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    for (var _iterator = entities, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var entity = _ref;
      addOneMutably(entity, state);
    }
  }

  function setAllMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    state.ids = [];
    state.entities = {};
    addManyMutably(entities, state);
  }

  function removeOneMutably(key, state) {
    return removeManyMutably([key], state);
  }

  function removeManyMutably(keys, state) {
    var didMutate = false;
    keys.forEach(function (key) {
      if (key in state.entities) {
        delete state.entities[key];
        didMutate = true;
      }
    });

    if (didMutate) {
      state.ids = state.ids.filter(function (id) {
        return id in state.entities;
      });
    }
  }

  function removeAllMutably(state) {
    Object.assign(state, {
      ids: [],
      entities: {}
    });
  }

  function takeNewKey(keys, update, state) {
    var original = state.entities[update.id];
    var updated = Object.assign({}, original, update.changes);
    var newKey = selectIdValue(updated, selectId);
    var hasNewKey = newKey !== update.id;

    if (hasNewKey) {
      keys[update.id] = newKey;
      delete state.entities[update.id];
    }

    state.entities[newKey] = updated;
    return hasNewKey;
  }

  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }

  function updateManyMutably(updates, state) {
    var newKeys = {};
    var updatesPerEntity = {};
    updates.forEach(function (update) {
      // Only apply updates to entities that currently exist
      if (update.id in state.entities) {
        // If there are multiple updates to one entity, merge them together
        updatesPerEntity[update.id] = {
          id: update.id,
          // Spreads ignore falsy values, so this works even if there isn't
          // an existing update already at this key
          changes: _extends({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null, {}, update.changes)
        };
      }
    });
    updates = Object.values(updatesPerEntity);
    var didMutateEntities = updates.length > 0;

    if (didMutateEntities) {
      var didMutateIds = updates.filter(function (update) {
        return takeNewKey(newKeys, update, state);
      }).length > 0;

      if (didMutateIds) {
        state.ids = state.ids.map(function (id) {
          return newKeys[id] || id;
        });
      }
    }
  }

  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }

  function upsertManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    var added = [];
    var updated = [];

    for (var _iterator2 = entities, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var entity = _ref2;
      var id = selectIdValue(entity, selectId);

      if (id in state.entities) {
        updated.push({
          id: id,
          changes: entity
        });
      } else {
        added.push(entity);
      }
    }

    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }

  return {
    removeAll: createSingleArgumentStateOperator(removeAllMutably),
    addOne: createStateOperator(addOneMutably),
    addMany: createStateOperator(addManyMutably),
    setAll: createStateOperator(setAllMutably),
    updateOne: createStateOperator(updateOneMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    upsertMany: createStateOperator(upsertManyMutably),
    removeOne: createStateOperator(removeOneMutably),
    removeMany: createStateOperator(removeManyMutably)
  };
}

function createSortedStateAdapter(selectId, sort) {
  var _createUnsortedStateA = createUnsortedStateAdapter(selectId),
      removeOne = _createUnsortedStateA.removeOne,
      removeMany = _createUnsortedStateA.removeMany,
      removeAll = _createUnsortedStateA.removeAll;

  function addOneMutably(entity, state) {
    return addManyMutably([entity], state);
  }

  function addManyMutably(newModels, state) {
    if (!Array.isArray(newModels)) {
      newModels = Object.values(newModels);
    }

    var models = newModels.filter(function (model) {
      return !(selectIdValue(model, selectId) in state.entities);
    });

    if (models.length !== 0) {
      merge(models, state);
    }
  }

  function setAllMutably(models, state) {
    if (!Array.isArray(models)) {
      models = Object.values(models);
    }

    state.entities = {};
    state.ids = [];
    addManyMutably(models, state);
  }

  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }

  function takeUpdatedModel(models, update, state) {
    if (!(update.id in state.entities)) {
      return false;
    }

    var original = state.entities[update.id];
    var updated = Object.assign({}, original, update.changes);
    var newKey = selectIdValue(updated, selectId);
    delete state.entities[update.id];
    models.push(updated);
    return newKey !== update.id;
  }

  function updateManyMutably(updates, state) {
    var models = [];
    updates.forEach(function (update) {
      return takeUpdatedModel(models, update, state);
    });

    if (models.length !== 0) {
      merge(models, state);
    }
  }

  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }

  function upsertManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    var added = [];
    var updated = [];

    for (var _iterator = entities, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var entity = _ref;
      var id = selectIdValue(entity, selectId);

      if (id in state.entities) {
        updated.push({
          id: id,
          changes: entity
        });
      } else {
        added.push(entity);
      }
    }

    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }

  function areArraysEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length && i < b.length; i++) {
      if (a[i] === b[i]) {
        continue;
      }

      return false;
    }

    return true;
  }

  function merge(models, state) {
    models.sort(sort); // Insert/overwrite all new/updated

    models.forEach(function (model) {
      state.entities[selectId(model)] = model;
    });
    var allEntities = Object.values(state.entities);
    allEntities.sort(sort);
    var newSortedIds = allEntities.map(selectId);
    var ids = state.ids;

    if (!areArraysEqual(ids, newSortedIds)) {
      state.ids = newSortedIds;
    }
  }

  return {
    removeOne: removeOne,
    removeMany: removeMany,
    removeAll: removeAll,
    addOne: createStateOperator(addOneMutably),
    updateOne: createStateOperator(updateOneMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    setAll: createStateOperator(setAllMutably),
    addMany: createStateOperator(addManyMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertMany: createStateOperator(upsertManyMutably)
  };
}

/**
 *
 * @param options
 *
 * @public
 */

function createEntityAdapter(options) {
  if (options === void 0) {
    options = {};
  }

  var _sortComparer$selectI = _extends({
    sortComparer: false,
    selectId: function selectId(instance) {
      return instance.id;
    }
  }, options),
      selectId = _sortComparer$selectI.selectId,
      sortComparer = _sortComparer$selectI.sortComparer;

  var stateFactory = createInitialStateFactory();
  var selectorsFactory = createSelectorsFactory();
  var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
  return _extends({
    selectId: selectId,
    sortComparer: sortComparer
  }, stateFactory, {}, selectorsFactory, {}, stateAdapter);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

// Borrowed from https://github.com/ai/nanoid/blob/3.0.2/non-secure/index.js
// This alphabet uses `A-Za-z0-9_-` symbols. A genetic algorithm helped
// optimize the gzip compression for this alphabet.
var urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
/**
 *
 * @public
 */

var nanoid = function nanoid(size) {
  if (size === void 0) {
    size = 21;
  }

  var id = ''; // A compact alternative for `for (var i = 0; i < step; i++)`.

  var i = size;

  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[Math.random() * 64 | 0];
  }

  return id;
};

var commonProperties = ['name', 'message', 'stack', 'code'];

var RejectWithValue = function RejectWithValue(value) {
  this.value = value;
}; // Reworked from https://github.com/sindresorhus/serialize-error


var miniSerializeError = function miniSerializeError(value) {
  if (typeof value === 'object' && value !== null) {
    var simpleError = {};

    for (var _iterator = commonProperties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var property = _ref;

      if (typeof value[property] === 'string') {
        simpleError[property] = value[property];
      }
    }

    return simpleError;
  }

  return {
    message: String(value)
  };
};
/**
 *
 * @param typePrefix
 * @param payloadCreator
 * @param options
 *
 * @public
 */

function createAsyncThunk(typePrefix, payloadCreator, options) {
  var fulfilled = createAction(typePrefix + '/fulfilled', function (result, requestId, arg) {
    return {
      payload: result,
      meta: {
        arg: arg,
        requestId: requestId
      }
    };
  });
  var pending = createAction(typePrefix + '/pending', function (requestId, arg) {
    return {
      payload: undefined,
      meta: {
        arg: arg,
        requestId: requestId
      }
    };
  });
  var rejected = createAction(typePrefix + '/rejected', function (error, requestId, arg, payload) {
    var aborted = !!error && error.name === 'AbortError';
    var condition = !!error && error.name === 'ConditionError';
    return {
      payload: payload,
      error: miniSerializeError(error || 'Rejected'),
      meta: {
        arg: arg,
        requestId: requestId,
        aborted: aborted,
        condition: condition
      }
    };
  });
  var displayedWarning = false;
  var AC = typeof AbortController !== 'undefined' ? AbortController :
  /*#__PURE__*/
  function () {
    function _class() {
      this.signal = {
        aborted: false,
        addEventListener: function addEventListener() {},
        dispatchEvent: function dispatchEvent() {
          return false;
        },
        onabort: function onabort() {},
        removeEventListener: function removeEventListener() {}
      };
    }

    var _proto = _class.prototype;

    _proto.abort = function abort() {
      if (true) {
        if (!displayedWarning) {
          displayedWarning = true;
          console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
        }
      }
    };

    return _class;
  }();

  function actionCreator(arg) {
    return function (dispatch, getState, extra) {
      var requestId = nanoid();
      var abortController = new AC();
      var abortReason;
      var abortedPromise = new Promise(function (_, reject) {
        return abortController.signal.addEventListener('abort', function () {
          return reject({
            name: 'AbortError',
            message: abortReason || 'Aborted'
          });
        });
      });
      var started = false;

      function abort(reason) {
        if (started) {
          abortReason = reason;
          abortController.abort();
        }
      }

      var promise = function () {
        try {
          var _temp3 = function _temp3(_result) {
            if (_exit2) return _result;
            // We dispatch the result action _after_ the catch, to avoid having any errors
            // here get swallowed by the try/catch block,
            // per https://twitter.com/dan_abramov/status/770914221638942720
            // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks
            var skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;

            if (!skipDispatch) {
              dispatch(finalAction);
            }

            return finalAction;
          };

          var _exit2 = false;
          var finalAction;

          var _temp4 = _catch(function () {
            if (options && options.condition && options.condition(arg, {
              getState: getState,
              extra: extra
            }) === false) {
              // eslint-disable-next-line no-throw-literal
              throw {
                name: 'ConditionError',
                message: 'Aborted due to condition callback returning false.'
              };
            }

            started = true;
            dispatch(pending(requestId, arg));
            return Promise.resolve(Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch: dispatch,
              getState: getState,
              extra: extra,
              requestId: requestId,
              signal: abortController.signal,
              rejectWithValue: function rejectWithValue(value) {
                return new RejectWithValue(value);
              }
            })).then(function (result) {
              if (result instanceof RejectWithValue) {
                return rejected(null, requestId, arg, result.value);
              }

              return fulfilled(result, requestId, arg);
            })])).then(function (_Promise$race) {
              finalAction = _Promise$race;
            });
          }, function (err) {
            finalAction = rejected(err, requestId, arg);
          });

          return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
        } catch (e) {
          return Promise.reject(e);
        }
      }();

      return Object.assign(promise, {
        abort: abort
      });
    };
  }

  return Object.assign(actionCreator, {
    pending: pending,
    rejected: rejected,
    fulfilled: fulfilled,
    typePrefix: typePrefix
  });
}
/**
 * @public
 */

function unwrapResult(returned) {
  if ('error' in returned) {
    throw returned.error;
  }

  return returned.payload;
}

// we assume RTK will be used with React Native and other Proxy-less
// environments.  In addition, that's how Immer 4 behaved, and since
// we want to ship this in an RTK minor, we should keep the same behavior.

Object(immer__WEBPACK_IMPORTED_MODULE_0__["enableES5"])();




/***/ }),

/***/ "../../node_modules/history/es/DOMUtils.js":
/*!*****************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/DOMUtils.js ***!
  \*****************************************************************************************************/
/*! exports provided: canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, supportsGoWithoutReloadUsingHash, isExtraneousPopstateEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canUseDOM", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeEventListener", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConfirmation", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsHistory", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsPopStateOnHashChange", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsGoWithoutReloadUsingHash", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isExtraneousPopstateEvent", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../../node_modules/history/es/LocationUtils.js":
/*!**********************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/LocationUtils.js ***!
  \**********************************************************************************************************/
/*! exports provided: createLocation, locationsAreEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return locationsAreEqual; });
/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resolve-pathname */ "../../node_modules/resolve-pathname/index.js");
/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! value-equal */ "../../node_modules/value-equal/index.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_2__["parsePath"])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_0__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(a.state, b.state);
};

/***/ }),

/***/ "../../node_modules/history/es/PathUtils.js":
/*!******************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/PathUtils.js ***!
  \******************************************************************************************************/
/*! exports provided: addLeadingSlash, stripLeadingSlash, hasBasename, stripBasename, stripTrailingSlash, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLeadingSlash", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripLeadingSlash", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBasename", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripBasename", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripTrailingSlash", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../../node_modules/history/es/createBrowserHistory.js":
/*!*****************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createBrowserHistory.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ "../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ "../../node_modules/history/es/DOMUtils.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["canUseDOM"], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsHistory"])();
  var needsHashChangeListener = !Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsPopStateOnHashChange"])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__["getConfirmation"] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripTrailingSlash"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["hasBasename"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripBasename"])(path, basename);

    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["isExtraneousPopstateEvent"])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
  };

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createBrowserHistory);

/***/ }),

/***/ "../../node_modules/history/es/createHashHistory.js":
/*!**************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createHashHistory.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ "../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ "../../node_modules/history/es/DOMUtils.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripLeadingSlash"])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripLeadingSlash"],
    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"]
  },
  slash: {
    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"],
    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["canUseDOM"], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsGoWithoutReloadUsingHash"])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__["getConfirmation"] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripTrailingSlash"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["hasBasename"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripBasename"])(path, basename);

    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path);
  };

  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["locationsAreEqual"])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location));
  };

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createHashHistory);

/***/ }),

/***/ "../../node_modules/history/es/createMemoryHistory.js":
/*!****************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createMemoryHistory.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_3__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(entry, undefined, createKey()) : Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils__WEBPACK_IMPORTED_MODULE_1__["createPath"];

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createMemoryHistory);

/***/ }),

/***/ "../../node_modules/history/es/createTransitionManager.js":
/*!********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createTransitionManager.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["default"] = (createTransitionManager);

/***/ }),

/***/ "../../node_modules/history/es/index.js":
/*!**************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/index.js ***!
  \**************************************************************************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserHistory */ "../../node_modules/history/es/createBrowserHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createBrowserHistory", function() { return _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _createHashHistory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createHashHistory */ "../../node_modules/history/es/createHashHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHashHistory", function() { return _createHashHistory__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createMemoryHistory */ "../../node_modules/history/es/createMemoryHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMemoryHistory", function() { return _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__["createLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__["locationsAreEqual"]; });

/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__["parsePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__["createPath"]; });











/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!******************************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "../../node_modules/immer/dist/immer.esm.js":
/*!******************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/immer/dist/immer.esm.js ***!
  \******************************************************************************************************/
/*! exports provided: default, Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableAllPlugins, enableES5, enableMapSet, enablePatches, finishDraft, immerable, isDraft, isDraftable, nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immer", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatches", function() { return vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castDraft", function() { return K; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castImmutable", function() { return $; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDraft", function() { return pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "current", function() { return D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableAllPlugins", function() { return J; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableES5", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableMapSet", function() { return C; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enablePatches", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finishDraft", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "immerable", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraft", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraftable", function() { return r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return H; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "original", function() { return e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produceWithPatches", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoFreeze", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseProxies", function() { return sn; });
function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];if(true){var i=Y[n],o=i?"function"==typeof i?i.apply(null,r):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function t(n){return!!n&&!!n[Q]}function r(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);return!t||t===Object.prototype}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function e(r){return t(r)||n(23,r),r[Q].t}function i(n,t,r){void 0===r&&(r=!1),0===o(n)?(r?Object.keys:Z)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function o(n){var t=n[Q];return t?t.i>3?t.i-4:t.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,t){return 2===o(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function a(n,t){return 2===o(n)?n.get(t):n[t]}function f(n,t,r){var e=o(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=nn(n);delete t[Q];for(var r=Z(t),e=0;e<r.length;e++){var i=r[e],o=t[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function d(n,e){y(n)||t(n)||!r(n)||(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,t){return d(t,!0)}),!0))}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(t){var r=tn[t];return r||n( true?18:undefined,t),r}function m(n,t){tn[n]=t}function _(){return false||U||n(0),U}function j(n,t){t&&(b("Patches"),n.u=[],n.s=[],n.v=t)}function g(n){O(n),n.p.forEach(S),n.p=null}function O(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var t=n[Q];0===t.i||1===t.i?t.j():t.g=!0}function P(t,e){e._=e.p.length;var i=e.p[0],o=void 0!==t&&t!==i;return e.h.O||b("ES5").S(e,t,o),o?(i[Q].P&&(g(e),n(4)),r(t)&&(t=M(e,t),e.l||x(e,t)),e.u&&b("Patches").M(i[Q],t,e.u,e.s)):t=M(e,i,[]),g(e),e.u&&e.v(e.u,e.s),t!==H?t:void 0}function M(n,t,r){if(y(t))return t;var e=t[Q];if(!e)return i(t,(function(i,o){return A(n,e,t,i,o,r)}),!0),t;if(e.A!==n)return t;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(t,i){return A(n,e,o,t,i,r)})),x(n,o,!1),r&&n.u&&b("Patches").R(e,r,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if( true&&c===o&&n(5),t(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!t(v))return;e.m=!1}if(r(c)&&!y(c)){if(!e.h.N&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,t,r){void 0===r&&(r=!1),n.h.N&&n.m&&d(t,r)}function z(n,t){var r=n[Q];return(r?p(r):n)[t]}function I(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.P||(n.P=!0,n.l&&E(n.l))}function k(n){n.o||(n.o=l(n.t))}function R(n,t,r){var e=s(t)?b("MapSet").T(t,r):v(t)?b("MapSet").F(t,r):n.O?function(n,t){var r=Array.isArray(n),e={i:r?1:0,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:null,o:null,j:null,C:!1},i=e,o=rn;r&&(i=[e],o=en);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(t,r):b("ES5").J(t,r);return(r?r.A:_()).p.push(e),e}function D(e){return t(e)||n(22,e),function n(t){if(!r(t))return t;var e,u=t[Q],c=o(t);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=N(t,c),u.I=!1}else e=N(t,c);return i(e,(function(t,r){u&&a(u.t,t)===r||f(e,t,n(r))})),3===c?new Set(e):e}(e)}function N(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function T(){function r(n,t){var r=s[n];return r?r.enumerable=t:s[n]=r={configurable:!0,enumerable:t,get:function(){var t=this[Q];return true&&f(t),rn.get(t,n)},set:function(t){var r=this[Q]; true&&f(r),rn.set(r,n,t)}},r}function e(n){for(var t=n.length-1;t>=0;t--){var r=n[t][Q];if(!r.P)switch(r.i){case 5:a(r)&&E(r);break;case 4:o(r)&&E(r)}}}function o(n){for(var t=n.t,r=n.k,e=Z(r),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=t[o];if(void 0===a&&!u(t,o))return!0;var f=r[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!t[Q];return e.length!==Z(t).length+(v?0:1)}function a(n){var t=n.k;if(t.length!==n.t.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);return!(!r||r.get)}function f(t){t.g&&n(3,JSON.stringify(p(t)))}var s={};m("ES5",{J:function(n,t){var e=Array.isArray(n),i=function(n,t){if(n){for(var e=Array(t.length),i=0;i<t.length;i++)Object.defineProperty(e,""+i,r(i,!0));return e}var o=nn(t);delete o[Q];for(var u=Z(o),a=0;a<u.length;a++){var f=u[a];o[f]=r(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(t),o)}(e,n),o={i:e?5:4,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:i,o:null,g:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,r,o){o?t(r)&&r[Q].A===n&&e(n.p):(n.u&&function n(t){if(t&&"object"==typeof t){var r=t[Q];if(r){var e=r.t,o=r.k,f=r.D,c=r.i;if(4===c)i(o,(function(t){t!==Q&&(void 0!==e[t]||u(e,t)?f[t]||n(o[t]):(f[t]=!0,E(r)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,E(r))}));else if(5===c){if(a(r)&&(E(r),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function F(){function e(n){if(!r(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var t=Object.create(Object.getPrototypeOf(n));for(var i in n)t[i]=e(n[i]);return t}function f(n){return t(n)?e(n):n}var c="add";m("Patches",{$:function(t,r){return r.forEach((function(r){for(var i=r.path,u=r.op,f=t,s=0;s<i.length-1;s++)"object"!=typeof(f=a(f,i[s]))&&n(15,i.join("/"));var v=o(f),p=e(r.value),l=i[i.length-1];switch(u){case"replace":switch(v){case 2:return f.set(l,p);case 3:n(16);default:return f[l]=p}case c:switch(v){case 1:return f.splice(l,0,p);case 2:return f.set(l,p);case 3:return f.add(p);default:return f[l]=p}case"remove":switch(v){case 1:return f.splice(l,1);case 2:return f.delete(l);case 3:return f.delete(r.value);default:return delete f[l]}default:n(17,u)}})),t},R:function(n,t,r,e){switch(n.i){case 0:case 4:case 2:return function(n,t,r,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=t.concat(n);r.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,t,r,e);case 5:case 1:return function(n,t,r,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,r];r=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=t.concat([v]);r.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=t.concat([l]);r.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,e);case 3:return function(n,t,r,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=t.concat([u]);r.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=t.concat([u]);r.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,t,r,e)}},M:function(n,t,r,e){r.push({op:"replace",path:[],value:t}),e.push({op:"replace",path:[],value:n.t})}})}function C(){function t(n,t){function r(){this.constructor=n}a(n,t),n.prototype=(r.prototype=t.prototype,new r)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(t){if(r(t)){var e=R(n.A.h,t,n);n.p.set(t,e),n.o.add(e)}else n.o.add(t)})))}function u(t){t.g&&n(3,JSON.stringify(p(t)))}var a=function(n,t){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},f=function(){function n(n,t){return this[Q]={i:2,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,g:!1},this}t(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,t){var r=this[Q];return u(r),p(r).has(n)&&p(r).get(n)===t||(e(r),E(r),r.D.set(n,!0),r.o.set(n,t),r.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),e(t),E(t),t.D.set(n,!1),t.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),E(n),n.D=new Map,i(n.t,(function(t){n.D.set(t,!1)})),n.o.clear())},o.forEach=function(n,t){var r=this;p(this[Q]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},o.get=function(n){var t=this[Q];u(t);var i=p(t).get(n);if(t.I||!r(i))return i;if(i!==t.t.get(n))return i;var o=R(t.A.h,i,t);return e(t),t.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},o.entries=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[Q]={i:3,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,g:!1,C:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,"size",{get:function(){return p(this[Q]).size}}),r.has=function(n){var t=this[Q];return u(t),t.o?!!t.o.has(n)||!(!t.p.has(n)||!t.o.has(t.p.get(n))):t.t.has(n)},r.add=function(n){var t=this[Q];return u(t),this.has(n)||(o(t),E(t),t.o.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),o(t),E(t),t.o.delete(n)||!!t.p.has(n)&&t.o.delete(t.p.get(n))},r.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),E(n),n.o.clear())},r.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},r.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},r.keys=function(){return this.values()},r[V]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();m("MapSet",{T:function(n,t){return new f(n,t)},F:function(n,t){return new c(n,t)}})}function J(){T(),C(),F()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},19:"plugin not loaded",20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n}},Z="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,nn=Object.getOwnPropertyDescriptors||function(n){var t={};return Z(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},tn={},rn={get:function(n,t){if(t===Q)return n;var e=p(n);if(!u(e,t))return function(n,t,r){var e,i=I(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.I||!r(i)?i:i===z(n.t,t)?(k(n),n.o[t]=R(n.A.h,i,n)):i},has:function(n,t){return t in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,t,r){var e=I(p(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.P){var i=z(p(n),t),o=null==i?void 0:i[Q];if(o&&o.t===r)return n.o[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||u(n.t,t)))return!0;k(n),E(n)}return n.o[t]=r,n.D[t]=!0,!0},deleteProperty:function(n,t){return void 0!==z(n.t,t)||t in n.t?(n.D[t]=!1,k(n),E(n)):delete n.D[t],n.o&&delete n.o[t],!0},getOwnPropertyDescriptor:function(n,t){var r=p(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.i||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},en={};i(rn,(function(n,t){en[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),en.deleteProperty=function(t,r){return true&&isNaN(parseInt(r))&&n(13),rn.deleteProperty.call(this,t[0],r)},en.set=function(t,r,e){return true&&"length"!==r&&isNaN(parseInt(r))&&n(14),rn.set.call(this,t[0],r,e,t[0])};var on=function(){function e(n){this.O=B,this.N="production"!=="development","boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze),this.produce=this.produce.bind(this),this.produceWithPatches=this.produceWithPatches.bind(this)}var i=e.prototype;return i.produce=function(t,e,i){if("function"==typeof t&&"function"!=typeof e){var o=e;e=t;var u=this;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,i=Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];return u.produce(n,(function(n){var r;return(r=e).call.apply(r,[t,n].concat(i))}))}}var a;if("function"!=typeof e&&n(6),void 0!==i&&"function"!=typeof i&&n(7),r(t)){var f=w(this),c=R(this,t,void 0),s=!0;try{a=e(c),s=!1}finally{s?g(f):O(f)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return j(f,i),P(n,f)}),(function(n){throw g(f),n})):(j(f,i),P(a,f))}if(!t||"object"!=typeof t){if((a=e(t))===H)return;return void 0===a&&(a=t),this.N&&d(a,!0),a}n(21,t)},i.produceWithPatches=function(n,t){var r,e,i=this;return"function"==typeof n?function(t){for(var r=arguments.length,e=Array(r>1?r-1:0),o=1;o<r;o++)e[o-1]=arguments[o];return i.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(e))}))}:[this.produce(n,t,(function(n,t){r=n,e=t})),r,e]},i.createDraft=function(e){r(e)||n(8),t(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,O(i),o},i.finishDraft=function(t,r){var e=t&&t[Q]; true&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,r),P(void 0,i)},i.setAutoFreeze=function(n){this.N=n},i.setUseProxies=function(t){t&&!B&&n(20),this.O=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}var o=b("Patches").$;return t(n)?o(n,r):this.produce(n,(function(n){return o(n,r.slice(e+1))}))},e}(),un=new on,an=un.produce,fn=un.produceWithPatches.bind(un),cn=un.setAutoFreeze.bind(un),sn=un.setUseProxies.bind(un),vn=un.applyPatches.bind(un),pn=un.createDraft.bind(un),ln=un.finishDraft.bind(un);/* harmony default export */ __webpack_exports__["default"] = (an);


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/*!***************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/invariant/browser.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*****************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/object-assign/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../../node_modules/prop-types/checkPropTypes.js":
/*!***********************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/checkPropTypes.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../../node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/*!**************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/querystring-es3/decode.js":
/*!********************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/decode.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../../node_modules/querystring-es3/encode.js":
/*!********************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/encode.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "../../node_modules/querystring-es3/index.js":
/*!*******************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "../../node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "../../node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.development.js":
/*!*******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-is/cjs/react-is.development.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/react-is/index.js":
/*!************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-is/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/react-redux/es/components/Context.js":
/*!*******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/Context.js ***!
  \*******************************************************************************************************************/
/*! exports provided: ReactReduxContext, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactReduxContext", function() { return ReactReduxContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var ReactReduxContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext(null);

if (true) {
  ReactReduxContext.displayName = 'ReactRedux';
}

/* harmony default export */ __webpack_exports__["default"] = (ReactReduxContext);

/***/ }),

/***/ "../../node_modules/react-redux/es/components/Provider.js":
/*!********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/Provider.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");





function Provider(_ref) {
  var store = _ref.store,
      context = _ref.context,
      children = _ref.children;
  var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    var subscription = new _utils_Subscription__WEBPACK_IMPORTED_MODULE_3__["default"](store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store,
      subscription: subscription
    };
  }, [store]);
  var previousState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return store.getState();
  }, [store]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return function () {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || _Context__WEBPACK_IMPORTED_MODULE_2__["ReactReduxContext"];
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

if (true) {
  Provider.propTypes = {
    store: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({
      subscribe: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
      dispatch: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
      getState: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired
    }),
    context: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
    children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Provider);

/***/ }),

/***/ "../../node_modules/react-redux/es/components/connectAdvanced.js":
/*!***************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/connectAdvanced.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return connectAdvanced; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hoist-non-react-statics */ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");
/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js");
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Context */ "../../node_modules/react-redux/es/components/Context.js");







 // Define some constant arrays just to avoid re-creating these

var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];

var stringifyComponent = function stringifyComponent(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};

function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}

function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_6__["useIsomorphicLayoutEffect"])(function () {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}

function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  // We want to capture the wrapper props and child props we used for later comparisons
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}

function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  // If we're not subscribed to the store, nothing to do here
  if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

  var didUnsubscribe = false;
  var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

  var checkForUpdates = function checkForUpdates() {
    if (didUnsubscribe) {
      // Don't run stale listeners.
      // Redux doesn't guarantee unsubscriptions happen until next dispatch.
      return;
    }

    var latestStoreState = store.getState();
    var newChildProps, error;

    try {
      // Actually run the selector with the most recent store state and wrapper props
      // to determine what the child props should be
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }

    if (!error) {
      lastThrownError = null;
    } // If the child props haven't changed, nothing to do here - cascade the subscription update


    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      // Save references to the new child props.  Note that we track the "child props from store update"
      // as a ref instead of a useState/useReducer because we need a way to determine if that value has
      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
      // forcing another re-render, which we don't want.
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

      forceComponentUpdateDispatch({
        type: 'STORE_UPDATED',
        payload: {
          error: error
        }
      });
    }
  }; // Actually subscribe to the nearest connected ancestor (or store)


  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe(); // Pull data from the store after first render in case the store has
  // changed since we began.

  checkForUpdates();

  var unsubscribeWrapper = function unsubscribeWrapper() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;

    if (lastThrownError) {
      // It's possible that we caught an error due to a bad mapState function, but the
      // parent re-rendered without this component and we're about to unmount.
      // This shouldn't happen as long as we do top-down subscriptions correctly, but
      // if we ever do those wrong, this throw will surface the error in our tests.
      // In that case, throw the error from here so it doesn't get lost.
      throw lastThrownError;
    }
  };

  return unsubscribeWrapper;
}

var initStateUpdates = function initStateUpdates() {
  return [null, 0];
};

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
     export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
   Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
   Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory, // options object:
_ref) {
  if (_ref === void 0) {
    _ref = {};
  }

  var _ref2 = _ref,
      _ref2$getDisplayName = _ref2.getDisplayName,
      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName,
      _ref2$methodName = _ref2.methodName,
      methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
      _ref2$renderCountProp = _ref2.renderCountProp,
      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
      _ref2$storeKey = _ref2.storeKey,
      storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
      _ref2$withRef = _ref2.withRef,
      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
      _ref2$forwardRef = _ref2.forwardRef,
      forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
      _ref2$context = _ref2.context,
      context = _ref2$context === void 0 ? _Context__WEBPACK_IMPORTED_MODULE_7__["ReactReduxContext"] : _ref2$context,
      connectOptions = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"]);

  if (true) {
    if (renderCountProp !== undefined) {
      throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    }

    if (withRef) {
      throw new Error('withRef is removed. To access the wrapped instance, use a ref on the connected component');
    }

    var customStoreWarningMessage = 'To use a custom Redux store for specific components, create a custom React context with ' + "React.createContext(), and pass the context object to React Redux's Provider and specific components" + ' like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. ' + 'You may also pass a {context : MyContext} option to connect';

    if (storeKey !== 'store') {
      throw new Error('storeKey has been removed and does not do anything. ' + customStoreWarningMessage);
    }
  }

  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if ( true && !Object(react_is__WEBPACK_IMPORTED_MODULE_4__["isValidElementType"])(WrappedComponent)) {
      throw new Error("You must pass a component to the function returned by " + (methodName + ". Instead received " + stringifyComponent(WrappedComponent)));
    }

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var pure = connectOptions.pure;

    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    } // If we aren't running in "pure" mode, we don't want to memoize values.
    // To avoid conditionally calling hooks, we fall back to a tiny wrapper
    // that just executes the given callback immediately.


    var usePureOnlyMemo = pure ? react__WEBPACK_IMPORTED_MODULE_3__["useMemo"] : function (callback) {
      return callback();
    };

    function ConnectFunction(props) {
      var _useMemo = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // Distinguish between actual "data" props that were passed to the wrapper component,
        // and values needed to control behavior (forwarded refs, alternate context instances).
        // To maintain the wrapperProps object reference, memoize this destructuring.
        var reactReduxForwardedRef = props.reactReduxForwardedRef,
            wrapperProps = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(props, ["reactReduxForwardedRef"]);

        return [props.context, reactReduxForwardedRef, wrapperProps];
      }, [props]),
          propsContext = _useMemo[0],
          reactReduxForwardedRef = _useMemo[1],
          wrapperProps = _useMemo[2];

      var ContextToUse = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
        // Memoize the check that determines which context instance we should use.
        return propsContext && propsContext.Consumer && Object(react_is__WEBPACK_IMPORTED_MODULE_4__["isContextConsumer"])( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

      var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_3__["useContext"])(ContextToUse); // The store _must_ exist as either a prop or in context.
      // We'll check to see if it _looks_ like a Redux store first.
      // This allows us to pass through a `store` prop that is just a plain value.

      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);

      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error("Could not find \"store\" in the context of " + ("\"" + displayName + "\". Either wrap the root component in a <Provider>, ") + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
      } // Based on the previous check, one of these must be true


      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // The child props selector needs the store reference as an input.
        // Re-create this selector whenever the store changes.
        return createChildSelector(store);
      }, [store]);

      var _useMemo2 = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.

        var subscription = new _utils_Subscription__WEBPACK_IMPORTED_MODULE_5__["default"](store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.

        var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
        return [subscription, notifyNestedSubs];
      }, [store, didStoreComeFromProps, contextValue]),
          subscription = _useMemo2[0],
          notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
      // and memoize that value to avoid unnecessary context updates.


      var overriddenContextValue = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (didStoreComeFromProps) {
          // This component is directly subscribed to a store from props.
          // We don't want descendants reading from this store - pass down whatever
          // the existing context value is from the nearest connected ancestor.
          return contextValue;
        } // Otherwise, put this component's subscription instance into context, so that
        // connected descendants won't update until after this component is done


        return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, contextValue, {
          subscription: subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
      // causes a change to the calculated child component props (or we caught an error in mapState)

      var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_3__["useReducer"])(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
          _useReducer$ = _useReducer[0],
          previousStateUpdateResult = _useReducer$[0],
          forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards


      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      } // Set up refs to coordinate values between the subscription effect and the render logic


      var lastChildProps = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])();
      var lastWrapperProps = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(wrapperProps);
      var childPropsFromStoreUpdate = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])();
      var renderIsScheduled = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(false);
      var actualChildProps = usePureOnlyMemo(function () {
        // Tricky logic here:
        // - This render may have been triggered by a Redux store update that produced new child props
        // - However, we may have gotten new wrapper props after that
        // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
        // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
        // So, we'll use the child props from store update only if the wrapper props are the same as last time.
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        } // TODO We're reading the store directly in render() here. Bad idea?
        // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
        // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
        // to determine what the child props should be.


        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
      // about useLayoutEffect in SSR, so we try to detect environment and fall back to
      // just useEffect instead to avoid the warning, since neither will run anyway.

      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
      // We memoize the elements for the rendered child component as an optimization.

      var renderedWrappedComponent = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(WrappedComponent, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

      var renderedChild = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (shouldHandleStateChanges) {
          // If this component is subscribed to store updates, we need to pass its own
          // subscription instance down to our descendants. That means rendering the same
          // Context instance, and putting a different value into the context.
          return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }

        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.


    var Connect = pure ? react__WEBPACK_IMPORTED_MODULE_3___default.a.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;

    if (forwardRef) {
      var forwarded = react__WEBPACK_IMPORTED_MODULE_3___default.a.forwardRef(function forwardConnectRef(props, ref) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(Connect, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(forwarded, WrappedComponent);
    }

    return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(Connect, WrappedComponent);
  };
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/connect.js":
/*!****************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/connect.js ***!
  \****************************************************************************************************************/
/*! exports provided: createConnect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConnect", function() { return createConnect; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/connectAdvanced */ "../../node_modules/react-redux/es/components/connectAdvanced.js");
/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/shallowEqual */ "../../node_modules/react-redux/es/utils/shallowEqual.js");
/* harmony import */ var _mapDispatchToProps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapDispatchToProps */ "../../node_modules/react-redux/es/connect/mapDispatchToProps.js");
/* harmony import */ var _mapStateToProps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mapStateToProps */ "../../node_modules/react-redux/es/connect/mapStateToProps.js");
/* harmony import */ var _mergeProps__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mergeProps */ "../../node_modules/react-redux/es/connect/mergeProps.js");
/* harmony import */ var _selectorFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./selectorFactory */ "../../node_modules/react-redux/es/connect/selectorFactory.js");








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}

function strictEqual(a, b) {
  return a === b;
} // createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios


function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === void 0 ? _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_2__["default"] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? _mapStateToProps__WEBPACK_IMPORTED_MODULE_5__["default"] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? _mapDispatchToProps__WEBPACK_IMPORTED_MODULE_4__["default"] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === void 0 ? _mergeProps__WEBPACK_IMPORTED_MODULE_6__["default"] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === void 0 ? _selectorFactory__WEBPACK_IMPORTED_MODULE_7__["default"] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }

    var _ref3 = _ref2,
        _ref3$pure = _ref3.pure,
        pure = _ref3$pure === void 0 ? true : _ref3$pure,
        _ref3$areStatesEqual = _ref3.areStatesEqual,
        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areOwnPropsEqua,
        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areStatePropsEq,
        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areMergedPropsE,
        extraOptions = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
    return connectHOC(selectorFactory, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      // used in error messages
      methodName: 'connect',
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual
    }, extraOptions));
  };
}
/* harmony default export */ __webpack_exports__["default"] = (/*#__PURE__*/createConnect());

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mapDispatchToProps.js":
/*!***************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mapDispatchToProps.js ***!
  \***************************************************************************************************************************/
/*! exports provided: whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsFunction", function() { return whenMapDispatchToPropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsMissing", function() { return whenMapDispatchToPropsIsMissing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsObject", function() { return whenMapDispatchToPropsIsObject; });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "../../node_modules/redux/es/redux.js");
/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrapMapToProps */ "../../node_modules/react-redux/es/connect/wrapMapToProps.js");


function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsFunc"])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsConstant"])(function (dispatch) {
    return {
      dispatch: dispatch
    };
  }) : undefined;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsConstant"])(function (dispatch) {
    return Object(redux__WEBPACK_IMPORTED_MODULE_0__["bindActionCreators"])(mapDispatchToProps, dispatch);
  }) : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mapStateToProps.js":
/*!************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mapStateToProps.js ***!
  \************************************************************************************************************************/
/*! exports provided: whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapStateToPropsIsFunction", function() { return whenMapStateToPropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapStateToPropsIsMissing", function() { return whenMapStateToPropsIsMissing; });
/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapMapToProps */ "../../node_modules/react-redux/es/connect/wrapMapToProps.js");

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__["wrapMapToPropsFunc"])(mapStateToProps, 'mapStateToProps') : undefined;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__["wrapMapToPropsConstant"])(function () {
    return {};
  }) : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mergeProps.js":
/*!*******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mergeProps.js ***!
  \*******************************************************************************************************************/
/*! exports provided: defaultMergeProps, wrapMergePropsFunc, whenMergePropsIsFunction, whenMergePropsIsOmitted, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMergeProps", function() { return defaultMergeProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMergePropsFunc", function() { return wrapMergePropsFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMergePropsIsFunction", function() { return whenMergePropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMergePropsIsOmitted", function() { return whenMergePropsIsOmitted; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/verifyPlainObject */ "../../node_modules/react-redux/es/utils/verifyPlainObject.js");


function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true) Object(_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/selectorFactory.js":
/*!************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/selectorFactory.js ***!
  \************************************************************************************************************************/
/*! exports provided: impureFinalPropsSelectorFactory, pureFinalPropsSelectorFactory, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "impureFinalPropsSelectorFactory", function() { return impureFinalPropsSelectorFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pureFinalPropsSelectorFactory", function() { return pureFinalPropsSelectorFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return finalPropsSelectorFactory; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _verifySubselectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./verifySubselectors */ "../../node_modules/react-redux/es/connect/verifySubselectors.js");


function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
} // TODO: Add more comments
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (true) {
    Object(_verifySubselectors__WEBPACK_IMPORTED_MODULE_1__["default"])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/verifySubselectors.js":
/*!***************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/verifySubselectors.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return verifySubselectors; });
/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/warning */ "../../node_modules/react-redux/es/utils/warning.js");


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {
      Object(_utils_warning__WEBPACK_IMPORTED_MODULE_0__["default"])("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/wrapMapToProps.js":
/*!***********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/wrapMapToProps.js ***!
  \***********************************************************************************************************************/
/*! exports provided: wrapMapToPropsConstant, getDependsOnOwnProps, wrapMapToPropsFunc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMapToPropsConstant", function() { return wrapMapToPropsConstant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDependsOnOwnProps", function() { return getDependsOnOwnProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMapToPropsFunc", function() { return wrapMapToPropsFunc; });
/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/verifyPlainObject */ "../../node_modules/react-redux/es/utils/verifyPlainObject.js");

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }

    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
//
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..

function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
//
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//

function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    }; // allow detectFactoryAndVerify to get ownProps


    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (true) Object(_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(props, displayName, methodName);
      return props;
    };

    return proxy;
  };
}

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useDispatch.js":
/*!******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useDispatch.js ***!
  \******************************************************************************************************************/
/*! exports provided: createDispatchHook, useDispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDispatchHook", function() { return createDispatchHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDispatch", function() { return useDispatch; });
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _useStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useStore */ "../../node_modules/react-redux/es/hooks/useStore.js");


/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

function createDispatchHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_0__["ReactReduxContext"];
  }

  var useStore = context === _components_Context__WEBPACK_IMPORTED_MODULE_0__["ReactReduxContext"] ? _useStore__WEBPACK_IMPORTED_MODULE_1__["useStore"] : Object(_useStore__WEBPACK_IMPORTED_MODULE_1__["createStoreHook"])(context);
  return function useDispatch() {
    var store = useStore();
    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

var useDispatch = /*#__PURE__*/createDispatchHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useReduxContext.js":
/*!**********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useReduxContext.js ***!
  \**********************************************************************************************************************/
/*! exports provided: useReduxContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReduxContext", function() { return useReduxContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");


/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */

function useReduxContext() {
  var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"]);

  if ( true && !contextValue) {
    throw new Error('could not find react-redux context value; please ensure the component is wrapped in a <Provider>');
  }

  return contextValue;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useSelector.js":
/*!******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useSelector.js ***!
  \******************************************************************************************************************/
/*! exports provided: createSelectorHook, useSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelectorHook", function() { return createSelectorHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSelector", function() { return useSelector; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useReduxContext */ "../../node_modules/react-redux/es/hooks/useReduxContext.js");
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");
/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js");
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");






var refEquality = function refEquality(a, b) {
  return a === b;
};

function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  var subscription = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return new _utils_Subscription__WEBPACK_IMPORTED_MODULE_2__["default"](store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestSelector = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestStoreState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestSelectedState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var storeState = store.getState();
  var selectedState;

  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      selectedState = selector(storeState);
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }

    throw err;
  }

  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__["useIsomorphicLayoutEffect"])(function () {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = undefined;
  });
  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__["useIsomorphicLayoutEffect"])(function () {
    function checkForUpdates() {
      try {
        var newSelectedState = latestSelector.current(store.getState());

        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return;
        }

        latestSelectedState.current = newSelectedState;
      } catch (err) {
        // we ignore all errors here, since when the component
        // is re-rendered, the selectors are called again, and
        // will throw again, if neither props nor store state
        // changed
        latestSubscriptionCallbackError.current = err;
      }

      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function () {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_4__["ReactReduxContext"];
  }

  var useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_4__["ReactReduxContext"] ? _useReduxContext__WEBPACK_IMPORTED_MODULE_1__["useReduxContext"] : function () {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(context);
  };
  return function useSelector(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }

    if ( true && !selector) {
      throw new Error("You must pass a selector to useSelector");
    }

    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store,
        contextSub = _useReduxContext.subscription;

    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"])(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

var useSelector = /*#__PURE__*/createSelectorHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useStore.js":
/*!***************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useStore.js ***!
  \***************************************************************************************************************/
/*! exports provided: createStoreHook, useStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStoreHook", function() { return createStoreHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStore", function() { return useStore; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useReduxContext */ "../../node_modules/react-redux/es/hooks/useReduxContext.js");



/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

function createStoreHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"];
  }

  var useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"] ? _useReduxContext__WEBPACK_IMPORTED_MODULE_2__["useReduxContext"] : function () {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(context);
  };
  return function useStore() {
    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store;

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

var useStore = /*#__PURE__*/createStoreHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/index.js":
/*!******************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/index.js ***!
  \******************************************************************************************************/
/*! exports provided: Provider, connectAdvanced, ReactReduxContext, connect, batch, useDispatch, createDispatchHook, useSelector, createSelectorHook, useStore, createStoreHook, shallowEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Provider */ "../../node_modules/react-redux/es/components/Provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return _components_Provider__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/connectAdvanced */ "../../node_modules/react-redux/es/components/connectAdvanced.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() { return _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReactReduxContext", function() { return _components_Context__WEBPACK_IMPORTED_MODULE_2__["ReactReduxContext"]; });

/* harmony import */ var _connect_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connect/connect */ "../../node_modules/react-redux/es/connect/connect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return _connect_connect__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useDispatch */ "../../node_modules/react-redux/es/hooks/useDispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDispatch", function() { return _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__["useDispatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createDispatchHook", function() { return _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__["createDispatchHook"]; });

/* harmony import */ var _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks/useSelector */ "../../node_modules/react-redux/es/hooks/useSelector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSelector", function() { return _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__["useSelector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSelectorHook", function() { return _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__["createSelectorHook"]; });

/* harmony import */ var _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useStore */ "../../node_modules/react-redux/es/hooks/useStore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useStore", function() { return _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__["useStore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStoreHook", function() { return _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__["createStoreHook"]; });

/* harmony import */ var _utils_batch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/batch */ "../../node_modules/react-redux/es/utils/batch.js");
/* harmony import */ var _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/reactBatchedUpdates */ "../../node_modules/react-redux/es/utils/reactBatchedUpdates.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batch", function() { return _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__["unstable_batchedUpdates"]; });

/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/shallowEqual */ "../../node_modules/react-redux/es/utils/shallowEqual.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowEqual", function() { return _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_9__["default"]; });











Object(_utils_batch__WEBPACK_IMPORTED_MODULE_7__["setBatch"])(_utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__["unstable_batchedUpdates"]);


/***/ }),

/***/ "../../node_modules/react-redux/es/utils/Subscription.js":
/*!*******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/Subscription.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Subscription; });
/* harmony import */ var _batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batch */ "../../node_modules/react-redux/es/utils/batch.js");
 // encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  var batch = Object(_batch__WEBPACK_IMPORTED_MODULE_0__["getBatch"])();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify() {
      batch(function () {
        var listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}

var Subscription = /*#__PURE__*/function () {
  function Subscription(store, parentSub) {
    this.store = store;
    this.parentSub = parentSub;
    this.unsubscribe = null;
    this.listeners = nullListeners;
    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
  }

  var _proto = Subscription.prototype;

  _proto.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  _proto.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  _proto.handleChangeWrapper = function handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  };

  _proto.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  _proto.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
      this.listeners = createListenerCollection();
    }
  };

  _proto.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),

/***/ "../../node_modules/react-redux/es/utils/batch.js":
/*!************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/batch.js ***!
  \************************************************************************************************************/
/*! exports provided: setBatch, getBatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBatch", function() { return setBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBatch", function() { return getBatch; });
// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

var batch = defaultNoopBatch; // Allow injecting another batching function later

var setBatch = function setBatch(newBatch) {
  return batch = newBatch;
}; // Supply a getter just to skip dealing with ESM bindings

var getBatch = function getBatch() {
  return batch;
};

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/isPlainObject.js":
/*!********************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/isPlainObject.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isPlainObject; });
/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = Object.getPrototypeOf(obj);
  if (proto === null) return true;
  var baseProto = proto;

  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }

  return proto === baseProto;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/reactBatchedUpdates.js":
/*!**************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/reactBatchedUpdates.js ***!
  \**************************************************************************************************************************/
/*! exports provided: unstable_batchedUpdates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return react_dom__WEBPACK_IMPORTED_MODULE_0__["unstable_batchedUpdates"]; });

/* eslint-disable import/no-unresolved */


/***/ }),

/***/ "../../node_modules/react-redux/es/utils/shallowEqual.js":
/*!*******************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/shallowEqual.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowEqual; });
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js":
/*!********************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js ***!
  \********************************************************************************************************************************/
/*! exports provided: useIsomorphicLayoutEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useIsomorphicLayoutEffect", function() { return useIsomorphicLayoutEffect; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 // React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"] : react__WEBPACK_IMPORTED_MODULE_0__["useEffect"];

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/verifyPlainObject.js":
/*!************************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/verifyPlainObject.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return verifyPlainObject; });
/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isPlainObject */ "../../node_modules/react-redux/es/utils/isPlainObject.js");
/* harmony import */ var _warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./warning */ "../../node_modules/react-redux/es/utils/warning.js");


function verifyPlainObject(value, displayName, methodName) {
  if (!Object(_isPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    Object(_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
  }
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/warning.js":
/*!**************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/warning.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return warning; });
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */

}

/***/ }),

/***/ "../../node_modules/redux-thunk/es/index.js":
/*!******************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/redux-thunk/es/index.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

/* harmony default export */ __webpack_exports__["default"] = (thunk);

/***/ }),

/***/ "../../node_modules/redux/es/redux.js":
/*!************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/redux/es/redux.js ***!
  \************************************************************************************************/
/*! exports provided: __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "../../node_modules/symbol-observable/es/index.js");


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}




/***/ }),

/***/ "../../node_modules/reselect/es/index.js":
/*!***************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/reselect/es/index.js ***!
  \***************************************************************************************************/
/*! exports provided: defaultMemoize, createSelectorCreator, createSelector, createStructuredSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMemoize", function() { return defaultMemoize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelectorCreator", function() { return createSelectorCreator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelector", function() { return createSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStructuredSelector", function() { return createStructuredSelector; });
function defaultEqualityCheck(a, b) {
  return a === b;
}

function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep;
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = memoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.dependencies = dependencies;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var createSelector = createSelectorCreator(defaultMemoize);

function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}

/***/ }),

/***/ "../../node_modules/resolve-pathname/index.js":
/*!********************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/resolve-pathname/index.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),

/***/ "../../node_modules/symbol-observable/es/index.js":
/*!************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/symbol-observable/es/index.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "../../node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "../../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../../node_modules/symbol-observable/es/ponyfill.js":
/*!***************************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/symbol-observable/es/ponyfill.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "../../node_modules/value-equal/index.js":
/*!***************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/value-equal/index.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),

/***/ "../../node_modules/warning/browser.js":
/*!*************************************************************************************************!*\
  !*** D:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/warning/browser.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./TSX/SystemCenter/Company/CompanyTypeSlice.ts":
/*!******************************************************!*\
  !*** ./TSX/SystemCenter/Company/CompanyTypeSlice.ts ***!
  \******************************************************/
/*! exports provided: FetchCompanyTypes, CompanyTypeSlice, _b, default, SelectCompanyTypes, SelectCompanyTypesStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchCompanyTypes", function() { return FetchCompanyTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompanyTypeSlice", function() { return CompanyTypeSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectCompanyTypes", function() { return SelectCompanyTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectCompanyTypesStatus", function() { return SelectCompanyTypesStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  CompanyTypeSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var _a;

var FetchCompanyTypes = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Companys/FetchCompanyTypes', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetCompanyTypes()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var CompanyTypeSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'CompanyType',
    initialState: {
        Status: 'unitiated',
        CompanyType: [],
        Error: null
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchCompanyTypes.fulfilled, function (state, action) {
            var _a;
            state.Status = 'idle';
            state.Error = null;
            (_a = state.CompanyType).push.apply(_a, __spread(action.payload));
            FetchCompanyTypes();
        });
        builder.addCase(FetchCompanyTypes.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchCompanyTypes.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = CompanyTypeSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (CompanyTypeSlice.reducer);
var SelectCompanyTypes = function (state) { return state.CompanyType.CompanyType; };
var SelectCompanyTypesStatus = function (state) { return state.CompanyType.Status; };
function GetCompanyTypes() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/SystemCenter/CompanyType",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/Store.ts":
/*!*****************************************!*\
  !*** ./TSX/SystemCenter/Store/Store.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var _Company_CompanyTypeSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Company/CompanyTypeSlice */ "./TSX/SystemCenter/Company/CompanyTypeSlice.ts");
//******************************************************************************************************
//  Store.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************


/* harmony default export */ __webpack_exports__["default"] = (Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["configureStore"])({
    reducer: {
        CompanyType: _Company_CompanyTypeSlice__WEBPACK_IMPORTED_MODULE_1__["default"],
    }
}));


/***/ }),

/***/ "./TSX/SystemCenter/SystemCenter.tsx":
/*!*******************************************!*\
  !*** ./TSX/SystemCenter/SystemCenter.tsx ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! querystring */ "../../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history */ "../../node_modules/history/es/index.js");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-redux */ "../../node_modules/react-redux/es/index.js");
/* harmony import */ var _Store_Store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Store/Store */ "./TSX/SystemCenter/Store/Store.ts");
//******************************************************************************************************
//  SystemCenter.tsx - Gbtc
//
//  Copyright © 2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/22/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};







var SystemCenter = function (props) {
    var history = Object(history__WEBPACK_IMPORTED_MODULE_4__["createBrowserHistory"])();
    var ByMeter = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByMeter */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByMeter")]).then(__webpack_require__.bind(null, /*! ./Meter/ByMeter */ "./TSX/SystemCenter/Meter/ByMeter.tsx")); });
    var ByLocation = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByLocation */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("ByLocation")]).then(__webpack_require__.bind(null, /*! ./Location/ByLocation */ "./TSX/SystemCenter/Location/ByLocation.tsx")); });
    var ByAsset = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByAsset */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset"), __webpack_require__.e("ByAsset")]).then(__webpack_require__.bind(null, /*! ./Asset/ByAsset */ "./TSX/SystemCenter/Asset/ByAsset.tsx")); });
    var ByCustomer = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByCustomer */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByCustomer")]).then(__webpack_require__.bind(null, /*! ./Customer/ByCustomer */ "./TSX/SystemCenter/Customer/ByCustomer.tsx")); });
    var ByUser = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByUser */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByUser~User"), __webpack_require__.e("ByUser")]).then(__webpack_require__.bind(null, /*! ./User/ByUser */ "./TSX/SystemCenter/User/ByUser.tsx")); });
    var UserStatistics = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | UserStatistics */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("UserStatistics")]).then(__webpack_require__.bind(null, /*! ./UserStatistics/UserStatistics */ "./TSX/SystemCenter/UserStatistics/UserStatistics.tsx")); });
    var Customer = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Customer */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Customer")]).then(__webpack_require__.bind(null, /*! ./Customer/Customer */ "./TSX/SystemCenter/Customer/Customer.tsx")); });
    var User = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | User */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByUser~User"), __webpack_require__.e("User")]).then(__webpack_require__.bind(null, /*! ./User/User */ "./TSX/SystemCenter/User/User.tsx")); });
    var Asset = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Asset */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Asset~ByAsset"), __webpack_require__.e("Asset")]).then(__webpack_require__.bind(null, /*! ./Asset/Asset */ "./TSX/SystemCenter/Asset/Asset.tsx")); });
    var NewMeterWizard = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | NewMeterWizard */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("NewMeterWizard")]).then(__webpack_require__.bind(null, /*! ./NewMeterWizard/NewMeterWizard */ "./TSX/SystemCenter/NewMeterWizard/NewMeterWizard.tsx")); });
    var ConfigurationHistory = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ConfigurationHistory */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ConfigurationHistory")]).then(__webpack_require__.bind(null, /*! ./ConfigurationHistory/ConfigurationHistory */ "./TSX/SystemCenter/ConfigurationHistory/ConfigurationHistory.tsx")); });
    var Meter = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Meter */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Meter")]).then(__webpack_require__.bind(null, /*! ./Meter/Meter */ "./TSX/SystemCenter/Meter/Meter.tsx")); });
    var Location = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Location */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Location")]).then(__webpack_require__.bind(null, /*! ./Location/Location */ "./TSX/SystemCenter/Location/Location.tsx")); });
    var ByAssetGroup = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByAssetGroup */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("AssetGroup~ByAssetGroup"), __webpack_require__.e("ByAssetGroup")]).then(__webpack_require__.bind(null, /*! ./AssetGroups/ByAssetGroup */ "./TSX/SystemCenter/AssetGroups/ByAssetGroup.tsx")); });
    var AssetGroup = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | AssetGroup */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("AssetGroup~ByAssetGroup"), __webpack_require__.e("AssetGroup")]).then(__webpack_require__.bind(null, /*! ./AssetGroups/AssetGroup */ "./TSX/SystemCenter/AssetGroups/AssetGroup.tsx")); });
    var ByCompany = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByCompany */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("vendors~ByCompany~Company"), __webpack_require__.e("ByCompany")]).then(__webpack_require__.bind(null, /*! ./Company/ByCompany */ "./TSX/SystemCenter/Company/ByCompany.tsx")); });
    var Company = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Company */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("vendors~ByCompany~Company"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Company")]).then(__webpack_require__.bind(null, /*! ./Company/Company */ "./TSX/SystemCenter/Company/Company.tsx")); });
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0__["useState"]([]), 2), roles = _a[0], setRoles = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"](function (x) { return x + 1; }, 0), 2), ignored = _b[0], forceUpdate = _b[1]; // integer state for resize renders
    react__WEBPACK_IMPORTED_MODULE_0__["useEffect"](function () {
        var handle = getRoles();
        handle.done(function (rs) { return setRoles(rs); });
        window.addEventListener('resize', function (evt) { return forceUpdate(); });
        return function cleanup() {
            if (handle.abort != null)
                handle.abort();
            window.removeEventListener('resize', function (evt) { });
        };
    }, []);
    function getRoles() {
        return $.ajax({
            type: "GET",
            url: homePath + "api/SystemCenter/SecurityRoles",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
    }
    if (Object.keys(querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(history.location.search)).length == 0)
        history.push({ pathname: homePath + 'index.cshtml', search: 'name=Meters', state: {} });
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["BrowserRouter"], null,
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "navbar navbar-dark fixed-top bg-dark flex-md-nowrap p-0 shadow", style: { height: 75 } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { className: "col-sm-3 col-md-2 mr-0", style: { textAlign: 'center' }, href: "https://www.gridprotectionalliance.org" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("img", { style: { width: '100%', margin: -5 }, src: "../Images/SystemCenter-TopLeft.png" })),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { className: "navbar-nav px-3" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item text-nowrap" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { className: "nav-link", href: "#" }, "Sign out")))),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "container-fluid", style: { top: 75, position: 'absolute', width: '100%', height: 'calc(100% - 75px)', overflow: 'hidden' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "row", style: { height: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "col bg-light sidebar", style: { maxWidth: 250 } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "sidebar-sticky" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', marginTop: 5, textAlign: 'center' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h3", null, "System Center")),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading" }, "Monitors and Assets"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column" },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Meters"; }, to: controllerViewPath + "?name=Meters" }, "Meters")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Locations"; }, to: controllerViewPath + "?name=Locations" }, "Substations")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Assets"; }, to: controllerViewPath + "?name=Assets" }, "Transmission Assets")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=AssetGroups"; }, to: controllerViewPath + "?name=AssetGroups" }, "Asset Groups"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading" }, "External Links"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column" },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Companies"; }, to: controllerViewPath + "?name=Companies" }, "Companies")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=PQViewCustomers"; }, to: controllerViewPath + "?name=PQViewCustomers" }, "PQView Customer Access")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=PQViewSites"; }, to: controllerViewPath + "?name=PQViewSites" }, "PQView Sites"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading", hidden: roles.indexOf('Administrator') < 0 }, "System Settings"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column", hidden: roles.indexOf('Administrator') < 0 },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=ValueLists"; }, to: controllerViewPath + "?name=ValueLists" }, "Value Lists"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading", hidden: roles.indexOf('Administrator') < 0 }, "User Settings"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column", hidden: roles.indexOf('Administrator') < 0 },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=UserStatistics"; }, to: controllerViewPath + "?name=UserStatistics" }, "User Statistics")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Users"; }, to: controllerViewPath + "?name=Users" }, "Users"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', textAlign: 'center', position: 'absolute', bottom: 50 } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null, "Version 0.1"),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("br", null),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null)))),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "col", style: { width: '100%', height: 'inherit', padding: '0 0 0 0', overflow: 'hidden' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react__WEBPACK_IMPORTED_MODULE_0__["Suspense"], { fallback: react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null, "Loading...") },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Switch"], null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    var qs = querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search);
                                    if (qs['?name'] == undefined || qs['?name'] == "Meters") {
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByMeter, { Roles: roles });
                                    }
                                    else if (qs['?name'] == "Locations") {
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByLocation, { Roles: roles });
                                    }
                                    else if (qs['?name'] == "Assets")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByAsset, { Roles: roles });
                                    else if (qs['?name'] == "AssetGroups")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByAssetGroup, { Roles: roles });
                                    else if (qs['?name'] == "Users")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByUser, { Roles: roles });
                                    else if (qs['?name'] == "Companies")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByCompany, { Roles: roles });
                                    else if (qs['?name'] == "User")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](User, { UserID: qs.UserAccountID });
                                    else if (qs['?name'] == "UserStatistics")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](UserStatistics, { Roles: roles });
                                    else if (qs['?name'] == "Meter")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Meter, { MeterID: parseInt(qs.MeterID) });
                                    else if (qs['?name'] == "Location")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Location, { LocationID: parseInt(qs.LocationID) });
                                    else if (qs['?name'] == "Asset")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Asset, { AssetID: parseInt(qs.AssetID) });
                                    else if (qs['?name'] == "AssetGroup")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](AssetGroup, { AssetGroupID: parseInt(qs.AssetGroupID) });
                                    else if (qs['?name'] == "Customer")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Customer, { CustomerID: parseInt(qs.CustomerID) });
                                    else if (qs['?name'] == "Company")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Company, { CompanyID: parseInt(qs.CompanyID) });
                                    else if (qs['?name'] == "PQViewSites")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("iframe", { style: { width: '100%', height: '100%' }, src: homePath + 'PQViewDataLoader.cshtml' });
                                    else if (qs['?name'] == "PQViewCustomers")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByCustomer, { Roles: roles });
                                    else if (qs['?name'] == "NewMeterWizard")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](NewMeterWizard, null);
                                    else
                                        return null;
                                } }),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    if (roles.indexOf('Administrator') < 0)
                                        return null;
                                    else if (querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search)['?name'] == "ValueLists")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("iframe", { style: { width: '100%', height: '100%' }, src: homePath + 'ValueListGroups.cshtml' });
                                    else
                                        return null;
                                } }),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    if (roles.indexOf('Administrator') < 0 && roles.indexOf('Transmission SME') < 0)
                                        return null;
                                    else if (querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search)['?name'] == "ConfigurationHistory")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ConfigurationHistory, { MeterConfigurationID: parseInt(querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search).MeterConfigurationID), MeterKey: querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search).MeterKey });
                                    else
                                        return null;
                                } }))))))));
};
react_dom__WEBPACK_IMPORTED_MODULE_1__["render"](react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_redux__WEBPACK_IMPORTED_MODULE_5__["Provider"], { store: _Store_Store__WEBPACK_IMPORTED_MODULE_6__["default"] },
    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SystemCenter, null)), document.getElementById('window'));


/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),

/***/ "react-dom":
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),

/***/ "react-router-dom":
/*!*********************************!*\
  !*** external "ReactRouterDOM" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactRouterDOM;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uLi9zcmMvZGV2dG9vbHNFeHRlbnNpb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pc1BsYWluT2JqZWN0LnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbmZpZ3VyZVN0b3JlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY3JlYXRlQWN0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvbWFwQnVpbGRlcnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jcmVhdGVSZWR1Y2VyLnRzIiwid2VicGFjazovLy8uLi9zcmMvY3JlYXRlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9zdGF0ZV9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvZW50aXRpZXMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXBsdWdpbi10cmFuc2Zvcm0tYXN5bmMtdG8tcHJvbWlzZXMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL25hbm9pZC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2Vycm9ycy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2NvbW1vbi50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3R5cGVzL3R5cGVzLWludGVybmFsLnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMvcGx1Z2lucy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc2NvcGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL2ZpbmFsaXplLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9wcm94eS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW1tZXJDbGFzcy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvY3VycmVudC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3BsdWdpbnMvZXM1LnRzIiwid2VicGFjazovLy8uLi9zcmMvcGx1Z2lucy9wYXRjaGVzLnRzIiwid2VicGFjazovLy8uLi9zcmMvcGx1Z2lucy9tYXBzZXQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wbHVnaW5zL2FsbC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2ltbWVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMvZW52LnRzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Db250ZXh0LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9jb25uZWN0LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2hvb2tzL3VzZURpc3BhdGNoLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2hvb2tzL3VzZVJlZHV4Q29udGV4dC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTdG9yZS5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvYmF0Y2guanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzLmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy9EOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0Q6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vRDovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9Db21wYW55L0NvbXBhbnlUeXBlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TdG9yZS9TdG9yZS50cyIsIndlYnBhY2s6Ly8vLi9UU1gvU3lzdGVtQ2VudGVyL1N5c3RlbUNlbnRlci50c3giLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZDNcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdFwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIlJlYWN0RE9NXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RSb3V0ZXJET01cIiJdLCJuYW1lcyI6WyJjb21wb3NlV2l0aERldlRvb2xzIiwid2luZG93IiwiX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwiY29tcG9zZSIsImFwcGx5IiwiaXNQbGFpbk9iamVjdCIsInZhbHVlIiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImdldFRpbWVNZWFzdXJlVXRpbHMiLCJtYXhEZWxheSIsImZuTmFtZSIsImVsYXBzZWQiLCJtZWFzdXJlVGltZSIsImZuIiwic3RhcnRlZCIsIkRhdGUiLCJub3ciLCJmaW5pc2hlZCIsIndhcm5JZkV4Y2VlZGVkIiwiY29uc29sZSIsIndhcm4iLCJNaWRkbGV3YXJlQXJyYXkiLCJjb25jYXQiLCJhcnIiLCJwcmVwZW5kIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNQcm9kdWN0aW9uIiwicHJvY2VzcyIsInByZWZpeCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJFcnJvciIsInN0cmluZ2lmeSIsIm9iaiIsInNlcmlhbGl6ZXIiLCJpbmRlbnQiLCJkZWN5Y2xlciIsIkpTT04iLCJnZXRTZXJpYWxpemUiLCJzdGFjayIsImtleXMiLCJfIiwic2xpY2UiLCJpbmRleE9mIiwiam9pbiIsImtleSIsInRoaXNQb3MiLCJzcGxpY2UiLCJwdXNoIiwiSW5maW5pdHkiLCJjYWxsIiwiaXNJbW11dGFibGVEZWZhdWx0IiwidHJhY2tGb3JNdXRhdGlvbnMiLCJpc0ltbXV0YWJsZSIsImlnbm9yZVBhdGhzIiwidHJhY2tlZFByb3BlcnRpZXMiLCJ0cmFja1Byb3BlcnRpZXMiLCJkZXRlY3RNdXRhdGlvbnMiLCJwYXRoIiwidHJhY2tlZCIsImNoaWxkcmVuIiwiY2hpbGRQYXRoIiwidHJhY2tlZFByb3BlcnR5Iiwic2FtZVBhcmVudFJlZiIsInByZXZPYmoiLCJzYW1lUmVmIiwiTnVtYmVyIiwiaXNOYU4iLCJ3YXNNdXRhdGVkIiwia2V5c1RvRGV0ZWN0IiwiZm9yRWFjaCIsImkiLCJyZXN1bHQiLCJjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJvcHRpb25zIiwiaWdub3JlZFBhdGhzIiwid2FybkFmdGVyIiwiaWdub3JlIiwidHJhY2siLCJiaW5kIiwiZ2V0U3RhdGUiLCJzdGF0ZSIsInRyYWNrZXIiLCJuZXh0IiwiYWN0aW9uIiwibWVhc3VyZVV0aWxzIiwiZGlzcGF0Y2hlZEFjdGlvbiIsImlzUGxhaW4iLCJ2YWwiLCJmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc1NlcmlhbGl6YWJsZSIsImdldEVudHJpZXMiLCJmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZSIsImtleVBhdGgiLCJlbnRyaWVzIiwiaGFzSWdub3JlZFBhdGhzIiwicHJvcGVydHkiLCJuZXN0ZWRWYWx1ZSIsIm5lc3RlZFBhdGgiLCJjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUiLCJpZ25vcmVkQWN0aW9ucyIsImlnbm9yZWRBY3Rpb25QYXRocyIsInN0b3JlQVBJIiwidHlwZSIsImZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJlcnJvciIsImZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSIsImlzQm9vbGVhbiIsIngiLCJjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlIiwiY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlIiwiZ2V0RGVmYXVsdE1pZGRsZXdhcmUiLCJ0aHVuayIsImltbXV0YWJsZUNoZWNrIiwic2VyaWFsaXphYmxlQ2hlY2siLCJtaWRkbGV3YXJlQXJyYXkiLCJ0aHVua01pZGRsZXdhcmUiLCJ3aXRoRXh0cmFBcmd1bWVudCIsImV4dHJhQXJndW1lbnQiLCJpbW11dGFibGVPcHRpb25zIiwidW5zaGlmdCIsInNlcmlhbGl6YWJsZU9wdGlvbnMiLCJJU19QUk9EVUNUSU9OIiwiY29uZmlndXJlU3RvcmUiLCJyZWR1Y2VyIiwibWlkZGxld2FyZSIsImRldlRvb2xzIiwicHJlbG9hZGVkU3RhdGUiLCJlbmhhbmNlcnMiLCJyb290UmVkdWNlciIsImNvbWJpbmVSZWR1Y2VycyIsIm1pZGRsZXdhcmVFbmhhbmNlciIsImFwcGx5TWlkZGxld2FyZSIsImZpbmFsQ29tcG9zZSIsInRyYWNlIiwic3RvcmVFbmhhbmNlcnMiLCJjb21wb3NlZEVuaGFuY2VyIiwiY3JlYXRlU3RvcmUiLCJjcmVhdGVBY3Rpb24iLCJwcmVwYXJlQWN0aW9uIiwiYWN0aW9uQ3JlYXRvciIsInByZXBhcmVkIiwicGF5bG9hZCIsIm1ldGEiLCJ0b1N0cmluZyIsIm1hdGNoIiwiaXNGU0EiLCJldmVyeSIsImlzVmFsaWRLZXkiLCJnZXRUeXBlIiwiZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2siLCJidWlsZGVyQ2FsbGJhY2siLCJhY3Rpb25zTWFwIiwiYWN0aW9uTWF0Y2hlcnMiLCJkZWZhdWx0Q2FzZVJlZHVjZXIiLCJidWlsZGVyIiwiYWRkQ2FzZSIsInR5cGVPckFjdGlvbkNyZWF0b3IiLCJhZGRNYXRjaGVyIiwibWF0Y2hlciIsImFkZERlZmF1bHRDYXNlIiwiY3JlYXRlUmVkdWNlciIsImluaXRpYWxTdGF0ZSIsIm1hcE9yQnVpbGRlckNhbGxiYWNrIiwiZmluYWxBY3Rpb25NYXRjaGVycyIsImZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyIiwiY2FzZVJlZHVjZXJzIiwiZmlsdGVyIiwibWFwIiwiY3IiLCJyZWR1Y2UiLCJwcmV2aW91c1N0YXRlIiwiY2FzZVJlZHVjZXIiLCJpc0RyYWZ0IiwiZHJhZnQiLCJpc0RyYWZ0YWJsZSIsImNyZWF0ZU5leHRTdGF0ZSIsImFjdGlvbktleSIsImNyZWF0ZVNsaWNlIiwibmFtZSIsInJlZHVjZXJzIiwiZXh0cmFSZWR1Y2VycyIsInJlZHVjZXJOYW1lcyIsInNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lIiwic2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUiLCJhY3Rpb25DcmVhdG9ycyIsInJlZHVjZXJOYW1lIiwibWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUiLCJwcmVwYXJlQ2FsbGJhY2siLCJwcmVwYXJlIiwiZmluYWxDYXNlUmVkdWNlcnMiLCJhY3Rpb25zIiwiZ2V0SW5pdGlhbEVudGl0eVN0YXRlIiwiaWRzIiwiZW50aXRpZXMiLCJjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IiwiZ2V0SW5pdGlhbFN0YXRlIiwiYWRkaXRpb25hbFN0YXRlIiwiYXNzaWduIiwiY3JlYXRlU2VsZWN0b3JzRmFjdG9yeSIsImdldFNlbGVjdG9ycyIsInNlbGVjdFN0YXRlIiwic2VsZWN0SWRzIiwic2VsZWN0RW50aXRpZXMiLCJzZWxlY3RBbGwiLCJjcmVhdGVTZWxlY3RvciIsImlkIiwic2VsZWN0SWQiLCJzZWxlY3RCeUlkIiwic2VsZWN0VG90YWwiLCJzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMiLCJjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3IiLCJtdXRhdG9yIiwib3BlcmF0b3IiLCJjcmVhdGVTdGF0ZU9wZXJhdG9yIiwib3BlcmF0aW9uIiwiYXJnIiwiaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQiLCJydW5NdXRhdG9yIiwic2VsZWN0SWRWYWx1ZSIsImVudGl0eSIsImNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIiwiYWRkT25lTXV0YWJseSIsImFkZE1hbnlNdXRhYmx5IiwidmFsdWVzIiwic2V0QWxsTXV0YWJseSIsInJlbW92ZU9uZU11dGFibHkiLCJyZW1vdmVNYW55TXV0YWJseSIsImRpZE11dGF0ZSIsInJlbW92ZUFsbE11dGFibHkiLCJ0YWtlTmV3S2V5IiwidXBkYXRlIiwib3JpZ2luYWwiLCJ1cGRhdGVkIiwiY2hhbmdlcyIsIm5ld0tleSIsImhhc05ld0tleSIsInVwZGF0ZU9uZU11dGFibHkiLCJ1cGRhdGVNYW55TXV0YWJseSIsInVwZGF0ZXMiLCJuZXdLZXlzIiwidXBkYXRlc1BlckVudGl0eSIsImRpZE11dGF0ZUVudGl0aWVzIiwiZGlkTXV0YXRlSWRzIiwidXBzZXJ0T25lTXV0YWJseSIsInVwc2VydE1hbnlNdXRhYmx5IiwiYWRkZWQiLCJyZW1vdmVBbGwiLCJhZGRPbmUiLCJhZGRNYW55Iiwic2V0QWxsIiwidXBkYXRlT25lIiwidXBkYXRlTWFueSIsInVwc2VydE9uZSIsInVwc2VydE1hbnkiLCJyZW1vdmVPbmUiLCJyZW1vdmVNYW55IiwiY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIiwic29ydCIsIm5ld01vZGVscyIsIm1vZGVscyIsIm1vZGVsIiwibWVyZ2UiLCJ0YWtlVXBkYXRlZE1vZGVsIiwiYXJlQXJyYXlzRXF1YWwiLCJhIiwiYiIsImFsbEVudGl0aWVzIiwibmV3U29ydGVkSWRzIiwiY3JlYXRlRW50aXR5QWRhcHRlciIsInNvcnRDb21wYXJlciIsImluc3RhbmNlIiwic3RhdGVGYWN0b3J5Iiwic2VsZWN0b3JzRmFjdG9yeSIsInN0YXRlQWRhcHRlciIsInVybEFscGhhYmV0IiwibmFub2lkIiwic2l6ZSIsIk1hdGgiLCJyYW5kb20iLCJjb21tb25Qcm9wZXJ0aWVzIiwiUmVqZWN0V2l0aFZhbHVlIiwibWluaVNlcmlhbGl6ZUVycm9yIiwic2ltcGxlRXJyb3IiLCJTdHJpbmciLCJjcmVhdGVBc3luY1RodW5rIiwidHlwZVByZWZpeCIsInBheWxvYWRDcmVhdG9yIiwiZnVsZmlsbGVkIiwicmVxdWVzdElkIiwicGVuZGluZyIsInJlamVjdGVkIiwiYWJvcnRlZCIsImRpc3BsYXllZFdhcm5pbmciLCJBQyIsIkFib3J0Q29udHJvbGxlciIsImFkZEV2ZW50TGlzdGVuZXIiLCJkaXNwYXRjaEV2ZW50Iiwib25hYm9ydCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhYm9ydCIsImluZm8iLCJkaXNwYXRjaCIsImV4dHJhIiwiYWJvcnRDb250cm9sbGVyIiwiYWJvcnRSZWFzb24iLCJhYm9ydGVkUHJvbWlzZSIsIlByb21pc2UiLCJyZWplY3QiLCJzaWduYWwiLCJyZWFzb24iLCJwcm9taXNlIiwic2tpcERpc3BhdGNoIiwiZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24iLCJmaW5hbEFjdGlvbiIsInJhY2UiLCJyZXNvbHZlIiwicmVqZWN0V2l0aFZhbHVlIiwidGhlbiIsImVyciIsInVud3JhcFJlc3VsdCIsInJldHVybmVkIiwiZW5hYmxlRVM1IiwiZGllIiwiYXJncyIsImUiLCJlcnJvcnMiLCJtc2ciLCJEUkFGVF9TVEFURSIsInByb3RvdHlwZSIsIkRSQUZUQUJMRSIsImNvbnN0cnVjdG9yIiwiaXNNYXAiLCJpc1NldCIsImJhc2VfIiwiZWFjaCIsIml0ZXIiLCJlbnVtZXJhYmxlT25seSIsImdldEFyY2h0eXBlIiwib3duS2V5cyIsImVudHJ5IiwiaW5kZXgiLCJ0aGluZyIsInR5cGVfIiwiaGFzIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiZ2V0Iiwic2V0IiwicHJvcE9yT2xkVmFsdWUiLCJ0IiwiZGVsZXRlIiwiYWRkIiwiaXMiLCJ5IiwidGFyZ2V0IiwiaGFzTWFwIiwiTWFwIiwiaGFzU2V0IiwiU2V0IiwibGF0ZXN0IiwiY29weV8iLCJzaGFsbG93Q29weSIsImJhc2UiLCJkZXNjcmlwdG9ycyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZXNjIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiY3JlYXRlIiwiZnJlZXplIiwiZGVlcCIsImlzRnJvemVuIiwiY2xlYXIiLCJkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMiLCJnZXRQbHVnaW4iLCJwbHVnaW5LZXkiLCJwbHVnaW4iLCJwbHVnaW5zIiwibG9hZFBsdWdpbiIsImltcGxlbWVudGF0aW9uIiwiZ2V0Q3VycmVudFNjb3BlIiwiY3VycmVudFNjb3BlIiwidXNlUGF0Y2hlc0luU2NvcGUiLCJzY29wZSIsInBhdGNoTGlzdGVuZXIiLCJwYXRjaGVzXyIsImludmVyc2VQYXRjaGVzXyIsInBhdGNoTGlzdGVuZXJfIiwicmV2b2tlU2NvcGUiLCJsZWF2ZVNjb3BlIiwiZHJhZnRzXyIsInJldm9rZURyYWZ0IiwicGFyZW50XyIsImVudGVyU2NvcGUiLCJpbW1lciIsImltbWVyXyIsImNhbkF1dG9GcmVlemVfIiwidW5maW5hbGl6ZWREcmFmdHNfIiwicmV2b2tlXyIsInJldm9rZWRfIiwicHJvY2Vzc1Jlc3VsdCIsImJhc2VEcmFmdCIsImlzUmVwbGFjZWQiLCJ1c2VQcm94aWVzXyIsIndpbGxGaW5hbGl6ZUVTNV8iLCJtb2RpZmllZF8iLCJmaW5hbGl6ZSIsIm1heWJlRnJlZXplIiwiZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfIiwiTk9USElORyIsInJvb3RTY29wZSIsImNoaWxkVmFsdWUiLCJmaW5hbGl6ZVByb3BlcnR5Iiwic2NvcGVfIiwiZmluYWxpemVkXyIsImRyYWZ0XyIsImdlbmVyYXRlUGF0Y2hlc18iLCJwYXJlbnRTdGF0ZSIsInRhcmdldE9iamVjdCIsInJvb3RQYXRoIiwicmVzIiwiYXNzaWduZWRfIiwiYXV0b0ZyZWV6ZV8iLCJwZWVrIiwiZ2V0RGVzY3JpcHRvckZyb21Qcm90byIsInNvdXJjZSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIm1hcmtDaGFuZ2VkIiwicHJlcGFyZUNvcHkiLCJjcmVhdGVQcm94eSIsInBhcmVudCIsInByb3h5TWFwXyIsInByb3h5U2V0XyIsImlzTWFudWFsXyIsInRyYXBzIiwib2JqZWN0VHJhcHMiLCJhcnJheVRyYXBzIiwiUHJveHkiLCJyZXZvY2FibGUiLCJyZXZva2UiLCJwcm94eSIsImNyZWF0ZVByb3h5UHJveHkiLCJjcmVhdGVFUzVQcm94eV8iLCJjdXJyZW50IiwiY3VycmVudEltcGwiLCJjb3B5IiwiYXJjaFR5cGUiLCJoYXNDaGFuZ2VzXyIsImNvcHlIZWxwZXIiLCJmcm9tIiwicHJveHlQcm9wZXJ0eSIsInRoaXMiLCJhc3NlcnRVbnJldm9rZWQiLCJtYXJrQ2hhbmdlc1N3ZWVwIiwiZHJhZnRzIiwiaGFzQXJyYXlDaGFuZ2VzIiwiaGFzT2JqZWN0Q2hhbmdlcyIsImJhc2VWYWx1ZSIsImJhc2VJc0RyYWZ0IiwiZGVzY3JpcHRvciIsImRlZmluZVByb3BlcnR5IiwiY3JlYXRlRVM1RHJhZnQiLCJtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5Iiwib2JqZWN0IiwibWluIiwiZW5hYmxlUGF0Y2hlcyIsImRlZXBDbG9uZVBhdGNoVmFsdWUiLCJjbG9uZWQiLCJjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZCIsIkFERCIsImFwcGx5UGF0Y2hlc18iLCJwYXRjaGVzIiwicGF0Y2giLCJvcCIsImJhc2VQYXRoIiwiaW52ZXJzZVBhdGNoZXMiLCJhc3NpZ25lZFZhbHVlIiwib3JpZ1ZhbHVlIiwiZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkIiwiZ2VuZXJhdGVBcnJheVBhdGNoZXMiLCJnZW5lcmF0ZVNldFBhdGNoZXMiLCJyb290U3RhdGUiLCJyZXBsYWNlbWVudCIsImVuYWJsZU1hcFNldCIsIl9fZXh0ZW5kcyIsImQiLCJfXyIsImV4dGVuZFN0YXRpY3MiLCJwcmVwYXJlTWFwQ29weSIsInByZXBhcmVTZXRDb3B5Iiwic2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJwIiwiRHJhZnRNYXAiLCJjYiIsInRoaXNBcmciLCJfdmFsdWUiLCJfdGhpcyIsIml0ZXJhdG9yIiwiaXRlcmF0b3JTeW1ib2wiLCJfdGhpczIiLCJyIiwiZG9uZSIsIl90aGlzMyIsIkRyYWZ0U2V0IiwiZW5hYmxlQWxsUGx1Z2lucyIsImNhc3REcmFmdCIsImNhc3RJbW11dGFibGUiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJoYXNQcm94aWVzIiwiUmVmbGVjdCIsImZvciIsImRhdGEiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiX2Rlc2MkZ2V0IiwicmVhZFByb3BGcm9tUHJvdG8iLCJjdXJyZW50U3RhdGUiLCJkZWxldGVQcm9wZXJ0eSIsIm93bmVyIiwicGFyc2VJbnQiLCJJbW1lciIsImNvbmZpZyIsInVzZVByb3hpZXMiLCJzZXRVc2VQcm94aWVzIiwiYXV0b0ZyZWV6ZSIsInNldEF1dG9GcmVlemUiLCJwcm9kdWNlIiwicHJvZHVjZVdpdGhQYXRjaGVzIiwicmVjaXBlIiwiZGVmYXVsdEJhc2UiLCJzZWxmIiwiaGFzRXJyb3IiLCJhcmcxIiwiYXJnMiIsImlwIiwiY3JlYXRlRHJhZnQiLCJmaW5pc2hEcmFmdCIsImFwcGx5UGF0Y2hlcyIsImFwcGx5UGF0Y2hlc0ltcGwiXSwibWFwcGluZ3MiOiI7UUFBQTtRQUNBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTtRQUNBO1FBQ0EsUUFBUSxvQkFBb0I7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7Ozs7UUFJQTtRQUNBO1FBQ0EseUNBQXlDLHNtQ0FBc21DO1FBQy9vQzs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7OztRQUdBOztRQUVBO1FBQ0EsaUNBQWlDOztRQUVqQztRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0Esd0JBQXdCLGtDQUFrQztRQUMxRCxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztR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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtB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Ozs7QUNBQSwwQjs7Ozs7Ozs7Ozs7QUNBQSxnQyIsImZpbGUiOiJTeXN0ZW1DZW50ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBpbnN0YWxsIGEgSlNPTlAgY2FsbGJhY2sgZm9yIGNodW5rIGxvYWRpbmdcbiBcdGZ1bmN0aW9uIHdlYnBhY2tKc29ucENhbGxiYWNrKGRhdGEpIHtcbiBcdFx0dmFyIGNodW5rSWRzID0gZGF0YVswXTtcbiBcdFx0dmFyIG1vcmVNb2R1bGVzID0gZGF0YVsxXTtcblxuXG4gXHRcdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuIFx0XHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcbiBcdFx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMCwgcmVzb2x2ZXMgPSBbXTtcbiBcdFx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG4gXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRyZXNvbHZlcy5wdXNoKGluc3RhbGxlZENodW5rc1tjaHVua0lkXVswXSk7XG4gXHRcdFx0fVxuIFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IDA7XG4gXHRcdH1cbiBcdFx0Zm9yKG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vcmVNb2R1bGVzLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZihwYXJlbnRKc29ucEZ1bmN0aW9uKSBwYXJlbnRKc29ucEZ1bmN0aW9uKGRhdGEpO1xuXG4gXHRcdHdoaWxlKHJlc29sdmVzLmxlbmd0aCkge1xuIFx0XHRcdHJlc29sdmVzLnNoaWZ0KCkoKTtcbiBcdFx0fVxuXG4gXHR9O1xuXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIG9iamVjdCB0byBzdG9yZSBsb2FkZWQgYW5kIGxvYWRpbmcgY2h1bmtzXG4gXHQvLyB1bmRlZmluZWQgPSBjaHVuayBub3QgbG9hZGVkLCBudWxsID0gY2h1bmsgcHJlbG9hZGVkL3ByZWZldGNoZWRcbiBcdC8vIFByb21pc2UgPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG4gXHR2YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuIFx0XHRcIlN5c3RlbUNlbnRlclwiOiAwXG4gXHR9O1xuXG5cblxuIFx0Ly8gc2NyaXB0IHBhdGggZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIGpzb25wU2NyaXB0U3JjKGNodW5rSWQpIHtcbiBcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyAoe1widmVuZG9yc35Bc3NldH5Bc3NldEdyb3VwfkJ5QXNzZXR+QnlBc3NldEdyb3VwfkJ5Q29tcGFueX5CeUN1c3RvbWVyfkJ5TG9jYXRpb25+QnlNZXRlcn5CeVVzZXJ+Q29tcGFueX4xNTlhNzE3MVwiOlwidmVuZG9yc35Bc3NldH5Bc3NldEdyb3VwfkJ5QXNzZXR+QnlBc3NldEdyb3VwfkJ5Q29tcGFueX5CeUN1c3RvbWVyfkJ5TG9jYXRpb25+QnlNZXRlcn5CeVVzZXJ+Q29tcGFueX4xNTlhNzE3MVwiLFwiQXNzZXRHcm91cH5CeUFzc2V0R3JvdXBcIjpcIkFzc2V0R3JvdXB+QnlBc3NldEdyb3VwXCIsXCJBc3NldEdyb3VwXCI6XCJBc3NldEdyb3VwXCIsXCJCeUFzc2V0R3JvdXBcIjpcIkJ5QXNzZXRHcm91cFwiLFwiQXNzZXR+QnlBc3NldH5CeUxvY2F0aW9ufkNvbXBhbnl+Q3VzdG9tZXJ+TG9jYXRpb25+TWV0ZXJ+TmV3TWV0ZXJXaXphcmRcIjpcIkFzc2V0fkJ5QXNzZXR+QnlMb2NhdGlvbn5Db21wYW55fkN1c3RvbWVyfkxvY2F0aW9ufk1ldGVyfk5ld01ldGVyV2l6YXJkXCIsXCJBc3NldH5CeUFzc2V0fkxvY2F0aW9ufk1ldGVyfk5ld01ldGVyV2l6YXJkXCI6XCJBc3NldH5CeUFzc2V0fkxvY2F0aW9ufk1ldGVyfk5ld01ldGVyV2l6YXJkXCIsXCJBc3NldH5CeUFzc2V0XCI6XCJBc3NldH5CeUFzc2V0XCIsXCJCeUFzc2V0XCI6XCJCeUFzc2V0XCIsXCJBc3NldH5Db21wYW55fkN1c3RvbWVyfkxvY2F0aW9ufk1ldGVyXCI6XCJBc3NldH5Db21wYW55fkN1c3RvbWVyfkxvY2F0aW9ufk1ldGVyXCIsXCJBc3NldFwiOlwiQXNzZXRcIixcIkxvY2F0aW9uXCI6XCJMb2NhdGlvblwiLFwiTWV0ZXJcIjpcIk1ldGVyXCIsXCJOZXdNZXRlcldpemFyZFwiOlwiTmV3TWV0ZXJXaXphcmRcIixcIkN1c3RvbWVyXCI6XCJDdXN0b21lclwiLFwiQnlMb2NhdGlvblwiOlwiQnlMb2NhdGlvblwiLFwiQnlDdXN0b21lclwiOlwiQnlDdXN0b21lclwiLFwiQnlNZXRlclwiOlwiQnlNZXRlclwiLFwiQnlVc2VyflVzZXJcIjpcIkJ5VXNlcn5Vc2VyXCIsXCJCeVVzZXJcIjpcIkJ5VXNlclwiLFwiVXNlclwiOlwiVXNlclwiLFwiQ29uZmlndXJhdGlvbkhpc3RvcnlcIjpcIkNvbmZpZ3VyYXRpb25IaXN0b3J5XCIsXCJVc2VyU3RhdGlzdGljc1wiOlwiVXNlclN0YXRpc3RpY3NcIixcInZlbmRvcnN+QnlDb21wYW55fkNvbXBhbnlcIjpcInZlbmRvcnN+QnlDb21wYW55fkNvbXBhbnlcIixcIkNvbXBhbnlcIjpcIkNvbXBhbnlcIixcIkJ5Q29tcGFueVwiOlwiQnlDb21wYW55XCJ9W2NodW5rSWRdfHxjaHVua0lkKSArIFwiLmpzXCJcbiBcdH1cblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG4gXHQvLyBUaGlzIGZpbGUgY29udGFpbnMgb25seSB0aGUgZW50cnkgY2h1bmsuXG4gXHQvLyBUaGUgY2h1bmsgbG9hZGluZyBmdW5jdGlvbiBmb3IgYWRkaXRpb25hbCBjaHVua3NcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZSA9IGZ1bmN0aW9uIHJlcXVpcmVFbnN1cmUoY2h1bmtJZCkge1xuIFx0XHR2YXIgcHJvbWlzZXMgPSBbXTtcblxuXG4gXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblxuIFx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdO1xuIFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEgIT09IDApIHsgLy8gMCBtZWFucyBcImFscmVhZHkgaW5zdGFsbGVkXCIuXG5cbiBcdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuIFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSkge1xuIFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0pO1xuIFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHQvLyBzZXR1cCBQcm9taXNlIGluIGNodW5rIGNhY2hlXG4gXHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gPSBbcmVzb2x2ZSwgcmVqZWN0XTtcbiBcdFx0XHRcdH0pO1xuIFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuIFx0XHRcdFx0Ly8gc3RhcnQgY2h1bmsgbG9hZGluZ1xuIFx0XHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuIFx0XHRcdFx0dmFyIG9uU2NyaXB0Q29tcGxldGU7XG5cbiBcdFx0XHRcdHNjcmlwdC5jaGFyc2V0ID0gJ3V0Zi04JztcbiBcdFx0XHRcdHNjcmlwdC50aW1lb3V0ID0gMTIwO1xuIFx0XHRcdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcbiBcdFx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIF9fd2VicGFja19yZXF1aXJlX18ubmMpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0c2NyaXB0LnNyYyA9IGpzb25wU2NyaXB0U3JjKGNodW5rSWQpO1xuXG4gXHRcdFx0XHRvblNjcmlwdENvbXBsZXRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gXHRcdFx0XHRcdC8vIGF2b2lkIG1lbSBsZWFrcyBpbiBJRS5cbiBcdFx0XHRcdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcbiBcdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuIFx0XHRcdFx0XHR2YXIgY2h1bmsgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdFx0XHRcdGlmKGNodW5rICE9PSAwKSB7XG4gXHRcdFx0XHRcdFx0aWYoY2h1bmspIHtcbiBcdFx0XHRcdFx0XHRcdHZhciBlcnJvclR5cGUgPSBldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2xvYWQnID8gJ21pc3NpbmcnIDogZXZlbnQudHlwZSk7XG4gXHRcdFx0XHRcdFx0XHR2YXIgcmVhbFNyYyA9IGV2ZW50ICYmIGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuc3JjO1xuIFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yID0gbmV3IEVycm9yKCdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJyk7XG4gXHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuIFx0XHRcdFx0XHRcdFx0ZXJyb3IucmVxdWVzdCA9IHJlYWxTcmM7XG4gXHRcdFx0XHRcdFx0XHRjaHVua1sxXShlcnJvcik7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IHVuZGVmaW5lZDtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fTtcbiBcdFx0XHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuIFx0XHRcdFx0XHRvblNjcmlwdENvbXBsZXRlKHsgdHlwZTogJ3RpbWVvdXQnLCB0YXJnZXQ6IHNjcmlwdCB9KTtcbiBcdFx0XHRcdH0sIDEyMDAwMCk7XG4gXHRcdFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBvblNjcmlwdENvbXBsZXRlO1xuIFx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuIFx0fTtcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlNjcmlwdHMvXCI7XG5cbiBcdC8vIG9uIGVycm9yIGZ1bmN0aW9uIGZvciBhc3luYyBsb2FkaW5nXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm9lID0gZnVuY3Rpb24oZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgdGhyb3cgZXJyOyB9O1xuXG4gXHR2YXIganNvbnBBcnJheSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSA9IHdpbmRvd1tcIndlYnBhY2tKc29ucFwiXSB8fCBbXTtcbiBcdHZhciBvbGRKc29ucEZ1bmN0aW9uID0ganNvbnBBcnJheS5wdXNoLmJpbmQoanNvbnBBcnJheSk7XG4gXHRqc29ucEFycmF5LnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjaztcbiBcdGpzb25wQXJyYXkgPSBqc29ucEFycmF5LnNsaWNlKCk7XG4gXHRmb3IodmFyIGkgPSAwOyBpIDwganNvbnBBcnJheS5sZW5ndGg7IGkrKykgd2VicGFja0pzb25wQ2FsbGJhY2soanNvbnBBcnJheVtpXSk7XG4gXHR2YXIgcGFyZW50SnNvbnBGdW5jdGlvbiA9IG9sZEpzb25wRnVuY3Rpb247XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vVFNYL1N5c3RlbUNlbnRlci9TeXN0ZW1DZW50ZXIudHN4XCIpO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn0iLCJpbXBvcnQgeyBBY3Rpb24sIEFjdGlvbkNyZWF0b3IsIFN0b3JlRW5oYW5jZXIsIGNvbXBvc2UgfSBmcm9tICdyZWR1eCdcclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VyT3B0aW9ucyB7XHJcbiAgLyoqXHJcbiAgICogdGhlIGluc3RhbmNlIG5hbWUgdG8gYmUgc2hvd2VkIG9uIHRoZSBtb25pdG9yIHBhZ2UuIERlZmF1bHQgdmFsdWUgaXMgYGRvY3VtZW50LnRpdGxlYC5cclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkIGFuZCB0aGVyZSdzIG5vIGRvY3VtZW50IHRpdGxlLCBpdCB3aWxsIGNvbnNpc3Qgb2YgYHRhYklkYCBhbmQgYGluc3RhbmNlSWRgLlxyXG4gICAqL1xyXG4gIG5hbWU/OiBzdHJpbmdcclxuICAvKipcclxuICAgKiBhY3Rpb24gY3JlYXRvcnMgZnVuY3Rpb25zIHRvIGJlIGF2YWlsYWJsZSBpbiB0aGUgRGlzcGF0Y2hlci5cclxuICAgKi9cclxuICBhY3Rpb25DcmVhdG9ycz86IEFjdGlvbkNyZWF0b3I8YW55PltdIHwgeyBba2V5OiBzdHJpbmddOiBBY3Rpb25DcmVhdG9yPGFueT4gfVxyXG4gIC8qKlxyXG4gICAqIGlmIG1vcmUgdGhhbiBvbmUgYWN0aW9uIGlzIGRpc3BhdGNoZWQgaW4gdGhlIGluZGljYXRlZCBpbnRlcnZhbCwgYWxsIG5ldyBhY3Rpb25zIHdpbGwgYmUgY29sbGVjdGVkIGFuZCBzZW50IGF0IG9uY2UuXHJcbiAgICogSXQgaXMgdGhlIGpvaW50IGJldHdlZW4gcGVyZm9ybWFuY2UgYW5kIHNwZWVkLiBXaGVuIHNldCB0byBgMGAsIGFsbCBhY3Rpb25zIHdpbGwgYmUgc2VudCBpbnN0YW50bHkuXHJcbiAgICogU2V0IGl0IHRvIGEgaGlnaGVyIHZhbHVlIHdoZW4gZXhwZXJpZW5jaW5nIHBlcmYgaXNzdWVzIChhbHNvIGBtYXhBZ2VgIHRvIGEgbG93ZXIgdmFsdWUpLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgNTAwIG1zLlxyXG4gICAqL1xyXG4gIGxhdGVuY3k/OiBudW1iZXJcclxuICAvKipcclxuICAgKiAoPiAxKSAtIG1heGltdW0gYWxsb3dlZCBhY3Rpb25zIHRvIGJlIHN0b3JlZCBpbiB0aGUgaGlzdG9yeSB0cmVlLiBUaGUgb2xkZXN0IGFjdGlvbnMgYXJlIHJlbW92ZWQgb25jZSBtYXhBZ2UgaXMgcmVhY2hlZC4gSXQncyBjcml0aWNhbCBmb3IgcGVyZm9ybWFuY2UuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCA1MFxyXG4gICAqL1xyXG4gIG1heEFnZT86IG51bWJlclxyXG4gIC8qKlxyXG4gICAqIC0gYHVuZGVmaW5lZGAgLSB3aWxsIHVzZSByZWd1bGFyIGBKU09OLnN0cmluZ2lmeWAgdG8gc2VuZCBkYXRhIChpdCdzIHRoZSBmYXN0IG1vZGUpLlxyXG4gICAqIC0gYGZhbHNlYCAtIHdpbGwgaGFuZGxlIGFsc28gY2lyY3VsYXIgcmVmZXJlbmNlcy5cclxuICAgKiAtIGB0cnVlYCAtIHdpbGwgaGFuZGxlIGFsc28gZGF0ZSwgcmVnZXgsIHVuZGVmaW5lZCwgZXJyb3Igb2JqZWN0cywgc3ltYm9scywgbWFwcywgc2V0cyBhbmQgZnVuY3Rpb25zLlxyXG4gICAqIC0gb2JqZWN0LCB3aGljaCBjb250YWlucyBgZGF0ZWAsIGByZWdleGAsIGB1bmRlZmluZWRgLCBgZXJyb3JgLCBgc3ltYm9sYCwgYG1hcGAsIGBzZXRgIGFuZCBgZnVuY3Rpb25gIGtleXMuXHJcbiAgICogICBGb3IgZWFjaCBvZiB0aGVtIHlvdSBjYW4gaW5kaWNhdGUgaWYgdG8gaW5jbHVkZSAoYnkgc2V0dGluZyBhcyBgdHJ1ZWApLlxyXG4gICAqICAgRm9yIGBmdW5jdGlvbmAga2V5IHlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgY3VzdG9tIGZ1bmN0aW9uIHdoaWNoIGhhbmRsZXMgc2VyaWFsaXphdGlvbi5cclxuICAgKiAgIFNlZSBbYGpzYW5gXShodHRwczovL2dpdGh1Yi5jb20va29sb2RueS9qc2FuKSBmb3IgbW9yZSBkZXRhaWxzLlxyXG4gICAqL1xyXG4gIHNlcmlhbGl6ZT86XHJcbiAgICB8IGJvb2xlYW5cclxuICAgIHwge1xyXG4gICAgICAgIGRhdGU/OiBib29sZWFuXHJcbiAgICAgICAgcmVnZXg/OiBib29sZWFuXHJcbiAgICAgICAgdW5kZWZpbmVkPzogYm9vbGVhblxyXG4gICAgICAgIGVycm9yPzogYm9vbGVhblxyXG4gICAgICAgIHN5bWJvbD86IGJvb2xlYW5cclxuICAgICAgICBtYXA/OiBib29sZWFuXHJcbiAgICAgICAgc2V0PzogYm9vbGVhblxyXG4gICAgICAgIGZ1bmN0aW9uPzogYm9vbGVhbiB8IEZ1bmN0aW9uXHJcbiAgICAgIH1cclxuICAvKipcclxuICAgKiBmdW5jdGlvbiB3aGljaCB0YWtlcyBgYWN0aW9uYCBvYmplY3QgYW5kIGlkIG51bWJlciBhcyBhcmd1bWVudHMsIGFuZCBzaG91bGQgcmV0dXJuIGBhY3Rpb25gIG9iamVjdCBiYWNrLlxyXG4gICAqL1xyXG4gIGFjdGlvblNhbml0aXplcj86IDxBIGV4dGVuZHMgQWN0aW9uPihhY3Rpb246IEEsIGlkOiBudW1iZXIpID0+IEFcclxuICAvKipcclxuICAgKiBmdW5jdGlvbiB3aGljaCB0YWtlcyBgc3RhdGVgIG9iamVjdCBhbmQgaW5kZXggYXMgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiBgc3RhdGVgIG9iamVjdCBiYWNrLlxyXG4gICAqL1xyXG4gIHN0YXRlU2FuaXRpemVyPzogPFM+KHN0YXRlOiBTLCBpbmRleDogbnVtYmVyKSA9PiBTXHJcbiAgLyoqXHJcbiAgICogKnN0cmluZyBvciBhcnJheSBvZiBzdHJpbmdzIGFzIHJlZ2V4KiAtIGFjdGlvbnMgdHlwZXMgdG8gYmUgaGlkZGVuIC8gc2hvd24gaW4gdGhlIG1vbml0b3JzICh3aGlsZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXJzKS5cclxuICAgKiBJZiBgYWN0aW9uc1doaXRlbGlzdGAgc3BlY2lmaWVkLCBgYWN0aW9uc0JsYWNrbGlzdGAgaXMgaWdub3JlZC5cclxuICAgKi9cclxuICBhY3Rpb25zQmxhY2tsaXN0Pzogc3RyaW5nIHwgc3RyaW5nW11cclxuICAvKipcclxuICAgKiAqc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgYXMgcmVnZXgqIC0gYWN0aW9ucyB0eXBlcyB0byBiZSBoaWRkZW4gLyBzaG93biBpbiB0aGUgbW9uaXRvcnMgKHdoaWxlIHBhc3NlZCB0byB0aGUgcmVkdWNlcnMpLlxyXG4gICAqIElmIGBhY3Rpb25zV2hpdGVsaXN0YCBzcGVjaWZpZWQsIGBhY3Rpb25zQmxhY2tsaXN0YCBpcyBpZ25vcmVkLlxyXG4gICAqL1xyXG4gIGFjdGlvbnNXaGl0ZWxpc3Q/OiBzdHJpbmcgfCBzdHJpbmdbXVxyXG4gIC8qKlxyXG4gICAqIGNhbGxlZCBmb3IgZXZlcnkgYWN0aW9uIGJlZm9yZSBzZW5kaW5nLCB0YWtlcyBgc3RhdGVgIGFuZCBgYWN0aW9uYCBvYmplY3QsIGFuZCByZXR1cm5zIGB0cnVlYCBpbiBjYXNlIGl0IGFsbG93cyBzZW5kaW5nIHRoZSBjdXJyZW50IGRhdGEgdG8gdGhlIG1vbml0b3IuXHJcbiAgICogVXNlIGl0IGFzIGEgbW9yZSBhZHZhbmNlZCB2ZXJzaW9uIG9mIGBhY3Rpb25zQmxhY2tsaXN0YC9gYWN0aW9uc1doaXRlbGlzdGAgcGFyYW1ldGVycy5cclxuICAgKi9cclxuICBwcmVkaWNhdGU/OiA8UywgQSBleHRlbmRzIEFjdGlvbj4oc3RhdGU6IFMsIGFjdGlvbjogQSkgPT4gYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgZmFsc2VgLCBpdCB3aWxsIG5vdCByZWNvcmQgdGhlIGNoYW5nZXMgdGlsbCBjbGlja2luZyBvbiBgU3RhcnQgcmVjb3JkaW5nYCBidXR0b24uXHJcbiAgICogQXZhaWxhYmxlIG9ubHkgZm9yIFJlZHV4IGVuaGFuY2VyLCBmb3Igb3RoZXJzIHVzZSBgYXV0b1BhdXNlYC5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IHRydWVcclxuICAgKi9cclxuICBzaG91bGRSZWNvcmRDaGFuZ2VzPzogYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCwgd2hlbmV2ZXIgY2xpY2tpbmcgb24gYFBhdXNlIHJlY29yZGluZ2AgYnV0dG9uIGFuZCB0aGVyZSBhcmUgYWN0aW9ucyBpbiB0aGUgaGlzdG9yeSBsb2csIHdpbGwgYWRkIHRoaXMgYWN0aW9uIHR5cGUuXHJcbiAgICogSWYgbm90IHNwZWNpZmllZCwgd2lsbCBjb21taXQgd2hlbiBwYXVzZWQuIEF2YWlsYWJsZSBvbmx5IGZvciBSZWR1eCBlbmhhbmNlci5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IFwiQEBQQVVTRURcIlwiXHJcbiAgICovXHJcbiAgcGF1c2VBY3Rpb25UeXBlPzogc3RyaW5nXHJcbiAgLyoqXHJcbiAgICogYXV0byBwYXVzZXMgd2hlbiB0aGUgZXh0ZW5zaW9u4oCZcyB3aW5kb3cgaXMgbm90IG9wZW5lZCwgYW5kIHNvIGhhcyB6ZXJvIGltcGFjdCBvbiB5b3VyIGFwcCB3aGVuIG5vdCBpbiB1c2UuXHJcbiAgICogTm90IGF2YWlsYWJsZSBmb3IgUmVkdXggZW5oYW5jZXIgKGFzIGl0IGFscmVhZHkgZG9lcyBpdCBidXQgc3RvcmluZyB0aGUgZGF0YSB0byBiZSBzZW50KS5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXHJcbiAgYXV0b1BhdXNlPzogYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgdHJ1ZWAsIGl0IHdpbGwgbm90IGFsbG93IGFueSBub24tbW9uaXRvciBhY3Rpb25zIHRvIGJlIGRpc3BhdGNoZWQgdGlsbCBjbGlja2luZyBvbiBgVW5sb2NrIGNoYW5nZXNgIGJ1dHRvbi5cclxuICAgKiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqL1xyXG4gIHNob3VsZFN0YXJ0TG9ja2VkPzogYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIGlmIHNldCB0byBgZmFsc2VgLCB3aWxsIG5vdCByZWNvbXB1dGUgdGhlIHN0YXRlcyBvbiBob3QgcmVsb2FkaW5nIChvciBvbiByZXBsYWNpbmcgdGhlIHJlZHVjZXJzKS4gQXZhaWxhYmxlIG9ubHkgZm9yIFJlZHV4IGVuaGFuY2VyLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAqL1xyXG4gIHNob3VsZEhvdFJlbG9hZD86IGJvb2xlYW5cclxuICAvKipcclxuICAgKiBpZiBzcGVjaWZpZWQgYXMgYHRydWVgLCB3aGVuZXZlciB0aGVyZSdzIGFuIGV4Y2VwdGlvbiBpbiByZWR1Y2VycywgdGhlIG1vbml0b3JzIHdpbGwgc2hvdyB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIG5leHQgYWN0aW9ucyB3aWxsIG5vdCBiZSBkaXNwYXRjaGVkLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgKi9cclxuICBzaG91bGRDYXRjaEVycm9ycz86IGJvb2xlYW5cclxuICAvKipcclxuICAgKiBJZiB5b3Ugd2FudCB0byByZXN0cmljdCB0aGUgZXh0ZW5zaW9uLCBzcGVjaWZ5IHRoZSBmZWF0dXJlcyB5b3UgYWxsb3cuXHJcbiAgICogSWYgbm90IHNwZWNpZmllZCwgYWxsIG9mIHRoZSBmZWF0dXJlcyBhcmUgZW5hYmxlZC4gV2hlbiBzZXQgYXMgYW4gb2JqZWN0LCBvbmx5IHRob3NlIGluY2x1ZGVkIGFzIGB0cnVlYCB3aWxsIGJlIGFsbG93ZWQuXHJcbiAgICogTm90ZSB0aGF0IGV4Y2VwdCBgdHJ1ZWAvYGZhbHNlYCwgYGltcG9ydGAgYW5kIGBleHBvcnRgIGNhbiBiZSBzZXQgYXMgYGN1c3RvbWAgKHdoaWNoIGlzIGJ5IGRlZmF1bHQgZm9yIFJlZHV4IGVuaGFuY2VyKSwgbWVhbmluZyB0aGF0IHRoZSBpbXBvcnRpbmcvZXhwb3J0aW5nIG9jY3VycyBvbiB0aGUgY2xpZW50IHNpZGUuXHJcbiAgICogT3RoZXJ3aXNlLCB5b3UnbGwgZ2V0L3NldCB0aGUgZGF0YSByaWdodCBmcm9tIHRoZSBtb25pdG9yIHBhcnQuXHJcbiAgICovXHJcbiAgZmVhdHVyZXM/OiB7XHJcbiAgICAvKipcclxuICAgICAqIHN0YXJ0L3BhdXNlIHJlY29yZGluZyBvZiBkaXNwYXRjaGVkIGFjdGlvbnNcclxuICAgICAqL1xyXG4gICAgcGF1c2U/OiBib29sZWFuXHJcbiAgICAvKipcclxuICAgICAqIGxvY2svdW5sb2NrIGRpc3BhdGNoaW5nIGFjdGlvbnMgYW5kIHNpZGUgZWZmZWN0c1xyXG4gICAgICovXHJcbiAgICBsb2NrPzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBwZXJzaXN0IHN0YXRlcyBvbiBwYWdlIHJlbG9hZGluZ1xyXG4gICAgICovXHJcbiAgICBwZXJzaXN0PzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBleHBvcnQgaGlzdG9yeSBvZiBhY3Rpb25zIGluIGEgZmlsZVxyXG4gICAgICovXHJcbiAgICBleHBvcnQ/OiBib29sZWFuIHwgJ2N1c3RvbSdcclxuICAgIC8qKlxyXG4gICAgICogaW1wb3J0IGhpc3Rvcnkgb2YgYWN0aW9ucyBmcm9tIGEgZmlsZVxyXG4gICAgICovXHJcbiAgICBpbXBvcnQ/OiBib29sZWFuIHwgJ2N1c3RvbSdcclxuICAgIC8qKlxyXG4gICAgICoganVtcCBiYWNrIGFuZCBmb3J0aCAodGltZSB0cmF2ZWxsaW5nKVxyXG4gICAgICovXHJcbiAgICBqdW1wPzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBza2lwIChjYW5jZWwpIGFjdGlvbnNcclxuICAgICAqL1xyXG4gICAgc2tpcD86IGJvb2xlYW5cclxuICAgIC8qKlxyXG4gICAgICogZHJhZyBhbmQgZHJvcCBhY3Rpb25zIGluIHRoZSBoaXN0b3J5IGxpc3RcclxuICAgICAqL1xyXG4gICAgcmVvcmRlcj86IGJvb2xlYW5cclxuICAgIC8qKlxyXG4gICAgICogZGlzcGF0Y2ggY3VzdG9tIGFjdGlvbnMgb3IgYWN0aW9uIGNyZWF0b3JzXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoPzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBnZW5lcmF0ZSB0ZXN0cyBmb3IgdGhlIHNlbGVjdGVkIGFjdGlvbnNcclxuICAgICAqL1xyXG4gICAgdGVzdD86IGJvb2xlYW5cclxuICB9XHJcbiAgLyoqXHJcbiAgICogU2V0IHRvIHRydWUgb3IgYSBzdGFja3RyYWNlLXJldHVybmluZyBmdW5jdGlvbiB0byByZWNvcmQgY2FsbCBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgYWN0aW9ucy5cclxuICAgKiBEZWZhdWx0cyB0byBmYWxzZS5cclxuICAgKi9cclxuICB0cmFjZT86IGJvb2xlYW4gfCAoPEEgZXh0ZW5kcyBBY3Rpb24+KGFjdGlvbjogQSkgPT4gc3RyaW5nKVxyXG4gIC8qKlxyXG4gICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGFjayB0cmFjZSBlbnRyaWVzIHRvIHJlY29yZCBwZXIgYWN0aW9uLiBEZWZhdWx0cyB0byAxMC5cclxuICAgKi9cclxuICB0cmFjZUxpbWl0PzogbnVtYmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgY29tcG9zZVdpdGhEZXZUb29sczoge1xyXG4gIChvcHRpb25zOiBFbmhhbmNlck9wdGlvbnMpOiB0eXBlb2YgY29tcG9zZVxyXG4gIDxTdG9yZUV4dD4oLi4uZnVuY3M6IEFycmF5PFN0b3JlRW5oYW5jZXI8U3RvcmVFeHQ+Pik6IFN0b3JlRW5oYW5jZXI8U3RvcmVFeHQ+XHJcbn0gPVxyXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgKHdpbmRvdyBhcyBhbnkpLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfX1xyXG4gICAgPyAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fXHJcbiAgICA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdvYmplY3QnKSByZXR1cm4gY29tcG9zZVxyXG4gICAgICAgIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIChhcmd1bWVudHMgYXMgYW55KSBhcyBGdW5jdGlvbltdKVxyXG4gICAgICB9XHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGRldlRvb2xzRW5oYW5jZXI6IHtcclxuICAob3B0aW9uczogRW5oYW5jZXJPcHRpb25zKTogU3RvcmVFbmhhbmNlcjxhbnk+XHJcbn0gPVxyXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgYXMgYW55KS5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fXHJcbiAgICA/ICh3aW5kb3cgYXMgYW55KS5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9fXHJcbiAgICA6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbihub29wKSB7XHJcbiAgICAgICAgICByZXR1cm4gbm9vcFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4iLCIvKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgXCJwbGFpblwiIG9iamVjdCwgaS5lLiBhbiBvYmplY3Qgd2hvc2VcclxuICogcHJvdG95cGUgaXMgdGhlIHJvb3QgYE9iamVjdC5wcm90b3R5cGVgLiBUaGlzIGluY2x1ZGVzIG9iamVjdHMgY3JlYXRlZFxyXG4gKiB1c2luZyBvYmplY3QgbGl0ZXJhbHMsIGJ1dCBub3QgZm9yIGluc3RhbmNlIGZvciBjbGFzcyBpbnN0YW5jZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgb2JqZWN0IHtcclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXHJcblxyXG4gIGxldCBwcm90byA9IHZhbHVlXHJcbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykgIT09IG51bGwpIHtcclxuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvXHJcbn1cclxuIiwiaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gJ3JlZHV4J1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVNZWFzdXJlVXRpbHMobWF4RGVsYXk6IG51bWJlciwgZm5OYW1lOiBzdHJpbmcpIHtcclxuICBsZXQgZWxhcHNlZCA9IDBcclxuICByZXR1cm4ge1xyXG4gICAgbWVhc3VyZVRpbWU8VD4oZm46ICgpID0+IFQpOiBUIHtcclxuICAgICAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KClcclxuICAgICAgdHJ5IHtcclxuICAgICAgICByZXR1cm4gZm4oKVxyXG4gICAgICB9IGZpbmFsbHkge1xyXG4gICAgICAgIGNvbnN0IGZpbmlzaGVkID0gRGF0ZS5ub3coKVxyXG4gICAgICAgIGVsYXBzZWQgKz0gZmluaXNoZWQgLSBzdGFydGVkXHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB3YXJuSWZFeGNlZWRlZCgpIHtcclxuICAgICAgaWYgKGVsYXBzZWQgPiBtYXhEZWxheSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgJHtmbk5hbWV9IHRvb2sgJHtlbGFwc2VkfW1zLCB3aGljaCBpcyBtb3JlIHRoYW4gdGhlIHdhcm5pbmcgdGhyZXNob2xkIG9mICR7bWF4RGVsYXl9bXMuIFxyXG5JZiB5b3VyIHN0YXRlIG9yIGFjdGlvbnMgYXJlIHZlcnkgbGFyZ2UsIHlvdSBtYXkgd2FudCB0byBkaXNhYmxlIHRoZSBtaWRkbGV3YXJlIGFzIGl0IG1pZ2h0IGNhdXNlIHRvbyBtdWNoIG9mIGEgc2xvd2Rvd24gaW4gZGV2ZWxvcG1lbnQgbW9kZS4gU2VlIGh0dHBzOi8vcmVkdXgtdG9vbGtpdC5qcy5vcmcvYXBpL2dldERlZmF1bHRNaWRkbGV3YXJlIGZvciBpbnN0cnVjdGlvbnMuXHJcbkl0IGlzIGRpc2FibGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzLCBzbyB5b3UgZG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCB0aGF0LmApXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWlkZGxld2FyZUFycmF5PFxyXG4gIE1pZGRsZXdhcmVzIGV4dGVuZHMgTWlkZGxld2FyZTxhbnksIGFueT5cclxuPiBleHRlbmRzIEFycmF5PE1pZGRsZXdhcmVzPiB7XHJcbiAgY29uY2F0PEFkZGl0aW9uYWxNaWRkbGV3YXJlcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8TWlkZGxld2FyZTxhbnksIGFueT4+PihcclxuICAgIGl0ZW1zOiBBZGRpdGlvbmFsTWlkZGxld2FyZXNcclxuICApOiBNaWRkbGV3YXJlQXJyYXk8TWlkZGxld2FyZXMgfCBBZGRpdGlvbmFsTWlkZGxld2FyZXNbbnVtYmVyXT5cclxuXHJcbiAgY29uY2F0PEFkZGl0aW9uYWxNaWRkbGV3YXJlcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8TWlkZGxld2FyZTxhbnksIGFueT4+PihcclxuICAgIC4uLml0ZW1zOiBBZGRpdGlvbmFsTWlkZGxld2FyZXNcclxuICApOiBNaWRkbGV3YXJlQXJyYXk8TWlkZGxld2FyZXMgfCBBZGRpdGlvbmFsTWlkZGxld2FyZXNbbnVtYmVyXT5cclxuXHJcbiAgY29uY2F0KC4uLmFycjogYW55W10pIHtcclxuICAgIHJldHVybiBuZXcgTWlkZGxld2FyZUFycmF5KC4uLnN1cGVyLmNvbmNhdCguLi5hcnIpKVxyXG4gIH1cclxuXHJcbiAgcHJlcGVuZDxBZGRpdGlvbmFsTWlkZGxld2FyZXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU8YW55LCBhbnk+Pj4oXHJcbiAgICBpdGVtczogQWRkaXRpb25hbE1pZGRsZXdhcmVzXHJcbiAgKTogTWlkZGxld2FyZUFycmF5PEFkZGl0aW9uYWxNaWRkbGV3YXJlc1tudW1iZXJdIHwgTWlkZGxld2FyZXM+XHJcblxyXG4gIHByZXBlbmQ8QWRkaXRpb25hbE1pZGRsZXdhcmVzIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxNaWRkbGV3YXJlPGFueSwgYW55Pj4+KFxyXG4gICAgLi4uaXRlbXM6IEFkZGl0aW9uYWxNaWRkbGV3YXJlc1xyXG4gICk6IE1pZGRsZXdhcmVBcnJheTxBZGRpdGlvbmFsTWlkZGxld2FyZXNbbnVtYmVyXSB8IE1pZGRsZXdhcmVzPlxyXG5cclxuICBwcmVwZW5kKC4uLmFycjogYW55W10pIHtcclxuICAgIGlmIChhcnIubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoYXJyWzBdKSkge1xyXG4gICAgICByZXR1cm4gbmV3IE1pZGRsZXdhcmVBcnJheSguLi5hcnJbMF0uY29uY2F0KHRoaXMpKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBNaWRkbGV3YXJlQXJyYXkoLi4uYXJyLmNvbmNhdCh0aGlzKSlcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTWlkZGxld2FyZSB9IGZyb20gJ3JlZHV4J1xyXG5pbXBvcnQgeyBnZXRUaW1lTWVhc3VyZVV0aWxzIH0gZnJvbSAnLi91dGlscydcclxuXHJcbnR5cGUgRW50cnlQcm9jZXNzb3IgPSAoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpID0+IGFueVxyXG5cclxuY29uc3QgaXNQcm9kdWN0aW9uOiBib29sZWFuID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xyXG5jb25zdCBwcmVmaXg6IHN0cmluZyA9ICdJbnZhcmlhbnQgZmFpbGVkJ1xyXG5cclxuLy8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIGNvbmRpdGlvbiBmYWlsc1xyXG4vLyBTdHJpcCBvdXQgZXJyb3IgbWVzc2FnZXMgZm9yIHByb2R1Y3Rpb25cclxuLy8gPiBOb3QgcHJvdmlkaW5nIGFuIGlubGluZSBkZWZhdWx0IGFyZ3VtZW50IGZvciBtZXNzYWdlIGFzIHRoZSByZXN1bHQgaXMgc21hbGxlclxyXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZGl0aW9uOiBhbnksIG1lc3NhZ2U/OiBzdHJpbmcpIHtcclxuICBpZiAoY29uZGl0aW9uKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgLy8gQ29uZGl0aW9uIG5vdCBwYXNzZWRcclxuXHJcbiAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBzdHJpcCB0aGUgbWVzc2FnZSBidXQgc3RpbGwgdGhyb3dcclxuICBpZiAoaXNQcm9kdWN0aW9uKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4KVxyXG4gIH1cclxuXHJcbiAgLy8gV2hlbiBub3QgaW4gcHJvZHVjdGlvbiB3ZSBhbGxvdyB0aGUgbWVzc2FnZSB0byBwYXNzIHRocm91Z2hcclxuICAvLyAqVGhpcyBibG9jayB3aWxsIGJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMqXHJcbiAgdGhyb3cgbmV3IEVycm9yKGAke3ByZWZpeH06ICR7bWVzc2FnZSB8fCAnJ31gKVxyXG59XHJcblxyXG5mdW5jdGlvbiBzdHJpbmdpZnkoXHJcbiAgb2JqOiBhbnksXHJcbiAgc2VyaWFsaXplcj86IEVudHJ5UHJvY2Vzc29yLFxyXG4gIGluZGVudD86IHN0cmluZyB8IG51bWJlcixcclxuICBkZWN5Y2xlcj86IEVudHJ5UHJvY2Vzc29yXHJcbik6IHN0cmluZyB7XHJcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgZ2V0U2VyaWFsaXplKHNlcmlhbGl6ZXIsIGRlY3ljbGVyKSwgaW5kZW50KVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRTZXJpYWxpemUoXHJcbiAgc2VyaWFsaXplcj86IEVudHJ5UHJvY2Vzc29yLFxyXG4gIGRlY3ljbGVyPzogRW50cnlQcm9jZXNzb3JcclxuKTogRW50cnlQcm9jZXNzb3Ige1xyXG4gIGxldCBzdGFjazogYW55W10gPSBbXSxcclxuICAgIGtleXM6IGFueVtdID0gW11cclxuXHJcbiAgaWYgKCFkZWN5Y2xlcilcclxuICAgIGRlY3ljbGVyID0gZnVuY3Rpb24oXzogc3RyaW5nLCB2YWx1ZTogYW55KSB7XHJcbiAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHJldHVybiAnW0NpcmN1bGFyIH5dJ1xyXG4gICAgICByZXR1cm4gKFxyXG4gICAgICAgICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBzdGFjay5pbmRleE9mKHZhbHVlKSkuam9pbignLicpICsgJ10nXHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaXM6IGFueSwga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcclxuICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHZhciB0aGlzUG9zID0gc3RhY2suaW5kZXhPZih0aGlzKVxyXG4gICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpXHJcbiAgICAgIH50aGlzUG9zID8ga2V5cy5zcGxpY2UodGhpc1BvcywgSW5maW5pdHksIGtleSkgOiBrZXlzLnB1c2goa2V5KVxyXG4gICAgICBpZiAofnN0YWNrLmluZGV4T2YodmFsdWUpKSB2YWx1ZSA9IGRlY3ljbGVyIS5jYWxsKHRoaXMsIGtleSwgdmFsdWUpXHJcbiAgICB9IGVsc2Ugc3RhY2sucHVzaCh2YWx1ZSlcclxuXHJcbiAgICByZXR1cm4gc2VyaWFsaXplciA9PSBudWxsID8gdmFsdWUgOiBzZXJpYWxpemVyLmNhbGwodGhpcywga2V5LCB2YWx1ZSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBgaXNJbW11dGFibGVgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNJbW11dGFibGVEZWZhdWx0KHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIChcclxuICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJ1xyXG4gIClcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRm9yTXV0YXRpb25zKFxyXG4gIGlzSW1tdXRhYmxlOiBJc0ltbXV0YWJsZUZ1bmMsXHJcbiAgaWdub3JlUGF0aHM6IHN0cmluZ1tdIHwgdW5kZWZpbmVkLFxyXG4gIG9iajogYW55XHJcbikge1xyXG4gIGNvbnN0IHRyYWNrZWRQcm9wZXJ0aWVzID0gdHJhY2tQcm9wZXJ0aWVzKGlzSW1tdXRhYmxlLCBpZ25vcmVQYXRocywgb2JqKVxyXG4gIHJldHVybiB7XHJcbiAgICBkZXRlY3RNdXRhdGlvbnMoKSB7XHJcbiAgICAgIHJldHVybiBkZXRlY3RNdXRhdGlvbnMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCB0cmFja2VkUHJvcGVydGllcywgb2JqKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFRyYWNrZWRQcm9wZXJ0eSB7XHJcbiAgdmFsdWU6IGFueVxyXG4gIGNoaWxkcmVuOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRyYWNrUHJvcGVydGllcyhcclxuICBpc0ltbXV0YWJsZTogSXNJbW11dGFibGVGdW5jLFxyXG4gIGlnbm9yZVBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLFxyXG4gIG9iajogUmVjb3JkPHN0cmluZywgYW55PixcclxuICBwYXRoOiBzdHJpbmdbXSA9IFtdXHJcbikge1xyXG4gIGNvbnN0IHRyYWNrZWQ6IFBhcnRpYWw8VHJhY2tlZFByb3BlcnR5PiA9IHsgdmFsdWU6IG9iaiB9XHJcblxyXG4gIGlmICghaXNJbW11dGFibGUob2JqKSkge1xyXG4gICAgdHJhY2tlZC5jaGlsZHJlbiA9IHt9XHJcblxyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XHJcbiAgICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGtleSlcclxuICAgICAgaWYgKFxyXG4gICAgICAgIGlnbm9yZVBhdGhzLmxlbmd0aCAmJlxyXG4gICAgICAgIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoLmpvaW4oJy4nKSkgIT09IC0xXHJcbiAgICAgICkge1xyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRyYWNrZWQuY2hpbGRyZW5ba2V5XSA9IHRyYWNrUHJvcGVydGllcyhcclxuICAgICAgICBpc0ltbXV0YWJsZSxcclxuICAgICAgICBpZ25vcmVQYXRocyxcclxuICAgICAgICBvYmpba2V5XSxcclxuICAgICAgICBjaGlsZFBhdGhcclxuICAgICAgKVxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdHJhY2tlZCBhcyBUcmFja2VkUHJvcGVydHlcclxufVxyXG5cclxudHlwZSBJZ25vcmVQYXRocyA9IHN0cmluZ1tdXHJcblxyXG5mdW5jdGlvbiBkZXRlY3RNdXRhdGlvbnMoXHJcbiAgaXNJbW11dGFibGU6IElzSW1tdXRhYmxlRnVuYyxcclxuICBpZ25vcmVQYXRoczogSWdub3JlUGF0aHMgPSBbXSxcclxuICB0cmFja2VkUHJvcGVydHk6IFRyYWNrZWRQcm9wZXJ0eSxcclxuICBvYmo6IGFueSxcclxuICBzYW1lUGFyZW50UmVmOiBib29sZWFuID0gZmFsc2UsXHJcbiAgcGF0aDogc3RyaW5nW10gPSBbXVxyXG4pOiB7IHdhc011dGF0ZWQ6IGJvb2xlYW47IHBhdGg/OiBzdHJpbmdbXSB9IHtcclxuICBjb25zdCBwcmV2T2JqID0gdHJhY2tlZFByb3BlcnR5ID8gdHJhY2tlZFByb3BlcnR5LnZhbHVlIDogdW5kZWZpbmVkXHJcblxyXG4gIGNvbnN0IHNhbWVSZWYgPSBwcmV2T2JqID09PSBvYmpcclxuXHJcbiAgaWYgKHNhbWVQYXJlbnRSZWYgJiYgIXNhbWVSZWYgJiYgIU51bWJlci5pc05hTihvYmopKSB7XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiB0cnVlLCBwYXRoIH1cclxuICB9XHJcblxyXG4gIGlmIChpc0ltbXV0YWJsZShwcmV2T2JqKSB8fCBpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9XHJcbiAgfVxyXG5cclxuICAvLyBHYXRoZXIgYWxsIGtleXMgZnJvbSBwcmV2ICh0cmFja2VkKSBhbmQgYWZ0ZXIgb2Jqc1xyXG4gIGNvbnN0IGtleXNUb0RldGVjdDogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fVxyXG4gIE9iamVjdC5rZXlzKHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlXHJcbiAgfSlcclxuICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goa2V5ID0+IHtcclxuICAgIGtleXNUb0RldGVjdFtrZXldID0gdHJ1ZVxyXG4gIH0pXHJcblxyXG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhrZXlzVG9EZXRlY3QpXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldXHJcbiAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLmNvbmNhdChrZXkpXHJcbiAgICBpZiAoaWdub3JlUGF0aHMubGVuZ3RoICYmIGlnbm9yZVBhdGhzLmluZGV4T2YoY2hpbGRQYXRoLmpvaW4oJy4nKSkgIT09IC0xKSB7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gZGV0ZWN0TXV0YXRpb25zKFxyXG4gICAgICBpc0ltbXV0YWJsZSxcclxuICAgICAgaWdub3JlUGF0aHMsXHJcbiAgICAgIHRyYWNrZWRQcm9wZXJ0eS5jaGlsZHJlbltrZXldLFxyXG4gICAgICBvYmpba2V5XSxcclxuICAgICAgc2FtZVJlZixcclxuICAgICAgY2hpbGRQYXRoXHJcbiAgICApXHJcblxyXG4gICAgaWYgKHJlc3VsdC53YXNNdXRhdGVkKSB7XHJcbiAgICAgIHJldHVybiByZXN1bHRcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHsgd2FzTXV0YXRlZDogZmFsc2UgfVxyXG59XHJcblxyXG50eXBlIElzSW1tdXRhYmxlRnVuYyA9ICh2YWx1ZTogYW55KSA9PiBib29sZWFuXHJcblxyXG4vKipcclxuICogT3B0aW9ucyBmb3IgYGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSgpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zIHtcclxuICAvKipcclxuICAgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIGEgdmFsdWUgaXMgY29uc2lkZXJlZCB0byBiZSBpbW11dGFibGUuXHJcbiAgICBUaGlzIGZ1bmN0aW9uIGlzIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gZXZlcnkgdmFsdWUgY29udGFpbmVkIGluIHRoZSBzdGF0ZS5cclxuICAgIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgcmV0dXJuIHRydWUgZm9yIHByaW1pdGl2ZSB0eXBlcyBcclxuICAgIChsaWtlIG51bWJlcnMsIHN0cmluZ3MsIGJvb2xlYW5zLCBudWxsIGFuZCB1bmRlZmluZWQpLlxyXG4gICAqL1xyXG4gIGlzSW1tdXRhYmxlPzogSXNJbW11dGFibGVGdW5jXHJcbiAgLyoqIFxyXG4gICAgQW4gYXJyYXkgb2YgZG90LXNlcGFyYXRlZCBwYXRoIHN0cmluZ3MgdGhhdCBtYXRjaCBuYW1lZCBub2RlcyBmcm9tIFxyXG4gICAgdGhlIHJvb3Qgc3RhdGUgdG8gaWdub3JlIHdoZW4gY2hlY2tpbmcgZm9yIGltbXV0YWJpbGl0eS5cclxuICAgIERlZmF1bHRzIHRvIHVuZGVmaW5lZFxyXG4gICAqL1xyXG4gIGlnbm9yZWRQYXRocz86IHN0cmluZ1tdXHJcbiAgLyoqIFByaW50IGEgd2FybmluZyBpZiBjaGVja3MgdGFrZSBsb25nZXIgdGhhbiBOIG1zLiBEZWZhdWx0OiAzMm1zICovXHJcbiAgd2FybkFmdGVyPzogbnVtYmVyXHJcbiAgLy8gQGRlcHJlY2F0ZWQuIFVzZSBpZ25vcmVkUGF0aHNcclxuICBpZ25vcmU/OiBzdHJpbmdbXVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1pZGRsZXdhcmUgdGhhdCBjaGVja3Mgd2hldGhlciBhbnkgc3RhdGUgd2FzIG11dGF0ZWQgaW4gYmV0d2VlblxyXG4gKiBkaXNwYXRjaGVzIG9yIGR1cmluZyBhIGRpc3BhdGNoLiBJZiBhbnkgbXV0YXRpb25zIGFyZSBkZXRlY3RlZCwgYW4gZXJyb3IgaXNcclxuICogdGhyb3duLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBNaWRkbGV3YXJlIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoXHJcbiAgb3B0aW9uczogSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9XHJcbik6IE1pZGRsZXdhcmUge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4gbmV4dChhY3Rpb24pXHJcbiAgfVxyXG5cclxuICBsZXQge1xyXG4gICAgaXNJbW11dGFibGUgPSBpc0ltbXV0YWJsZURlZmF1bHQsXHJcbiAgICBpZ25vcmVkUGF0aHMsXHJcbiAgICB3YXJuQWZ0ZXIgPSAzMixcclxuICAgIGlnbm9yZVxyXG4gIH0gPSBvcHRpb25zXHJcblxyXG4gIC8vIEFsaWFzIGlnbm9yZS0+aWdub3JlZFBhdGhzLCBidXQgcHJlZmVyIGlnbm9yZWRQYXRocyBpZiBwcmVzZW50XHJcbiAgaWdub3JlZFBhdGhzID0gaWdub3JlZFBhdGhzIHx8IGlnbm9yZVxyXG5cclxuICBjb25zdCB0cmFjayA9IHRyYWNrRm9yTXV0YXRpb25zLmJpbmQobnVsbCwgaXNJbW11dGFibGUsIGlnbm9yZWRQYXRocylcclxuXHJcbiAgcmV0dXJuICh7IGdldFN0YXRlIH0pID0+IHtcclxuICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKClcclxuICAgIGxldCB0cmFja2VyID0gdHJhY2soc3RhdGUpXHJcblxyXG4gICAgbGV0IHJlc3VsdFxyXG4gICAgcmV0dXJuIG5leHQgPT4gYWN0aW9uID0+IHtcclxuICAgICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyhcclxuICAgICAgICB3YXJuQWZ0ZXIsXHJcbiAgICAgICAgJ0ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSdcclxuICAgICAgKVxyXG5cclxuICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcclxuICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKClcclxuXHJcbiAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKVxyXG4gICAgICAgIC8vIFRyYWNrIGJlZm9yZSBwb3RlbnRpYWxseSBub3QgbWVldGluZyB0aGUgaW52YXJpYW50XHJcbiAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKVxyXG5cclxuICAgICAgICBpbnZhcmlhbnQoXHJcbiAgICAgICAgICAhcmVzdWx0Lndhc011dGF0ZWQsXHJcbiAgICAgICAgICBgQSBzdGF0ZSBtdXRhdGlvbiB3YXMgZGV0ZWN0ZWQgYmV0d2VlbiBkaXNwYXRjaGVzLCBpbiB0aGUgcGF0aCAnJHsoXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoIHx8IFtdXHJcbiAgICAgICAgICApLmpvaW4oXHJcbiAgICAgICAgICAgICcuJ1xyXG4gICAgICAgICAgKX0nLiAgVGhpcyBtYXkgY2F1c2UgaW5jb3JyZWN0IGJlaGF2aW9yLiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHJvdWJsZXNob290aW5nI25ldmVyLW11dGF0ZS1yZWR1Y2VyLWFyZ3VtZW50cylgXHJcbiAgICAgICAgKVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgY29uc3QgZGlzcGF0Y2hlZEFjdGlvbiA9IG5leHQoYWN0aW9uKVxyXG5cclxuICAgICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcclxuICAgICAgICBzdGF0ZSA9IGdldFN0YXRlKClcclxuXHJcbiAgICAgICAgcmVzdWx0ID0gdHJhY2tlci5kZXRlY3RNdXRhdGlvbnMoKVxyXG4gICAgICAgIC8vIFRyYWNrIGJlZm9yZSBwb3RlbnRpYWxseSBub3QgbWVldGluZyB0aGUgaW52YXJpYW50XHJcbiAgICAgICAgdHJhY2tlciA9IHRyYWNrKHN0YXRlKVxyXG5cclxuICAgICAgICByZXN1bHQud2FzTXV0YXRlZCAmJlxyXG4gICAgICAgICAgaW52YXJpYW50KFxyXG4gICAgICAgICAgICAhcmVzdWx0Lndhc011dGF0ZWQsXHJcbiAgICAgICAgICAgIGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBpbnNpZGUgYSBkaXNwYXRjaCwgaW4gdGhlIHBhdGg6ICR7KFxyXG4gICAgICAgICAgICAgIHJlc3VsdC5wYXRoIHx8IFtdXHJcbiAgICAgICAgICAgICkuam9pbihcclxuICAgICAgICAgICAgICAnLidcclxuICAgICAgICAgICAgKX0uIFRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoZSBhY3Rpb24gJHtzdHJpbmdpZnkoXHJcbiAgICAgICAgICAgICAgYWN0aW9uXHJcbiAgICAgICAgICAgICl9LiAoaHR0cHM6Ly9yZWR1eC5qcy5vcmcvdHJvdWJsZXNob290aW5nI25ldmVyLW11dGF0ZS1yZWR1Y2VyLWFyZ3VtZW50cylgXHJcbiAgICAgICAgICApXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKVxyXG5cclxuICAgICAgcmV0dXJuIGRpc3BhdGNoZWRBY3Rpb25cclxuICAgIH1cclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0J1xyXG5pbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7IGdldFRpbWVNZWFzdXJlVXRpbHMgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIFwicGxhaW5cIiwgaS5lLiBhIHZhbHVlIHRoYXQgaXMgZWl0aGVyXHJcbiAqIGRpcmVjdGx5IEpTT04tc2VyaWFsaXphYmxlIChib29sZWFuLCBudW1iZXIsIHN0cmluZywgYXJyYXksIHBsYWluIG9iamVjdClcclxuICogb3IgYHVuZGVmaW5lZGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWwgVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbih2YWw6IGFueSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgdmFsID09PSBudWxsIHx8XHJcbiAgICB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fFxyXG4gICAgdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nIHx8XHJcbiAgICB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyB8fFxyXG4gICAgQXJyYXkuaXNBcnJheSh2YWwpIHx8XHJcbiAgICBpc1BsYWluT2JqZWN0KHZhbClcclxuICApXHJcbn1cclxuXHJcbmludGVyZmFjZSBOb25TZXJpYWxpemFibGVWYWx1ZSB7XHJcbiAga2V5UGF0aDogc3RyaW5nXHJcbiAgdmFsdWU6IHVua25vd25cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXHJcbiAgdmFsdWU6IHVua25vd24sXHJcbiAgcGF0aDogUmVhZG9ubHlBcnJheTxzdHJpbmc+ID0gW10sXHJcbiAgaXNTZXJpYWxpemFibGU6ICh2YWx1ZTogdW5rbm93bikgPT4gYm9vbGVhbiA9IGlzUGxhaW4sXHJcbiAgZ2V0RW50cmllcz86ICh2YWx1ZTogdW5rbm93bikgPT4gW3N0cmluZywgYW55XVtdLFxyXG4gIGlnbm9yZWRQYXRoczogc3RyaW5nW10gPSBbXVxyXG4pOiBOb25TZXJpYWxpemFibGVWYWx1ZSB8IGZhbHNlIHtcclxuICBsZXQgZm91bmROZXN0ZWRTZXJpYWxpemFibGU6IE5vblNlcmlhbGl6YWJsZVZhbHVlIHwgZmFsc2VcclxuXHJcbiAgaWYgKCFpc1NlcmlhbGl6YWJsZSh2YWx1ZSkpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGtleVBhdGg6IHBhdGguam9pbignLicpIHx8ICc8cm9vdD4nLFxyXG4gICAgICB2YWx1ZTogdmFsdWVcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gZmFsc2VcclxuICB9XHJcblxyXG4gIGNvbnN0IGVudHJpZXMgPSBnZXRFbnRyaWVzICE9IG51bGwgPyBnZXRFbnRyaWVzKHZhbHVlKSA6IE9iamVjdC5lbnRyaWVzKHZhbHVlKVxyXG5cclxuICBjb25zdCBoYXNJZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMubGVuZ3RoID4gMFxyXG5cclxuICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgbmVzdGVkVmFsdWVdIG9mIGVudHJpZXMpIHtcclxuICAgIGNvbnN0IG5lc3RlZFBhdGggPSBwYXRoLmNvbmNhdChwcm9wZXJ0eSlcclxuXHJcbiAgICBpZiAoaGFzSWdub3JlZFBhdGhzICYmIGlnbm9yZWRQYXRocy5pbmRleE9mKG5lc3RlZFBhdGguam9pbignLicpKSA+PSAwKSB7XHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1NlcmlhbGl6YWJsZShuZXN0ZWRWYWx1ZSkpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBrZXlQYXRoOiBuZXN0ZWRQYXRoLmpvaW4oJy4nKSxcclxuICAgICAgICB2YWx1ZTogbmVzdGVkVmFsdWVcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2YgbmVzdGVkVmFsdWUgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKFxyXG4gICAgICAgIG5lc3RlZFZhbHVlLFxyXG4gICAgICAgIG5lc3RlZFBhdGgsXHJcbiAgICAgICAgaXNTZXJpYWxpemFibGUsXHJcbiAgICAgICAgZ2V0RW50cmllcyxcclxuICAgICAgICBpZ25vcmVkUGF0aHNcclxuICAgICAgKVxyXG5cclxuICAgICAgaWYgKGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZvdW5kTmVzdGVkU2VyaWFsaXphYmxlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmYWxzZVxyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9ucyBmb3IgYGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSgpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zIHtcclxuICAvKipcclxuICAgKiBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBjb25zaWRlcmVkIHNlcmlhbGl6YWJsZS4gVGhpc1xyXG4gICAqIGZ1bmN0aW9uIGlzIGFwcGxpZWQgcmVjdXJzaXZlbHkgdG8gZXZlcnkgdmFsdWUgY29udGFpbmVkIGluIHRoZVxyXG4gICAqIHN0YXRlLiBEZWZhdWx0cyB0byBgaXNQbGFpbigpYC5cclxuICAgKi9cclxuICBpc1NlcmlhbGl6YWJsZT86ICh2YWx1ZTogYW55KSA9PiBib29sZWFuXHJcbiAgLyoqXHJcbiAgICogVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJldHJpZXZlIGVudHJpZXMgZnJvbSBlYWNoXHJcbiAgICogdmFsdWUuICBJZiB1bnNwZWNpZmllZCwgYE9iamVjdC5lbnRyaWVzYCB3aWxsIGJlIHVzZWQuIERlZmF1bHRzXHJcbiAgICogdG8gYHVuZGVmaW5lZGAuXHJcbiAgICovXHJcbiAgZ2V0RW50cmllcz86ICh2YWx1ZTogYW55KSA9PiBbc3RyaW5nLCBhbnldW11cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgYWN0aW9uIHR5cGVzIHRvIGlnbm9yZSB3aGVuIGNoZWNraW5nIGZvciBzZXJpYWxpemFiaWxpdHkuXHJcbiAgICogRGVmYXVsdHMgdG8gW11cclxuICAgKi9cclxuICBpZ25vcmVkQWN0aW9ucz86IHN0cmluZ1tdXHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGFycmF5IG9mIGRvdC1zZXBhcmF0ZWQgcGF0aCBzdHJpbmdzIHRvIGlnbm9yZSB3aGVuIGNoZWNraW5nXHJcbiAgICogZm9yIHNlcmlhbGl6YWJpbGl0eSwgRGVmYXVsdHMgdG8gWydtZXRhLmFyZyddXHJcbiAgICovXHJcbiAgaWdub3JlZEFjdGlvblBhdGhzPzogc3RyaW5nW11cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgZG90LXNlcGFyYXRlZCBwYXRoIHN0cmluZ3MgdG8gaWdub3JlIHdoZW4gY2hlY2tpbmdcclxuICAgKiBmb3Igc2VyaWFsaXphYmlsaXR5LCBEZWZhdWx0cyB0byBbXVxyXG4gICAqL1xyXG4gIGlnbm9yZWRQYXRocz86IHN0cmluZ1tdXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0aW9uIHRpbWUgd2FybmluZyB0aHJlc2hvbGQuIElmIHRoZSBtaWRkbGV3YXJlIHRha2VzIGxvbmdlclxyXG4gICAqIHRoYW4gYHdhcm5BZnRlcmAgbXMsIGEgd2FybmluZyB3aWxsIGJlIGRpc3BsYXllZCBpbiB0aGUgY29uc29sZS5cclxuICAgKiBEZWZhdWx0cyB0byAzMm1zLlxyXG4gICAqL1xyXG4gIHdhcm5BZnRlcj86IG51bWJlclxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG1pZGRsZXdhcmUgdGhhdCwgYWZ0ZXIgZXZlcnkgc3RhdGUgY2hhbmdlLCBjaGVja3MgaWYgdGhlIG5ld1xyXG4gKiBzdGF0ZSBpcyBzZXJpYWxpemFibGUuIElmIGEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSBpcyBmb3VuZCB3aXRoaW4gdGhlXHJcbiAqIHN0YXRlLCBhbiBlcnJvciBpcyBwcmludGVkIHRvIHRoZSBjb25zb2xlLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3B0aW9ucyBNaWRkbGV3YXJlIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoXHJcbiAgb3B0aW9uczogU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9XHJcbik6IE1pZGRsZXdhcmUge1xyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICByZXR1cm4gKCkgPT4gbmV4dCA9PiBhY3Rpb24gPT4gbmV4dChhY3Rpb24pXHJcbiAgfVxyXG4gIGNvbnN0IHtcclxuICAgIGlzU2VyaWFsaXphYmxlID0gaXNQbGFpbixcclxuICAgIGdldEVudHJpZXMsXHJcbiAgICBpZ25vcmVkQWN0aW9ucyA9IFtdLFxyXG4gICAgaWdub3JlZEFjdGlvblBhdGhzID0gWydtZXRhLmFyZyddLFxyXG4gICAgaWdub3JlZFBhdGhzID0gW10sXHJcbiAgICB3YXJuQWZ0ZXIgPSAzMlxyXG4gIH0gPSBvcHRpb25zXHJcblxyXG4gIHJldHVybiBzdG9yZUFQSSA9PiBuZXh0ID0+IGFjdGlvbiA9PiB7XHJcbiAgICBpZiAoaWdub3JlZEFjdGlvbnMubGVuZ3RoICYmIGlnbm9yZWRBY3Rpb25zLmluZGV4T2YoYWN0aW9uLnR5cGUpICE9PSAtMSkge1xyXG4gICAgICByZXR1cm4gbmV4dChhY3Rpb24pXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVhc3VyZVV0aWxzID0gZ2V0VGltZU1lYXN1cmVVdGlscyhcclxuICAgICAgd2FybkFmdGVyLFxyXG4gICAgICAnU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG4gICAgKVxyXG4gICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcclxuICAgICAgY29uc3QgZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcclxuICAgICAgICBhY3Rpb24sXHJcbiAgICAgICAgW10sXHJcbiAgICAgICAgaXNTZXJpYWxpemFibGUsXHJcbiAgICAgICAgZ2V0RW50cmllcyxcclxuICAgICAgICBpZ25vcmVkQWN0aW9uUGF0aHNcclxuICAgICAgKVxyXG5cclxuICAgICAgaWYgKGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWUpIHtcclxuICAgICAgICBjb25zdCB7IGtleVBhdGgsIHZhbHVlIH0gPSBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlXHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiBhbiBhY3Rpb24sIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLFxyXG4gICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAnXFxuVGFrZSBhIGxvb2sgYXQgdGhlIGxvZ2ljIHRoYXQgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbjogJyxcclxuICAgICAgICAgIGFjdGlvbixcclxuICAgICAgICAgICdcXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9hY3Rpb25zI3doeS1zaG91bGQtdHlwZS1iZS1hLXN0cmluZy1vci1hdC1sZWFzdC1zZXJpYWxpemFibGUtd2h5LXNob3VsZC1teS1hY3Rpb24tdHlwZXMtYmUtY29uc3RhbnRzKScsXHJcbiAgICAgICAgICAnXFxuKFRvIGFsbG93IG5vbi1zZXJpYWxpemFibGUgdmFsdWVzIHNlZTogaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy91c2FnZS91c2FnZS1ndWlkZSN3b3JraW5nLXdpdGgtbm9uLXNlcmlhbGl6YWJsZS1kYXRhKSdcclxuICAgICAgICApXHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gbmV4dChhY3Rpb24pXHJcblxyXG4gICAgbWVhc3VyZVV0aWxzLm1lYXN1cmVUaW1lKCgpID0+IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZUFQSS5nZXRTdGF0ZSgpXHJcblxyXG4gICAgICBjb25zdCBmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXHJcbiAgICAgICAgc3RhdGUsXHJcbiAgICAgICAgW10sXHJcbiAgICAgICAgaXNTZXJpYWxpemFibGUsXHJcbiAgICAgICAgZ2V0RW50cmllcyxcclxuICAgICAgICBpZ25vcmVkUGF0aHNcclxuICAgICAgKVxyXG5cclxuICAgICAgaWYgKGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsga2V5UGF0aCwgdmFsdWUgfSA9IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZVxyXG5cclxuICAgICAgICBjb25zb2xlLmVycm9yKFxyXG4gICAgICAgICAgYEEgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZSB3YXMgZGV0ZWN0ZWQgaW4gdGhlIHN0YXRlLCBpbiB0aGUgcGF0aDogXFxgJHtrZXlQYXRofVxcYC4gVmFsdWU6YCxcclxuICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgYFxyXG5UYWtlIGEgbG9vayBhdCB0aGUgcmVkdWNlcihzKSBoYW5kbGluZyB0aGlzIGFjdGlvbiB0eXBlOiAke2FjdGlvbi50eXBlfS5cclxuKFNlZSBodHRwczovL3JlZHV4LmpzLm9yZy9mYXEvb3JnYW5pemluZy1zdGF0ZSNjYW4taS1wdXQtZnVuY3Rpb25zLXByb21pc2VzLW9yLW90aGVyLW5vbi1zZXJpYWxpemFibGUtaXRlbXMtaW4tbXktc3RvcmUtc3RhdGUpYFxyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBtZWFzdXJlVXRpbHMud2FybklmRXhjZWVkZWQoKVxyXG5cclxuICAgIHJldHVybiByZXN1bHRcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTWlkZGxld2FyZSwgQW55QWN0aW9uIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB0aHVua01pZGRsZXdhcmUsIHsgVGh1bmtNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgtdGh1bmsnXHJcbmltcG9ydCB7XHJcbiAgLyogUFJPRF9TVEFSVF9SRU1PVkVfVU1EICovXHJcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxyXG4gIC8qIFBST0RfU1RPUF9SRU1PVkVfVU1EICovXHJcbiAgSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9uc1xyXG59IGZyb20gJy4vaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG5cclxuaW1wb3J0IHtcclxuICBjcmVhdGVTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXHJcbiAgU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9uc1xyXG59IGZyb20gJy4vc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG5pbXBvcnQgeyBNaWRkbGV3YXJlQXJyYXkgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZnVuY3Rpb24gaXNCb29sZWFuKHg6IGFueSk6IHggaXMgYm9vbGVhbiB7XHJcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnYm9vbGVhbidcclxufVxyXG5cclxuaW50ZXJmYWNlIFRodW5rT3B0aW9uczxFID0gYW55PiB7XHJcbiAgZXh0cmFBcmd1bWVudDogRVxyXG59XHJcblxyXG5pbnRlcmZhY2UgR2V0RGVmYXVsdE1pZGRsZXdhcmVPcHRpb25zIHtcclxuICB0aHVuaz86IGJvb2xlYW4gfCBUaHVua09wdGlvbnNcclxuICBpbW11dGFibGVDaGVjaz86IGJvb2xlYW4gfCBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zXHJcbiAgc2VyaWFsaXphYmxlQ2hlY2s/OiBib29sZWFuIHwgU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9uc1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBUaHVua01pZGRsZXdhcmVGb3I8XHJcbiAgUyxcclxuICBPIGV4dGVuZHMgR2V0RGVmYXVsdE1pZGRsZXdhcmVPcHRpb25zID0ge31cclxuPiA9IE8gZXh0ZW5kcyB7XHJcbiAgdGh1bms6IGZhbHNlXHJcbn1cclxuICA/IG5ldmVyXHJcbiAgOiBPIGV4dGVuZHMgeyB0aHVuazogeyBleHRyYUFyZ3VtZW50OiBpbmZlciBFIH0gfVxyXG4gID8gVGh1bmtNaWRkbGV3YXJlPFMsIEFueUFjdGlvbiwgRT5cclxuICA6XHJcbiAgICAgIHwgVGh1bmtNaWRkbGV3YXJlPFMsIEFueUFjdGlvbiwgbnVsbD4gLy9UaGUgVGh1bmtNaWRkbGV3YXJlIHdpdGggYSBgbnVsbGAgRXh0cmFBcmd1bWVudCBpcyBoZXJlIHRvIHByb3ZpZGUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXHJcbiAgICAgIHwgVGh1bmtNaWRkbGV3YXJlPFMsIEFueUFjdGlvbj5cclxuXHJcbmV4cG9ydCB0eXBlIEN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZTxTID0gYW55PiA9IDxcclxuICBPIGV4dGVuZHMgUGFydGlhbDxHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnM+ID0ge1xyXG4gICAgdGh1bms6IHRydWVcclxuICAgIGltbXV0YWJsZUNoZWNrOiB0cnVlXHJcbiAgICBzZXJpYWxpemFibGVDaGVjazogdHJ1ZVxyXG4gIH1cclxuPihcclxuICBvcHRpb25zPzogT1xyXG4pID0+IE1pZGRsZXdhcmVBcnJheTxNaWRkbGV3YXJlPHt9LCBTPiB8IFRodW5rTWlkZGxld2FyZUZvcjxTLCBPPj5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlPFxyXG4gIFMgPSBhbnlcclxuPigpOiBDdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmU8Uz4ge1xyXG4gIHJldHVybiBmdW5jdGlvbiBjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIGdldERlZmF1bHRNaWRkbGV3YXJlKG9wdGlvbnMpXHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhbnkgYXJyYXkgY29udGFpbmluZyB0aGUgZGVmYXVsdCBtaWRkbGV3YXJlIGluc3RhbGxlZCBieVxyXG4gKiBgY29uZmlndXJlU3RvcmUoKWAuIFVzZWZ1bCBpZiB5b3Ugd2FudCB0byBjb25maWd1cmUgeW91ciBzdG9yZSB3aXRoIGEgY3VzdG9tXHJcbiAqIGBtaWRkbGV3YXJlYCBhcnJheSBidXQgc3RpbGwga2VlcCB0aGUgZGVmYXVsdCBzZXQuXHJcbiAqXHJcbiAqIEByZXR1cm4gVGhlIGRlZmF1bHQgbWlkZGxld2FyZSB1c2VkIGJ5IGBjb25maWd1cmVTdG9yZSgpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERlZmF1bHRNaWRkbGV3YXJlPFxyXG4gIFMgPSBhbnksXHJcbiAgTyBleHRlbmRzIFBhcnRpYWw8R2V0RGVmYXVsdE1pZGRsZXdhcmVPcHRpb25zPiA9IHtcclxuICAgIHRodW5rOiB0cnVlXHJcbiAgICBpbW11dGFibGVDaGVjazogdHJ1ZVxyXG4gICAgc2VyaWFsaXphYmxlQ2hlY2s6IHRydWVcclxuICB9XHJcbj4oXHJcbiAgb3B0aW9uczogTyA9IHt9IGFzIE9cclxuKTogTWlkZGxld2FyZUFycmF5PE1pZGRsZXdhcmU8e30sIFM+IHwgVGh1bmtNaWRkbGV3YXJlRm9yPFMsIE8+PiB7XHJcbiAgY29uc3Qge1xyXG4gICAgdGh1bmsgPSB0cnVlLFxyXG4gICAgaW1tdXRhYmxlQ2hlY2sgPSB0cnVlLFxyXG4gICAgc2VyaWFsaXphYmxlQ2hlY2sgPSB0cnVlXHJcbiAgfSA9IG9wdGlvbnNcclxuXHJcbiAgbGV0IG1pZGRsZXdhcmVBcnJheTogTWlkZGxld2FyZTx7fSwgUz5bXSA9IG5ldyBNaWRkbGV3YXJlQXJyYXkoKVxyXG5cclxuICBpZiAodGh1bmspIHtcclxuICAgIGlmIChpc0Jvb2xlYW4odGh1bmspKSB7XHJcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKHRodW5rTWlkZGxld2FyZSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKFxyXG4gICAgICAgIHRodW5rTWlkZGxld2FyZS53aXRoRXh0cmFBcmd1bWVudCh0aHVuay5leHRyYUFyZ3VtZW50KVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgaWYgKGltbXV0YWJsZUNoZWNrKSB7XHJcbiAgICAgIC8qIFBST0RfU1RBUlRfUkVNT1ZFX1VNRCAqL1xyXG4gICAgICBsZXQgaW1tdXRhYmxlT3B0aW9uczogSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9XHJcblxyXG4gICAgICBpZiAoIWlzQm9vbGVhbihpbW11dGFibGVDaGVjaykpIHtcclxuICAgICAgICBpbW11dGFibGVPcHRpb25zID0gaW1tdXRhYmxlQ2hlY2tcclxuICAgICAgfVxyXG5cclxuICAgICAgbWlkZGxld2FyZUFycmF5LnVuc2hpZnQoXHJcbiAgICAgICAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKGltbXV0YWJsZU9wdGlvbnMpXHJcbiAgICAgIClcclxuICAgICAgLyogUFJPRF9TVE9QX1JFTU9WRV9VTUQgKi9cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2VyaWFsaXphYmxlQ2hlY2spIHtcclxuICAgICAgbGV0IHNlcmlhbGl6YWJsZU9wdGlvbnM6IFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMgPSB7fVxyXG5cclxuICAgICAgaWYgKCFpc0Jvb2xlYW4oc2VyaWFsaXphYmxlQ2hlY2spKSB7XHJcbiAgICAgICAgc2VyaWFsaXphYmxlT3B0aW9ucyA9IHNlcmlhbGl6YWJsZUNoZWNrXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG1pZGRsZXdhcmVBcnJheS5wdXNoKFxyXG4gICAgICAgIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShzZXJpYWxpemFibGVPcHRpb25zKVxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbWlkZGxld2FyZUFycmF5IGFzIGFueVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgY3JlYXRlU3RvcmUsXHJcbiAgY29tcG9zZSxcclxuICBhcHBseU1pZGRsZXdhcmUsXHJcbiAgY29tYmluZVJlZHVjZXJzLFxyXG4gIFJlZHVjZXIsXHJcbiAgUmVkdWNlcnNNYXBPYmplY3QsXHJcbiAgTWlkZGxld2FyZSxcclxuICBBY3Rpb24sXHJcbiAgQW55QWN0aW9uLFxyXG4gIFN0b3JlRW5oYW5jZXIsXHJcbiAgU3RvcmUsXHJcbiAgRGVlcFBhcnRpYWwsXHJcbiAgRGlzcGF0Y2hcclxufSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHtcclxuICBjb21wb3NlV2l0aERldlRvb2xzLFxyXG4gIEVuaGFuY2VyT3B0aW9ucyBhcyBEZXZUb29sc09wdGlvbnNcclxufSBmcm9tICcuL2RldnRvb2xzRXh0ZW5zaW9uJ1xyXG5cclxuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0J1xyXG5pbXBvcnQge1xyXG4gIFRodW5rTWlkZGxld2FyZUZvcixcclxuICBjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlLFxyXG4gIEN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZVxyXG59IGZyb20gJy4vZ2V0RGVmYXVsdE1pZGRsZXdhcmUnXHJcbmltcG9ydCB7IERpc3BhdGNoRm9yTWlkZGxld2FyZXMgfSBmcm9tICcuL3RzSGVscGVycydcclxuXHJcbmNvbnN0IElTX1BST0RVQ1RJT04gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXHJcblxyXG4vKipcclxuICogQ2FsbGJhY2sgZnVuY3Rpb24gdHlwZSwgdG8gYmUgdXNlZCBpbiBgQ29uZmlndXJlU3RvcmVPcHRpb25zLmVuaGFuY2Vyc2BcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ29uZmlndXJlRW5oYW5jZXJzQ2FsbGJhY2sgPSAoXHJcbiAgZGVmYXVsdEVuaGFuY2VyczogU3RvcmVFbmhhbmNlcltdXHJcbikgPT4gU3RvcmVFbmhhbmNlcltdXHJcblxyXG4vKipcclxuICogT3B0aW9ucyBmb3IgYGNvbmZpZ3VyZVN0b3JlKClgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENvbmZpZ3VyZVN0b3JlT3B0aW9uczxcclxuICBTID0gYW55LFxyXG4gIEEgZXh0ZW5kcyBBY3Rpb24gPSBBbnlBY3Rpb24sXHJcbiAgTSBleHRlbmRzIE1pZGRsZXdhcmVzPFM+ID0gTWlkZGxld2FyZXM8Uz5cclxuPiB7XHJcbiAgLyoqXHJcbiAgICogQSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgdXNlZCBhcyB0aGUgcm9vdCByZWR1Y2VyLCBvciBhblxyXG4gICAqIG9iamVjdCBvZiBzbGljZSByZWR1Y2VycyB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIGBjb21iaW5lUmVkdWNlcnMoKWAuXHJcbiAgICovXHJcbiAgcmVkdWNlcjogUmVkdWNlcjxTLCBBPiB8IFJlZHVjZXJzTWFwT2JqZWN0PFMsIEE+XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuIGFycmF5IG9mIFJlZHV4IG1pZGRsZXdhcmUgdG8gaW5zdGFsbC4gSWYgbm90IHN1cHBsaWVkLCBkZWZhdWx0cyB0b1xyXG4gICAqIHRoZSBzZXQgb2YgbWlkZGxld2FyZSByZXR1cm5lZCBieSBgZ2V0RGVmYXVsdE1pZGRsZXdhcmUoKWAuXHJcbiAgICovXHJcbiAgbWlkZGxld2FyZT86ICgoZ2V0RGVmYXVsdE1pZGRsZXdhcmU6IEN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZTxTPikgPT4gTSkgfCBNXHJcblxyXG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIFJlZHV4IERldlRvb2xzIGludGVncmF0aW9uLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXHJcbiAgICpcclxuICAgKiBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gY2FuIGJlIGRvbmUgYnkgcGFzc2luZyBSZWR1eCBEZXZUb29scyBvcHRpb25zXHJcbiAgICovXHJcbiAgZGV2VG9vbHM/OiBib29sZWFuIHwgRGV2VG9vbHNPcHRpb25zXHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbml0aWFsIHN0YXRlLCBzYW1lIGFzIFJlZHV4J3MgY3JlYXRlU3RvcmUuXHJcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXQgdG8gaHlkcmF0ZSB0aGUgc3RhdGVcclxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYSBwcmV2aW91c2x5IHNlcmlhbGl6ZWRcclxuICAgKiB1c2VyIHNlc3Npb24uIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2VycygpYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXJcclxuICAgKiBmdW5jdGlvbiAoZWl0aGVyIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgYnkgcGFzc2luZyBhbiBvYmplY3QgYXMgYHJlZHVjZXJgKSxcclxuICAgKiB0aGlzIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgdGhlIHJlZHVjZXIgbWFwIGtleXMuXHJcbiAgICovXHJcbiAgLy8gTk9URTogVGhlIG5lZWRsZXNzbHkgY29tcGxpY2F0ZWQgYFMgZXh0ZW5kcyBhbnkgPyBTIDogU2AgaW5zdGVhZCBvZiBqdXN0XHJcbiAgLy8gYFNgIGVuc3VyZXMgdGhhdCB0aGUgVHlwZVNjcmlwdCBjb21waWxlciBkb2Vzbid0IGF0dGVtcHQgdG8gaW5mZXIgYFNgXHJcbiAgLy8gYmFzZWQgb24gdGhlIHZhbHVlIHBhc3NlZCBhcyBgcHJlbG9hZGVkU3RhdGVgLCB3aGljaCBtaWdodCBiZSBhIHBhcnRpYWxcclxuICAvLyBzdGF0ZSByYXRoZXIgdGhhbiB0aGUgZnVsbCB0aGluZy5cclxuICBwcmVsb2FkZWRTdGF0ZT86IERlZXBQYXJ0aWFsPFMgZXh0ZW5kcyBhbnkgPyBTIDogUz5cclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHN0b3JlIGVuaGFuY2VycyB0byBhcHBseS4gU2VlIFJlZHV4J3MgYGNyZWF0ZVN0b3JlKClgLlxyXG4gICAqIEFsbCBlbmhhbmNlcnMgd2lsbCBiZSBpbmNsdWRlZCBiZWZvcmUgdGhlIERldlRvb2xzIEV4dGVuc2lvbiBlbmhhbmNlci5cclxuICAgKiBJZiB5b3UgbmVlZCB0byBjdXN0b21pemUgdGhlIG9yZGVyIG9mIGVuaGFuY2Vycywgc3VwcGx5IGEgY2FsbGJhY2tcclxuICAgKiBmdW5jdGlvbiB0aGF0IHdpbGwgcmVjZWl2ZSB0aGUgb3JpZ2luYWwgYXJyYXkgKGllLCBgW2FwcGx5TWlkZGxld2FyZV1gKSxcclxuICAgKiBhbmQgc2hvdWxkIHJldHVybiBhIG5ldyBhcnJheSAoc3VjaCBhcyBgW2FwcGx5TWlkZGxld2FyZSwgb2ZmbGluZV1gKS5cclxuICAgKiBJZiB5b3Ugb25seSBuZWVkIHRvIGFkZCBtaWRkbGV3YXJlLCB5b3UgY2FuIHVzZSB0aGUgYG1pZGRsZXdhcmVgIHBhcmFtZXRlciBpbnN0ZWFkLlxyXG4gICAqL1xyXG4gIGVuaGFuY2Vycz86IFN0b3JlRW5oYW5jZXJbXSB8IENvbmZpZ3VyZUVuaGFuY2Vyc0NhbGxiYWNrXHJcbn1cclxuXHJcbnR5cGUgTWlkZGxld2FyZXM8Uz4gPSBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU8e30sIFM+PlxyXG5cclxuLyoqXHJcbiAqIEEgUmVkdXggc3RvcmUgcmV0dXJuZWQgYnkgYGNvbmZpZ3VyZVN0b3JlKClgLiBTdXBwb3J0cyBkaXNwYXRjaGluZ1xyXG4gKiBzaWRlLWVmZmVjdGZ1bCBfdGh1bmtzXyBpbiBhZGRpdGlvbiB0byBwbGFpbiBhY3Rpb25zLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEVuaGFuY2VkU3RvcmU8XHJcbiAgUyA9IGFueSxcclxuICBBIGV4dGVuZHMgQWN0aW9uID0gQW55QWN0aW9uLFxyXG4gIE0gZXh0ZW5kcyBNaWRkbGV3YXJlczxTPiA9IE1pZGRsZXdhcmVzPFM+XHJcbj4gZXh0ZW5kcyBTdG9yZTxTLCBBPiB7XHJcbiAgLyoqXHJcbiAgICogVGhlIGBkaXNwYXRjaGAgbWV0aG9kIG9mIHlvdXIgc3RvcmUsIGVuaGFuY2VkIGJ5IGFsbCBpdCdzIG1pZGRsZXdhcmVzLlxyXG4gICAqXHJcbiAgICogQGluaGVyaXRkb2NcclxuICAgKi9cclxuICBkaXNwYXRjaDogRGlzcGF0Y2hGb3JNaWRkbGV3YXJlczxNPiAmIERpc3BhdGNoPEE+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGZyaWVuZGx5IGFic3RyYWN0aW9uIG92ZXIgdGhlIHN0YW5kYXJkIFJlZHV4IGBjcmVhdGVTdG9yZSgpYCBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIGNvbmZpZyBUaGUgc3RvcmUgY29uZmlndXJhdGlvbi5cclxuICogQHJldHVybnMgQSBjb25maWd1cmVkIFJlZHV4IHN0b3JlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29uZmlndXJlU3RvcmU8XHJcbiAgUyA9IGFueSxcclxuICBBIGV4dGVuZHMgQWN0aW9uID0gQW55QWN0aW9uLFxyXG4gIE0gZXh0ZW5kcyBNaWRkbGV3YXJlczxTPiA9IFtUaHVua01pZGRsZXdhcmVGb3I8Uz5dXHJcbj4ob3B0aW9uczogQ29uZmlndXJlU3RvcmVPcHRpb25zPFMsIEEsIE0+KTogRW5oYW5jZWRTdG9yZTxTLCBBLCBNPiB7XHJcbiAgY29uc3QgY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlID0gY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZTxTPigpXHJcblxyXG4gIGNvbnN0IHtcclxuICAgIHJlZHVjZXIgPSB1bmRlZmluZWQsXHJcbiAgICBtaWRkbGV3YXJlID0gY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKCksXHJcbiAgICBkZXZUb29scyA9IHRydWUsXHJcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZCxcclxuICAgIGVuaGFuY2VycyA9IHVuZGVmaW5lZFxyXG4gIH0gPSBvcHRpb25zIHx8IHt9XHJcblxyXG4gIGxldCByb290UmVkdWNlcjogUmVkdWNlcjxTLCBBPlxyXG5cclxuICBpZiAodHlwZW9mIHJlZHVjZXIgPT09ICdmdW5jdGlvbicpIHtcclxuICAgIHJvb3RSZWR1Y2VyID0gcmVkdWNlclxyXG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChyZWR1Y2VyKSkge1xyXG4gICAgcm9vdFJlZHVjZXIgPSBjb21iaW5lUmVkdWNlcnMocmVkdWNlcilcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAnXCJyZWR1Y2VyXCIgaXMgYSByZXF1aXJlZCBhcmd1bWVudCwgYW5kIG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3Qgb2YgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHBhc3NlZCB0byBjb21iaW5lUmVkdWNlcnMnXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBjb25zdCBtaWRkbGV3YXJlRW5oYW5jZXIgPSBhcHBseU1pZGRsZXdhcmUoXHJcbiAgICAuLi4odHlwZW9mIG1pZGRsZXdhcmUgPT09ICdmdW5jdGlvbidcclxuICAgICAgPyBtaWRkbGV3YXJlKGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSlcclxuICAgICAgOiBtaWRkbGV3YXJlKVxyXG4gIClcclxuXHJcbiAgbGV0IGZpbmFsQ29tcG9zZSA9IGNvbXBvc2VcclxuXHJcbiAgaWYgKGRldlRvb2xzKSB7XHJcbiAgICBmaW5hbENvbXBvc2UgPSBjb21wb3NlV2l0aERldlRvb2xzKHtcclxuICAgICAgLy8gRW5hYmxlIGNhcHR1cmUgb2Ygc3RhY2sgdHJhY2VzIGZvciBkaXNwYXRjaGVkIFJlZHV4IGFjdGlvbnNcclxuICAgICAgdHJhY2U6ICFJU19QUk9EVUNUSU9OLFxyXG4gICAgICAuLi4odHlwZW9mIGRldlRvb2xzID09PSAnb2JqZWN0JyAmJiBkZXZUb29scylcclxuICAgIH0pXHJcbiAgfVxyXG5cclxuICBsZXQgc3RvcmVFbmhhbmNlcnM6IFN0b3JlRW5oYW5jZXJbXSA9IFttaWRkbGV3YXJlRW5oYW5jZXJdXHJcblxyXG4gIGlmIChBcnJheS5pc0FycmF5KGVuaGFuY2VycykpIHtcclxuICAgIHN0b3JlRW5oYW5jZXJzID0gW21pZGRsZXdhcmVFbmhhbmNlciwgLi4uZW5oYW5jZXJzXVxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuaGFuY2VycyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgc3RvcmVFbmhhbmNlcnMgPSBlbmhhbmNlcnMoc3RvcmVFbmhhbmNlcnMpXHJcbiAgfVxyXG5cclxuICBjb25zdCBjb21wb3NlZEVuaGFuY2VyID0gZmluYWxDb21wb3NlKC4uLnN0b3JlRW5oYW5jZXJzKSBhcyBhbnlcclxuXHJcbiAgcmV0dXJuIGNyZWF0ZVN0b3JlKFxyXG4gICAgcm9vdFJlZHVjZXIsXHJcbiAgICBwcmVsb2FkZWRTdGF0ZSBhcyBEZWVwUGFydGlhbDxTPixcclxuICAgIGNvbXBvc2VkRW5oYW5jZXJcclxuICApXHJcbn1cclxuIiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7XHJcbiAgSXNVbmtub3duT3JOb25JbmZlcnJhYmxlLFxyXG4gIElmTWF5YmVVbmRlZmluZWQsXHJcbiAgSWZWb2lkLFxyXG4gIElzQW55XHJcbn0gZnJvbSAnLi90c0hlbHBlcnMnXHJcbmltcG9ydCBpc1BsYWluT2JqZWN0IGZyb20gJy4vaXNQbGFpbk9iamVjdCdcclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gd2l0aCBhIHN0cmluZyB0eXBlIGFuZCBhbiBhc3NvY2lhdGVkIHBheWxvYWQuIFRoaXMgaXMgdGhlXHJcbiAqIHR5cGUgb2YgYWN0aW9uIHJldHVybmVkIGJ5IGBjcmVhdGVBY3Rpb24oKWAgYWN0aW9uIGNyZWF0b3JzLlxyXG4gKlxyXG4gKiBAdGVtcGxhdGUgUCBUaGUgdHlwZSBvZiB0aGUgYWN0aW9uJ3MgcGF5bG9hZC5cclxuICogQHRlbXBsYXRlIFQgdGhlIHR5cGUgdXNlZCBmb3IgdGhlIGFjdGlvbiB0eXBlLlxyXG4gKiBAdGVtcGxhdGUgTSBUaGUgdHlwZSBvZiB0aGUgYWN0aW9uJ3MgbWV0YSAob3B0aW9uYWwpXHJcbiAqIEB0ZW1wbGF0ZSBFIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb24ncyBlcnJvciAob3B0aW9uYWwpXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFBheWxvYWRBY3Rpb248XHJcbiAgUCA9IHZvaWQsXHJcbiAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcclxuICBNID0gbmV2ZXIsXHJcbiAgRSA9IG5ldmVyXHJcbj4gPSB7XHJcbiAgcGF5bG9hZDogUFxyXG4gIHR5cGU6IFRcclxufSAmIChbTV0gZXh0ZW5kcyBbbmV2ZXJdXHJcbiAgPyB7fVxyXG4gIDoge1xyXG4gICAgICBtZXRhOiBNXHJcbiAgICB9KSAmXHJcbiAgKFtFXSBleHRlbmRzIFtuZXZlcl1cclxuICAgID8ge31cclxuICAgIDoge1xyXG4gICAgICAgIGVycm9yOiBFXHJcbiAgICAgIH0pXHJcblxyXG4vKipcclxuICogQSBcInByZXBhcmVcIiBtZXRob2QgdG8gYmUgdXNlZCBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlciBvZiBgY3JlYXRlQWN0aW9uYC5cclxuICogVGFrZXMgYW55IG51bWJlciBvZiBhcmd1bWVudHMgYW5kIHJldHVybnMgYSBGbHV4IFN0YW5kYXJkIEFjdGlvbiB3aXRob3V0XHJcbiAqIHR5cGUgKHdpbGwgYmUgYWRkZWQgbGF0ZXIpIHRoYXQgKm11c3QqIGNvbnRhaW4gYSBwYXlsb2FkIChtaWdodCBiZSB1bmRlZmluZWQpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQcmVwYXJlQWN0aW9uPFA+ID1cclxuICB8ICgoLi4uYXJnczogYW55W10pID0+IHsgcGF5bG9hZDogUCB9KVxyXG4gIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4geyBwYXlsb2FkOiBQOyBtZXRhOiBhbnkgfSlcclxuICB8ICgoLi4uYXJnczogYW55W10pID0+IHsgcGF5bG9hZDogUDsgZXJyb3I6IGFueSB9KVxyXG4gIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4geyBwYXlsb2FkOiBQOyBtZXRhOiBhbnk7IGVycm9yOiBhbnkgfSlcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCB2ZXJzaW9uIG9mIGBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZGAuIE5vdCB0byBiZSB1c2VkIGV4dGVybmFsbHkuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZXhwb3J0IHR5cGUgX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFxyXG4gIFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+IHwgdm9pZCxcclxuICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXHJcbj4gPSBQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248aW5mZXIgUD5cclxuICA/IEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFxyXG4gICAgICBQYXJhbWV0ZXJzPFBBPixcclxuICAgICAgUCxcclxuICAgICAgVCxcclxuICAgICAgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XHJcbiAgICAgICAgZXJyb3I6IGluZmVyIEVcclxuICAgICAgfVxyXG4gICAgICAgID8gRVxyXG4gICAgICAgIDogbmV2ZXIsXHJcbiAgICAgIFJldHVyblR5cGU8UEE+IGV4dGVuZHMge1xyXG4gICAgICAgIG1ldGE6IGluZmVyIE1cclxuICAgICAgfVxyXG4gICAgICAgID8gTVxyXG4gICAgICAgIDogbmV2ZXJcclxuICAgID5cclxuICA6IHZvaWRcclxuXHJcbi8qKlxyXG4gKiBCYXNpYyB0eXBlIGZvciBhbGwgYWN0aW9uIGNyZWF0b3JzLlxyXG4gKlxyXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cclxuICovXHJcbmludGVyZmFjZSBCYXNlQWN0aW9uQ3JlYXRvcjxQLCBUIGV4dGVuZHMgc3RyaW5nLCBNID0gbmV2ZXIsIEUgPSBuZXZlcj4ge1xyXG4gIHR5cGU6IFRcclxuICBtYXRjaChhY3Rpb246IEFjdGlvbjx1bmtub3duPik6IGFjdGlvbiBpcyBQYXlsb2FkQWN0aW9uPFAsIFQsIE0sIEU+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciB0aGF0IHRha2VzIG11bHRpcGxlIGFyZ3VtZW50cyB0aGF0IGFyZSBwYXNzZWRcclxuICogdG8gYSBgUHJlcGFyZUFjdGlvbmAgbWV0aG9kIHRvIGNyZWF0ZSB0aGUgZmluYWwgQWN0aW9uLlxyXG4gKiBAdHlwZVBhcmFtIEFyZ3MgYXJndW1lbnRzIGZvciB0aGUgYWN0aW9uIGNyZWF0b3IgZnVuY3Rpb25cclxuICogQHR5cGVQYXJhbSBQIGBwYXlsb2FkYCB0eXBlXHJcbiAqIEB0eXBlUGFyYW0gVCBgdHlwZWAgbmFtZVxyXG4gKiBAdHlwZVBhcmFtIEUgb3B0aW9uYWwgYGVycm9yYCB0eXBlXHJcbiAqIEB0eXBlUGFyYW0gTSBvcHRpb25hbCBgbWV0YWAgdHlwZVxyXG4gKlxyXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxcclxuICBBcmdzIGV4dGVuZHMgdW5rbm93bltdLFxyXG4gIFAsXHJcbiAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcclxuICBFID0gbmV2ZXIsXHJcbiAgTSA9IG5ldmVyXHJcbj4gZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjxQLCBULCBNLCBFPiB7XHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGBBcmdzYCB3aWxsIHJldHVyblxyXG4gICAqIGFuIEFjdGlvbiB3aXRoIGEgcGF5bG9hZCBvZiB0eXBlIGBQYCBhbmQgKGRlcGVuZGluZyBvbiB0aGUgYFByZXBhcmVBY3Rpb25gXHJcbiAgICogbWV0aG9kIHVzZWQpIGEgYG1ldGFgLSBhbmQgYGVycm9yYCBwcm9wZXJ0eSBvZiB0eXBlcyBgTWAgYW5kIGBFYCByZXNwZWN0aXZlbHkuXHJcbiAgICovXHJcbiAgKC4uLmFyZ3M6IEFyZ3MpOiBQYXlsb2FkQWN0aW9uPFAsIFQsIE0sIEU+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB0aGF0IHRha2VzIGFuIG9wdGlvbmFsIHBheWxvYWQgb2YgdHlwZSBgUGAuXHJcbiAqXHJcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoT3B0aW9uYWxQYXlsb2FkPFAsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+XHJcbiAgZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjxQLCBUPiB7XHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGFuIGFyZ3VtZW50IHdpbGxcclxuICAgKiByZXR1cm4gYSB7QGxpbmsgUGF5bG9hZEFjdGlvbn0gb2YgdHlwZSBgVGAgd2l0aCBhIHBheWxvYWQgb2YgYFBgLlxyXG4gICAqIENhbGxpbmcgaXQgd2l0aG91dCBhbiBhcmd1bWVudCB3aWxsIHJldHVybiBhIFBheWxvYWRBY3Rpb24gd2l0aCBhIHBheWxvYWQgb2YgYHVuZGVmaW5lZGAuXHJcbiAgICovXHJcbiAgKHBheWxvYWQ/OiBQKTogUGF5bG9hZEFjdGlvbjxQLCBUPlxyXG59XHJcblxyXG4vKipcclxuICogQW4gYWN0aW9uIGNyZWF0b3Igb2YgdHlwZSBgVGAgdGhhdCB0YWtlcyBubyBwYXlsb2FkLlxyXG4gKlxyXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQ8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz5cclxuICBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPHVuZGVmaW5lZCwgVD4ge1xyXG4gIC8qKlxyXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2lsbFxyXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZCBvZiBgdW5kZWZpbmVkYFxyXG4gICAqL1xyXG4gICgpOiBQYXlsb2FkQWN0aW9uPHVuZGVmaW5lZCwgVD5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIG9mIHR5cGUgYFRgIHRoYXQgcmVxdWlyZXMgYSBwYXlsb2FkIG9mIHR5cGUgUC5cclxuICpcclxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPFAsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+XHJcbiAgZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjxQLCBUPiB7XHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGFuIGFyZ3VtZW50IHdpbGxcclxuICAgKiByZXR1cm4gYSB7QGxpbmsgUGF5bG9hZEFjdGlvbn0gb2YgdHlwZSBgVGAgd2l0aCBhIHBheWxvYWQgb2YgYFBgXHJcbiAgICovXHJcbiAgKHBheWxvYWQ6IFApOiBQYXlsb2FkQWN0aW9uPFAsIFQ+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB3aG9zZSBgcGF5bG9hZGAgdHlwZSBjb3VsZCBub3QgYmUgaW5mZXJyZWQuIEFjY2VwdHMgZXZlcnl0aGluZyBhcyBgcGF5bG9hZGAuXHJcbiAqXHJcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoTm9uSW5mZXJyYWJsZVBheWxvYWQ8XHJcbiAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZ1xyXG4+IGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8dW5rbm93biwgVD4ge1xyXG4gIC8qKlxyXG4gICAqIENhbGxpbmcgdGhpcyB7QGxpbmsgcmVkdXgjQWN0aW9uQ3JlYXRvcn0gd2l0aCBhbiBhcmd1bWVudCB3aWxsXHJcbiAgICogcmV0dXJuIGEge0BsaW5rIFBheWxvYWRBY3Rpb259IG9mIHR5cGUgYFRgIHdpdGggYSBwYXlsb2FkXHJcbiAgICogb2YgZXhhY3RseSB0aGUgdHlwZSBvZiB0aGUgYXJndW1lbnQuXHJcbiAgICovXHJcbiAgPFBUIGV4dGVuZHMgdW5rbm93bj4ocGF5bG9hZDogUFQpOiBQYXlsb2FkQWN0aW9uPFBULCBUPlxyXG59XHJcblxyXG4vKipcclxuICogQW4gYWN0aW9uIGNyZWF0b3IgdGhhdCBwcm9kdWNlcyBhY3Rpb25zIHdpdGggYSBgcGF5bG9hZGAgYXR0cmlidXRlLlxyXG4gKlxyXG4gKiBAdHlwZVBhcmFtIFAgdGhlIGBwYXlsb2FkYCB0eXBlXHJcbiAqIEB0eXBlUGFyYW0gVCB0aGUgYHR5cGVgIG9mIHRoZSByZXN1bHRpbmcgYWN0aW9uXHJcbiAqIEB0eXBlUGFyYW0gUEEgaWYgdGhlIHJlc3VsdGluZyBhY3Rpb24gaXMgcHJlcHJvY2Vzc2VkIGJ5IGEgYHByZXBhcmVgIG1ldGhvZCwgdGhlIHNpZ25hdHVyZSBvZiBzYWlkIG1ldGhvZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGF5bG9hZEFjdGlvbkNyZWF0b3I8XHJcbiAgUCA9IHZvaWQsXHJcbiAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcclxuICBQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248UD4gfCB2b2lkID0gdm9pZFxyXG4+ID0gSWZQcmVwYXJlQWN0aW9uTWV0aG9kUHJvdmlkZWQ8XHJcbiAgUEEsXHJcbiAgX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFBBLCBUPixcclxuICAvLyBlbHNlXHJcbiAgSXNBbnk8XHJcbiAgICBQLFxyXG4gICAgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPGFueSwgVD4sXHJcbiAgICBJc1Vua25vd25Pck5vbkluZmVycmFibGU8XHJcbiAgICAgIFAsXHJcbiAgICAgIEFjdGlvbkNyZWF0b3JXaXRoTm9uSW5mZXJyYWJsZVBheWxvYWQ8VD4sXHJcbiAgICAgIC8vIGVsc2VcclxuICAgICAgSWZWb2lkPFxyXG4gICAgICAgIFAsXHJcbiAgICAgICAgQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkPFQ+LFxyXG4gICAgICAgIC8vIGVsc2VcclxuICAgICAgICBJZk1heWJlVW5kZWZpbmVkPFxyXG4gICAgICAgICAgUCxcclxuICAgICAgICAgIEFjdGlvbkNyZWF0b3JXaXRoT3B0aW9uYWxQYXlsb2FkPFAsIFQ+LFxyXG4gICAgICAgICAgLy8gZWxzZVxyXG4gICAgICAgICAgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkPFAsIFQ+XHJcbiAgICAgICAgPlxyXG4gICAgICA+XHJcbiAgICA+XHJcbiAgPlxyXG4+XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBhY3Rpb24gY3JlYXRvciBmb3IgdGhlIGdpdmVuIGFjdGlvbiB0eXBlXHJcbiAqIHN0cmluZy4gVGhlIGFjdGlvbiBjcmVhdG9yIGFjY2VwdHMgYSBzaW5nbGUgYXJndW1lbnQsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWRcclxuICogaW4gdGhlIGFjdGlvbiBvYmplY3QgYXMgYSBmaWVsZCBjYWxsZWQgcGF5bG9hZC4gVGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXHJcbiAqIHdpbGwgYWxzbyBoYXZlIGl0cyB0b1N0cmluZygpIG92ZXJyaWRlbiBzbyB0aGF0IGl0IHJldHVybnMgdGhlIGFjdGlvbiB0eXBlLFxyXG4gKiBhbGxvd2luZyBpdCB0byBiZSB1c2VkIGluIHJlZHVjZXIgbG9naWMgdGhhdCBpcyBsb29raW5nIGZvciB0aGF0IGFjdGlvbiB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdHlwZSBUaGUgYWN0aW9uIHR5cGUgdG8gdXNlIGZvciBjcmVhdGVkIGFjdGlvbnMuXHJcbiAqIEBwYXJhbSBwcmVwYXJlIChvcHRpb25hbCkgYSBtZXRob2QgdGhhdCB0YWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB7IHBheWxvYWQgfSBvciB7IHBheWxvYWQsIG1ldGEgfS5cclxuICogICAgICAgICAgICAgICAgSWYgdGhpcyBpcyBnaXZlbiwgdGhlIHJlc3VsdGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIHBhc3MgaXQncyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgdG8gY2FsY3VsYXRlIHBheWxvYWQgJiBtZXRhLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aW9uPFAgPSB2b2lkLCBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcclxuICB0eXBlOiBUXHJcbik6IFBheWxvYWRBY3Rpb25DcmVhdG9yPFAsIFQ+XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBhY3Rpb24gY3JlYXRvciBmb3IgdGhlIGdpdmVuIGFjdGlvbiB0eXBlXHJcbiAqIHN0cmluZy4gVGhlIGFjdGlvbiBjcmVhdG9yIGFjY2VwdHMgYSBzaW5nbGUgYXJndW1lbnQsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWRcclxuICogaW4gdGhlIGFjdGlvbiBvYmplY3QgYXMgYSBmaWVsZCBjYWxsZWQgcGF5bG9hZC4gVGhlIGFjdGlvbiBjcmVhdG9yIGZ1bmN0aW9uXHJcbiAqIHdpbGwgYWxzbyBoYXZlIGl0cyB0b1N0cmluZygpIG92ZXJyaWRlbiBzbyB0aGF0IGl0IHJldHVybnMgdGhlIGFjdGlvbiB0eXBlLFxyXG4gKiBhbGxvd2luZyBpdCB0byBiZSB1c2VkIGluIHJlZHVjZXIgbG9naWMgdGhhdCBpcyBsb29raW5nIGZvciB0aGF0IGFjdGlvbiB0eXBlLlxyXG4gKlxyXG4gKiBAcGFyYW0gdHlwZSBUaGUgYWN0aW9uIHR5cGUgdG8gdXNlIGZvciBjcmVhdGVkIGFjdGlvbnMuXHJcbiAqIEBwYXJhbSBwcmVwYXJlIChvcHRpb25hbCkgYSBtZXRob2QgdGhhdCB0YWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyB7IHBheWxvYWQgfSBvciB7IHBheWxvYWQsIG1ldGEgfS5cclxuICogICAgICAgICAgICAgICAgSWYgdGhpcyBpcyBnaXZlbiwgdGhlIHJlc3VsdGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIHBhc3MgaXQncyBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgdG8gY2FsY3VsYXRlIHBheWxvYWQgJiBtZXRhLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aW9uPFxyXG4gIFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+LFxyXG4gIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmdcclxuPihcclxuICB0eXBlOiBULFxyXG4gIHByZXBhcmVBY3Rpb246IFBBXHJcbik6IFBheWxvYWRBY3Rpb25DcmVhdG9yPFJldHVyblR5cGU8UEE+WydwYXlsb2FkJ10sIFQsIFBBPlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbih0eXBlOiBzdHJpbmcsIHByZXBhcmVBY3Rpb24/OiBGdW5jdGlvbik6IGFueSB7XHJcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvciguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgaWYgKHByZXBhcmVBY3Rpb24pIHtcclxuICAgICAgbGV0IHByZXBhcmVkID0gcHJlcGFyZUFjdGlvbiguLi5hcmdzKVxyXG4gICAgICBpZiAoIXByZXBhcmVkKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmVwYXJlQWN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdCcpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZSxcclxuICAgICAgICBwYXlsb2FkOiBwcmVwYXJlZC5wYXlsb2FkLFxyXG4gICAgICAgIC4uLignbWV0YScgaW4gcHJlcGFyZWQgJiYgeyBtZXRhOiBwcmVwYXJlZC5tZXRhIH0pLFxyXG4gICAgICAgIC4uLignZXJyb3InIGluIHByZXBhcmVkICYmIHsgZXJyb3I6IHByZXBhcmVkLmVycm9yIH0pXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IHR5cGUsIHBheWxvYWQ6IGFyZ3NbMF0gfVxyXG4gIH1cclxuXHJcbiAgYWN0aW9uQ3JlYXRvci50b1N0cmluZyA9ICgpID0+IGAke3R5cGV9YFxyXG5cclxuICBhY3Rpb25DcmVhdG9yLnR5cGUgPSB0eXBlXHJcblxyXG4gIGFjdGlvbkNyZWF0b3IubWF0Y2ggPSAoYWN0aW9uOiBBY3Rpb248dW5rbm93bj4pOiBhY3Rpb24gaXMgUGF5bG9hZEFjdGlvbiA9PlxyXG4gICAgYWN0aW9uLnR5cGUgPT09IHR5cGVcclxuXHJcbiAgcmV0dXJuIGFjdGlvbkNyZWF0b3JcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRlNBKFxyXG4gIGFjdGlvbjogdW5rbm93blxyXG4pOiBhY3Rpb24gaXMge1xyXG4gIHR5cGU6IHN0cmluZ1xyXG4gIHBheWxvYWQ/OiB1bmtub3duXHJcbiAgZXJyb3I/OiB1bmtub3duXHJcbiAgbWV0YT86IHVua25vd25cclxufSB7XHJcbiAgcmV0dXJuIChcclxuICAgIGlzUGxhaW5PYmplY3QoYWN0aW9uKSAmJlxyXG4gICAgdHlwZW9mIChhY3Rpb24gYXMgYW55KS50eXBlID09PSAnc3RyaW5nJyAmJlxyXG4gICAgT2JqZWN0LmtleXMoYWN0aW9uKS5ldmVyeShpc1ZhbGlkS2V5KVxyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXk6IHN0cmluZykge1xyXG4gIHJldHVybiBbJ3R5cGUnLCAncGF5bG9hZCcsICdlcnJvcicsICdtZXRhJ10uaW5kZXhPZihrZXkpID4gLTFcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGFjdGlvbiB0eXBlIG9mIHRoZSBhY3Rpb25zIGNyZWF0ZWQgYnkgdGhlIHBhc3NlZFxyXG4gKiBgY3JlYXRlQWN0aW9uKClgLWdlbmVyYXRlZCBhY3Rpb24gY3JlYXRvciAoYXJiaXRyYXJ5IGFjdGlvbiBjcmVhdG9yc1xyXG4gKiBhcmUgbm90IHN1cHBvcnRlZCkuXHJcbiAqXHJcbiAqIEBwYXJhbSBhY3Rpb24gVGhlIGFjdGlvbiBjcmVhdG9yIHdob3NlIGFjdGlvbiB0eXBlIHRvIGdldC5cclxuICogQHJldHVybnMgVGhlIGFjdGlvbiB0eXBlIHVzZWQgYnkgdGhlIGFjdGlvbiBjcmVhdG9yLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZTxUIGV4dGVuZHMgc3RyaW5nPihcclxuICBhY3Rpb25DcmVhdG9yOiBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxhbnksIFQ+XHJcbik6IFQge1xyXG4gIHJldHVybiBgJHthY3Rpb25DcmVhdG9yfWAgYXMgVFxyXG59XHJcblxyXG4vLyBoZWxwZXIgdHlwZXMgZm9yIG1vcmUgcmVhZGFibGUgdHlwaW5nc1xyXG5cclxudHlwZSBJZlByZXBhcmVBY3Rpb25NZXRob2RQcm92aWRlZDxcclxuICBQQSBleHRlbmRzIFByZXBhcmVBY3Rpb248YW55PiB8IHZvaWQsXHJcbiAgVHJ1ZSxcclxuICBGYWxzZVxyXG4+ID0gUEEgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueSA/IFRydWUgOiBGYWxzZVxyXG4iLCJpbXBvcnQgeyBBY3Rpb24sIEFueUFjdGlvbiB9IGZyb20gJ3JlZHV4J1xyXG5pbXBvcnQge1xyXG4gIENhc2VSZWR1Y2VyLFxyXG4gIENhc2VSZWR1Y2VycyxcclxuICBBY3Rpb25NYXRjaGVyLFxyXG4gIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb25cclxufSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVkQWN0aW9uQ3JlYXRvcjxUeXBlIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgKC4uLmFyZ3M6IGFueVtdKTogQWN0aW9uPFR5cGU+XHJcbiAgdHlwZTogVHlwZVxyXG59XHJcblxyXG4vKipcclxuICogQSBidWlsZGVyIGZvciBhbiBhY3Rpb24gPC0+IHJlZHVjZXIgbWFwLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPiB7XHJcbiAgLyoqXHJcbiAgICogQWRkIGEgY2FzZSByZWR1Y2VyIGZvciBhY3Rpb25zIGNyZWF0ZWQgYnkgdGhpcyBhY3Rpb24gY3JlYXRvci5cclxuICAgKiBAcGFyYW0gYWN0aW9uQ3JlYXRvclxyXG4gICAqIEBwYXJhbSByZWR1Y2VyXHJcbiAgICovXHJcbiAgYWRkQ2FzZTxBY3Rpb25DcmVhdG9yIGV4dGVuZHMgVHlwZWRBY3Rpb25DcmVhdG9yPHN0cmluZz4+KFxyXG4gICAgYWN0aW9uQ3JlYXRvcjogQWN0aW9uQ3JlYXRvcixcclxuICAgIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBSZXR1cm5UeXBlPEFjdGlvbkNyZWF0b3I+PlxyXG4gICk6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPlxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIGNhc2UgcmVkdWNlciBmb3IgYWN0aW9ucyB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cclxuICAgKiBAcGFyYW0gdHlwZVxyXG4gICAqIEBwYXJhbSByZWR1Y2VyXHJcbiAgICovXHJcbiAgYWRkQ2FzZTxUeXBlIGV4dGVuZHMgc3RyaW5nLCBBIGV4dGVuZHMgQWN0aW9uPFR5cGU+PihcclxuICAgIHR5cGU6IFR5cGUsXHJcbiAgICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQT5cclxuICApOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTdGF0ZT5cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIHJlZHVjZXIgZm9yIGFsbCBhY3Rpb25zLCB1c2luZyBgbWF0Y2hlcmAgYXMgYSBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAgICogSWYgbXVsdGlwbGUgbWF0Y2hlciByZWR1Y2VycyBtYXRjaCwgYWxsIG9mIHRoZW0gd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgb3JkZXJcclxuICAgKiB0aGV5IHdlcmUgZGVmaW5lZCBpZiAtIGV2ZW4gaWYgYSBjYXNlIHJlZHVjZXIgYWxyZWFkeSBtYXRjaGVkLlxyXG4gICAqIEBwYXJhbSBtYXRjaGVyIEEgbWF0Y2hlciBmdW5jdGlvbi4gSW4gVHlwZVNjcmlwdCwgdGhpcyBzaG91bGQgYmUgYSBbdHlwZSBwcmVkaWNhdGVdKGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2FkdmFuY2VkLXR5cGVzLmh0bWwjdXNpbmctdHlwZS1wcmVkaWNhdGVzKVxyXG4gICAqICAgZnVuY3Rpb25cclxuICAgKiBAcGFyYW0gcmVkdWNlclxyXG4gICAqL1xyXG4gIGFkZE1hdGNoZXI8QSBleHRlbmRzIEFueUFjdGlvbj4oXHJcbiAgICBtYXRjaGVyOiBBY3Rpb25NYXRjaGVyPEE+LFxyXG4gICAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEE+XHJcbiAgKTogT21pdDxBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTdGF0ZT4sICdhZGRDYXNlJz5cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIFwiZGVmYXVsdCBjYXNlXCIgcmVkdWNlciB0aGF0IGlzIGV4ZWN1dGVkIGlmIG5vIGNhc2UgcmVkdWNlciBhbmQgbm8gbWF0Y2hlclxyXG4gICAqIHJlZHVjZXIgd2FzIGV4ZWN1dGVkIGZvciB0aGlzIGFjdGlvbi5cclxuICAgKiBAcGFyYW0gcmVkdWNlclxyXG4gICAqL1xyXG4gIGFkZERlZmF1bHRDYXNlKHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBBbnlBY3Rpb24+KToge31cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrPFM+KFxyXG4gIGJ1aWxkZXJDYWxsYmFjazogKGJ1aWxkZXI6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFM+KSA9PiB2b2lkXHJcbik6IFtcclxuICBDYXNlUmVkdWNlcnM8UywgYW55PixcclxuICBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+LFxyXG4gIENhc2VSZWR1Y2VyPFMsIEFueUFjdGlvbj4gfCB1bmRlZmluZWRcclxuXSB7XHJcbiAgY29uc3QgYWN0aW9uc01hcDogQ2FzZVJlZHVjZXJzPFMsIGFueT4gPSB7fVxyXG4gIGNvbnN0IGFjdGlvbk1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+ID0gW11cclxuICBsZXQgZGVmYXVsdENhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTLCBBbnlBY3Rpb24+IHwgdW5kZWZpbmVkXHJcbiAgY29uc3QgYnVpbGRlciA9IHtcclxuICAgIGFkZENhc2UoXHJcbiAgICAgIHR5cGVPckFjdGlvbkNyZWF0b3I6IHN0cmluZyB8IFR5cGVkQWN0aW9uQ3JlYXRvcjxhbnk+LFxyXG4gICAgICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTPlxyXG4gICAgKSB7XHJcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgLypcclxuICAgICAgICAgdG8ga2VlcCB0aGUgZGVmaW5pdGlvbiBieSB0aGUgdXNlciBpbiBsaW5lIHdpdGggYWN0dWFsIGJlaGF2aW9yLCBcclxuICAgICAgICAgd2UgZW5mb3JjZSBgYWRkQ2FzZWAgdG8gYWx3YXlzIGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYWRkTWF0Y2hlcmBcclxuICAgICAgICAgYXMgbWF0Y2hpbmcgY2FzZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgbWF0Y2hlcnNcclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoYWN0aW9uTWF0Y2hlcnMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAnYGJ1aWxkZXIuYWRkQ2FzZWAgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBidWlsZGVyLmFkZE1hdGNoZXJgJ1xyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgJ1xyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0eXBlID1cclxuICAgICAgICB0eXBlb2YgdHlwZU9yQWN0aW9uQ3JlYXRvciA9PT0gJ3N0cmluZydcclxuICAgICAgICAgID8gdHlwZU9yQWN0aW9uQ3JlYXRvclxyXG4gICAgICAgICAgOiB0eXBlT3JBY3Rpb25DcmVhdG9yLnR5cGVcclxuICAgICAgaWYgKHR5cGUgaW4gYWN0aW9uc01hcCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICdhZGRDYXNlIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCB0d28gcmVkdWNlcnMgZm9yIHRoZSBzYW1lIGFjdGlvbiB0eXBlJ1xyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgICBhY3Rpb25zTWFwW3R5cGVdID0gcmVkdWNlclxyXG4gICAgICByZXR1cm4gYnVpbGRlclxyXG4gICAgfSxcclxuICAgIGFkZE1hdGNoZXI8QSBleHRlbmRzIEFueUFjdGlvbj4oXHJcbiAgICAgIG1hdGNoZXI6IEFjdGlvbk1hdGNoZXI8QT4sXHJcbiAgICAgIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIEE+XHJcbiAgICApIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdgYnVpbGRlci5hZGRNYXRjaGVyYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgJ1xyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBhY3Rpb25NYXRjaGVycy5wdXNoKHsgbWF0Y2hlciwgcmVkdWNlciB9KVxyXG4gICAgICByZXR1cm4gYnVpbGRlclxyXG4gICAgfSxcclxuICAgIGFkZERlZmF1bHRDYXNlKHJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIEFueUFjdGlvbj4pIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdENhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BidWlsZGVyLmFkZERlZmF1bHRDYXNlYCBjYW4gb25seSBiZSBjYWxsZWQgb25jZScpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHJlZHVjZXJcclxuICAgICAgcmV0dXJuIGJ1aWxkZXJcclxuICAgIH1cclxuICB9XHJcbiAgYnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpXHJcbiAgcmV0dXJuIFthY3Rpb25zTWFwLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXVxyXG59XHJcbiIsImltcG9ydCBjcmVhdGVOZXh0U3RhdGUsIHsgRHJhZnQsIGlzRHJhZnQsIGlzRHJhZnRhYmxlIH0gZnJvbSAnaW1tZXInXHJcbmltcG9ydCB7IEFueUFjdGlvbiwgQWN0aW9uLCBSZWR1Y2VyIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7XHJcbiAgZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2ssXHJcbiAgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXJcclxufSBmcm9tICcuL21hcEJ1aWxkZXJzJ1xyXG5pbXBvcnQgeyBOb0luZmVyIH0gZnJvbSAnLi90c0hlbHBlcnMnXHJcblxyXG4vKipcclxuICogRGVmaW5lcyBhIG1hcHBpbmcgZnJvbSBhY3Rpb24gdHlwZXMgdG8gY29ycmVzcG9uZGluZyBhY3Rpb24gb2JqZWN0IHNoYXBlcy5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgVGhpcyBzaG91bGQgbm90IGJlIHVzZWQgbWFudWFsbHkgLSBpdCBpcyBvbmx5IHVzZWQgZm9yIGludGVybmFsXHJcbiAqICAgICAgICAgICAgIGluZmVyZW5jZSBwdXJwb3NlcyBhbmQgc2hvdWxkIG5vdCBoYXZlIGFueSBmdXJ0aGVyIHZhbHVlLlxyXG4gKiAgICAgICAgICAgICBJdCBtaWdodCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIEFjdGlvbnM8VCBleHRlbmRzIGtleW9mIGFueSA9IHN0cmluZz4gPSBSZWNvcmQ8VCwgQWN0aW9uPlxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25NYXRjaGVyPEEgZXh0ZW5kcyBBbnlBY3Rpb24+IHtcclxuICAoYWN0aW9uOiBBbnlBY3Rpb24pOiBhY3Rpb24gaXMgQVxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb248UywgQSBleHRlbmRzIEFueUFjdGlvbj4gPSB7XHJcbiAgbWF0Y2hlcjogQWN0aW9uTWF0Y2hlcjxBPlxyXG4gIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIE5vSW5mZXI8QT4+XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb248Uz4gPSBBcnJheTxcclxuICBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb248UywgYW55PlxyXG4+XHJcblxyXG4vKipcclxuICogQW4gKmNhc2UgcmVkdWNlciogaXMgYSByZWR1Y2VyIGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIGFjdGlvbiB0eXBlLiBDYXNlXHJcbiAqIHJlZHVjZXJzIGNhbiBiZSBjb21wb3NlZCB0byBmdWxsIHJlZHVjZXJzIHVzaW5nIGBjcmVhdGVSZWR1Y2VyKClgLlxyXG4gKlxyXG4gKiBVbmxpa2UgYSBub3JtYWwgUmVkdXggcmVkdWNlciwgYSBjYXNlIHJlZHVjZXIgaXMgbmV2ZXIgY2FsbGVkIHdpdGggYW5cclxuICogYHVuZGVmaW5lZGAgc3RhdGUgdG8gZGV0ZXJtaW5lIHRoZSBpbml0aWFsIHN0YXRlLiBJbnN0ZWFkLCB0aGUgaW5pdGlhbFxyXG4gKiBzdGF0ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCBhcyBhbiBhcmd1bWVudCB0byBgY3JlYXRlUmVkdWNlcigpYC5cclxuICpcclxuICogSW4gYWRkaXRpb24sIGEgY2FzZSByZWR1Y2VyIGNhbiBjaG9vc2UgdG8gbXV0YXRlIHRoZSBwYXNzZWQtaW4gYHN0YXRlYFxyXG4gKiB2YWx1ZSBkaXJlY3RseSBpbnN0ZWFkIG9mIHJldHVybmluZyBhIG5ldyBzdGF0ZS4gVGhpcyBkb2VzIG5vdCBhY3R1YWxseVxyXG4gKiBjYXVzZSB0aGUgc3RvcmUgc3RhdGUgdG8gYmUgbXV0YXRlZCBkaXJlY3RseTsgaW5zdGVhZCwgdGhhbmtzIHRvXHJcbiAqIFtpbW1lcl0oaHR0cHM6Ly9naXRodWIuY29tL213ZXN0c3RyYXRlL2ltbWVyKSwgdGhlIG11dGF0aW9ucyBhcmVcclxuICogdHJhbnNsYXRlZCB0byBjb3B5IG9wZXJhdGlvbnMgdGhhdCByZXN1bHQgaW4gYSBuZXcgc3RhdGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIENhc2VSZWR1Y2VyPFMgPSBhbnksIEEgZXh0ZW5kcyBBY3Rpb24gPSBBbnlBY3Rpb24+ID0gKFxyXG4gIHN0YXRlOiBEcmFmdDxTPixcclxuICBhY3Rpb246IEFcclxuKSA9PiBTIHwgdm9pZFxyXG5cclxuLyoqXHJcbiAqIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBjYXNlIHJlZHVjZXJzIGZvciBgY3JlYXRlUmVkdWNlcigpYC5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgVGhpcyBzaG91bGQgbm90IGJlIHVzZWQgbWFudWFsbHkgLSBpdCBpcyBvbmx5IHVzZWRcclxuICogICAgICAgICAgICAgZm9yIGludGVybmFsIGluZmVyZW5jZSBwdXJwb3NlcyBhbmQgdXNpbmcgaXQgbWFudWFsbHlcclxuICogICAgICAgICAgICAgd291bGQgbGVhZCB0byB0eXBlIGVyYXN1cmUuXHJcbiAqICAgICAgICAgICAgIEl0IG1pZ2h0IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJzPFMsIEFTIGV4dGVuZHMgQWN0aW9ucz4gPSB7XHJcbiAgW1QgaW4ga2V5b2YgQVNdOiBBU1tUXSBleHRlbmRzIEFjdGlvbiA/IENhc2VSZWR1Y2VyPFMsIEFTW1RdPiA6IHZvaWRcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGFsbG93cyBkZWZpbmluZyBhIHJlZHVjZXIgYXMgYSBtYXBwaW5nIGZyb20gYWN0aW9uXHJcbiAqIHR5cGUgdG8gKmNhc2UgcmVkdWNlciogZnVuY3Rpb25zIHRoYXQgaGFuZGxlIHRoZXNlIGFjdGlvbiB0eXBlcy4gVGhlXHJcbiAqIHJlZHVjZXIncyBpbml0aWFsIHN0YXRlIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIFRoZSBib2R5IG9mIGV2ZXJ5IGNhc2UgcmVkdWNlciBpcyBpbXBsaWNpdGx5IHdyYXBwZWQgd2l0aCBhIGNhbGwgdG9cclxuICogYHByb2R1Y2UoKWAgZnJvbSB0aGUgW2ltbWVyXShodHRwczovL2dpdGh1Yi5jb20vbXdlc3RzdHJhdGUvaW1tZXIpIGxpYnJhcnkuXHJcbiAqIFRoaXMgbWVhbnMgdGhhdCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBuZXcgc3RhdGUgb2JqZWN0LCB5b3UgY2FuIGFsc29cclxuICogbXV0YXRlIHRoZSBwYXNzZWQtaW4gc3RhdGUgb2JqZWN0IGRpcmVjdGx5OyB0aGVzZSBtdXRhdGlvbnMgd2lsbCB0aGVuIGJlXHJcbiAqIGF1dG9tYXRpY2FsbHkgYW5kIGVmZmljaWVudGx5IHRyYW5zbGF0ZWQgaW50byBjb3BpZXMsIGdpdmluZyB5b3UgYm90aFxyXG4gKiBjb252ZW5pZW5jZSBhbmQgaW1tdXRhYmlsaXR5LlxyXG4gKlxyXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIHRvIGJlIHJldHVybmVkIGJ5IHRoZSByZWR1Y2VyLlxyXG4gKiBAcGFyYW0gYWN0aW9uc01hcCBBIG1hcHBpbmcgZnJvbSBhY3Rpb24gdHlwZXMgdG8gYWN0aW9uLXR5cGUtc3BlY2lmaWNcclxuICogICBjYXNlIHJlZHVjZXJzLlxyXG4gKiBAcGFyYW0gYWN0aW9uTWF0Y2hlcnMgQW4gYXJyYXkgb2YgbWF0Y2hlciBkZWZpbml0aW9ucyBpbiB0aGUgZm9ybSBge21hdGNoZXIsIHJlZHVjZXJ9YC5cclxuICogICBBbGwgbWF0Y2hpbmcgcmVkdWNlcnMgd2lsbCBiZSBleGVjdXRlZCBpbiBvcmRlciwgaW5kZXBlbmRlbnRseSBpZiBhIGNhc2UgcmVkdWNlciBtYXRjaGVkIG9yIG5vdC5cclxuICogQHBhcmFtIGRlZmF1bHRDYXNlUmVkdWNlciBBIFwiZGVmYXVsdCBjYXNlXCIgcmVkdWNlciB0aGF0IGlzIGV4ZWN1dGVkIGlmIG5vIGNhc2UgcmVkdWNlciBhbmQgbm8gbWF0Y2hlclxyXG4gKiAgIHJlZHVjZXIgd2FzIGV4ZWN1dGVkIGZvciB0aGlzIGFjdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXI8XHJcbiAgUyxcclxuICBDUiBleHRlbmRzIENhc2VSZWR1Y2VyczxTLCBhbnk+ID0gQ2FzZVJlZHVjZXJzPFMsIGFueT5cclxuPihcclxuICBpbml0aWFsU3RhdGU6IFMsXHJcbiAgYWN0aW9uc01hcDogQ1IsXHJcbiAgYWN0aW9uTWF0Y2hlcnM/OiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+LFxyXG4gIGRlZmF1bHRDYXNlUmVkdWNlcj86IENhc2VSZWR1Y2VyPFM+XHJcbik6IFJlZHVjZXI8Uz5cclxuLyoqXHJcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGFsbG93cyBkZWZpbmluZyBhIHJlZHVjZXIgYXMgYSBtYXBwaW5nIGZyb20gYWN0aW9uXHJcbiAqIHR5cGUgdG8gKmNhc2UgcmVkdWNlciogZnVuY3Rpb25zIHRoYXQgaGFuZGxlIHRoZXNlIGFjdGlvbiB0eXBlcy4gVGhlXHJcbiAqIHJlZHVjZXIncyBpbml0aWFsIHN0YXRlIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQuXHJcbiAqXHJcbiAqIFRoZSBib2R5IG9mIGV2ZXJ5IGNhc2UgcmVkdWNlciBpcyBpbXBsaWNpdGx5IHdyYXBwZWQgd2l0aCBhIGNhbGwgdG9cclxuICogYHByb2R1Y2UoKWAgZnJvbSB0aGUgW2ltbWVyXShodHRwczovL2dpdGh1Yi5jb20vbXdlc3RzdHJhdGUvaW1tZXIpIGxpYnJhcnkuXHJcbiAqIFRoaXMgbWVhbnMgdGhhdCByYXRoZXIgdGhhbiByZXR1cm5pbmcgYSBuZXcgc3RhdGUgb2JqZWN0LCB5b3UgY2FuIGFsc29cclxuICogbXV0YXRlIHRoZSBwYXNzZWQtaW4gc3RhdGUgb2JqZWN0IGRpcmVjdGx5OyB0aGVzZSBtdXRhdGlvbnMgd2lsbCB0aGVuIGJlXHJcbiAqIGF1dG9tYXRpY2FsbHkgYW5kIGVmZmljaWVudGx5IHRyYW5zbGF0ZWQgaW50byBjb3BpZXMsIGdpdmluZyB5b3UgYm90aFxyXG4gKiBjb252ZW5pZW5jZSBhbmQgaW1tdXRhYmlsaXR5LlxyXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRoZSBpbml0aWFsIHN0YXRlIHRvIGJlIHJldHVybmVkIGJ5IHRoZSByZWR1Y2VyLlxyXG4gKiBAcGFyYW0gYnVpbGRlckNhbGxiYWNrIEEgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyBhICpidWlsZGVyKiBvYmplY3QgdG8gZGVmaW5lXHJcbiAqICAgY2FzZSByZWR1Y2VycyB2aWEgY2FsbHMgdG8gYGJ1aWxkZXIuYWRkQ2FzZShhY3Rpb25DcmVhdG9yT3JUeXBlLCByZWR1Y2VyKWAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWR1Y2VyPFM+KFxyXG4gIGluaXRpYWxTdGF0ZTogUyxcclxuICBidWlsZGVyQ2FsbGJhY2s6IChidWlsZGVyOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTPikgPT4gdm9pZFxyXG4pOiBSZWR1Y2VyPFM+XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVkdWNlcjxTPihcclxuICBpbml0aWFsU3RhdGU6IFMsXHJcbiAgbWFwT3JCdWlsZGVyQ2FsbGJhY2s6XHJcbiAgICB8IENhc2VSZWR1Y2VyczxTLCBhbnk+XHJcbiAgICB8ICgoYnVpbGRlcjogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8Uz4pID0+IHZvaWQpLFxyXG4gIGFjdGlvbk1hdGNoZXJzOiBBY3Rpb25NYXRjaGVyRGVzY3JpcHRpb25Db2xsZWN0aW9uPFM+ID0gW10sXHJcbiAgZGVmYXVsdENhc2VSZWR1Y2VyPzogQ2FzZVJlZHVjZXI8Uz5cclxuKTogUmVkdWNlcjxTPiB7XHJcbiAgbGV0IFthY3Rpb25zTWFwLCBmaW5hbEFjdGlvbk1hdGNoZXJzLCBmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl0gPVxyXG4gICAgdHlwZW9mIG1hcE9yQnVpbGRlckNhbGxiYWNrID09PSAnZnVuY3Rpb24nXHJcbiAgICAgID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sobWFwT3JCdWlsZGVyQ2FsbGJhY2spXHJcbiAgICAgIDogW21hcE9yQnVpbGRlckNhbGxiYWNrLCBhY3Rpb25NYXRjaGVycywgZGVmYXVsdENhc2VSZWR1Y2VyXVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24oc3RhdGUgPSBpbml0aWFsU3RhdGUsIGFjdGlvbik6IFMge1xyXG4gICAgbGV0IGNhc2VSZWR1Y2VycyA9IFtcclxuICAgICAgYWN0aW9uc01hcFthY3Rpb24udHlwZV0sXHJcbiAgICAgIC4uLmZpbmFsQWN0aW9uTWF0Y2hlcnNcclxuICAgICAgICAuZmlsdGVyKCh7IG1hdGNoZXIgfSkgPT4gbWF0Y2hlcihhY3Rpb24pKVxyXG4gICAgICAgIC5tYXAoKHsgcmVkdWNlciB9KSA9PiByZWR1Y2VyKVxyXG4gICAgXVxyXG4gICAgaWYgKGNhc2VSZWR1Y2Vycy5maWx0ZXIoY3IgPT4gISFjcikubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIGNhc2VSZWR1Y2VycyA9IFtmaW5hbERlZmF1bHRDYXNlUmVkdWNlcl1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FzZVJlZHVjZXJzLnJlZHVjZSgocHJldmlvdXNTdGF0ZSwgY2FzZVJlZHVjZXIpOiBTID0+IHtcclxuICAgICAgaWYgKGNhc2VSZWR1Y2VyKSB7XHJcbiAgICAgICAgaWYgKGlzRHJhZnQocHJldmlvdXNTdGF0ZSkpIHtcclxuICAgICAgICAgIC8vIElmIGl0J3MgYWxyZWFkeSBhIGRyYWZ0LCB3ZSBtdXN0IGFscmVhZHkgYmUgaW5zaWRlIGEgYGNyZWF0ZU5leHRTdGF0ZWAgY2FsbCxcclxuICAgICAgICAgIC8vIGxpa2VseSBiZWNhdXNlIHRoaXMgaXMgYmVpbmcgd3JhcHBlZCBpbiBgY3JlYXRlUmVkdWNlcmAsIGBjcmVhdGVTbGljZWAsIG9yIG5lc3RlZFxyXG4gICAgICAgICAgLy8gaW5zaWRlIGFuIGV4aXN0aW5nIGRyYWZ0LiBJdCdzIHNhZmUgdG8ganVzdCBwYXNzIHRoZSBkcmFmdCB0byB0aGUgbXV0YXRvci5cclxuICAgICAgICAgIGNvbnN0IGRyYWZ0ID0gcHJldmlvdXNTdGF0ZSBhcyBEcmFmdDxTPiAvLyBXZSBjYW4gYXNzdW1lIHRoaXMgaXMgYWxyZWFkeSBhIGRyYWZ0XHJcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBjYXNlUmVkdWNlcihkcmFmdCwgYWN0aW9uKVxyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc0RyYWZ0YWJsZShwcmV2aW91c1N0YXRlKSkge1xyXG4gICAgICAgICAgLy8gSWYgc3RhdGUgaXMgbm90IGRyYWZ0YWJsZSAoZXg6IGEgcHJpbWl0aXZlLCBzdWNoIGFzIDApLCB3ZSB3YW50IHRvIGRpcmVjdGx5XHJcbiAgICAgICAgICAvLyByZXR1cm4gdGhlIGNhc2VSZWR1Y2VyIGZ1bmMgYW5kIG5vdCB3cmFwIGl0IHdpdGggcHJvZHVjZS5cclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKHByZXZpb3VzU3RhdGUgYXMgYW55LCBhY3Rpb24pXHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxyXG4gICAgICAgICAgICAgICdBIGNhc2UgcmVkdWNlciBvbiBhIG5vbi1kcmFmdGFibGUgdmFsdWUgbXVzdCBub3QgcmV0dXJuIHVuZGVmaW5lZCdcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBjcmVhdGVOZXh0U3RhdGUoKSBwcm9kdWNlcyBhbiBJbW11dGFibGU8RHJhZnQ8Uz4+IHJhdGhlclxyXG4gICAgICAgICAgLy8gdGhhbiBhbiBJbW11dGFibGU8Uz4sIGFuZCBUeXBlU2NyaXB0IGNhbm5vdCBmaW5kIG91dCBob3cgdG8gcmVjb25jaWxlXHJcbiAgICAgICAgICAvLyB0aGVzZSB0d28gdHlwZXMuXHJcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlKHByZXZpb3VzU3RhdGUsIChkcmFmdDogRHJhZnQ8Uz4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHByZXZpb3VzU3RhdGVcclxuICAgIH0sIHN0YXRlKVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBSZWR1Y2VyIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7XHJcbiAgQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkLFxyXG4gIGNyZWF0ZUFjdGlvbixcclxuICBQYXlsb2FkQWN0aW9uLFxyXG4gIFBheWxvYWRBY3Rpb25DcmVhdG9yLFxyXG4gIFByZXBhcmVBY3Rpb24sXHJcbiAgX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkXHJcbn0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nXHJcbmltcG9ydCB7IENhc2VSZWR1Y2VyLCBDYXNlUmVkdWNlcnMsIGNyZWF0ZVJlZHVjZXIgfSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInXHJcbmltcG9ydCB7XHJcbiAgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXIsXHJcbiAgZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2tcclxufSBmcm9tICcuL21hcEJ1aWxkZXJzJ1xyXG5pbXBvcnQgeyBPbWl0LCBOb0luZmVyIH0gZnJvbSAnLi90c0hlbHBlcnMnXHJcblxyXG4vKipcclxuICogQW4gYWN0aW9uIGNyZWF0b3IgYXR0YWNoZWQgdG8gYSBzbGljZS5cclxuICpcclxuICogQGRlcHJlY2F0ZWQgcGxlYXNlIHVzZSBQYXlsb2FkQWN0aW9uQ3JlYXRvciBkaXJlY3RseVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBTbGljZUFjdGlvbkNyZWF0b3I8UD4gPSBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxQPlxyXG5cclxuLyoqXHJcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgYGNyZWF0ZVNsaWNlYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNsaWNlPFxyXG4gIFN0YXRlID0gYW55LFxyXG4gIENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPixcclxuICBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXHJcbj4ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBzbGljZSBuYW1lLlxyXG4gICAqL1xyXG4gIG5hbWU6IE5hbWVcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHNsaWNlJ3MgcmVkdWNlci5cclxuICAgKi9cclxuICByZWR1Y2VyOiBSZWR1Y2VyPFN0YXRlPlxyXG5cclxuICAvKipcclxuICAgKiBBY3Rpb24gY3JlYXRvcnMgZm9yIHRoZSB0eXBlcyBvZiBhY3Rpb25zIHRoYXQgYXJlIGhhbmRsZWQgYnkgdGhlIHNsaWNlXHJcbiAgICogcmVkdWNlci5cclxuICAgKi9cclxuICBhY3Rpb25zOiBDYXNlUmVkdWNlckFjdGlvbnM8Q2FzZVJlZHVjZXJzPlxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW5kaXZpZHVhbCBjYXNlIHJlZHVjZXIgZnVuY3Rpb25zIHRoYXQgd2VyZSBwYXNzZWQgaW4gdGhlIGByZWR1Y2Vyc2AgcGFyYW1ldGVyLlxyXG4gICAqIFRoaXMgZW5hYmxlcyByZXVzZSBhbmQgdGVzdGluZyBpZiB0aGV5IHdlcmUgZGVmaW5lZCBpbmxpbmUgd2hlbiBjYWxsaW5nIGBjcmVhdGVTbGljZWAuXHJcbiAgICovXHJcbiAgY2FzZVJlZHVjZXJzOiBTbGljZURlZmluZWRDYXNlUmVkdWNlcnM8Q2FzZVJlZHVjZXJzPlxyXG59XHJcblxyXG4vKipcclxuICogT3B0aW9ucyBmb3IgYGNyZWF0ZVNsaWNlKClgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZVNsaWNlT3B0aW9uczxcclxuICBTdGF0ZSA9IGFueSxcclxuICBDUiBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPixcclxuICBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXHJcbj4ge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBzbGljZSdzIG5hbWUuIFVzZWQgdG8gbmFtZXNwYWNlIHRoZSBnZW5lcmF0ZWQgYWN0aW9uIHR5cGVzLlxyXG4gICAqL1xyXG4gIG5hbWU6IE5hbWVcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGluaXRpYWwgc3RhdGUgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIHNsaWNlIHJlZHVjZXIuXHJcbiAgICovXHJcbiAgaW5pdGlhbFN0YXRlOiBTdGF0ZVxyXG5cclxuICAvKipcclxuICAgKiBBIG1hcHBpbmcgZnJvbSBhY3Rpb24gdHlwZXMgdG8gYWN0aW9uLXR5cGUtc3BlY2lmaWMgKmNhc2UgcmVkdWNlcipcclxuICAgKiBmdW5jdGlvbnMuIEZvciBldmVyeSBhY3Rpb24gdHlwZSwgYSBtYXRjaGluZyBhY3Rpb24gY3JlYXRvciB3aWxsIGJlXHJcbiAgICogZ2VuZXJhdGVkIHVzaW5nIGBjcmVhdGVBY3Rpb24oKWAuXHJcbiAgICovXHJcbiAgcmVkdWNlcnM6IFZhbGlkYXRlU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGUsIENSPlxyXG5cclxuICAvKipcclxuICAgKiBBIG1hcHBpbmcgZnJvbSBhY3Rpb24gdHlwZXMgdG8gYWN0aW9uLXR5cGUtc3BlY2lmaWMgKmNhc2UgcmVkdWNlcipcclxuICAgKiBmdW5jdGlvbnMuIFRoZXNlIHJlZHVjZXJzIHNob3VsZCBoYXZlIGV4aXN0aW5nIGFjdGlvbiB0eXBlcyB1c2VkXHJcbiAgICogYXMgdGhlIGtleXMsIGFuZCBhY3Rpb24gY3JlYXRvcnMgd2lsbCBfbm90XyBiZSBnZW5lcmF0ZWQuXHJcbiAgICogQWx0ZXJuYXRpdmVseSwgYSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGEgKmJ1aWxkZXIqIG9iamVjdCB0byBkZWZpbmVcclxuICAgKiBjYXNlIHJlZHVjZXJzIHZpYSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlKGFjdGlvbkNyZWF0b3JPclR5cGUsIHJlZHVjZXIpYC5cclxuICAgKi9cclxuICBleHRyYVJlZHVjZXJzPzpcclxuICAgIHwgQ2FzZVJlZHVjZXJzPE5vSW5mZXI8U3RhdGU+LCBhbnk+XHJcbiAgICB8ICgoYnVpbGRlcjogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8Tm9JbmZlcjxTdGF0ZT4+KSA9PiB2b2lkKVxyXG59XHJcblxyXG4vKipcclxuICogQSBDYXNlUmVkdWNlciB3aXRoIGEgYHByZXBhcmVgIG1ldGhvZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgQWN0aW9uIGV4dGVuZHMgUGF5bG9hZEFjdGlvbj4gPSB7XHJcbiAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEFjdGlvbj5cclxuICBwcmVwYXJlOiBQcmVwYXJlQWN0aW9uPEFjdGlvblsncGF5bG9hZCddPlxyXG59XHJcblxyXG4vKipcclxuICogVGhlIHR5cGUgZGVzY3JpYmluZyBhIHNsaWNlJ3MgYHJlZHVjZXJzYCBvcHRpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPiA9IHtcclxuICBbSzogc3RyaW5nXTpcclxuICAgIHwgQ2FzZVJlZHVjZXI8U3RhdGUsIFBheWxvYWRBY3Rpb248YW55Pj5cclxuICAgIHwgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnksIHN0cmluZywgYW55LCBhbnk+PlxyXG59XHJcblxyXG4vKipcclxuICogRGVyaXZlcyB0aGUgc2xpY2UncyBgYWN0aW9uc2AgcHJvcGVydHkgZnJvbSB0aGUgYHJlZHVjZXJzYCBvcHRpb25zXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIENhc2VSZWR1Y2VyQWN0aW9uczxDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2Vyczxhbnk+PiA9IHtcclxuICBbVHlwZSBpbiBrZXlvZiBDYXNlUmVkdWNlcnNdOiBDYXNlUmVkdWNlcnNbVHlwZV0gZXh0ZW5kcyB7IHByZXBhcmU6IGFueSB9XHJcbiAgICA/IEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcldpdGhQcmVwYXJlPENhc2VSZWR1Y2Vyc1tUeXBlXT5cclxuICAgIDogQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyPENhc2VSZWR1Y2Vyc1tUeXBlXT5cclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBhIGBQYXlsb2FkQWN0aW9uQ3JlYXRvcmAgdHlwZSBmb3IgYSBwYXNzZWQgYENhc2VSZWR1Y2VyV2l0aFByZXBhcmVgXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudHlwZSBBY3Rpb25DcmVhdG9yRm9yQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZTxcclxuICBDUiBleHRlbmRzIHsgcHJlcGFyZTogYW55IH1cclxuPiA9IF9BY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxDUlsncHJlcGFyZSddLCBzdHJpbmc+XHJcblxyXG4vKipcclxuICogR2V0IGEgYFBheWxvYWRBY3Rpb25DcmVhdG9yYCB0eXBlIGZvciBhIHBhc3NlZCBgQ2FzZVJlZHVjZXJgXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudHlwZSBBY3Rpb25DcmVhdG9yRm9yQ2FzZVJlZHVjZXI8Q1I+ID0gQ1IgZXh0ZW5kcyAoXHJcbiAgc3RhdGU6IGFueSxcclxuICBhY3Rpb246IGluZmVyIEFjdGlvblxyXG4pID0+IGFueVxyXG4gID8gQWN0aW9uIGV4dGVuZHMgeyBwYXlsb2FkOiBpbmZlciBQIH1cclxuICAgID8gUGF5bG9hZEFjdGlvbkNyZWF0b3I8UD5cclxuICAgIDogQWN0aW9uQ3JlYXRvcldpdGhvdXRQYXlsb2FkXHJcbiAgOiBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWRcclxuXHJcbi8qKlxyXG4gKiBFeHRyYWN0cyB0aGUgQ2FzZVJlZHVjZXJzIG91dCBvZiBhIGByZWR1Y2Vyc2Agb2JqZWN0LCBldmVuIGlmIHRoZXkgYXJlXHJcbiAqIHRlc3RlZCBpbnRvIGEgYENhc2VSZWR1Y2VyV2l0aFByZXBhcmVgLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbnR5cGUgU2xpY2VEZWZpbmVkQ2FzZVJlZHVjZXJzPENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPGFueT4+ID0ge1xyXG4gIFtUeXBlIGluIGtleW9mIENhc2VSZWR1Y2Vyc106IENhc2VSZWR1Y2Vyc1tUeXBlXSBleHRlbmRzIHtcclxuICAgIHJlZHVjZXI6IGluZmVyIFJlZHVjZXJcclxuICB9XHJcbiAgICA/IFJlZHVjZXJcclxuICAgIDogQ2FzZVJlZHVjZXJzW1R5cGVdXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVc2VkIG9uIGEgU2xpY2VDYXNlUmVkdWNlcnMgb2JqZWN0LlxyXG4gKiBFbnN1cmVzIHRoYXQgaWYgYSBDYXNlUmVkdWNlciBpcyBhIGBDYXNlUmVkdWNlcldpdGhQcmVwYXJlYCwgdGhhdFxyXG4gKiB0aGUgYHJlZHVjZXJgIGFuZCB0aGUgYHByZXBhcmVgIGZ1bmN0aW9uIHVzZSB0aGUgc2FtZSB0eXBlIG9mIGBwYXlsb2FkYC5cclxuICpcclxuICogTWlnaHQgZG8gYWRkaXRpb25hbCBzdWNoIGNoZWNrcyBpbiB0aGUgZnV0dXJlLlxyXG4gKlxyXG4gKiBUaGlzIHR5cGUgaXMgb25seSBldmVyIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3cml0ZSB5b3VyIG93biB3cmFwcGVyIGFyb3VuZFxyXG4gKiBgY3JlYXRlU2xpY2VgLiBQbGVhc2UgZG9uJ3QgdXNlIGl0IG90aGVyd2lzZSFcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxcclxuICBTLFxyXG4gIEFDUiBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFM+XHJcbj4gPSBBQ1IgJlxyXG4gIHtcclxuICAgIFtUIGluIGtleW9mIEFDUl06IEFDUltUXSBleHRlbmRzIHtcclxuICAgICAgcmVkdWNlcihzOiBTLCBhY3Rpb24/OiBpbmZlciBBKTogYW55XHJcbiAgICB9XHJcbiAgICAgID8ge1xyXG4gICAgICAgICAgcHJlcGFyZSguLi5hOiBuZXZlcltdKTogT21pdDxBLCAndHlwZSc+XHJcbiAgICAgICAgfVxyXG4gICAgICA6IHt9XHJcbiAgfVxyXG5cclxuZnVuY3Rpb24gZ2V0VHlwZShzbGljZTogc3RyaW5nLCBhY3Rpb25LZXk6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGAke3NsaWNlfS8ke2FjdGlvbktleX1gXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhbiBpbml0aWFsIHN0YXRlLCBhbiBvYmplY3QgZnVsbCBvZiByZWR1Y2VyXHJcbiAqIGZ1bmN0aW9ucywgYW5kIGEgXCJzbGljZSBuYW1lXCIsIGFuZCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlc1xyXG4gKiBhY3Rpb24gY3JlYXRvcnMgYW5kIGFjdGlvbiB0eXBlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXHJcbiAqIHJlZHVjZXJzIGFuZCBzdGF0ZS5cclxuICpcclxuICogVGhlIGByZWR1Y2VyYCBhcmd1bWVudCBpcyBwYXNzZWQgdG8gYGNyZWF0ZVJlZHVjZXIoKWAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbGljZTxcclxuICBTdGF0ZSxcclxuICBDYXNlUmVkdWNlcnMgZXh0ZW5kcyBTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZT4sXHJcbiAgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZ1xyXG4+KFxyXG4gIG9wdGlvbnM6IENyZWF0ZVNsaWNlT3B0aW9uczxTdGF0ZSwgQ2FzZVJlZHVjZXJzLCBOYW1lPlxyXG4pOiBTbGljZTxTdGF0ZSwgQ2FzZVJlZHVjZXJzLCBOYW1lPiB7XHJcbiAgY29uc3QgeyBuYW1lLCBpbml0aWFsU3RhdGUgfSA9IG9wdGlvbnNcclxuICBpZiAoIW5hbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignYG5hbWVgIGlzIGEgcmVxdWlyZWQgb3B0aW9uIGZvciBjcmVhdGVTbGljZScpXHJcbiAgfVxyXG4gIGNvbnN0IHJlZHVjZXJzID0gb3B0aW9ucy5yZWR1Y2VycyB8fCB7fVxyXG4gIGNvbnN0IFtcclxuICAgIGV4dHJhUmVkdWNlcnMgPSB7fSxcclxuICAgIGFjdGlvbk1hdGNoZXJzID0gW10sXHJcbiAgICBkZWZhdWx0Q2FzZVJlZHVjZXIgPSB1bmRlZmluZWRcclxuICBdID1cclxuICAgIHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09ICd1bmRlZmluZWQnXHJcbiAgICAgID8gW11cclxuICAgICAgOiB0eXBlb2Ygb3B0aW9ucy5leHRyYVJlZHVjZXJzID09PSAnZnVuY3Rpb24nXHJcbiAgICAgID8gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2sob3B0aW9ucy5leHRyYVJlZHVjZXJzKVxyXG4gICAgICA6IFtvcHRpb25zLmV4dHJhUmVkdWNlcnNdXHJcblxyXG4gIGNvbnN0IHJlZHVjZXJOYW1lcyA9IE9iamVjdC5rZXlzKHJlZHVjZXJzKVxyXG5cclxuICBjb25zdCBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZTogUmVjb3JkPHN0cmluZywgQ2FzZVJlZHVjZXI+ID0ge31cclxuICBjb25zdCBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZTogUmVjb3JkPHN0cmluZywgQ2FzZVJlZHVjZXI+ID0ge31cclxuICBjb25zdCBhY3Rpb25DcmVhdG9yczogUmVjb3JkPHN0cmluZywgRnVuY3Rpb24+ID0ge31cclxuXHJcbiAgcmVkdWNlck5hbWVzLmZvckVhY2gocmVkdWNlck5hbWUgPT4ge1xyXG4gICAgY29uc3QgbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUgPSByZWR1Y2Vyc1tyZWR1Y2VyTmFtZV1cclxuICAgIGNvbnN0IHR5cGUgPSBnZXRUeXBlKG5hbWUsIHJlZHVjZXJOYW1lKVxyXG5cclxuICAgIGxldCBjYXNlUmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIGFueT5cclxuICAgIGxldCBwcmVwYXJlQ2FsbGJhY2s6IFByZXBhcmVBY3Rpb248YW55PiB8IHVuZGVmaW5lZFxyXG5cclxuICAgIGlmICgncmVkdWNlcicgaW4gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUpIHtcclxuICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZS5yZWR1Y2VyXHJcbiAgICAgIHByZXBhcmVDYWxsYmFjayA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnByZXBhcmVcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhc2VSZWR1Y2VyID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmVcclxuICAgIH1cclxuXHJcbiAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZVtyZWR1Y2VyTmFtZV0gPSBjYXNlUmVkdWNlclxyXG4gICAgc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGVbdHlwZV0gPSBjYXNlUmVkdWNlclxyXG4gICAgYWN0aW9uQ3JlYXRvcnNbcmVkdWNlck5hbWVdID0gcHJlcGFyZUNhbGxiYWNrXHJcbiAgICAgID8gY3JlYXRlQWN0aW9uKHR5cGUsIHByZXBhcmVDYWxsYmFjaylcclxuICAgICAgOiBjcmVhdGVBY3Rpb24odHlwZSlcclxuICB9KVxyXG5cclxuICBjb25zdCBmaW5hbENhc2VSZWR1Y2VycyA9IHsgLi4uZXh0cmFSZWR1Y2VycywgLi4uc2xpY2VDYXNlUmVkdWNlcnNCeVR5cGUgfVxyXG4gIGNvbnN0IHJlZHVjZXIgPSBjcmVhdGVSZWR1Y2VyKFxyXG4gICAgaW5pdGlhbFN0YXRlLFxyXG4gICAgZmluYWxDYXNlUmVkdWNlcnMgYXMgYW55LFxyXG4gICAgYWN0aW9uTWF0Y2hlcnMsXHJcbiAgICBkZWZhdWx0Q2FzZVJlZHVjZXJcclxuICApXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBuYW1lLFxyXG4gICAgcmVkdWNlcixcclxuICAgIGFjdGlvbnM6IGFjdGlvbkNyZWF0b3JzIGFzIGFueSxcclxuICAgIGNhc2VSZWR1Y2Vyczogc2xpY2VDYXNlUmVkdWNlcnNCeU5hbWUgYXMgYW55XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEVudGl0eVN0YXRlIH0gZnJvbSAnLi9tb2RlbHMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbEVudGl0eVN0YXRlPFY+KCk6IEVudGl0eVN0YXRlPFY+IHtcclxuICByZXR1cm4ge1xyXG4gICAgaWRzOiBbXSxcclxuICAgIGVudGl0aWVzOiB7fVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxTdGF0ZUZhY3Rvcnk8Vj4oKSB7XHJcbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKCk6IEVudGl0eVN0YXRlPFY+XHJcbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlPFMgZXh0ZW5kcyBvYmplY3Q+KFxyXG4gICAgYWRkaXRpb25hbFN0YXRlOiBTXHJcbiAgKTogRW50aXR5U3RhdGU8Vj4gJiBTXHJcbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbFN0YXRlKGFkZGl0aW9uYWxTdGF0ZTogYW55ID0ge30pOiBhbnkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZ2V0SW5pdGlhbEVudGl0eVN0YXRlKCksIGFkZGl0aW9uYWxTdGF0ZSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7IGdldEluaXRpYWxTdGF0ZSB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlU2VsZWN0b3IgfSBmcm9tICdyZXNlbGVjdCdcclxuaW1wb3J0IHsgRW50aXR5U3RhdGUsIEVudGl0eVNlbGVjdG9ycywgRGljdGlvbmFyeSwgRW50aXR5SWQgfSBmcm9tICcuL21vZGVscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5PFQ+KCkge1xyXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycygpOiBFbnRpdHlTZWxlY3RvcnM8VCwgRW50aXR5U3RhdGU8VD4+XHJcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzPFY+KFxyXG4gICAgc2VsZWN0U3RhdGU6IChzdGF0ZTogVikgPT4gRW50aXR5U3RhdGU8VD5cclxuICApOiBFbnRpdHlTZWxlY3RvcnM8VCwgVj5cclxuICBmdW5jdGlvbiBnZXRTZWxlY3RvcnMoXHJcbiAgICBzZWxlY3RTdGF0ZT86IChzdGF0ZTogYW55KSA9PiBFbnRpdHlTdGF0ZTxUPlxyXG4gICk6IEVudGl0eVNlbGVjdG9yczxULCBhbnk+IHtcclxuICAgIGNvbnN0IHNlbGVjdElkcyA9IChzdGF0ZTogYW55KSA9PiBzdGF0ZS5pZHNcclxuXHJcbiAgICBjb25zdCBzZWxlY3RFbnRpdGllcyA9IChzdGF0ZTogRW50aXR5U3RhdGU8VD4pID0+IHN0YXRlLmVudGl0aWVzXHJcblxyXG4gICAgY29uc3Qgc2VsZWN0QWxsID0gY3JlYXRlU2VsZWN0b3IoXHJcbiAgICAgIHNlbGVjdElkcyxcclxuICAgICAgc2VsZWN0RW50aXRpZXMsXHJcbiAgICAgIChpZHM6IFRbXSwgZW50aXRpZXM6IERpY3Rpb25hcnk8VD4pOiBhbnkgPT5cclxuICAgICAgICBpZHMubWFwKChpZDogYW55KSA9PiAoZW50aXRpZXMgYXMgYW55KVtpZF0pXHJcbiAgICApXHJcblxyXG4gICAgY29uc3Qgc2VsZWN0SWQgPSAoXzogYW55LCBpZDogRW50aXR5SWQpID0+IGlkXHJcblxyXG4gICAgY29uc3Qgc2VsZWN0QnlJZCA9IChlbnRpdGllczogRGljdGlvbmFyeTxUPiwgaWQ6IEVudGl0eUlkKSA9PiBlbnRpdGllc1tpZF1cclxuXHJcbiAgICBjb25zdCBzZWxlY3RUb3RhbCA9IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdElkcywgaWRzID0+IGlkcy5sZW5ndGgpXHJcblxyXG4gICAgaWYgKCFzZWxlY3RTdGF0ZSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHNlbGVjdElkcyxcclxuICAgICAgICBzZWxlY3RFbnRpdGllcyxcclxuICAgICAgICBzZWxlY3RBbGwsXHJcbiAgICAgICAgc2VsZWN0VG90YWwsXHJcbiAgICAgICAgc2VsZWN0QnlJZDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0RW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc2VsZWN0R2xvYmFsaXplZEVudGl0aWVzID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEVudGl0aWVzKVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNlbGVjdElkczogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdElkcyksXHJcbiAgICAgIHNlbGVjdEVudGl0aWVzOiBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsXHJcbiAgICAgIHNlbGVjdEFsbDogY3JlYXRlU2VsZWN0b3Ioc2VsZWN0U3RhdGUsIHNlbGVjdEFsbCksXHJcbiAgICAgIHNlbGVjdFRvdGFsOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0VG90YWwpLFxyXG4gICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMsIHNlbGVjdElkLCBzZWxlY3RCeUlkKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZ2V0U2VsZWN0b3JzIH1cclxufVxyXG4iLCJpbXBvcnQgY3JlYXRlTmV4dFN0YXRlLCB7IGlzRHJhZnQgfSBmcm9tICdpbW1lcidcclxuaW1wb3J0IHsgRW50aXR5U3RhdGUsIFByZXZlbnRBbnkgfSBmcm9tICcuL21vZGVscydcclxuaW1wb3J0IHsgUGF5bG9hZEFjdGlvbiwgaXNGU0EgfSBmcm9tICcuLi9jcmVhdGVBY3Rpb24nXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yPFY+KFxyXG4gIG11dGF0b3I6IChzdGF0ZTogRW50aXR5U3RhdGU8Vj4pID0+IHZvaWRcclxuKSB7XHJcbiAgY29uc3Qgb3BlcmF0b3IgPSBjcmVhdGVTdGF0ZU9wZXJhdG9yKChfOiB1bmRlZmluZWQsIHN0YXRlOiBFbnRpdHlTdGF0ZTxWPikgPT5cclxuICAgIG11dGF0b3Ioc3RhdGUpXHJcbiAgKVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uPFMgZXh0ZW5kcyBFbnRpdHlTdGF0ZTxWPj4oXHJcbiAgICBzdGF0ZTogUHJldmVudEFueTxTLCBWPlxyXG4gICk6IFMge1xyXG4gICAgcmV0dXJuIG9wZXJhdG9yKHN0YXRlIGFzIFMsIHVuZGVmaW5lZClcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdGF0ZU9wZXJhdG9yPFYsIFI+KFxyXG4gIG11dGF0b3I6IChhcmc6IFIsIHN0YXRlOiBFbnRpdHlTdGF0ZTxWPikgPT4gdm9pZFxyXG4pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gb3BlcmF0aW9uPFMgZXh0ZW5kcyBFbnRpdHlTdGF0ZTxWPj4oXHJcbiAgICBzdGF0ZTogUyxcclxuICAgIGFyZzogUiB8IFBheWxvYWRBY3Rpb248Uj5cclxuICApOiBTIHtcclxuICAgIGZ1bmN0aW9uIGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KFxyXG4gICAgICBhcmc6IFIgfCBQYXlsb2FkQWN0aW9uPFI+XHJcbiAgICApOiBhcmcgaXMgUGF5bG9hZEFjdGlvbjxSPiB7XHJcbiAgICAgIHJldHVybiBpc0ZTQShhcmcpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcnVuTXV0YXRvciA9IChkcmFmdDogRW50aXR5U3RhdGU8Vj4pID0+IHtcclxuICAgICAgaWYgKGlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50KGFyZykpIHtcclxuICAgICAgICBtdXRhdG9yKGFyZy5wYXlsb2FkLCBkcmFmdClcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtdXRhdG9yKGFyZywgZHJhZnQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNEcmFmdChzdGF0ZSkpIHtcclxuICAgICAgLy8gd2UgbXVzdCBhbHJlYWR5IGJlIGluc2lkZSBhIGBjcmVhdGVOZXh0U3RhdGVgIGNhbGwsIGxpa2VseSBiZWNhdXNlXHJcbiAgICAgIC8vIHRoaXMgaXMgYmVpbmcgd3JhcHBlZCBpbiBgY3JlYXRlUmVkdWNlcmAgb3IgYGNyZWF0ZVNsaWNlYC5cclxuICAgICAgLy8gSXQncyBzYWZlIHRvIGp1c3QgcGFzcyB0aGUgZHJhZnQgdG8gdGhlIG11dGF0b3IuXHJcbiAgICAgIHJ1bk11dGF0b3Ioc3RhdGUpXHJcblxyXG4gICAgICAvLyBzaW5jZSBpdCdzIGEgZHJhZnQsIHdlJ2xsIGp1c3QgcmV0dXJuIGl0XHJcbiAgICAgIHJldHVybiBzdGF0ZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gQHRzLWlnbm9yZSBjcmVhdGVOZXh0U3RhdGUoKSBwcm9kdWNlcyBhbiBJbW11dGFibGU8RHJhZnQ8Uz4+IHJhdGhlclxyXG4gICAgICAvLyB0aGFuIGFuIEltbXV0YWJsZTxTPiwgYW5kIFR5cGVTY3JpcHQgY2Fubm90IGZpbmQgb3V0IGhvdyB0byByZWNvbmNpbGVcclxuICAgICAgLy8gdGhlc2UgdHdvIHR5cGVzLlxyXG4gICAgICByZXR1cm4gY3JlYXRlTmV4dFN0YXRlKHN0YXRlLCBydW5NdXRhdG9yKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJZFNlbGVjdG9yIH0gZnJvbSAnLi9tb2RlbHMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2VsZWN0SWRWYWx1ZTxUPihlbnRpdHk6IFQsIHNlbGVjdElkOiBJZFNlbGVjdG9yPFQ+KSB7XHJcbiAgY29uc3Qga2V5ID0gc2VsZWN0SWQoZW50aXR5KVxyXG5cclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBrZXkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgY29uc29sZS53YXJuKFxyXG4gICAgICAnVGhlIGVudGl0eSBwYXNzZWQgdG8gdGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgdW5kZWZpbmVkLicsXHJcbiAgICAgICdZb3Ugc2hvdWxkIHByb2JhYmx5IHByb3ZpZGUgeW91ciBvd24gYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbi4nLFxyXG4gICAgICAnVGhlIGVudGl0eSB0aGF0IHdhcyBwYXNzZWQ6JyxcclxuICAgICAgZW50aXR5LFxyXG4gICAgICAnVGhlIGBzZWxlY3RJZGAgaW1wbGVtZW50YXRpb246JyxcclxuICAgICAgc2VsZWN0SWQudG9TdHJpbmcoKVxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGtleVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgRW50aXR5U3RhdGUsXHJcbiAgRW50aXR5U3RhdGVBZGFwdGVyLFxyXG4gIElkU2VsZWN0b3IsXHJcbiAgVXBkYXRlLFxyXG4gIEVudGl0eUlkXHJcbn0gZnJvbSAnLi9tb2RlbHMnXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlU3RhdGVPcGVyYXRvcixcclxuICBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3JcclxufSBmcm9tICcuL3N0YXRlX2FkYXB0ZXInXHJcbmltcG9ydCB7IHNlbGVjdElkVmFsdWUgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyPFQ+KFxyXG4gIHNlbGVjdElkOiBJZFNlbGVjdG9yPFQ+XHJcbik6IEVudGl0eVN0YXRlQWRhcHRlcjxUPiB7XHJcbiAgdHlwZSBSID0gRW50aXR5U3RhdGU8VD5cclxuXHJcbiAgZnVuY3Rpb24gYWRkT25lTXV0YWJseShlbnRpdHk6IFQsIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBjb25zdCBrZXkgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpXHJcblxyXG4gICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5pZHMucHVzaChrZXkpXHJcbiAgICBzdGF0ZS5lbnRpdGllc1trZXldID0gZW50aXR5XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShlbnRpdGllczogVFtdIHwgUmVjb3JkPEVudGl0eUlkLCBUPiwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKVxyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgIGFkZE9uZU11dGFibHkoZW50aXR5LCBzdGF0ZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHNldEFsbE11dGFibHkoZW50aXRpZXM6IFRbXSB8IFJlY29yZDxFbnRpdHlJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XHJcbiAgICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcylcclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5pZHMgPSBbXVxyXG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fVxyXG5cclxuICAgIGFkZE1hbnlNdXRhYmx5KGVudGl0aWVzLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU9uZU11dGFibHkoa2V5OiBFbnRpdHlJZCwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIHJldHVybiByZW1vdmVNYW55TXV0YWJseShba2V5XSwgc3RhdGUpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVNYW55TXV0YWJseShrZXlzOiBFbnRpdHlJZFtdLCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlXHJcblxyXG4gICAga2V5cy5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICAgIGlmIChrZXkgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNba2V5XVxyXG4gICAgICAgIGRpZE11dGF0ZSA9IHRydWVcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBpZiAoZGlkTXV0YXRlKSB7XHJcbiAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5maWx0ZXIoaWQgPT4gaWQgaW4gc3RhdGUuZW50aXRpZXMpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiByZW1vdmVBbGxNdXRhYmx5KHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLCB7XHJcbiAgICAgIGlkczogW10sXHJcbiAgICAgIGVudGl0aWVzOiB7fVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHRha2VOZXdLZXkoXHJcbiAgICBrZXlzOiB7IFtpZDogc3RyaW5nXTogRW50aXR5SWQgfSxcclxuICAgIHVwZGF0ZTogVXBkYXRlPFQ+LFxyXG4gICAgc3RhdGU6IFJcclxuICApOiBib29sZWFuIHtcclxuICAgIGNvbnN0IG9yaWdpbmFsID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXVxyXG4gICAgY29uc3QgdXBkYXRlZDogVCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsLCB1cGRhdGUuY2hhbmdlcylcclxuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpXHJcbiAgICBjb25zdCBoYXNOZXdLZXkgPSBuZXdLZXkgIT09IHVwZGF0ZS5pZFxyXG5cclxuICAgIGlmIChoYXNOZXdLZXkpIHtcclxuICAgICAga2V5c1t1cGRhdGUuaWRdID0gbmV3S2V5XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUuZW50aXRpZXNbbmV3S2V5XSA9IHVwZGF0ZWRcclxuXHJcbiAgICByZXR1cm4gaGFzTmV3S2V5XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVPbmVNdXRhYmx5KHVwZGF0ZTogVXBkYXRlPFQ+LCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgcmV0dXJuIHVwZGF0ZU1hbnlNdXRhYmx5KFt1cGRhdGVdLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZXM6IFVwZGF0ZTxUPltdLCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgY29uc3QgbmV3S2V5czogeyBbaWQ6IHN0cmluZ106IEVudGl0eUlkIH0gPSB7fVxyXG5cclxuICAgIGNvbnN0IHVwZGF0ZXNQZXJFbnRpdHk6IHsgW2lkOiBzdHJpbmddOiBVcGRhdGU8VD4gfSA9IHt9XHJcblxyXG4gICAgdXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB7XHJcbiAgICAgIC8vIE9ubHkgYXBwbHkgdXBkYXRlcyB0byBlbnRpdGllcyB0aGF0IGN1cnJlbnRseSBleGlzdFxyXG4gICAgICBpZiAodXBkYXRlLmlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIHVwZGF0ZXMgdG8gb25lIGVudGl0eSwgbWVyZ2UgdGhlbSB0b2dldGhlclxyXG4gICAgICAgIHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXSA9IHtcclxuICAgICAgICAgIGlkOiB1cGRhdGUuaWQsXHJcbiAgICAgICAgICAvLyBTcHJlYWRzIGlnbm9yZSBmYWxzeSB2YWx1ZXMsIHNvIHRoaXMgd29ya3MgZXZlbiBpZiB0aGVyZSBpc24ndFxyXG4gICAgICAgICAgLy8gYW4gZXhpc3RpbmcgdXBkYXRlIGFscmVhZHkgYXQgdGhpcyBrZXlcclxuICAgICAgICAgIGNoYW5nZXM6IHtcclxuICAgICAgICAgICAgLi4uKHVwZGF0ZXNQZXJFbnRpdHlbdXBkYXRlLmlkXVxyXG4gICAgICAgICAgICAgID8gdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdLmNoYW5nZXNcclxuICAgICAgICAgICAgICA6IG51bGwpLFxyXG4gICAgICAgICAgICAuLi51cGRhdGUuY2hhbmdlc1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICB1cGRhdGVzID0gT2JqZWN0LnZhbHVlcyh1cGRhdGVzUGVyRW50aXR5KVxyXG5cclxuICAgIGNvbnN0IGRpZE11dGF0ZUVudGl0aWVzID0gdXBkYXRlcy5sZW5ndGggPiAwXHJcblxyXG4gICAgaWYgKGRpZE11dGF0ZUVudGl0aWVzKSB7XHJcbiAgICAgIGNvbnN0IGRpZE11dGF0ZUlkcyA9XHJcbiAgICAgICAgdXBkYXRlcy5maWx0ZXIodXBkYXRlID0+IHRha2VOZXdLZXkobmV3S2V5cywgdXBkYXRlLCBzdGF0ZSkpLmxlbmd0aCA+IDBcclxuXHJcbiAgICAgIGlmIChkaWRNdXRhdGVJZHMpIHtcclxuICAgICAgICBzdGF0ZS5pZHMgPSBzdGF0ZS5pZHMubWFwKGlkID0+IG5ld0tleXNbaWRdIHx8IGlkKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cHNlcnRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIHJldHVybiB1cHNlcnRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cHNlcnRNYW55TXV0YWJseShcclxuICAgIGVudGl0aWVzOiBUW10gfCBSZWNvcmQ8RW50aXR5SWQsIFQ+LFxyXG4gICAgc3RhdGU6IFJcclxuICApOiB2b2lkIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGFkZGVkOiBUW10gPSBbXVxyXG4gICAgY29uc3QgdXBkYXRlZDogVXBkYXRlPFQ+W10gPSBbXVxyXG5cclxuICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgIGNvbnN0IGlkID0gc2VsZWN0SWRWYWx1ZShlbnRpdHksIHNlbGVjdElkKVxyXG4gICAgICBpZiAoaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICB1cGRhdGVkLnB1c2goeyBpZCwgY2hhbmdlczogZW50aXR5IH0pXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkZWQucHVzaChlbnRpdHkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVkLCBzdGF0ZSlcclxuICAgIGFkZE1hbnlNdXRhYmx5KGFkZGVkLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZW1vdmVBbGw6IGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvcihyZW1vdmVBbGxNdXRhYmx5KSxcclxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcclxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxyXG4gICAgc2V0QWxsOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHNldEFsbE11dGFibHkpLFxyXG4gICAgdXBkYXRlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU9uZU11dGFibHkpLFxyXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KSxcclxuICAgIHJlbW92ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVPbmVNdXRhYmx5KSxcclxuICAgIHJlbW92ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IocmVtb3ZlTWFueU11dGFibHkpXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7XHJcbiAgRW50aXR5U3RhdGUsXHJcbiAgSWRTZWxlY3RvcixcclxuICBDb21wYXJlcixcclxuICBFbnRpdHlTdGF0ZUFkYXB0ZXIsXHJcbiAgVXBkYXRlLFxyXG4gIEVudGl0eUlkXHJcbn0gZnJvbSAnLi9tb2RlbHMnXHJcbmltcG9ydCB7IGNyZWF0ZVN0YXRlT3BlcmF0b3IgfSBmcm9tICcuL3N0YXRlX2FkYXB0ZXInXHJcbmltcG9ydCB7IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIH0gZnJvbSAnLi91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyJ1xyXG5pbXBvcnQgeyBzZWxlY3RJZFZhbHVlIH0gZnJvbSAnLi91dGlscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXI8VD4oXHJcbiAgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VD4sXHJcbiAgc29ydDogQ29tcGFyZXI8VD5cclxuKTogRW50aXR5U3RhdGVBZGFwdGVyPFQ+IHtcclxuICB0eXBlIFIgPSBFbnRpdHlTdGF0ZTxUPlxyXG5cclxuICBjb25zdCB7IHJlbW92ZU9uZSwgcmVtb3ZlTWFueSwgcmVtb3ZlQWxsIH0gPSBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihcclxuICAgIHNlbGVjdElkXHJcbiAgKVxyXG5cclxuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIHJldHVybiBhZGRNYW55TXV0YWJseShbZW50aXR5XSwgc3RhdGUpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhZGRNYW55TXV0YWJseShcclxuICAgIG5ld01vZGVsczogVFtdIHwgUmVjb3JkPEVudGl0eUlkLCBUPixcclxuICAgIHN0YXRlOiBSXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3TW9kZWxzKSkge1xyXG4gICAgICBuZXdNb2RlbHMgPSBPYmplY3QudmFsdWVzKG5ld01vZGVscylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtb2RlbHMgPSBuZXdNb2RlbHMuZmlsdGVyKFxyXG4gICAgICBtb2RlbCA9PiAhKHNlbGVjdElkVmFsdWUobW9kZWwsIHNlbGVjdElkKSBpbiBzdGF0ZS5lbnRpdGllcylcclxuICAgIClcclxuXHJcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShtb2RlbHM6IFRbXSB8IFJlY29yZDxFbnRpdHlJZCwgVD4sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZWxzKSkge1xyXG4gICAgICBtb2RlbHMgPSBPYmplY3QudmFsdWVzKG1vZGVscylcclxuICAgIH1cclxuICAgIHN0YXRlLmVudGl0aWVzID0ge31cclxuICAgIHN0YXRlLmlkcyA9IFtdXHJcblxyXG4gICAgYWRkTWFueU11dGFibHkobW9kZWxzLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlOiBVcGRhdGU8VD4sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGFrZVVwZGF0ZWRNb2RlbChtb2RlbHM6IFRbXSwgdXBkYXRlOiBVcGRhdGU8VD4sIHN0YXRlOiBSKTogYm9vbGVhbiB7XHJcbiAgICBpZiAoISh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9yaWdpbmFsID0gc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXVxyXG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsLCB1cGRhdGUuY2hhbmdlcylcclxuICAgIGNvbnN0IG5ld0tleSA9IHNlbGVjdElkVmFsdWUodXBkYXRlZCwgc2VsZWN0SWQpXHJcblxyXG4gICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF1cclxuXHJcbiAgICBtb2RlbHMucHVzaCh1cGRhdGVkKVxyXG5cclxuICAgIHJldHVybiBuZXdLZXkgIT09IHVwZGF0ZS5pZFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlczogVXBkYXRlPFQ+W10sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBjb25zdCBtb2RlbHM6IFRbXSA9IFtdXHJcblxyXG4gICAgdXBkYXRlcy5mb3JFYWNoKHVwZGF0ZSA9PiB0YWtlVXBkYXRlZE1vZGVsKG1vZGVscywgdXBkYXRlLCBzdGF0ZSkpXHJcblxyXG4gICAgaWYgKG1vZGVscy5sZW5ndGggIT09IDApIHtcclxuICAgICAgbWVyZ2UobW9kZWxzLCBzdGF0ZSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KFxyXG4gICAgZW50aXRpZXM6IFRbXSB8IFJlY29yZDxFbnRpdHlJZCwgVD4sXHJcbiAgICBzdGF0ZTogUlxyXG4gICk6IHZvaWQge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xyXG4gICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkZWQ6IFRbXSA9IFtdXHJcbiAgICBjb25zdCB1cGRhdGVkOiBVcGRhdGU8VD5bXSA9IFtdXHJcblxyXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpXHJcbiAgICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkLCBjaGFuZ2VzOiBlbnRpdHkgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRlZC5wdXNoKGVudGl0eSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKVxyXG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gYXJlQXJyYXlzRXF1YWwoYTogdW5rbm93bltdLCBiOiB1bmtub3duW10pIHtcclxuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aCAmJiBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWVyZ2UobW9kZWxzOiBUW10sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBtb2RlbHMuc29ydChzb3J0KVxyXG5cclxuICAgIC8vIEluc2VydC9vdmVyd3JpdGUgYWxsIG5ldy91cGRhdGVkXHJcbiAgICBtb2RlbHMuZm9yRWFjaChtb2RlbCA9PiB7XHJcbiAgICAgIHN0YXRlLmVudGl0aWVzW3NlbGVjdElkKG1vZGVsKV0gPSBtb2RlbFxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCBhbGxFbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoc3RhdGUuZW50aXRpZXMpIGFzIFRbXVxyXG4gICAgYWxsRW50aXRpZXMuc29ydChzb3J0KVxyXG5cclxuICAgIGNvbnN0IG5ld1NvcnRlZElkcyA9IGFsbEVudGl0aWVzLm1hcChzZWxlY3RJZClcclxuICAgIGNvbnN0IHsgaWRzIH0gPSBzdGF0ZVxyXG5cclxuICAgIGlmICghYXJlQXJyYXlzRXF1YWwoaWRzLCBuZXdTb3J0ZWRJZHMpKSB7XHJcbiAgICAgIHN0YXRlLmlkcyA9IG5ld1NvcnRlZElkc1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbW92ZU9uZSxcclxuICAgIHJlbW92ZU1hbnksXHJcbiAgICByZW1vdmVBbGwsXHJcbiAgICBhZGRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkT25lTXV0YWJseSksXHJcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICB1cHNlcnRPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0T25lTXV0YWJseSksXHJcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICBhZGRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE1hbnlNdXRhYmx5KSxcclxuICAgIHVwZGF0ZU1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlTWFueU11dGFibHkpLFxyXG4gICAgdXBzZXJ0TWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRNYW55TXV0YWJseSlcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRW50aXR5RGVmaW5pdGlvbiwgQ29tcGFyZXIsIElkU2VsZWN0b3IsIEVudGl0eUFkYXB0ZXIgfSBmcm9tICcuL21vZGVscydcclxuaW1wb3J0IHsgY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSB9IGZyb20gJy4vZW50aXR5X3N0YXRlJ1xyXG5pbXBvcnQgeyBjcmVhdGVTZWxlY3RvcnNGYWN0b3J5IH0gZnJvbSAnLi9zdGF0ZV9zZWxlY3RvcnMnXHJcbmltcG9ydCB7IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlciB9IGZyb20gJy4vc29ydGVkX3N0YXRlX2FkYXB0ZXInXHJcbmltcG9ydCB7IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyIH0gZnJvbSAnLi91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyJ1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbnRpdHlBZGFwdGVyPFQ+KFxyXG4gIG9wdGlvbnM6IHtcclxuICAgIHNlbGVjdElkPzogSWRTZWxlY3RvcjxUPlxyXG4gICAgc29ydENvbXBhcmVyPzogZmFsc2UgfCBDb21wYXJlcjxUPlxyXG4gIH0gPSB7fVxyXG4pOiBFbnRpdHlBZGFwdGVyPFQ+IHtcclxuICBjb25zdCB7IHNlbGVjdElkLCBzb3J0Q29tcGFyZXIgfTogRW50aXR5RGVmaW5pdGlvbjxUPiA9IHtcclxuICAgIHNvcnRDb21wYXJlcjogZmFsc2UsXHJcbiAgICBzZWxlY3RJZDogKGluc3RhbmNlOiBhbnkpID0+IGluc3RhbmNlLmlkLFxyXG4gICAgLi4ub3B0aW9uc1xyXG4gIH1cclxuXHJcbiAgY29uc3Qgc3RhdGVGYWN0b3J5ID0gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeTxUPigpXHJcbiAgY29uc3Qgc2VsZWN0b3JzRmFjdG9yeSA9IGNyZWF0ZVNlbGVjdG9yc0ZhY3Rvcnk8VD4oKVxyXG4gIGNvbnN0IHN0YXRlQWRhcHRlciA9IHNvcnRDb21wYXJlclxyXG4gICAgPyBjcmVhdGVTb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQsIHNvcnRDb21wYXJlcilcclxuICAgIDogY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIoc2VsZWN0SWQpXHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBzZWxlY3RJZCxcclxuICAgIHNvcnRDb21wYXJlcixcclxuICAgIC4uLnN0YXRlRmFjdG9yeSxcclxuICAgIC4uLnNlbGVjdG9yc0ZhY3RvcnksXHJcbiAgICAuLi5zdGF0ZUFkYXB0ZXJcclxuICB9XHJcbn1cclxuIiwiLy8gQSB0eXBlIG9mIHByb21pc2UtbGlrZSB0aGF0IHJlc29sdmVzIHN5bmNocm9ub3VzbHkgYW5kIHN1cHBvcnRzIG9ubHkgb25lIG9ic2VydmVyXG5leHBvcnQgY29uc3QgX1BhY3QgPSAvKiNfX1BVUkVfXyovKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBfUGFjdCgpIHt9XG5cdF9QYWN0LnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcblx0XHRjb25zdCByZXN1bHQgPSBuZXcgX1BhY3QoKTtcblx0XHRjb25zdCBzdGF0ZSA9IHRoaXMucztcblx0XHRpZiAoc3RhdGUpIHtcblx0XHRcdGNvbnN0IGNhbGxiYWNrID0gc3RhdGUgJiAxID8gb25GdWxmaWxsZWQgOiBvblJlamVjdGVkO1xuXHRcdFx0aWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDEsIGNhbGxiYWNrKHRoaXMudikpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDIsIGUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5vID0gZnVuY3Rpb24oX3RoaXMpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gX3RoaXMudjtcblx0XHRcdFx0aWYgKF90aGlzLnMgJiAxKSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDEsIG9uRnVsZmlsbGVkID8gb25GdWxmaWxsZWQodmFsdWUpIDogdmFsdWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKG9uUmVqZWN0ZWQpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMSwgb25SZWplY3RlZCh2YWx1ZSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zZXR0bGUocmVzdWx0LCAyLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDIsIGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXHRyZXR1cm4gX1BhY3Q7XG59KSgpO1xuXG4vLyBTZXR0bGVzIGEgcGFjdCBzeW5jaHJvbm91c2x5XG5leHBvcnQgZnVuY3Rpb24gX3NldHRsZShwYWN0LCBzdGF0ZSwgdmFsdWUpIHtcblx0aWYgKCFwYWN0LnMpIHtcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBfUGFjdCkge1xuXHRcdFx0aWYgKHZhbHVlLnMpIHtcblx0XHRcdFx0aWYgKHN0YXRlICYgMSkge1xuXHRcdFx0XHRcdHN0YXRlID0gdmFsdWUucztcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLnY7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZS5vID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIHN0YXRlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0dmFsdWUudGhlbihfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpLCBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMikpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRwYWN0LnMgPSBzdGF0ZTtcblx0XHRwYWN0LnYgPSB2YWx1ZTtcblx0XHRjb25zdCBvYnNlcnZlciA9IHBhY3Qubztcblx0XHRpZiAob2JzZXJ2ZXIpIHtcblx0XHRcdG9ic2VydmVyKHBhY3QpO1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2lzU2V0dGxlZFBhY3QodGhlbmFibGUpIHtcblx0cmV0dXJuIHRoZW5hYmxlIGluc3RhbmNlb2YgX1BhY3QgJiYgdGhlbmFibGUucyAmIDE7XG59XG5cbi8vIENvbnZlcnRzIGFyZ3VtZW50IHRvIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBhIFByb21pc2VcbmV4cG9ydCBmdW5jdGlvbiBfYXN5bmMoZikge1xuXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgYXJncyA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZi5hcHBseSh0aGlzLCBhcmdzKSk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIEF3YWl0cyBvbiBhIHZhbHVlIHRoYXQgbWF5IG9yIG1heSBub3QgYmUgYSBQcm9taXNlIChlcXVpdmFsZW50IHRvIHRoZSBhd2FpdCBrZXl3b3JkIGluIEVTMjAxNSwgd2l0aCBjb250aW51YXRpb25zIHBhc3NlZCBleHBsaWNpdGx5KVxuZXhwb3J0IGZ1bmN0aW9uIF9hd2FpdCh2YWx1ZSwgdGhlbiwgZGlyZWN0KSB7XG5cdGlmIChkaXJlY3QpIHtcblx0XHRyZXR1cm4gdGhlbiA/IHRoZW4odmFsdWUpIDogdmFsdWU7XG5cdH1cblx0aWYgKCF2YWx1ZSB8fCAhdmFsdWUudGhlbikge1xuXHRcdHZhbHVlID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gdGhlbiA/IHZhbHVlLnRoZW4odGhlbikgOiB2YWx1ZTtcbn1cblxuLy8gQXdhaXRzIG9uIGEgdmFsdWUgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBhIFByb21pc2UsIHRoZW4gaWdub3JlcyBpdFxuZXhwb3J0IGZ1bmN0aW9uIF9hd2FpdElnbm9yZWQodmFsdWUsIGRpcmVjdCkge1xuXHRpZiAoIWRpcmVjdCkge1xuXHRcdHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50aGVuID8gdmFsdWUudGhlbihfZW1wdHkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cbn1cblxuLy8gUHJvY2VlZHMgYWZ0ZXIgYSB2YWx1ZSBoYXMgcmVzb2x2ZWQsIG9yIHByb2NlZWRzIGltbWVkaWF0ZWx5IGlmIHRoZSB2YWx1ZSBpcyBub3QgdGhlbmFibGVcbmV4cG9ydCBmdW5jdGlvbiBfY29udGludWUodmFsdWUsIHRoZW4pIHtcblx0cmV0dXJuIHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKHRoZW4pIDogdGhlbih2YWx1ZSk7XG59XG5cbi8vIFByb2NlZWRzIGFmdGVyIGEgdmFsdWUgaGFzIHJlc29sdmVkLCBvciBwcm9jZWVkcyBpbW1lZGlhdGVseSBpZiB0aGUgdmFsdWUgaXMgbm90IHRoZW5hYmxlXG5leHBvcnQgZnVuY3Rpb24gX2NvbnRpbnVlSWdub3JlZCh2YWx1ZSkge1xuXHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdHJldHVybiB2YWx1ZS50aGVuKF9lbXB0eSk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCB0aGF0IGhhcyBhIGxlbmd0aCBwcm9wZXJ0eSwgcGFzc2luZyB0aGUgaW5kZXggYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayAoZXZlbiBhcyB0aGUgbGVuZ3RoIHByb3BlcnR5IGNoYW5nZXMpXG5leHBvcnQgZnVuY3Rpb24gX2ZvclRvKGFycmF5LCBib2R5LCBjaGVjaykge1xuXHR2YXIgaSA9IC0xLCBwYWN0LCByZWplY3Q7XG5cdGZ1bmN0aW9uIF9jeWNsZShyZXN1bHQpIHtcblx0XHR0cnkge1xuXHRcdFx0d2hpbGUgKCsraSA8IGFycmF5Lmxlbmd0aCAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuXHRcdFx0XHRyZXN1bHQgPSBib2R5KGkpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC52O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QoKSwgMikpKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYWN0KSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhY3QgPSByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0X3NldHRsZShwYWN0IHx8IChwYWN0ID0gbmV3IF9QYWN0KCkpLCAyLCBlKTtcblx0XHR9XG5cdH1cblx0X2N5Y2xlKCk7XG5cdHJldHVybiBwYWN0O1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIHRocm91Z2ggYW4gb2JqZWN0J3MgcHJvcGVydGllcyAoaW5jbHVkaW5nIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZSlcbi8vIFVzZXMgYSBzbmFwc2hvdCBvZiB0aGUgb2JqZWN0J3MgcHJvcGVydGllc1xuZXhwb3J0IGZ1bmN0aW9uIF9mb3JJbih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG5cdHZhciBrZXlzID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcblx0XHRrZXlzLnB1c2goa2V5KTtcblx0fVxuXHRyZXR1cm4gX2ZvclRvKGtleXMsIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGJvZHkoa2V5c1tpXSk7IH0sIGNoZWNrKTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIChleGNsdWRpbmcgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSB0aGUgcHJvdG90eXBlKVxuLy8gVXNlcyBhIHNuYXBzaG90IG9mIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzXG5leHBvcnQgZnVuY3Rpb24gX2Zvck93bih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG5cdHZhciBrZXlzID0gW107XG5cdGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcblx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBfZm9yVG8oa2V5cywgZnVuY3Rpb24oaSkgeyByZXR1cm4gYm9keShrZXlzW2ldKTsgfSwgY2hlY2spO1xufVxuXG5leHBvcnQgY29uc3QgX2l0ZXJhdG9yU3ltYm9sID0gLyojX19QVVJFX18qLyB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gKFN5bWJvbC5pdGVyYXRvciB8fCAoU3ltYm9sLml0ZXJhdG9yID0gU3ltYm9sKFwiU3ltYm9sLml0ZXJhdG9yXCIpKSkgOiBcIkBAaXRlcmF0b3JcIjtcblxuLy8gQXN5bmNocm9ub3VzbHkgaXRlcmF0ZSB0aHJvdWdoIGFuIG9iamVjdCdzIHZhbHVlc1xuLy8gVXNlcyBmb3IuLi5vZiBpZiB0aGUgcnVudGltZSBzdXBwb3J0cyBpdCwgb3RoZXJ3aXNlIGl0ZXJhdGVzIHVudGlsIGxlbmd0aCBvbiBhIGNvcHlcbmV4cG9ydCBmdW5jdGlvbiBfZm9yT2YodGFyZ2V0LCBib2R5LCBjaGVjaykge1xuXHRpZiAodHlwZW9mIHRhcmdldFtfaXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR2YXIgaXRlcmF0b3IgPSB0YXJnZXRbX2l0ZXJhdG9yU3ltYm9sXSgpLCBzdGVwLCBwYWN0LCByZWplY3Q7XG5cdFx0ZnVuY3Rpb24gX2N5Y2xlKHJlc3VsdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0d2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSAmJiAoIWNoZWNrIHx8ICFjaGVjaygpKSkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGJvZHkoc3RlcC52YWx1ZSk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnY7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQudGhlbihfY3ljbGUsIHJlamVjdCB8fCAocmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QgPSBuZXcgX1BhY3QoKSwgMikpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFjdCkge1xuXHRcdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYWN0ID0gcmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCB8fCAocGFjdCA9IG5ldyBfUGFjdCgpKSwgMiwgZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9jeWNsZSgpO1xuXHRcdGlmIChpdGVyYXRvci5yZXR1cm4pIHtcblx0XHRcdHZhciBfZml4dXAgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGlmICghc3RlcC5kb25lKSB7XG5cdFx0XHRcdFx0XHRpdGVyYXRvci5yZXR1cm4oKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwYWN0ICYmIHBhY3QudGhlbikge1xuXHRcdFx0XHRyZXR1cm4gcGFjdC50aGVuKF9maXh1cCwgZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRcdHRocm93IF9maXh1cChlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRfZml4dXAoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhY3Q7XG5cdH1cblx0Ly8gTm8gc3VwcG9ydCBmb3IgU3ltYm9sLml0ZXJhdG9yXG5cdGlmICghKFwibGVuZ3RoXCIgaW4gdGFyZ2V0KSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlXCIpO1xuXHR9XG5cdC8vIEhhbmRsZSBsaXZlIGNvbGxlY3Rpb25zIHByb3Blcmx5XG5cdHZhciB2YWx1ZXMgPSBbXTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXQubGVuZ3RoOyBpKyspIHtcblx0XHR2YWx1ZXMucHVzaCh0YXJnZXRbaV0pO1xuXHR9XG5cdHJldHVybiBfZm9yVG8odmFsdWVzLCBmdW5jdGlvbihpKSB7IHJldHVybiBib2R5KHZhbHVlc1tpXSk7IH0sIGNoZWNrKTtcbn1cblxuZXhwb3J0IGNvbnN0IF9hc3luY0l0ZXJhdG9yU3ltYm9sID0gLyojX19QVVJFX18qLyB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiID8gKFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IChTeW1ib2wuYXN5bmNJdGVyYXRvciA9IFN5bWJvbChcIlN5bWJvbC5hc3luY0l0ZXJhdG9yXCIpKSkgOiBcIkBAYXN5bmNJdGVyYXRvclwiO1xuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIG9uIGEgdmFsdWUgdXNpbmcgaXQncyBhc3luYyBpdGVyYXRvciBpZiBwcmVzZW50LCBvciBpdHMgc3luY2hyb25vdXMgaXRlcmF0b3IgaWYgbWlzc2luZ1xuZXhwb3J0IGZ1bmN0aW9uIF9mb3JBd2FpdE9mKHRhcmdldCwgYm9keSwgY2hlY2spIHtcblx0aWYgKHR5cGVvZiB0YXJnZXRbX2FzeW5jSXRlcmF0b3JTeW1ib2xdID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHR2YXIgcGFjdCA9IG5ldyBfUGFjdCgpO1xuXHRcdHZhciBpdGVyYXRvciA9IHRhcmdldFtfYXN5bmNJdGVyYXRvclN5bWJvbF0oKTtcblx0XHRpdGVyYXRvci5uZXh0KCkudGhlbihfcmVzdW1lQWZ0ZXJOZXh0KS50aGVuKHZvaWQgMCwgX3JlamVjdCk7XG5cdFx0cmV0dXJuIHBhY3Q7XG5cdFx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyQm9keShyZXN1bHQpIHtcblx0XHRcdGlmIChjaGVjayAmJiBjaGVjaygpKSB7XG5cdFx0XHRcdHJldHVybiBfc2V0dGxlKHBhY3QsIDEsIGl0ZXJhdG9yLnJldHVybiA/IGl0ZXJhdG9yLnJldHVybigpLnRoZW4oZnVuY3Rpb24oKSB7IHJldHVybiByZXN1bHQ7IH0pIDogcmVzdWx0KTtcblx0XHRcdH1cblx0XHRcdGl0ZXJhdG9yLm5leHQoKS50aGVuKF9yZXN1bWVBZnRlck5leHQpLnRoZW4odm9pZCAwLCBfcmVqZWN0KTtcblx0XHR9XG5cdFx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyTmV4dChzdGVwKSB7XG5cdFx0XHRpZiAoc3RlcC5kb25lKSB7XG5cdFx0XHRcdF9zZXR0bGUocGFjdCwgMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQcm9taXNlLnJlc29sdmUoYm9keShzdGVwLnZhbHVlKSkudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgX3JlamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIF9yZWplY3QoZXJyb3IpIHtcblx0XHRcdF9zZXR0bGUocGFjdCwgMiwgaXRlcmF0b3IucmV0dXJuID8gaXRlcmF0b3IucmV0dXJuKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIGVycm9yOyB9KSA6IGVycm9yKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShfZm9yT2YodGFyZ2V0LCBmdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKGJvZHkpOyB9LCBjaGVjaykpO1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBpbXBsZW1lbnQgYSBnZW5lcmljIGZvciBsb29wXG5leHBvcnQgZnVuY3Rpb24gX2Zvcih0ZXN0LCB1cGRhdGUsIGJvZHkpIHtcblx0dmFyIHN0YWdlO1xuXHRmb3IgKDs7KSB7XG5cdFx0dmFyIHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXHRcdGlmIChfaXNTZXR0bGVkUGFjdChzaG91bGRDb250aW51ZSkpIHtcblx0XHRcdHNob3VsZENvbnRpbnVlID0gc2hvdWxkQ29udGludWUudjtcblx0XHR9XG5cdFx0aWYgKCFzaG91bGRDb250aW51ZSkge1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlLnRoZW4pIHtcblx0XHRcdHN0YWdlID0gMDtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5zO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c3RhZ2UgPSAxO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHVwZGF0ZSkge1xuXHRcdFx0dmFyIHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cdFx0XHRpZiAodXBkYXRlVmFsdWUgJiYgdXBkYXRlVmFsdWUudGhlbiAmJiAhX2lzU2V0dGxlZFBhY3QodXBkYXRlVmFsdWUpKSB7XG5cdFx0XHRcdHN0YWdlID0gMjtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHZhciBwYWN0ID0gbmV3IF9QYWN0KCk7XG5cdHZhciByZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMik7XG5cdChzdGFnZSA9PT0gMCA/IHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkgOiBzdGFnZSA9PT0gMSA/IHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpIDogdXBkYXRlVmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJVcGRhdGUpKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0cmV0dXJuIHBhY3Q7XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkodmFsdWUpIHtcblx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRkbyB7XG5cdFx0XHRpZiAodXBkYXRlKSB7XG5cdFx0XHRcdHVwZGF0ZVZhbHVlID0gdXBkYXRlKCk7XG5cdFx0XHRcdGlmICh1cGRhdGVWYWx1ZSAmJiB1cGRhdGVWYWx1ZS50aGVuICYmICFfaXNTZXR0bGVkUGFjdCh1cGRhdGVWYWx1ZSkpIHtcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblx0XHRcdGlmICghc2hvdWxkQ29udGludWUgfHwgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSAmJiAhc2hvdWxkQ29udGludWUudikpIHtcblx0XHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdH1cblx0XHR9IHdoaWxlICghcmVzdWx0IHx8ICFyZXN1bHQudGhlbik7XG5cdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdH1cblx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyVGVzdChzaG91bGRDb250aW51ZSkge1xuXHRcdGlmIChzaG91bGRDb250aW51ZSkge1xuXHRcdFx0cmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF9yZXN1bWVBZnRlckJvZHkocmVzdWx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdH1cblx0fVxuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJVcGRhdGUoKSB7XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlID0gdGVzdCgpKSB7XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3Jlc3VtZUFmdGVyVGVzdChzaG91bGRDb250aW51ZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHR9XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaW1wbGVtZW50IGEgZG8gLi4uIHdoaWxlIGxvb3BcbmV4cG9ydCBmdW5jdGlvbiBfZG8oYm9keSwgdGVzdCkge1xuXHR2YXIgYXdhaXRCb2R5O1xuXHRkbyB7XG5cdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF3YWl0Qm9keSA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgc2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0aWYgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSkge1xuXHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdH1cblx0XHRpZiAoIXNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fSB3aGlsZSAoIXNob3VsZENvbnRpbnVlLnRoZW4pO1xuXHRjb25zdCBwYWN0ID0gbmV3IF9QYWN0KCk7XG5cdGNvbnN0IHJlamVjdCA9IF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCAyKTtcblx0KGF3YWl0Qm9keSA/IHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpIDogc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdHJldHVybiBwYWN0O1xuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJCb2R5KHZhbHVlKSB7XG5cdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0c2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpKSB7XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlID0gc2hvdWxkQ29udGludWUudjtcblx0XHRcdH1cblx0XHRcdGlmICghc2hvdWxkQ29udGludWUpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnY7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0fVxuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXHRcdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpKSB7XG5cdFx0XHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghc2hvdWxkQ29udGludWUpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICghc2hvdWxkQ29udGludWUudGhlbik7XG5cdFx0XHRzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0fVxuXHR9XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGltcGxlbWVudCBhIHN3aXRjaCBzdGF0ZW1lbnRcbmV4cG9ydCBmdW5jdGlvbiBfc3dpdGNoKGRpc2NyaW1pbmFudCwgY2FzZXMpIHtcblx0dmFyIGRpc3BhdGNoSW5kZXggPSAtMTtcblx0dmFyIGF3YWl0Qm9keTtcblx0b3V0ZXI6IHtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNhc2VzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgdGVzdCA9IGNhc2VzW2ldWzBdO1xuXHRcdFx0aWYgKHRlc3QpIHtcblx0XHRcdFx0dmFyIHRlc3RWYWx1ZSA9IHRlc3QoKTtcblx0XHRcdFx0aWYgKHRlc3RWYWx1ZSAmJiB0ZXN0VmFsdWUudGhlbikge1xuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0ZXN0VmFsdWUgPT09IGRpc2NyaW1pbmFudCkge1xuXHRcdFx0XHRcdGRpc3BhdGNoSW5kZXggPSBpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3VuZCB0aGUgZGVmYXVsdCBjYXNlLCBzZXQgaXQgYXMgdGhlIHBlbmRpbmcgZGlzcGF0Y2ggY2FzZVxuXHRcdFx0XHRkaXNwYXRjaEluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGRpc3BhdGNoSW5kZXggIT09IC0xKSB7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdHZhciBib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHRcdHdoaWxlICghYm9keSkge1xuXHRcdFx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdFx0XHRib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRcdGF3YWl0Qm9keSA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGZhbGx0aHJvdWdoQ2hlY2sgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsyXTtcblx0XHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdFx0fSB3aGlsZSAoZmFsbHRocm91Z2hDaGVjayAmJiAhZmFsbHRocm91Z2hDaGVjaygpKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cdGNvbnN0IHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0Y29uc3QgcmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIDIpO1xuXHQoYXdhaXRCb2R5ID8gcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkgOiB0ZXN0VmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdHJldHVybiBwYWN0O1xuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHZhbHVlKSB7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0aWYgKHZhbHVlID09PSBkaXNjcmltaW5hbnQpIHtcblx0XHRcdFx0ZGlzcGF0Y2hJbmRleCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCsraSA9PT0gY2FzZXMubGVuZ3RoKSB7XG5cdFx0XHRcdGlmIChkaXNwYXRjaEluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRlc3QgPSBjYXNlc1tpXVswXTtcblx0XHRcdGlmICh0ZXN0KSB7XG5cdFx0XHRcdHZhbHVlID0gdGVzdCgpO1xuXHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUudGhlbikge1xuXHRcdFx0XHRcdHZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdHdoaWxlICghYm9keSkge1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0XHRcdGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdH1cblx0XHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgZmFsbHRocm91Z2hDaGVjayA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzJdO1xuXHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdH0gd2hpbGUgKGZhbGx0aHJvdWdoQ2hlY2sgJiYgIWZhbGx0aHJvdWdoQ2hlY2soKSk7XG5cdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHR9XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkocmVzdWx0KSB7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0dmFyIGZhbGx0aHJvdWdoQ2hlY2sgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsyXTtcblx0XHRcdGlmICghZmFsbHRocm91Z2hDaGVjayB8fCBmYWxsdGhyb3VnaENoZWNrKCkpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0XHR2YXIgYm9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0d2hpbGUgKCFib2R5KSB7XG5cdFx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdFx0Ym9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gZXhwbGljaXRseSBwYXNzZWQgY29udGludWF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIF9jYWxsKGJvZHksIHRoZW4sIGRpcmVjdCkge1xuXHRpZiAoZGlyZWN0KSB7XG5cdFx0cmV0dXJuIHRoZW4gPyB0aGVuKGJvZHkoKSkgOiBib2R5KCk7XG5cdH1cblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKGJvZHkoKSk7XG5cdFx0cmV0dXJuIHRoZW4gPyByZXN1bHQudGhlbih0aGVuKSA6IHJlc3VsdDtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBjYWxsIGEgZnVuY3Rpb24gYW5kIHN3YWxsb3cgdGhlIHJlc3VsdFxuZXhwb3J0IGZ1bmN0aW9uIF9jYWxsSWdub3JlZChib2R5LCBkaXJlY3QpIHtcblx0cmV0dXJuIF9jYWxsKGJvZHksIF9lbXB0eSwgZGlyZWN0KTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gZXhwbGljaXRseSBwYXNzZWQgY29udGludWF0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnZva2UoYm9keSwgdGhlbikge1xuXHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKHRoZW4pO1xuXHR9XG5cdHJldHVybiB0aGVuKHJlc3VsdCk7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGNhbGwgYSBmdW5jdGlvbiBhbmQgc3dhbGxvdyB0aGUgcmVzdWx0XG5leHBvcnQgZnVuY3Rpb24gX2ludm9rZUlnbm9yZWQoYm9keSkge1xuXHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKF9lbXB0eSk7XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBzZW5kIGVycm9ycyB0byByZWNvdmVyeSBjb250aW51YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2goYm9keSwgcmVjb3Zlcikge1xuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHJldHVybiByZWNvdmVyKGUpO1xuXHR9XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4odm9pZCAwLCByZWNvdmVyKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBhd2FpdCBhIHByb21pc2UgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBhIGZpbmFsbHkgY29udGludWF0aW9uXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmFsbHlSZXRocm93cyhib2R5LCBmaW5hbGl6ZXIpIHtcblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZpbmFsaXplcih0cnVlLCBlKTtcblx0fVxuXHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0cmV0dXJuIHJlc3VsdC50aGVuKGZpbmFsaXplci5iaW5kKG51bGwsIGZhbHNlKSwgZmluYWxpemVyLmJpbmQobnVsbCwgdHJ1ZSkpO1xuXHR9XG5cdHJldHVybiBmaW5hbGl6ZXIoZmFsc2UsIHJlc3VsdCk7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGF3YWl0IGEgcHJvbWlzZSBhbmQgaW52b2tlIGEgZmluYWxseSBjb250aW51YXRpb24gdGhhdCBhbHdheXMgb3ZlcnJpZGVzIHRoZSByZXN1bHRcbmV4cG9ydCBmdW5jdGlvbiBfZmluYWxseShib2R5LCBmaW5hbGl6ZXIpIHtcblx0dHJ5IHtcblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZpbmFsaXplcigpO1xuXHR9XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4oZmluYWxpemVyLCBmaW5hbGl6ZXIpO1xuXHR9XG5cdHJldHVybiBmaW5hbGl6ZXIoKTtcbn1cblxuLy8gUmV0aHJvdyBvciByZXR1cm4gYSB2YWx1ZSBmcm9tIGEgZmluYWxseSBjb250aW51YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBfcmV0aHJvdyh0aHJvd24sIHZhbHVlKSB7XG5cdGlmICh0aHJvd24pXG5cdFx0dGhyb3cgdmFsdWU7XG5cdHJldHVybiB2YWx1ZTtcbn1cblxuLy8gRW1wdHkgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJyZWFrIGFuZCBvdGhlciBjb250cm9sIGZsb3cgdGhhdCBpZ25vcmVzIGFzeW5jaHJvbm91cyByZXN1bHRzXG5leHBvcnQgZnVuY3Rpb24gX2VtcHR5KCkge1xufVxuXG4vLyBTZW50aW5lbCB2YWx1ZSBmb3IgZWFybHkgcmV0dXJucyBpbiBnZW5lcmF0b3JzIFxuZXhwb3J0IGNvbnN0IF9lYXJseVJldHVybiA9IC8qI19fUFVSRV9fKi8ge307XG5cbi8vIEFzeW5jaHJvbm91c2x5IGNhbGwgYSBmdW5jdGlvbiBhbmQgc2VuZCBlcnJvcnMgdG8gcmVjb3ZlcnkgY29udGludWF0aW9uLCBza2lwcGluZyBlYXJseSByZXR1cm5zXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoSW5HZW5lcmF0b3IoYm9keSwgcmVjb3Zlcikge1xuXHRyZXR1cm4gX2NhdGNoKGJvZHksIGZ1bmN0aW9uKGUpIHtcblx0XHRpZiAoZSA9PT0gX2Vhcmx5UmV0dXJuKSB7XG5cdFx0XHR0aHJvdyBlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVjb3ZlcihlKTtcblx0fSk7XG59XG5cbi8vIEFzeW5jaHJvbm91cyBnZW5lcmF0b3IgY2xhc3M7IGFjY2VwdHMgdGhlIGVudHJ5cG9pbnQgb2YgdGhlIGdlbmVyYXRvciwgdG8gd2hpY2ggaXQgcGFzc2VzIGl0c2VsZiB3aGVuIHRoZSBnZW5lcmF0b3Igc2hvdWxkIHN0YXJ0XG5leHBvcnQgY29uc3QgX0FzeW5jR2VuZXJhdG9yID0gLyojX19QVVJFX18qLyhmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gX0FzeW5jR2VuZXJhdG9yKGVudHJ5KSB7XG5cdFx0dGhpcy5fZW50cnkgPSBlbnRyeTtcblx0XHR0aGlzLl9wYWN0ID0gbnVsbDtcblx0XHR0aGlzLl9yZXNvbHZlID0gbnVsbDtcblx0XHR0aGlzLl9yZXR1cm4gPSBudWxsO1xuXHRcdHRoaXMuX3Byb21pc2UgPSBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gX3dyYXBSZXR1cm5lZFZhbHVlKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiB0cnVlIH07XG5cdH1cblx0ZnVuY3Rpb24gX3dyYXBZaWVsZGVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IGZhbHNlIH07XG5cdH1cblxuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLl95aWVsZCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gWWllbGQgdGhlIHZhbHVlIHRvIHRoZSBwZW5kaW5nIG5leHQgY2FsbFxuXHRcdHRoaXMuX3Jlc29sdmUodmFsdWUgJiYgdmFsdWUudGhlbiA/IHZhbHVlLnRoZW4oX3dyYXBZaWVsZGVkVmFsdWUpIDogX3dyYXBZaWVsZGVkVmFsdWUodmFsdWUpKTtcblx0XHQvLyBSZXR1cm4gYSBwYWN0IGZvciBhbiB1cGNvbWluZyBuZXh0L3JldHVybi90aHJvdyBjYWxsXG5cdFx0cmV0dXJuIHRoaXMuX3BhY3QgPSBuZXcgX1BhY3QoKTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBBZHZhbmNlIHRoZSBnZW5lcmF0b3IsIHN0YXJ0aW5nIGl0IGlmIGl0IGhhcyB5ZXQgdG8gYmUgc3RhcnRlZFxuXHRcdGNvbnN0IF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdFx0Y29uc3QgX3BhY3QgPSBfdGhpcy5fcGFjdDtcblx0XHRcdGlmIChfcGFjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRjb25zdCBfZW50cnkgPSBfdGhpcy5fZW50cnk7XG5cdFx0XHRcdGlmIChfZW50cnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgc3RhcnRlZCwgYnV0IG5vdCBhd2FpdGluZyBhIHlpZWxkIGV4cHJlc3Npb25cblx0XHRcdFx0XHQvLyBBYmFuZG9uIHRoZSBuZXh0IGNhbGwhXG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmUoX3RoaXMuX3Byb21pc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFN0YXJ0IHRoZSBnZW5lcmF0b3Jcblx0XHRcdFx0X3RoaXMuX2VudHJ5ID0gbnVsbDtcblx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0XHRmdW5jdGlvbiByZXR1cm5WYWx1ZSh2YWx1ZSkge1xuXHRcdFx0XHRcdF90aGlzLl9yZXNvbHZlKHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKF93cmFwUmV0dXJuZWRWYWx1ZSkgOiBfd3JhcFJldHVybmVkVmFsdWUodmFsdWUpKTtcblx0XHRcdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciByZXN1bHQgPSBfZW50cnkoX3RoaXMpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnRoZW4ocmV0dXJuVmFsdWUsIGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXJyb3IgPT09IF9lYXJseVJldHVybikge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5WYWx1ZShfdGhpcy5fcmV0dXJuKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUocGFjdCk7XG5cdFx0XHRcdFx0XHRcdF90aGlzLl9wYWN0ID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRfcmVzb2x2ZShwYWN0LCAyLCBlcnJvcik7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuVmFsdWUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIHN0YXJ0ZWQgYW5kIGEgeWllbGQgZXhwcmVzc2lvbiBpcyBwZW5kaW5nLCBzZXR0bGUgaXRcblx0XHRcdFx0X3RoaXMuX3BhY3QgPSBudWxsO1xuXHRcdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdF9zZXR0bGUoX3BhY3QsIDEsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS5yZXR1cm4gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIEVhcmx5IHJldHVybiBmcm9tIHRoZSBnZW5lcmF0b3IgaWYgc3RhcnRlZCwgb3RoZXJ3aXNlIGFiYW5kb25zIHRoZSBnZW5lcmF0b3Jcblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0XHRcdGNvbnN0IF9wYWN0ID0gX3RoaXMuX3BhY3Q7XG5cdFx0XHRpZiAoX3BhY3QgPT09IG51bGwpIHtcblx0XHRcdFx0aWYgKF90aGlzLl9lbnRyeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIEdlbmVyYXRvciBpcyBzdGFydGVkLCBidXQgbm90IGF3YWl0aW5nIGEgeWllbGQgZXhwcmVzc2lvblxuXHRcdFx0XHRcdC8vIEFiYW5kb24gdGhlIHJldHVybiBjYWxsIVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlKF90aGlzLl9wcm9taXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgbm90IHN0YXJ0ZWQsIGFiYW5kb24gaXQgYW5kIHJldHVybiB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRcdF90aGlzLl9lbnRyeSA9IG51bGw7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlKHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKF93cmFwUmV0dXJuZWRWYWx1ZSkgOiBfd3JhcFJldHVybmVkVmFsdWUodmFsdWUpKTtcblx0XHRcdH1cblx0XHRcdC8vIFNldHRsZSB0aGUgeWllbGQgZXhwcmVzc2lvbiB3aXRoIGEgcmVqZWN0ZWQgXCJlYXJseSByZXR1cm5cIiB2YWx1ZVxuXHRcdFx0X3RoaXMuX3JldHVybiA9IHZhbHVlO1xuXHRcdFx0X3RoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuXHRcdFx0X3RoaXMuX3BhY3QgPSBudWxsO1xuXHRcdFx0X3NldHRsZShfcGFjdCwgMiwgX2Vhcmx5UmV0dXJuKTtcblx0XHR9KTtcblx0fTtcblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0Ly8gSW5qZWN0IGFuIGV4Y2VwdGlvbiBpbnRvIHRoZSBwZW5kaW5nIHlpZWxkIGV4cHJlc3Npb25cblx0XHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdFx0cmV0dXJuIF90aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0Y29uc3QgX3BhY3QgPSBfdGhpcy5fcGFjdDtcblx0XHRcdGlmIChfcGFjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoX3RoaXMuX2VudHJ5ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIHN0YXJ0ZWQsIGJ1dCBub3QgYXdhaXRpbmcgYSB5aWVsZCBleHByZXNzaW9uXG5cdFx0XHRcdFx0Ly8gQWJhbmRvbiB0aGUgdGhyb3cgY2FsbCFcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShfdGhpcy5fcHJvbWlzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIG5vdCBzdGFydGVkLCBhYmFuZG9uIGl0IGFuZCByZXR1cm4gYSByZWplY3RlZCBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIGVycm9yXG5cdFx0XHRcdF90aGlzLl9lbnRyeSA9IG51bGw7XG5cdFx0XHRcdHJldHVybiByZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2V0dGxlIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpdGggdGhlIHZhbHVlIGFzIGEgcmVqZWN0aW9uXG5cdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRfc2V0dGxlKF9wYWN0LCAyLCBlcnJvcik7XG5cdFx0fSk7XG5cdH07XG5cblx0X0FzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtfYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblx0XG5cdHJldHVybiBfQXN5bmNHZW5lcmF0b3I7XG59KSgpO1xuIiwiLy8gQm9ycm93ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWkvbmFub2lkL2Jsb2IvMy4wLjIvbm9uLXNlY3VyZS9pbmRleC5qc1xyXG4vLyBUaGlzIGFscGhhYmV0IHVzZXMgYEEtWmEtejAtOV8tYCBzeW1ib2xzLiBBIGdlbmV0aWMgYWxnb3JpdGhtIGhlbHBlZFxyXG4vLyBvcHRpbWl6ZSB0aGUgZ3ppcCBjb21wcmVzc2lvbiBmb3IgdGhpcyBhbHBoYWJldC5cclxubGV0IHVybEFscGhhYmV0ID1cclxuICAnTW9kdWxlU3ltYmhhc093blByLTAxMjM0NTY3ODlBQkNERUZHSE5SVmZnY3RpVXZ6X0txWVRKa0x4cFpYSWpRVydcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgbGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcclxuICBsZXQgaWQgPSAnJ1xyXG4gIC8vIEEgY29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWAuXHJcbiAgbGV0IGkgPSBzaXplXHJcbiAgd2hpbGUgKGktLSkge1xyXG4gICAgLy8gYHwgMGAgaXMgbW9yZSBjb21wYWN0IGFuZCBmYXN0ZXIgdGhhbiBgTWF0aC5mbG9vcigpYC5cclxuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cclxuICB9XHJcbiAgcmV0dXJuIGlkXHJcbn1cclxuIiwiaW1wb3J0IHsgRGlzcGF0Y2gsIEFueUFjdGlvbiB9IGZyb20gJ3JlZHV4J1xyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZUFjdGlvbixcclxuICBQYXlsb2FkQWN0aW9uLFxyXG4gIEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkXHJcbn0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nXHJcbmltcG9ydCB7IFRodW5rRGlzcGF0Y2ggfSBmcm9tICdyZWR1eC10aHVuaydcclxuaW1wb3J0IHsgRmFsbGJhY2tJZlVua25vd24sIElzQW55IH0gZnJvbSAnLi90c0hlbHBlcnMnXHJcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4vbmFub2lkJ1xyXG5cclxuLy8gQHRzLWlnbm9yZSB3ZSBuZWVkIHRoZSBpbXBvcnQgb2YgdGhlc2UgdHlwZXMgZHVlIHRvIGEgYnVuZGxpbmcgaXNzdWUuXHJcbnR5cGUgX0tlZXAgPSBQYXlsb2FkQWN0aW9uIHwgQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8YW55LCB1bmtub3duPlxyXG5cclxuZXhwb3J0IHR5cGUgQmFzZVRodW5rQVBJPFxyXG4gIFMsXHJcbiAgRSxcclxuICBEIGV4dGVuZHMgRGlzcGF0Y2ggPSBEaXNwYXRjaCxcclxuICBSZWplY3RlZFZhbHVlID0gdW5kZWZpbmVkXHJcbj4gPSB7XHJcbiAgZGlzcGF0Y2g6IERcclxuICBnZXRTdGF0ZTogKCkgPT4gU1xyXG4gIGV4dHJhOiBFXHJcbiAgcmVxdWVzdElkOiBzdHJpbmdcclxuICBzaWduYWw6IEFib3J0U2lnbmFsXHJcbiAgcmVqZWN0V2l0aFZhbHVlKHZhbHVlOiBSZWplY3RlZFZhbHVlKTogUmVqZWN0V2l0aFZhbHVlPFJlamVjdGVkVmFsdWU+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6ZWRFcnJvciB7XHJcbiAgbmFtZT86IHN0cmluZ1xyXG4gIG1lc3NhZ2U/OiBzdHJpbmdcclxuICBzdGFjaz86IHN0cmluZ1xyXG4gIGNvZGU/OiBzdHJpbmdcclxufVxyXG5cclxuY29uc3QgY29tbW9uUHJvcGVydGllczogQXJyYXk8a2V5b2YgU2VyaWFsaXplZEVycm9yPiA9IFtcclxuICAnbmFtZScsXHJcbiAgJ21lc3NhZ2UnLFxyXG4gICdzdGFjaycsXHJcbiAgJ2NvZGUnXHJcbl1cclxuXHJcbmNsYXNzIFJlamVjdFdpdGhWYWx1ZTxSZWplY3RWYWx1ZT4ge1xyXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByZWFkb25seSB2YWx1ZTogUmVqZWN0VmFsdWUpIHt9XHJcbn1cclxuXHJcbi8vIFJld29ya2VkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9zZXJpYWxpemUtZXJyb3JcclxuZXhwb3J0IGNvbnN0IG1pbmlTZXJpYWxpemVFcnJvciA9ICh2YWx1ZTogYW55KTogU2VyaWFsaXplZEVycm9yID0+IHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgY29uc3Qgc2ltcGxlRXJyb3I6IFNlcmlhbGl6ZWRFcnJvciA9IHt9XHJcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIGNvbW1vblByb3BlcnRpZXMpIHtcclxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtwcm9wZXJ0eV0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgc2ltcGxlRXJyb3JbcHJvcGVydHldID0gdmFsdWVbcHJvcGVydHldXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc2ltcGxlRXJyb3JcclxuICB9XHJcblxyXG4gIHJldHVybiB7IG1lc3NhZ2U6IFN0cmluZyh2YWx1ZSkgfVxyXG59XHJcblxyXG50eXBlIEFzeW5jVGh1bmtDb25maWcgPSB7XHJcbiAgc3RhdGU/OiB1bmtub3duXHJcbiAgZGlzcGF0Y2g/OiBEaXNwYXRjaFxyXG4gIGV4dHJhPzogdW5rbm93blxyXG4gIHJlamVjdFZhbHVlPzogdW5rbm93blxyXG59XHJcblxyXG50eXBlIEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xyXG4gIHN0YXRlOiBpbmZlciBTdGF0ZVxyXG59XHJcbiAgPyBTdGF0ZVxyXG4gIDogdW5rbm93blxyXG50eXBlIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgeyBleHRyYTogaW5mZXIgRXh0cmEgfVxyXG4gID8gRXh0cmFcclxuICA6IHVua25vd25cclxudHlwZSBHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4gPSBUaHVua0FwaUNvbmZpZyBleHRlbmRzIHtcclxuICBkaXNwYXRjaDogaW5mZXIgRGlzcGF0Y2hcclxufVxyXG4gID8gRmFsbGJhY2tJZlVua25vd248XHJcbiAgICAgIERpc3BhdGNoLFxyXG4gICAgICBUaHVua0Rpc3BhdGNoPFxyXG4gICAgICAgIEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPixcclxuICAgICAgICBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sXHJcbiAgICAgICAgQW55QWN0aW9uXHJcbiAgICAgID5cclxuICAgID5cclxuICA6IFRodW5rRGlzcGF0Y2g8R2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LCBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sIEFueUFjdGlvbj5cclxuXHJcbnR5cGUgR2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+ID0gQmFzZVRodW5rQVBJPFxyXG4gIEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPixcclxuICBHZXRFeHRyYTxUaHVua0FwaUNvbmZpZz4sXHJcbiAgR2V0RGlzcGF0Y2g8VGh1bmtBcGlDb25maWc+LFxyXG4gIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPlxyXG4+XHJcblxyXG50eXBlIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xyXG4gIHJlamVjdFZhbHVlOiBpbmZlciBSZWplY3RWYWx1ZVxyXG59XHJcbiAgPyBSZWplY3RWYWx1ZVxyXG4gIDogdW5rbm93blxyXG4vKipcclxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYHBheWxvYWRDcmVhdG9yYCBhcmd1bWVudCB0byBgY3JlYXRlQXN5bmNUaHVua2AuXHJcbiAqIE1pZ2h0IGJlIHVzZWZ1bCBmb3Igd3JhcHBpbmcgYGNyZWF0ZUFzeW5jVGh1bmtgIGluIGN1c3RvbSBhYnN0cmFjdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvclJldHVyblZhbHVlPFxyXG4gIFJldHVybmVkLFxyXG4gIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZ1xyXG4+ID1cclxuICB8IFByb21pc2U8UmV0dXJuZWQgfCBSZWplY3RXaXRoVmFsdWU8R2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+Pj5cclxuICB8IFJldHVybmVkXHJcbiAgfCBSZWplY3RXaXRoVmFsdWU8R2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+PlxyXG4vKipcclxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIGBwYXlsb2FkQ3JlYXRvcmAgYXJndW1lbnQgdG8gYGNyZWF0ZUFzeW5jVGh1bmtgLlxyXG4gKiBNaWdodCBiZSB1c2VmdWwgZm9yIHdyYXBwaW5nIGBjcmVhdGVBc3luY1RodW5rYCBpbiBjdXN0b20gYWJzdHJhY3Rpb25zLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcmcgPSB2b2lkLFxyXG4gIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9XHJcbj4gPSAoXHJcbiAgYXJnOiBUaHVua0FyZyxcclxuICB0aHVua0FQSTogR2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+XHJcbikgPT4gQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yUmV0dXJuVmFsdWU8UmV0dXJuZWQsIFRodW5rQXBpQ29uZmlnPlxyXG5cclxuLyoqXHJcbiAqIEEgVGh1bmtBY3Rpb24gY3JlYXRlZCBieSBgY3JlYXRlQXN5bmNUaHVua2AuXHJcbiAqIERpc3BhdGNoaW5nIGl0IHJldHVybnMgYSBQcm9taXNlIGZvciBlaXRoZXIgYVxyXG4gKiBmdWxmaWxsZWQgb3IgcmVqZWN0ZWQgYWN0aW9uLlxyXG4gKiBBbHNvLCB0aGUgcmV0dXJuZWQgdmFsdWUgY29udGFpbnMgYSBgYWJvcnQoKWAgbWV0aG9kXHJcbiAqIHRoYXQgYWxsb3dzIHRoZSBhc3luY0FjdGlvbiB0byBiZSBjYW5jZWxsZWQgZnJvbSB0aGUgb3V0c2lkZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXN5bmNUaHVua0FjdGlvbjxcclxuICBSZXR1cm5lZCxcclxuICBUaHVua0FyZyxcclxuICBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWdcclxuPiA9IChcclxuICBkaXNwYXRjaDogR2V0RGlzcGF0Y2g8VGh1bmtBcGlDb25maWc+LFxyXG4gIGdldFN0YXRlOiAoKSA9PiBHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4sXHJcbiAgZXh0cmE6IEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPlxyXG4pID0+IFByb21pc2U8XHJcbiAgfCBQYXlsb2FkQWN0aW9uPFJldHVybmVkLCBzdHJpbmcsIHsgYXJnOiBUaHVua0FyZzsgcmVxdWVzdElkOiBzdHJpbmcgfT5cclxuICB8IFBheWxvYWRBY3Rpb248XHJcbiAgICAgIHVuZGVmaW5lZCB8IEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPixcclxuICAgICAgc3RyaW5nLFxyXG4gICAgICB7XHJcbiAgICAgICAgYXJnOiBUaHVua0FyZ1xyXG4gICAgICAgIHJlcXVlc3RJZDogc3RyaW5nXHJcbiAgICAgICAgYWJvcnRlZDogYm9vbGVhblxyXG4gICAgICAgIGNvbmRpdGlvbjogYm9vbGVhblxyXG4gICAgICB9LFxyXG4gICAgICBTZXJpYWxpemVkRXJyb3JcclxuICAgID5cclxuPiAmIHtcclxuICBhYm9ydChyZWFzb24/OiBzdHJpbmcpOiB2b2lkXHJcbn1cclxuXHJcbnR5cGUgQXN5bmNUaHVua0FjdGlvbkNyZWF0b3I8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcmcsXHJcbiAgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnXHJcbj4gPSBJc0FueTxcclxuICBUaHVua0FyZyxcclxuICAvLyBhbnkgaGFuZGxpbmdcclxuICAoYXJnOiBUaHVua0FyZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPixcclxuICAvLyB1bmtub3duIGhhbmRsaW5nXHJcbiAgdW5rbm93biBleHRlbmRzIFRodW5rQXJnXHJcbiAgICA/IChhcmc6IFRodW5rQXJnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IC8vIGFyZ3VtZW50IG5vdCBzcGVjaWZpZWQgb3Igc3BlY2lmaWVkIGFzIHZvaWQgb3IgdW5kZWZpbmVkXHJcbiAgICA6IFtUaHVua0FyZ10gZXh0ZW5kcyBbdm9pZF0gfCBbdW5kZWZpbmVkXVxyXG4gICAgPyAoKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IC8vIGFyZ3VtZW50IGNvbnRhaW5zIHZvaWRcclxuICAgIDogW3ZvaWRdIGV4dGVuZHMgW1RodW5rQXJnXSAvLyBtYWtlIG9wdGlvbmFsXHJcbiAgICA/IChhcmc/OiBUaHVua0FyZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiAvLyBhcmd1bWVudCBjb250YWlucyB1bmRlZmluZWRcclxuICAgIDogW3VuZGVmaW5lZF0gZXh0ZW5kcyBbVGh1bmtBcmddXHJcbiAgICA/IFdpdGhTdHJpY3ROdWxsQ2hlY2tzPFxyXG4gICAgICAgIC8vIHdpdGggc3RyaWN0IG51bGxDaGVja3M6IG1ha2Ugb3B0aW9uYWxcclxuICAgICAgICAoXHJcbiAgICAgICAgICBhcmc/OiBUaHVua0FyZ1xyXG4gICAgICAgICkgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPixcclxuICAgICAgICAvLyB3aXRob3V0IHN0cmljdCBudWxsIGNoZWNrcyB0aGlzIHdpbGwgbWF0Y2ggZXZlcnl0aGluZywgc28gZG9uJ3QgbWFrZSBpdCBvcHRpb25hbFxyXG4gICAgICAgIChhcmc6IFRodW5rQXJnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+XHJcbiAgICAgID4gLy8gZGVmYXVsdCBjYXNlOiBub3JtYWwgYXJndW1lbnRcclxuICAgIDogKGFyZzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5cclxuPlxyXG5cclxuaW50ZXJmYWNlIEFzeW5jVGh1bmtPcHRpb25zPFxyXG4gIFRodW5rQXJnID0gdm9pZCxcclxuICBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWcgPSB7fVxyXG4+IHtcclxuICAvKipcclxuICAgKiBBIG1ldGhvZCB0byBjb250cm9sIHdoZXRoZXIgdGhlIGFzeW5jVGh1bmsgc2hvdWxkIGJlIGV4ZWN1dGVkLiBIYXMgYWNjZXNzIHRvIHRoZVxyXG4gICAqIGBhcmdgLCBgYXBpLmdldFN0YXRlKClgIGFuZCBgYXBpLmV4dHJhYCBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBgZmFsc2VgIGlmIGl0IHNob3VsZCBiZSBza2lwcGVkXHJcbiAgICovXHJcbiAgY29uZGl0aW9uPyhcclxuICAgIGFyZzogVGh1bmtBcmcsXHJcbiAgICBhcGk6IFBpY2s8R2V0VGh1bmtBUEk8VGh1bmtBcGlDb25maWc+LCAnZ2V0U3RhdGUnIHwgJ2V4dHJhJz5cclxuICApOiBib29sZWFuIHwgdW5kZWZpbmVkXHJcbiAgLyoqXHJcbiAgICogSWYgYGNvbmRpdGlvbmAgcmV0dXJucyBgZmFsc2VgLCB0aGUgYXN5bmNUaHVuayB3aWxsIGJlIHNraXBwZWQuXHJcbiAgICogVGhpcyBvcHRpb24gYWxsb3dzIHlvdSB0byBjb250cm9sIHdoZXRoZXIgYSBgcmVqZWN0ZWRgIGFjdGlvbiB3aXRoIGBtZXRhLmNvbmRpdGlvbiA9PSBmYWxzZWBcclxuICAgKiB3aWxsIGJlIGRpc3BhdGNoZWQgb3Igbm90LlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgYGZhbHNlYFxyXG4gICAqL1xyXG4gIGRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uPzogYm9vbGVhblxyXG59XHJcblxyXG50eXBlIEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjxcclxuICBUaHVua0FyZ1xyXG4+ID0gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8XHJcbiAgW3N0cmluZywgVGh1bmtBcmddLFxyXG4gIHVuZGVmaW5lZCxcclxuICBzdHJpbmcsXHJcbiAgbmV2ZXIsXHJcbiAge1xyXG4gICAgYXJnOiBUaHVua0FyZ1xyXG4gICAgcmVxdWVzdElkOiBzdHJpbmdcclxuICB9XHJcbj5cclxuXHJcbnR5cGUgQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjxcclxuICBUaHVua0FyZyxcclxuICBUaHVua0FwaUNvbmZpZ1xyXG4+ID0gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8XHJcbiAgW1xyXG4gICAgRXJyb3IgfCBudWxsLFxyXG4gICAgc3RyaW5nLFxyXG4gICAgVGh1bmtBcmcsXHJcbiAgICAoR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+IHwgdW5kZWZpbmVkKT9cclxuICBdLFxyXG4gIEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPiB8IHVuZGVmaW5lZCxcclxuICBzdHJpbmcsXHJcbiAgU2VyaWFsaXplZEVycm9yLFxyXG4gIHtcclxuICAgIGFyZzogVGh1bmtBcmdcclxuICAgIHJlcXVlc3RJZDogc3RyaW5nXHJcbiAgICBhYm9ydGVkOiBib29sZWFuXHJcbiAgICBjb25kaXRpb246IGJvb2xlYW5cclxuICB9XHJcbj5cclxuXHJcbnR5cGUgQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcmdcclxuPiA9IEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFxyXG4gIFtSZXR1cm5lZCwgc3RyaW5nLCBUaHVua0FyZ10sXHJcbiAgUmV0dXJuZWQsXHJcbiAgc3RyaW5nLFxyXG4gIG5ldmVyLFxyXG4gIHtcclxuICAgIGFyZzogVGh1bmtBcmdcclxuICAgIHJlcXVlc3RJZDogc3RyaW5nXHJcbiAgfVxyXG4+XHJcblxyXG4vKipcclxuICogQSB0eXBlIGRlc2NyaWJpbmcgdGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlQXN5bmNUaHVua2AuXHJcbiAqIE1pZ2h0IGJlIHVzZWZ1bCBmb3Igd3JhcHBpbmcgYGNyZWF0ZUFzeW5jVGh1bmtgIGluIGN1c3RvbSBhYnN0cmFjdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIEFzeW5jVGh1bms8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcmcsXHJcbiAgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnXHJcbj4gPSBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiAmIHtcclxuICBwZW5kaW5nOiBBc3luY1RodW5rUGVuZGluZ0FjdGlvbkNyZWF0b3I8VGh1bmtBcmc+XHJcbiAgcmVqZWN0ZWQ6IEFzeW5jVGh1bmtSZWplY3RlZEFjdGlvbkNyZWF0b3I8VGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPlxyXG4gIGZ1bGZpbGxlZDogQXN5bmNUaHVua0Z1bGZpbGxlZEFjdGlvbkNyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnPlxyXG4gIHR5cGVQcmVmaXg6IHN0cmluZ1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIHR5cGVQcmVmaXhcclxuICogQHBhcmFtIHBheWxvYWRDcmVhdG9yXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY1RodW5rPFxyXG4gIFJldHVybmVkLFxyXG4gIFRodW5rQXJnID0gdm9pZCxcclxuICBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWcgPSB7fVxyXG4+KFxyXG4gIHR5cGVQcmVmaXg6IHN0cmluZyxcclxuICBwYXlsb2FkQ3JlYXRvcjogQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+LFxyXG4gIG9wdGlvbnM/OiBBc3luY1RodW5rT3B0aW9uczxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+XHJcbik6IEFzeW5jVGh1bms8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4ge1xyXG4gIHR5cGUgUmVqZWN0ZWRWYWx1ZSA9IEdldFJlamVjdFZhbHVlPFRodW5rQXBpQ29uZmlnPlxyXG5cclxuICBjb25zdCBmdWxmaWxsZWQgPSBjcmVhdGVBY3Rpb24oXHJcbiAgICB0eXBlUHJlZml4ICsgJy9mdWxmaWxsZWQnLFxyXG4gICAgKHJlc3VsdDogUmV0dXJuZWQsIHJlcXVlc3RJZDogc3RyaW5nLCBhcmc6IFRodW5rQXJnKSA9PiB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF5bG9hZDogcmVzdWx0LFxyXG4gICAgICAgIG1ldGE6IHsgYXJnLCByZXF1ZXN0SWQgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgKVxyXG5cclxuICBjb25zdCBwZW5kaW5nID0gY3JlYXRlQWN0aW9uKFxyXG4gICAgdHlwZVByZWZpeCArICcvcGVuZGluZycsXHJcbiAgICAocmVxdWVzdElkOiBzdHJpbmcsIGFyZzogVGh1bmtBcmcpID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXlsb2FkOiB1bmRlZmluZWQsXHJcbiAgICAgICAgbWV0YTogeyBhcmcsIHJlcXVlc3RJZCB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApXHJcblxyXG4gIGNvbnN0IHJlamVjdGVkID0gY3JlYXRlQWN0aW9uKFxyXG4gICAgdHlwZVByZWZpeCArICcvcmVqZWN0ZWQnLFxyXG4gICAgKFxyXG4gICAgICBlcnJvcjogRXJyb3IgfCBudWxsLFxyXG4gICAgICByZXF1ZXN0SWQ6IHN0cmluZyxcclxuICAgICAgYXJnOiBUaHVua0FyZyxcclxuICAgICAgcGF5bG9hZD86IFJlamVjdGVkVmFsdWVcclxuICAgICkgPT4ge1xyXG4gICAgICBjb25zdCBhYm9ydGVkID0gISFlcnJvciAmJiBlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcidcclxuICAgICAgY29uc3QgY29uZGl0aW9uID0gISFlcnJvciAmJiBlcnJvci5uYW1lID09PSAnQ29uZGl0aW9uRXJyb3InXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgcGF5bG9hZCxcclxuICAgICAgICBlcnJvcjogbWluaVNlcmlhbGl6ZUVycm9yKGVycm9yIHx8ICdSZWplY3RlZCcpLFxyXG4gICAgICAgIG1ldGE6IHtcclxuICAgICAgICAgIGFyZyxcclxuICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgIGFib3J0ZWQsXHJcbiAgICAgICAgICBjb25kaXRpb25cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApXHJcblxyXG4gIGxldCBkaXNwbGF5ZWRXYXJuaW5nID0gZmFsc2VcclxuXHJcbiAgY29uc3QgQUMgPVxyXG4gICAgdHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gJ3VuZGVmaW5lZCdcclxuICAgICAgPyBBYm9ydENvbnRyb2xsZXJcclxuICAgICAgOiBjbGFzcyBpbXBsZW1lbnRzIEFib3J0Q29udHJvbGxlciB7XHJcbiAgICAgICAgICBzaWduYWw6IEFib3J0U2lnbmFsID0ge1xyXG4gICAgICAgICAgICBhYm9ydGVkOiBmYWxzZSxcclxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcigpIHt9LFxyXG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbmFib3J0KCkge30sXHJcbiAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYWJvcnQoKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5ZWRXYXJuaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5ZWRXYXJuaW5nID0gdHJ1ZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5pbmZvKFxyXG4gICAgICAgICAgICAgICAgICBgVGhpcyBwbGF0Zm9ybSBkb2VzIG5vdCBpbXBsZW1lbnQgQWJvcnRDb250cm9sbGVyLiBcclxuSWYgeW91IHdhbnQgdG8gdXNlIHRoZSBBYm9ydENvbnRyb2xsZXIgdG8gcmVhY3QgdG8gXFxgYWJvcnRcXGAgZXZlbnRzLCBwbGVhc2UgY29uc2lkZXIgaW1wb3J0aW5nIGEgcG9seWZpbGwgbGlrZSAnYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsL2Rpc3QvYWJvcnRjb250cm9sbGVyLXBvbHlmaWxsLW9ubHknLmBcclxuICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFjdGlvbkNyZWF0b3IoXHJcbiAgICBhcmc6IFRodW5rQXJnXHJcbiAgKTogQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiB7XHJcbiAgICByZXR1cm4gKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmEpID0+IHtcclxuICAgICAgY29uc3QgcmVxdWVzdElkID0gbmFub2lkKClcclxuXHJcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBQygpXHJcbiAgICAgIGxldCBhYm9ydFJlYXNvbjogc3RyaW5nIHwgdW5kZWZpbmVkXHJcblxyXG4gICAgICBjb25zdCBhYm9ydGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlPG5ldmVyPigoXywgcmVqZWN0KSA9PlxyXG4gICAgICAgIGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PlxyXG4gICAgICAgICAgcmVqZWN0KHsgbmFtZTogJ0Fib3J0RXJyb3InLCBtZXNzYWdlOiBhYm9ydFJlYXNvbiB8fCAnQWJvcnRlZCcgfSlcclxuICAgICAgICApXHJcbiAgICAgIClcclxuXHJcbiAgICAgIGxldCBzdGFydGVkID0gZmFsc2VcclxuICAgICAgZnVuY3Rpb24gYWJvcnQocmVhc29uPzogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcclxuICAgICAgICAgIGFib3J0UmVhc29uID0gcmVhc29uXHJcbiAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgcHJvbWlzZSA9IChhc3luYyBmdW5jdGlvbigpIHtcclxuICAgICAgICBsZXQgZmluYWxBY3Rpb246IFJldHVyblR5cGU8dHlwZW9mIGZ1bGZpbGxlZCB8IHR5cGVvZiByZWplY3RlZD5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBvcHRpb25zICYmXHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZGl0aW9uICYmXHJcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZGl0aW9uKGFyZywgeyBnZXRTdGF0ZSwgZXh0cmEgfSkgPT09IGZhbHNlXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcclxuICAgICAgICAgICAgdGhyb3cge1xyXG4gICAgICAgICAgICAgIG5hbWU6ICdDb25kaXRpb25FcnJvcicsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ0Fib3J0ZWQgZHVlIHRvIGNvbmRpdGlvbiBjYWxsYmFjayByZXR1cm5pbmcgZmFsc2UuJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBzdGFydGVkID0gdHJ1ZVxyXG4gICAgICAgICAgZGlzcGF0Y2gocGVuZGluZyhyZXF1ZXN0SWQsIGFyZykpXHJcbiAgICAgICAgICBmaW5hbEFjdGlvbiA9IGF3YWl0IFByb21pc2UucmFjZShbXHJcbiAgICAgICAgICAgIGFib3J0ZWRQcm9taXNlLFxyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoXHJcbiAgICAgICAgICAgICAgcGF5bG9hZENyZWF0b3IoYXJnLCB7XHJcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCxcclxuICAgICAgICAgICAgICAgIGdldFN0YXRlLFxyXG4gICAgICAgICAgICAgICAgZXh0cmEsXHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXHJcbiAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXHJcbiAgICAgICAgICAgICAgICByZWplY3RXaXRoVmFsdWUodmFsdWU6IFJlamVjdGVkVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWplY3RXaXRoVmFsdWUodmFsdWUpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgKS50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlamVjdFdpdGhWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdGVkKG51bGwsIHJlcXVlc3RJZCwgYXJnLCByZXN1bHQudmFsdWUpXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHJldHVybiBmdWxmaWxsZWQocmVzdWx0LCByZXF1ZXN0SWQsIGFyZylcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgIF0pXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgICBmaW5hbEFjdGlvbiA9IHJlamVjdGVkKGVyciwgcmVxdWVzdElkLCBhcmcpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIHRoZSByZXN1bHQgYWN0aW9uIF9hZnRlcl8gdGhlIGNhdGNoLCB0byBhdm9pZCBoYXZpbmcgYW55IGVycm9yc1xyXG4gICAgICAgIC8vIGhlcmUgZ2V0IHN3YWxsb3dlZCBieSB0aGUgdHJ5L2NhdGNoIGJsb2NrLFxyXG4gICAgICAgIC8vIHBlciBodHRwczovL3R3aXR0ZXIuY29tL2Rhbl9hYnJhbW92L3N0YXR1cy83NzA5MTQyMjE2Mzg5NDI3MjBcclxuICAgICAgICAvLyBhbmQgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy90dXRvcmlhbHMvYWR2YW5jZWQtdHV0b3JpYWwjYXN5bmMtZXJyb3ItaGFuZGxpbmctbG9naWMtaW4tdGh1bmtzXHJcblxyXG4gICAgICAgIGNvbnN0IHNraXBEaXNwYXRjaCA9XHJcbiAgICAgICAgICBvcHRpb25zICYmXHJcbiAgICAgICAgICAhb3B0aW9ucy5kaXNwYXRjaENvbmRpdGlvblJlamVjdGlvbiAmJlxyXG4gICAgICAgICAgcmVqZWN0ZWQubWF0Y2goZmluYWxBY3Rpb24pICYmXHJcbiAgICAgICAgICBmaW5hbEFjdGlvbi5tZXRhLmNvbmRpdGlvblxyXG5cclxuICAgICAgICBpZiAoIXNraXBEaXNwYXRjaCkge1xyXG4gICAgICAgICAgZGlzcGF0Y2goZmluYWxBY3Rpb24pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaW5hbEFjdGlvblxyXG4gICAgICB9KSgpXHJcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHByb21pc2UsIHsgYWJvcnQgfSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBPYmplY3QuYXNzaWduKFxyXG4gICAgYWN0aW9uQ3JlYXRvciBhcyBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxcclxuICAgICAgUmV0dXJuZWQsXHJcbiAgICAgIFRodW5rQXJnLFxyXG4gICAgICBUaHVua0FwaUNvbmZpZ1xyXG4gICAgPixcclxuICAgIHtcclxuICAgICAgcGVuZGluZyxcclxuICAgICAgcmVqZWN0ZWQsXHJcbiAgICAgIGZ1bGZpbGxlZCxcclxuICAgICAgdHlwZVByZWZpeFxyXG4gICAgfVxyXG4gIClcclxufVxyXG5cclxudHlwZSBBY3Rpb25UeXBlc1dpdGhPcHRpb25hbEVycm9yQWN0aW9uID1cclxuICB8IHsgZXJyb3I6IGFueSB9XHJcbiAgfCB7IGVycm9yPzogbmV2ZXI7IHBheWxvYWQ6IGFueSB9XHJcbnR5cGUgUGF5bG9hZEZvckFjdGlvblR5cGVzRXhjbHVkaW5nRXJyb3JBY3Rpb25zPFQ+ID0gVCBleHRlbmRzIHsgZXJyb3I6IGFueSB9XHJcbiAgPyBuZXZlclxyXG4gIDogVCBleHRlbmRzIHsgcGF5bG9hZDogaW5mZXIgUCB9XHJcbiAgPyBQXHJcbiAgOiBuZXZlclxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBSZXN1bHQ8UiBleHRlbmRzIEFjdGlvblR5cGVzV2l0aE9wdGlvbmFsRXJyb3JBY3Rpb24+KFxyXG4gIHJldHVybmVkOiBSXHJcbik6IFBheWxvYWRGb3JBY3Rpb25UeXBlc0V4Y2x1ZGluZ0Vycm9yQWN0aW9uczxSPiB7XHJcbiAgaWYgKCdlcnJvcicgaW4gcmV0dXJuZWQpIHtcclxuICAgIHRocm93IHJldHVybmVkLmVycm9yXHJcbiAgfVxyXG4gIHJldHVybiAocmV0dXJuZWQgYXMgYW55KS5wYXlsb2FkXHJcbn1cclxuXHJcbnR5cGUgV2l0aFN0cmljdE51bGxDaGVja3M8VHJ1ZSwgRmFsc2U+ID0gdW5kZWZpbmVkIGV4dGVuZHMgYm9vbGVhblxyXG4gID8gRmFsc2VcclxuICA6IFRydWVcclxuIiwiaW1wb3J0IHsgZW5hYmxlRVM1IH0gZnJvbSAnaW1tZXInXHJcbmV4cG9ydCAqIGZyb20gJ3JlZHV4J1xyXG5leHBvcnQgeyBkZWZhdWx0IGFzIGNyZWF0ZU5leHRTdGF0ZSwgRHJhZnQsIGN1cnJlbnQgfSBmcm9tICdpbW1lcidcclxuZXhwb3J0IHtcclxuICBjcmVhdGVTZWxlY3RvcixcclxuICBTZWxlY3RvcixcclxuICBPdXRwdXRQYXJhbWV0cmljU2VsZWN0b3IsXHJcbiAgT3V0cHV0U2VsZWN0b3IsXHJcbiAgUGFyYW1ldHJpY1NlbGVjdG9yXHJcbn0gZnJvbSAncmVzZWxlY3QnXHJcbmV4cG9ydCB7IFRodW5rQWN0aW9uLCBUaHVua0Rpc3BhdGNoIH0gZnJvbSAncmVkdXgtdGh1bmsnXHJcblxyXG4vLyBXZSBkZWxpYmVyYXRlbHkgZW5hYmxlIEltbWVyJ3MgRVM1IHN1cHBvcnQsIG9uIHRoZSBncm91bmRzIHRoYXRcclxuLy8gd2UgYXNzdW1lIFJUSyB3aWxsIGJlIHVzZWQgd2l0aCBSZWFjdCBOYXRpdmUgYW5kIG90aGVyIFByb3h5LWxlc3NcclxuLy8gZW52aXJvbm1lbnRzLiAgSW4gYWRkaXRpb24sIHRoYXQncyBob3cgSW1tZXIgNCBiZWhhdmVkLCBhbmQgc2luY2VcclxuLy8gd2Ugd2FudCB0byBzaGlwIHRoaXMgaW4gYW4gUlRLIG1pbm9yLCB3ZSBzaG91bGQga2VlcCB0aGUgc2FtZSBiZWhhdmlvci5cclxuZW5hYmxlRVM1KClcclxuXHJcbmV4cG9ydCB7XHJcbiAgLy8ganNcclxuICBjb25maWd1cmVTdG9yZSxcclxuICAvLyB0eXBlc1xyXG4gIENvbmZpZ3VyZUVuaGFuY2Vyc0NhbGxiYWNrLFxyXG4gIENvbmZpZ3VyZVN0b3JlT3B0aW9ucyxcclxuICBFbmhhbmNlZFN0b3JlXHJcbn0gZnJvbSAnLi9jb25maWd1cmVTdG9yZSdcclxuZXhwb3J0IHtcclxuICAvLyBqc1xyXG4gIGNyZWF0ZUFjdGlvbixcclxuICBnZXRUeXBlLFxyXG4gIC8vIHR5cGVzXHJcbiAgUGF5bG9hZEFjdGlvbixcclxuICBQYXlsb2FkQWN0aW9uQ3JlYXRvcixcclxuICBBY3Rpb25DcmVhdG9yV2l0aE5vbkluZmVycmFibGVQYXlsb2FkLFxyXG4gIEFjdGlvbkNyZWF0b3JXaXRoT3B0aW9uYWxQYXlsb2FkLFxyXG4gIEFjdGlvbkNyZWF0b3JXaXRoUGF5bG9hZCxcclxuICBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQsXHJcbiAgQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQsXHJcbiAgUHJlcGFyZUFjdGlvblxyXG59IGZyb20gJy4vY3JlYXRlQWN0aW9uJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgY3JlYXRlUmVkdWNlcixcclxuICAvLyB0eXBlc1xyXG4gIEFjdGlvbnMsXHJcbiAgQ2FzZVJlZHVjZXIsXHJcbiAgQ2FzZVJlZHVjZXJzXHJcbn0gZnJvbSAnLi9jcmVhdGVSZWR1Y2VyJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgY3JlYXRlU2xpY2UsXHJcbiAgLy8gdHlwZXNcclxuICBDcmVhdGVTbGljZU9wdGlvbnMsXHJcbiAgU2xpY2UsXHJcbiAgQ2FzZVJlZHVjZXJBY3Rpb25zLFxyXG4gIFNsaWNlQ2FzZVJlZHVjZXJzLFxyXG4gIFZhbGlkYXRlU2xpY2VDYXNlUmVkdWNlcnMsXHJcbiAgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZSxcclxuICBTbGljZUFjdGlvbkNyZWF0b3JcclxufSBmcm9tICcuL2NyZWF0ZVNsaWNlJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxyXG4gIGlzSW1tdXRhYmxlRGVmYXVsdCxcclxuICAvLyB0eXBlc1xyXG4gIEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnNcclxufSBmcm9tICcuL2ltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSdcclxuZXhwb3J0IHtcclxuICAvLyBqc1xyXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcclxuICBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUsXHJcbiAgaXNQbGFpbixcclxuICAvLyB0eXBlc1xyXG4gIFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnNcclxufSBmcm9tICcuL3NlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSdcclxuZXhwb3J0IHtcclxuICAvLyBqc1xyXG4gIGdldERlZmF1bHRNaWRkbGV3YXJlXHJcbn0gZnJvbSAnLi9nZXREZWZhdWx0TWlkZGxld2FyZSdcclxuZXhwb3J0IHtcclxuICAvLyB0eXBlc1xyXG4gIEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyXHJcbn0gZnJvbSAnLi9tYXBCdWlsZGVycydcclxuZXhwb3J0IHsgTWlkZGxld2FyZUFycmF5IH0gZnJvbSAnLi91dGlscydcclxuXHJcbmV4cG9ydCB7IGNyZWF0ZUVudGl0eUFkYXB0ZXIgfSBmcm9tICcuL2VudGl0aWVzL2NyZWF0ZV9hZGFwdGVyJ1xyXG5leHBvcnQge1xyXG4gIERpY3Rpb25hcnksXHJcbiAgRW50aXR5U3RhdGUsXHJcbiAgRW50aXR5QWRhcHRlcixcclxuICBFbnRpdHlTZWxlY3RvcnMsXHJcbiAgRW50aXR5U3RhdGVBZGFwdGVyLFxyXG4gIEVudGl0eUlkLFxyXG4gIFVwZGF0ZSxcclxuICBJZFNlbGVjdG9yLFxyXG4gIENvbXBhcmVyXHJcbn0gZnJvbSAnLi9lbnRpdGllcy9tb2RlbHMnXHJcblxyXG5leHBvcnQge1xyXG4gIEFzeW5jVGh1bmssXHJcbiAgQXN5bmNUaHVua0FjdGlvbixcclxuICBBc3luY1RodW5rUGF5bG9hZENyZWF0b3JSZXR1cm5WYWx1ZSxcclxuICBBc3luY1RodW5rUGF5bG9hZENyZWF0b3IsXHJcbiAgY3JlYXRlQXN5bmNUaHVuayxcclxuICB1bndyYXBSZXN1bHQsXHJcbiAgU2VyaWFsaXplZEVycm9yXHJcbn0gZnJvbSAnLi9jcmVhdGVBc3luY1RodW5rJ1xyXG5cclxuZXhwb3J0IHsgbmFub2lkIH0gZnJvbSAnLi9uYW5vaWQnXHJcbiIsImV4cG9ydCB2YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuZXhwb3J0IHZhciBhZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIG5vZGUuYWRkRXZlbnRMaXN0ZW5lciA/IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKSA6IG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG59O1xuXG5leHBvcnQgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyID8gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgZ2V0Q29uZmlybWF0aW9uID0gZnVuY3Rpb24gZ2V0Q29uZmlybWF0aW9uKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWFsZXJ0XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXJvdXRlci9pc3N1ZXMvNTg2XG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNIaXN0b3J5ID0gZnVuY3Rpb24gc3VwcG9ydHNIaXN0b3J5KCkge1xuICB2YXIgdWEgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcblxuICBpZiAoKHVhLmluZGV4T2YoJ0FuZHJvaWQgMi4nKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignQW5kcm9pZCA0LjAnKSAhPT0gLTEpICYmIHVhLmluZGV4T2YoJ01vYmlsZSBTYWZhcmknKSAhPT0gLTEgJiYgdWEuaW5kZXhPZignQ2hyb21lJykgPT09IC0xICYmIHVhLmluZGV4T2YoJ1dpbmRvd3MgUGhvbmUnKSA9PT0gLTEpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gd2luZG93Lmhpc3RvcnkgJiYgJ3B1c2hTdGF0ZScgaW4gd2luZG93Lmhpc3Rvcnk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBicm93c2VyIGZpcmVzIHBvcHN0YXRlIG9uIGhhc2ggY2hhbmdlLlxuICogSUUxMCBhbmQgSUUxMSBkbyBub3QuXG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSA9IGZ1bmN0aW9uIHN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKSB7XG4gIHJldHVybiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50JykgPT09IC0xO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cbmV4cG9ydCB2YXIgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBmdW5jdGlvbiBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIHBvcHN0YXRlIGV2ZW50IGlzIGFuIGV4dHJhbmVvdXMgV2ViS2l0IGV2ZW50LlxuICogQWNjb3VudHMgZm9yIHRoZSBmYWN0IHRoYXQgQ2hyb21lIG9uIGlPUyBmaXJlcyByZWFsIHBvcHN0YXRlIGV2ZW50c1xuICogY29udGFpbmluZyB1bmRlZmluZWQgc3RhdGUgd2hlbiBwcmVzc2luZyB0aGUgYmFjayBidXR0b24uXG4gKi9cbmV4cG9ydCB2YXIgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCA9IGZ1bmN0aW9uIGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LnN0YXRlID09PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDcmlPUycpID09PSAtMTtcbn07IiwidmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHJlc29sdmVQYXRobmFtZSBmcm9tICdyZXNvbHZlLXBhdGhuYW1lJztcbmltcG9ydCB2YWx1ZUVxdWFsIGZyb20gJ3ZhbHVlLWVxdWFsJztcbmltcG9ydCB7IHBhcnNlUGF0aCB9IGZyb20gJy4vUGF0aFV0aWxzJztcblxuZXhwb3J0IHZhciBjcmVhdGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgbG9jYXRpb24gPSB2b2lkIDA7XG4gIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBUd28tYXJnIGZvcm06IHB1c2gocGF0aCwgc3RhdGUpXG4gICAgbG9jYXRpb24gPSBwYXJzZVBhdGgocGF0aCk7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBPbmUtYXJnIGZvcm06IHB1c2gobG9jYXRpb24pXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgcGF0aCk7XG5cbiAgICBpZiAobG9jYXRpb24ucGF0aG5hbWUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24ucGF0aG5hbWUgPSAnJztcblxuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5zZWFyY2guY2hhckF0KDApICE9PSAnPycpIGxvY2F0aW9uLnNlYXJjaCA9ICc/JyArIGxvY2F0aW9uLnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uc2VhcmNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKGxvY2F0aW9uLmhhc2gpIHtcbiAgICAgIGlmIChsb2NhdGlvbi5oYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBsb2NhdGlvbi5oYXNoID0gJyMnICsgbG9jYXRpb24uaGFzaDtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZSAhPT0gdW5kZWZpbmVkICYmIGxvY2F0aW9uLnN0YXRlID09PSB1bmRlZmluZWQpIGxvY2F0aW9uLnN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gZGVjb2RlVVJJKGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVVJJRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBVUklFcnJvcignUGF0aG5hbWUgXCInICsgbG9jYXRpb24ucGF0aG5hbWUgKyAnXCIgY291bGQgbm90IGJlIGRlY29kZWQuICcgKyAnVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGFuIGludmFsaWQgcGVyY2VudC1lbmNvZGluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICBpZiAoa2V5KSBsb2NhdGlvbi5rZXkgPSBrZXk7XG5cbiAgaWYgKGN1cnJlbnRMb2NhdGlvbikge1xuICAgIC8vIFJlc29sdmUgaW5jb21wbGV0ZS9yZWxhdGl2ZSBwYXRobmFtZSByZWxhdGl2ZSB0byBjdXJyZW50IGxvY2F0aW9uLlxuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gY3VycmVudExvY2F0aW9uLnBhdGhuYW1lO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gcmVzb2x2ZVBhdGhuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXaGVuIHRoZXJlIGlzIG5vIHByaW9yIGxvY2F0aW9uIGFuZCBwYXRobmFtZSBpcyBlbXB0eSwgc2V0IGl0IHRvIC9cbiAgICBpZiAoIWxvY2F0aW9uLnBhdGhuYW1lKSB7XG4gICAgICBsb2NhdGlvbi5wYXRobmFtZSA9ICcvJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9jYXRpb247XG59O1xuXG5leHBvcnQgdmFyIGxvY2F0aW9uc0FyZUVxdWFsID0gZnVuY3Rpb24gbG9jYXRpb25zQXJlRXF1YWwoYSwgYikge1xuICByZXR1cm4gYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZSAmJiBhLnNlYXJjaCA9PT0gYi5zZWFyY2ggJiYgYS5oYXNoID09PSBiLmhhc2ggJiYgYS5rZXkgPT09IGIua2V5ICYmIHZhbHVlRXF1YWwoYS5zdGF0ZSwgYi5zdGF0ZSk7XG59OyIsImV4cG9ydCB2YXIgYWRkTGVhZGluZ1NsYXNoID0gZnVuY3Rpb24gYWRkTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoIDogJy8nICsgcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcExlYWRpbmdTbGFzaChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nID8gcGF0aC5zdWJzdHIoMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBoYXNCYXNlbmFtZSA9IGZ1bmN0aW9uIGhhc0Jhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyBwcmVmaXggKyAnKFxcXFwvfFxcXFw/fCN8JCknLCAnaScpLnRlc3QocGF0aCk7XG59O1xuXG5leHBvcnQgdmFyIHN0cmlwQmFzZW5hbWUgPSBmdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGgsIHByZWZpeCkge1xuICByZXR1cm4gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSA/IHBhdGguc3Vic3RyKHByZWZpeC5sZW5ndGgpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24gc3RyaXBUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJyA/IHBhdGguc2xpY2UoMCwgLTEpIDogcGF0aDtcbn07XG5cbmV4cG9ydCB2YXIgcGFyc2VQYXRoID0gZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhdGhuYW1lID0gcGF0aCB8fCAnLyc7XG4gIHZhciBzZWFyY2ggPSAnJztcbiAgdmFyIGhhc2ggPSAnJztcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCA9PT0gJz8nID8gJycgOiBzZWFyY2gsXG4gICAgaGFzaDogaGFzaCA9PT0gJyMnID8gJycgOiBoYXNoXG4gIH07XG59O1xuXG5leHBvcnQgdmFyIGNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGxvY2F0aW9uKSB7XG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoLFxuICAgICAgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG5cblxuICB2YXIgcGF0aCA9IHBhdGhuYW1lIHx8ICcvJztcblxuICBpZiAoc2VhcmNoICYmIHNlYXJjaCAhPT0gJz8nKSBwYXRoICs9IHNlYXJjaC5jaGFyQXQoMCkgPT09ICc/JyA/IHNlYXJjaCA6ICc/JyArIHNlYXJjaDtcblxuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGggKz0gaGFzaC5jaGFyQXQoMCkgPT09ICcjJyA/IGhhc2ggOiAnIycgKyBoYXNoO1xuXG4gIHJldHVybiBwYXRoO1xufTsiLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IHsgYWRkTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzSGlzdG9yeSwgc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSwgaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudCB9IGZyb20gJy4vRE9NVXRpbHMnO1xuXG52YXIgUG9wU3RhdGVFdmVudCA9ICdwb3BzdGF0ZSc7XG52YXIgSGFzaENoYW5nZUV2ZW50ID0gJ2hhc2hjaGFuZ2UnO1xuXG52YXIgZ2V0SGlzdG9yeVN0YXRlID0gZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKCkge1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuaGlzdG9yeS5zdGF0ZSB8fCB7fTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDExIHNvbWV0aW1lcyB0aHJvd3Mgd2hlbiBhY2Nlc3Npbmcgd2luZG93Lmhpc3Rvcnkuc3RhdGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1JlYWN0VHJhaW5pbmcvaGlzdG9yeS9wdWxsLzI4OVxuICAgIHJldHVybiB7fTtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGlzdG9yeSBvYmplY3QgdGhhdCB1c2VzIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpbmNsdWRpbmdcbiAqIHB1c2hTdGF0ZSwgcmVwbGFjZVN0YXRlLCBhbmQgdGhlIHBvcHN0YXRlIGV2ZW50LlxuICovXG52YXIgY3JlYXRlQnJvd3Nlckhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhblVzZUhpc3RvcnkgPSBzdXBwb3J0c0hpc3RvcnkoKTtcbiAgdmFyIG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyID0gIXN1cHBvcnRzUG9wU3RhdGVPbkhhc2hDaGFuZ2UoKTtcblxuICB2YXIgX3Byb3BzJGZvcmNlUmVmcmVzaCA9IHByb3BzLmZvcmNlUmVmcmVzaCxcbiAgICAgIGZvcmNlUmVmcmVzaCA9IF9wcm9wcyRmb3JjZVJlZnJlc2ggPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogX3Byb3BzJGZvcmNlUmVmcmVzaCxcbiAgICAgIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cbiAgdmFyIGJhc2VuYW1lID0gcHJvcHMuYmFzZW5hbWUgPyBzdHJpcFRyYWlsaW5nU2xhc2goYWRkTGVhZGluZ1NsYXNoKHByb3BzLmJhc2VuYW1lKSkgOiAnJztcblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbihoaXN0b3J5U3RhdGUpIHtcbiAgICB2YXIgX3JlZiA9IGhpc3RvcnlTdGF0ZSB8fCB7fSxcbiAgICAgICAga2V5ID0gX3JlZi5rZXksXG4gICAgICAgIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICAgIHZhciBfd2luZG93JGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uLFxuICAgICAgICBwYXRobmFtZSA9IF93aW5kb3ckbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHNlYXJjaCA9IF93aW5kb3ckbG9jYXRpb24uc2VhcmNoLFxuICAgICAgICBoYXNoID0gX3dpbmRvdyRsb2NhdGlvbi5oYXNoO1xuXG5cbiAgICB2YXIgcGF0aCA9IHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwga2V5KTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wU3RhdGUgPSBmdW5jdGlvbiBoYW5kbGVQb3BTdGF0ZShldmVudCkge1xuICAgIC8vIElnbm9yZSBleHRyYW5lb3VzIHBvcHN0YXRlIGV2ZW50cyBpbiBXZWJLaXQuXG4gICAgaWYgKGlzRXh0cmFuZW91c1BvcHN0YXRlRXZlbnQoZXZlbnQpKSByZXR1cm47XG5cbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZXZlbnQuc3RhdGUpKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgaGFuZGxlUG9wKGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKSk7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuXG4gIHZhciBoYW5kbGVQb3AgPSBmdW5jdGlvbiBoYW5kbGVQb3AobG9jYXRpb24pIHtcbiAgICBpZiAoZm9yY2VOZXh0UG9wKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSBmYWxzZTtcbiAgICAgIHNldFN0YXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhY3Rpb24gPSAnUE9QJztcblxuICAgICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgICAgaWYgKG9rKSB7XG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldmVydFBvcChsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmV2ZXJ0UG9wID0gZnVuY3Rpb24gcmV2ZXJ0UG9wKGZyb21Mb2NhdGlvbikge1xuICAgIHZhciB0b0xvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgIC8vIFRPRE86IFdlIGNvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyBtb3JlIHJlbGlhYmxlIGJ5XG4gICAgLy8ga2VlcGluZyBhIGxpc3Qgb2Yga2V5cyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBrZXlzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbEtleXMuaW5kZXhPZih0b0xvY2F0aW9uLmtleSk7XG5cbiAgICBpZiAodG9JbmRleCA9PT0gLTEpIHRvSW5kZXggPSAwO1xuXG4gICAgdmFyIGZyb21JbmRleCA9IGFsbEtleXMuaW5kZXhPZihmcm9tTG9jYXRpb24ua2V5KTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKGdldEhpc3RvcnlTdGF0ZSgpKTtcbiAgdmFyIGFsbEtleXMgPSBbaW5pdGlhbExvY2F0aW9uLmtleV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcHVzaCB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGhyZWY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgdmFyIG5leHRLZXlzID0gYWxsS2V5cy5zbGljZSgwLCBwcmV2SW5kZXggPT09IC0xID8gMCA6IHByZXZJbmRleCArIDEpO1xuXG4gICAgICAgICAgbmV4dEtleXMucHVzaChsb2NhdGlvbi5rZXkpO1xuICAgICAgICAgIGFsbEtleXMgPSBuZXh0S2V5cztcblxuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnQnJvd3NlciBoaXN0b3J5IGNhbm5vdCBwdXNoIHN0YXRlIGluIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgSFRNTDUgaGlzdG9yeScpO1xuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgaHJlZiA9IGNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleSxcbiAgICAgICAgICBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuXG5cbiAgICAgIGlmIChjYW5Vc2VIaXN0b3J5KSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZSB9LCBudWxsLCBocmVmKTtcblxuICAgICAgICBpZiAoZm9yY2VSZWZyZXNoKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbEtleXMuaW5kZXhPZihoaXN0b3J5LmxvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsS2V5c1twcmV2SW5kZXhdID0gbG9jYXRpb24ua2V5O1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHJlcGxhY2Ugc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UoaHJlZik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBQb3BTdGF0ZUV2ZW50LCBoYW5kbGVQb3BTdGF0ZSk7XG5cbiAgICAgIGlmIChuZWVkc0hhc2hDaGFuZ2VMaXN0ZW5lcikgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBpc0Jsb2NrZWQgPSBmYWxzZTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciB1bmJsb2NrID0gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG5cbiAgICBpZiAoIWlzQmxvY2tlZCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG4gICAgICBpc0Jsb2NrZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXNCbG9ja2VkKSB7XG4gICAgICAgIGlzQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmJsb2NrKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbGlzdGVuID0gZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgdmFyIHVubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgaGlzdG9yeSA9IHtcbiAgICBsZW5ndGg6IGdsb2JhbEhpc3RvcnkubGVuZ3RoLFxuICAgIGFjdGlvbjogJ1BPUCcsXG4gICAgbG9jYXRpb246IGluaXRpYWxMb2NhdGlvbixcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgYmxvY2s6IGJsb2NrLFxuICAgIGxpc3RlbjogbGlzdGVuXG4gIH07XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCcm93c2VySGlzdG9yeTsiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnaW52YXJpYW50JztcbmltcG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwTGVhZGluZ1NsYXNoLCBzdHJpcFRyYWlsaW5nU2xhc2gsIGhhc0Jhc2VuYW1lLCBzdHJpcEJhc2VuYW1lLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgY2FuVXNlRE9NLCBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyLCBnZXRDb25maXJtYXRpb24sIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoIH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBIYXNoUGF0aENvZGVycyA9IHtcbiAgaGFzaGJhbmc6IHtcbiAgICBlbmNvZGVQYXRoOiBmdW5jdGlvbiBlbmNvZGVQYXRoKHBhdGgpIHtcbiAgICAgIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJyEnID8gcGF0aCA6ICchLycgKyBzdHJpcExlYWRpbmdTbGFzaChwYXRoKTtcbiAgICB9LFxuICAgIGRlY29kZVBhdGg6IGZ1bmN0aW9uIGRlY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG4gICAgfVxuICB9LFxuICBub3NsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogc3RyaXBMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH0sXG4gIHNsYXNoOiB7XG4gICAgZW5jb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoLFxuICAgIGRlY29kZVBhdGg6IGFkZExlYWRpbmdTbGFzaFxuICB9XG59O1xuXG52YXIgZ2V0SGFzaFBhdGggPSBmdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICB2YXIgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB2YXIgaGFzaEluZGV4ID0gaHJlZi5pbmRleE9mKCcjJyk7XG4gIHJldHVybiBoYXNoSW5kZXggPT09IC0xID8gJycgOiBocmVmLnN1YnN0cmluZyhoYXNoSW5kZXggKyAxKTtcbn07XG5cbnZhciBwdXNoSGFzaFBhdGggPSBmdW5jdGlvbiBwdXNoSGFzaFBhdGgocGF0aCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhhc2ggPSBwYXRoO1xufTtcblxudmFyIHJlcGxhY2VIYXNoUGF0aCA9IGZ1bmN0aW9uIHJlcGxhY2VIYXNoUGF0aChwYXRoKSB7XG4gIHZhciBoYXNoSW5kZXggPSB3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKCcjJyk7XG5cbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLmhyZWYuc2xpY2UoMCwgaGFzaEluZGV4ID49IDAgPyBoYXNoSW5kZXggOiAwKSArICcjJyArIHBhdGgpO1xufTtcblxudmFyIGNyZWF0ZUhhc2hIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgaW52YXJpYW50KGNhblVzZURPTSwgJ0hhc2ggaGlzdG9yeSBuZWVkcyBhIERPTScpO1xuXG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG4gIHZhciBjYW5Hb1dpdGhvdXRSZWxvYWQgPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCgpO1xuXG4gIHZhciBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbiA9IF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9PT0gdW5kZWZpbmVkID8gZ2V0Q29uZmlybWF0aW9uIDogX3Byb3BzJGdldFVzZXJDb25maXJtLFxuICAgICAgX3Byb3BzJGhhc2hUeXBlID0gcHJvcHMuaGFzaFR5cGUsXG4gICAgICBoYXNoVHlwZSA9IF9wcm9wcyRoYXNoVHlwZSA9PT0gdW5kZWZpbmVkID8gJ3NsYXNoJyA6IF9wcm9wcyRoYXNoVHlwZTtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBfSGFzaFBhdGhDb2RlcnMkaGFzaFQgPSBIYXNoUGF0aENvZGVyc1toYXNoVHlwZV0sXG4gICAgICBlbmNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmVuY29kZVBhdGgsXG4gICAgICBkZWNvZGVQYXRoID0gX0hhc2hQYXRoQ29kZXJzJGhhc2hULmRlY29kZVBhdGg7XG5cblxuICB2YXIgZ2V0RE9NTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRET01Mb2NhdGlvbigpIHtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVBhdGgoZ2V0SGFzaFBhdGgoKSk7XG5cbiAgICB3YXJuaW5nKCFiYXNlbmFtZSB8fCBoYXNCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSksICdZb3UgYXJlIGF0dGVtcHRpbmcgdG8gdXNlIGEgYmFzZW5hbWUgb24gYSBwYWdlIHdob3NlIFVSTCBwYXRoIGRvZXMgbm90IGJlZ2luICcgKyAnd2l0aCB0aGUgYmFzZW5hbWUuIEV4cGVjdGVkIHBhdGggXCInICsgcGF0aCArICdcIiB0byBiZWdpbiB3aXRoIFwiJyArIGJhc2VuYW1lICsgJ1wiLicpO1xuXG4gICAgaWYgKGJhc2VuYW1lKSBwYXRoID0gc3RyaXBCYXNlbmFtZShwYXRoLCBiYXNlbmFtZSk7XG5cbiAgICByZXR1cm4gY3JlYXRlTG9jYXRpb24ocGF0aCk7XG4gIH07XG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBnbG9iYWxIaXN0b3J5Lmxlbmd0aDtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLm5vdGlmeUxpc3RlbmVycyhoaXN0b3J5LmxvY2F0aW9uLCBoaXN0b3J5LmFjdGlvbik7XG4gIH07XG5cbiAgdmFyIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICB2YXIgaWdub3JlUGF0aCA9IG51bGw7XG5cbiAgdmFyIGhhbmRsZUhhc2hDaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVIYXNoQ2hhbmdlKCkge1xuICAgIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gICAgaWYgKHBhdGggIT09IGVuY29kZWRQYXRoKSB7XG4gICAgICAvLyBFbnN1cmUgd2UgYWx3YXlzIGhhdmUgYSBwcm9wZXJseS1lbmNvZGVkIGhhc2guXG4gICAgICByZXBsYWNlSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBnZXRET01Mb2NhdGlvbigpO1xuICAgICAgdmFyIHByZXZMb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAgIGlmICghZm9yY2VOZXh0UG9wICYmIGxvY2F0aW9uc0FyZUVxdWFsKHByZXZMb2NhdGlvbiwgbG9jYXRpb24pKSByZXR1cm47IC8vIEEgaGFzaGNoYW5nZSBkb2Vzbid0IGFsd2F5cyA9PSBsb2NhdGlvbiBjaGFuZ2UuXG5cbiAgICAgIGlmIChpZ25vcmVQYXRoID09PSBjcmVhdGVQYXRoKGxvY2F0aW9uKSkgcmV0dXJuOyAvLyBJZ25vcmUgdGhpcyBjaGFuZ2U7IHdlIGFscmVhZHkgc2V0U3RhdGUgaW4gcHVzaC9yZXBsYWNlLlxuXG4gICAgICBpZ25vcmVQYXRoID0gbnVsbDtcblxuICAgICAgaGFuZGxlUG9wKGxvY2F0aW9uKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBwYXRocyB3ZSd2ZSBzZWVuIGluIHNlc3Npb25TdG9yYWdlLlxuICAgIC8vIEluc3RlYWQsIHdlIGp1c3QgZGVmYXVsdCB0byAwIGZvciBwYXRocyB3ZSBkb24ndCBrbm93LlxuXG4gICAgdmFyIHRvSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKHRvTG9jYXRpb24pKTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsUGF0aHMubGFzdEluZGV4T2YoY3JlYXRlUGF0aChmcm9tTG9jYXRpb24pKTtcblxuICAgIGlmIChmcm9tSW5kZXggPT09IC0xKSBmcm9tSW5kZXggPSAwO1xuXG4gICAgdmFyIGRlbHRhID0gdG9JbmRleCAtIGZyb21JbmRleDtcblxuICAgIGlmIChkZWx0YSkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gdHJ1ZTtcbiAgICAgIGdvKGRlbHRhKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gRW5zdXJlIHRoZSBoYXNoIGlzIGVuY29kZWQgcHJvcGVybHkgYmVmb3JlIGRvaW5nIGFueXRoaW5nIGVsc2UuXG4gIHZhciBwYXRoID0gZ2V0SGFzaFBhdGgoKTtcbiAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChwYXRoKTtcblxuICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgdmFyIGluaXRpYWxMb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gIHZhciBhbGxQYXRocyA9IFtjcmVhdGVQYXRoKGluaXRpYWxMb2NhdGlvbildO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGZ1bmN0aW9uIGNyZWF0ZUhyZWYobG9jYXRpb24pIHtcbiAgICByZXR1cm4gJyMnICsgZW5jb2RlUGF0aChiYXNlbmFtZSArIGNyZWF0ZVBhdGgobG9jYXRpb24pKTtcbiAgfTtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdIYXNoIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUFVTSCc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgoYmFzZW5hbWUgKyBwYXRoKTtcbiAgICAgIHZhciBoYXNoQ2hhbmdlZCA9IGdldEhhc2hQYXRoKCkgIT09IGVuY29kZWRQYXRoO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IHRlbGwgaWYgYSBoYXNoY2hhbmdlIHdhcyBjYXVzZWQgYnkgYSBQVVNILCBzbyB3ZSdkXG4gICAgICAgIC8vIHJhdGhlciBzZXRTdGF0ZSBoZXJlIGFuZCBpZ25vcmUgdGhlIGhhc2hjaGFuZ2UuIFRoZSBjYXZlYXQgaGVyZVxuICAgICAgICAvLyBpcyB0aGF0IG90aGVyIGhhc2ggaGlzdG9yaWVzIGluIHRoZSBwYWdlIHdpbGwgY29uc2lkZXIgaXQgYSBQT1AuXG4gICAgICAgIGlnbm9yZVBhdGggPSBwYXRoO1xuICAgICAgICBwdXNoSGFzaFBhdGgoZW5jb2RlZFBhdGgpO1xuXG4gICAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGhpc3RvcnkubG9jYXRpb24pKTtcbiAgICAgICAgdmFyIG5leHRQYXRocyA9IGFsbFBhdGhzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgbmV4dFBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgIGFsbFBhdGhzID0gbmV4dFBhdGhzO1xuXG4gICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdIYXNoIGhpc3RvcnkgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aDsgYSBuZXcgZW50cnkgd2lsbCBub3QgYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2snKTtcblxuICAgICAgICBzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdSRVBMQUNFJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFJFUExBQ0UsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2SW5kZXggPSBhbGxQYXRocy5pbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuXG4gICAgICBpZiAocHJldkluZGV4ICE9PSAtMSkgYWxsUGF0aHNbcHJldkluZGV4XSA9IHBhdGg7XG5cbiAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgd2FybmluZyhjYW5Hb1dpdGhvdXRSZWxvYWQsICdIYXNoIGhpc3RvcnkgZ28obikgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZCBpbiB0aGlzIGJyb3dzZXInKTtcblxuICAgIGdsb2JhbEhpc3RvcnkuZ28obik7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMDtcblxuICB2YXIgY2hlY2tET01MaXN0ZW5lcnMgPSBmdW5jdGlvbiBjaGVja0RPTUxpc3RlbmVycyhkZWx0YSkge1xuICAgIGxpc3RlbmVyQ291bnQgKz0gZGVsdGE7XG5cbiAgICBpZiAobGlzdGVuZXJDb3VudCA9PT0gMSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcih3aW5kb3csIEhhc2hDaGFuZ2VFdmVudCwgaGFuZGxlSGFzaENoYW5nZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lckNvdW50ID09PSAwKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUhhc2hIaXN0b3J5OyIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgeyBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24gfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuaW1wb3J0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIGZyb20gJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInO1xuXG52YXIgY2xhbXAgPSBmdW5jdGlvbiBjbGFtcChuLCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChuLCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHN0b3JlcyBsb2NhdGlvbnMgaW4gbWVtb3J5LlxuICovXG52YXIgY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZU1lbW9yeUhpc3RvcnkoKSB7XG4gIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBnZXRVc2VyQ29uZmlybWF0aW9uID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIF9wcm9wcyRpbml0aWFsRW50cmllcyA9IHByb3BzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfcHJvcHMkaW5pdGlhbEVudHJpZXMgPT09IHVuZGVmaW5lZCA/IFsnLyddIDogX3Byb3BzJGluaXRpYWxFbnRyaWVzLFxuICAgICAgX3Byb3BzJGluaXRpYWxJbmRleCA9IHByb3BzLmluaXRpYWxJbmRleCxcbiAgICAgIGluaXRpYWxJbmRleCA9IF9wcm9wcyRpbml0aWFsSW5kZXggPT09IHVuZGVmaW5lZCA/IDAgOiBfcHJvcHMkaW5pdGlhbEluZGV4LFxuICAgICAgX3Byb3BzJGtleUxlbmd0aCA9IHByb3BzLmtleUxlbmd0aCxcbiAgICAgIGtleUxlbmd0aCA9IF9wcm9wcyRrZXlMZW5ndGggPT09IHVuZGVmaW5lZCA/IDYgOiBfcHJvcHMka2V5TGVuZ3RoO1xuXG5cbiAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKTtcblxuICB2YXIgc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZShuZXh0U3RhdGUpIHtcbiAgICBfZXh0ZW5kcyhoaXN0b3J5LCBuZXh0U3RhdGUpO1xuXG4gICAgaGlzdG9yeS5sZW5ndGggPSBoaXN0b3J5LmVudHJpZXMubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlS2V5ID0gZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwga2V5TGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgaW5kZXggPSBjbGFtcChpbml0aWFsSW5kZXgsIDAsIGluaXRpYWxFbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgZW50cmllcyA9IGluaXRpYWxFbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyA/IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGNyZWF0ZUtleSgpKSA6IGNyZWF0ZUxvY2F0aW9uKGVudHJ5LCB1bmRlZmluZWQsIGVudHJ5LmtleSB8fCBjcmVhdGVLZXkoKSk7XG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBpbnRlcmZhY2VcblxuICB2YXIgY3JlYXRlSHJlZiA9IGNyZWF0ZVBhdGg7XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIHByZXZJbmRleCA9IGhpc3RvcnkuaW5kZXg7XG4gICAgICB2YXIgbmV4dEluZGV4ID0gcHJldkluZGV4ICsgMTtcblxuICAgICAgdmFyIG5leHRFbnRyaWVzID0gaGlzdG9yeS5lbnRyaWVzLnNsaWNlKDApO1xuICAgICAgaWYgKG5leHRFbnRyaWVzLmxlbmd0aCA+IG5leHRJbmRleCkge1xuICAgICAgICBuZXh0RW50cmllcy5zcGxpY2UobmV4dEluZGV4LCBuZXh0RW50cmllcy5sZW5ndGggLSBuZXh0SW5kZXgsIGxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGluZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGVudHJpZXM6IG5leHRFbnRyaWVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgcmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHJlcGxhY2Ugd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICBoaXN0b3J5LmVudHJpZXNbaGlzdG9yeS5pbmRleF0gPSBsb2NhdGlvbjtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gY2xhbXAoaGlzdG9yeS5pbmRleCArIG4sIDAsIGhpc3RvcnkuZW50cmllcy5sZW5ndGggLSAxKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUE9QJztcbiAgICB2YXIgbG9jYXRpb24gPSBoaXN0b3J5LmVudHJpZXNbbmV4dEluZGV4XTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAob2spIHtcbiAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBpbmRleDogbmV4dEluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTWltaWMgdGhlIGJlaGF2aW9yIG9mIERPTSBoaXN0b3JpZXMgYnlcbiAgICAgICAgLy8gY2F1c2luZyBhIHJlbmRlciBhZnRlciBhIGNhbmNlbGxlZCBQT1AuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvQmFjayA9IGZ1bmN0aW9uIGdvQmFjaygpIHtcbiAgICByZXR1cm4gZ28oLTEpO1xuICB9O1xuXG4gIHZhciBnb0ZvcndhcmQgPSBmdW5jdGlvbiBnb0ZvcndhcmQoKSB7XG4gICAgcmV0dXJuIGdvKDEpO1xuICB9O1xuXG4gIHZhciBjYW5HbyA9IGZ1bmN0aW9uIGNhbkdvKG4pIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gaGlzdG9yeS5pbmRleCArIG47XG4gICAgcmV0dXJuIG5leHRJbmRleCA+PSAwICYmIG5leHRJbmRleCA8IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG4gIH07XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuYXBwZW5kTGlzdGVuZXIobGlzdGVuZXIpO1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZW50cmllcy5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogZW50cmllc1tpbmRleF0sXG4gICAgaW5kZXg6IGluZGV4LFxuICAgIGVudHJpZXM6IGVudHJpZXMsXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGNhbkdvOiBjYW5HbyxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7IiwiaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5cbnZhciBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCkge1xuICB2YXIgcHJvbXB0ID0gbnVsbDtcblxuICB2YXIgc2V0UHJvbXB0ID0gZnVuY3Rpb24gc2V0UHJvbXB0KG5leHRQcm9tcHQpIHtcbiAgICB3YXJuaW5nKHByb21wdCA9PSBudWxsLCAnQSBoaXN0b3J5IHN1cHBvcnRzIG9ubHkgb25lIHByb21wdCBhdCBhIHRpbWUnKTtcblxuICAgIHByb21wdCA9IG5leHRQcm9tcHQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb21wdCA9PT0gbmV4dFByb21wdCkgcHJvbXB0ID0gbnVsbDtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBjb25maXJtVHJhbnNpdGlvblRvID0gZnVuY3Rpb24gY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBjYWxsYmFjaykge1xuICAgIC8vIFRPRE86IElmIGFub3RoZXIgdHJhbnNpdGlvbiBzdGFydHMgd2hpbGUgd2UncmUgc3RpbGwgY29uZmlybWluZ1xuICAgIC8vIHRoZSBwcmV2aW91cyBvbmUsIHdlIG1heSBlbmQgdXAgaW4gYSB3ZWlyZCBzdGF0ZS4gRmlndXJlIG91dCB0aGVcbiAgICAvLyBiZXN0IHdheSB0byBoYW5kbGUgdGhpcy5cbiAgICBpZiAocHJvbXB0ICE9IG51bGwpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0eXBlb2YgcHJvbXB0ID09PSAnZnVuY3Rpb24nID8gcHJvbXB0KGxvY2F0aW9uLCBhY3Rpb24pIDogcHJvbXB0O1xuXG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXRVc2VyQ29uZmlybWF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZ2V0VXNlckNvbmZpcm1hdGlvbihyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQSBoaXN0b3J5IG5lZWRzIGEgZ2V0VXNlckNvbmZpcm1hdGlvbiBmdW5jdGlvbiBpbiBvcmRlciB0byB1c2UgYSBwcm9tcHQgbWVzc2FnZScpO1xuXG4gICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBmYWxzZSBmcm9tIGEgdHJhbnNpdGlvbiBob29rIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbi5cbiAgICAgICAgY2FsbGJhY2socmVzdWx0ICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgdmFyIGFwcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gYXBwZW5kTGlzdGVuZXIoZm4pIHtcbiAgICB2YXIgaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICBpZiAoaXNBY3RpdmUpIGZuLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlzQWN0aXZlID0gZmFsc2U7XG4gICAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIG5vdGlmeUxpc3RlbmVycyA9IGZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycygpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgc2V0UHJvbXB0OiBzZXRQcm9tcHQsXG4gICAgY29uZmlybVRyYW5zaXRpb25UbzogY29uZmlybVRyYW5zaXRpb25UbyxcbiAgICBhcHBlbmRMaXN0ZW5lcjogYXBwZW5kTGlzdGVuZXIsXG4gICAgbm90aWZ5TGlzdGVuZXJzOiBub3RpZnlMaXN0ZW5lcnNcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyOyIsImltcG9ydCBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgZnJvbSAnLi9jcmVhdGVCcm93c2VySGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlQnJvd3Nlckhpc3RvcnkgYXMgY3JlYXRlQnJvd3Nlckhpc3RvcnkgfTtcbmltcG9ydCBfY3JlYXRlSGFzaEhpc3RvcnkgZnJvbSAnLi9jcmVhdGVIYXNoSGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlSGFzaEhpc3RvcnkgYXMgY3JlYXRlSGFzaEhpc3RvcnkgfTtcbmltcG9ydCBfY3JlYXRlTWVtb3J5SGlzdG9yeSBmcm9tICcuL2NyZWF0ZU1lbW9yeUhpc3RvcnknO1xuZXhwb3J0IHsgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgYXMgY3JlYXRlTWVtb3J5SGlzdG9yeSB9O1xuXG5leHBvcnQgeyBjcmVhdGVMb2NhdGlvbiwgbG9jYXRpb25zQXJlRXF1YWwgfSBmcm9tICcuL0xvY2F0aW9uVXRpbHMnO1xuZXhwb3J0IHsgcGFyc2VQYXRoLCBjcmVhdGVQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4vKipcbiAqIENvcHlyaWdodCAyMDE1LCBZYWhvbyEgSW5jLlxuICogQ29weXJpZ2h0cyBsaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBMaWNlbnNlLiBTZWUgdGhlIGFjY29tcGFueWluZyBMSUNFTlNFIGZpbGUgZm9yIHRlcm1zLlxuICovXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgY2hpbGRDb250ZXh0VHlwZXM6IHRydWUsXG4gIGNvbnRleHRUeXBlOiB0cnVlLFxuICBjb250ZXh0VHlwZXM6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM6IHRydWUsXG4gIG1peGluczogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIEtOT1dOX1NUQVRJQ1MgPSB7XG4gIG5hbWU6IHRydWUsXG4gIGxlbmd0aDogdHJ1ZSxcbiAgcHJvdG90eXBlOiB0cnVlLFxuICBjYWxsZXI6IHRydWUsXG4gIGNhbGxlZTogdHJ1ZSxcbiAgYXJndW1lbnRzOiB0cnVlLFxuICBhcml0eTogdHJ1ZVxufTtcbnZhciBGT1JXQVJEX1JFRl9TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICByZW5kZXI6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZVxufTtcbnZhciBNRU1PX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIGNvbXBhcmU6IHRydWUsXG4gIGRlZmF1bHRQcm9wczogdHJ1ZSxcbiAgZGlzcGxheU5hbWU6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBUWVBFX1NUQVRJQ1MgPSB7fTtcblRZUEVfU1RBVElDU1tyZWFjdElzLkZvcndhcmRSZWZdID0gRk9SV0FSRF9SRUZfU1RBVElDUztcblRZUEVfU1RBVElDU1tyZWFjdElzLk1lbW9dID0gTUVNT19TVEFUSUNTO1xuXG5mdW5jdGlvbiBnZXRTdGF0aWNzKGNvbXBvbmVudCkge1xuICAvLyBSZWFjdCB2MTYuMTEgYW5kIGJlbG93XG4gIGlmIChyZWFjdElzLmlzTWVtbyhjb21wb25lbnQpKSB7XG4gICAgcmV0dXJuIE1FTU9fU1RBVElDUztcbiAgfSAvLyBSZWFjdCB2MTYuMTIgYW5kIGFib3ZlXG5cblxuICByZXR1cm4gVFlQRV9TVEFUSUNTW2NvbXBvbmVudFsnJCR0eXBlb2YnXV0gfHwgUkVBQ1RfU1RBVElDUztcbn1cblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbmZ1bmN0aW9uIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgc291cmNlQ29tcG9uZW50LCBibGFja2xpc3QpIHtcbiAgaWYgKHR5cGVvZiBzb3VyY2VDb21wb25lbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgLy8gZG9uJ3QgaG9pc3Qgb3ZlciBzdHJpbmcgKGh0bWwpIGNvbXBvbmVudHNcbiAgICBpZiAob2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICB2YXIgaW5oZXJpdGVkQ29tcG9uZW50ID0gZ2V0UHJvdG90eXBlT2Yoc291cmNlQ29tcG9uZW50KTtcblxuICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIGluaGVyaXRlZENvbXBvbmVudCwgYmxhY2tsaXN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoc291cmNlQ29tcG9uZW50KTtcblxuICAgIGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlQ29tcG9uZW50KSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldFN0YXRpY3MgPSBnZXRTdGF0aWNzKHRhcmdldENvbXBvbmVudCk7XG4gICAgdmFyIHNvdXJjZVN0YXRpY3MgPSBnZXRTdGF0aWNzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIUtOT1dOX1NUQVRJQ1Nba2V5XSAmJiAhKGJsYWNrbGlzdCAmJiBibGFja2xpc3Rba2V5XSkgJiYgIShzb3VyY2VTdGF0aWNzICYmIHNvdXJjZVN0YXRpY3Nba2V5XSkgJiYgISh0YXJnZXRTdGF0aWNzICYmIHRhcmdldFN0YXRpY3Nba2V5XSkpIHtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlQ29tcG9uZW50LCBrZXkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRhcmdldENvbXBvbmVudCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0Q29tcG9uZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhvaXN0Tm9uUmVhY3RTdGF0aWNzO1xuIiwiY29uc3QgZXJyb3JzID0ge1xuXHQwOiBcIklsbGVnYWwgc3RhdGVcIixcblx0MTogXCJJbW1lciBkcmFmdHMgY2Fubm90IGhhdmUgY29tcHV0ZWQgcHJvcGVydGllc1wiLFxuXHQyOiBcIlRoaXMgb2JqZWN0IGhhcyBiZWVuIGZyb3plbiBhbmQgc2hvdWxkIG5vdCBiZSBtdXRhdGVkXCIsXG5cdDMoZGF0YTogYW55KSB7XG5cdFx0cmV0dXJuIChcblx0XHRcdFwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIiArXG5cdFx0XHRkYXRhXG5cdFx0KVxuXHR9LFxuXHQ0OiBcIkFuIGltbWVyIHByb2R1Y2VyIHJldHVybmVkIGEgbmV3IHZhbHVlICphbmQqIG1vZGlmaWVkIGl0cyBkcmFmdC4gRWl0aGVyIHJldHVybiBhIG5ldyB2YWx1ZSAqb3IqIG1vZGlmeSB0aGUgZHJhZnQuXCIsXG5cdDU6IFwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsXG5cdDY6IFwiVGhlIGZpcnN0IG9yIHNlY29uZCBhcmd1bWVudCB0byBgcHJvZHVjZWAgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsXG5cdDc6IFwiVGhlIHRoaXJkIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgdW5kZWZpbmVkXCIsXG5cdDg6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLFxuXHQ5OiBcIkZpcnN0IGFyZ3VtZW50IHRvIGBmaW5pc2hEcmFmdGAgbXVzdCBiZSBhIGRyYWZ0IHJldHVybmVkIGJ5IGBjcmVhdGVEcmFmdGBcIixcblx0MTA6IFwiVGhlIGdpdmVuIGRyYWZ0IGlzIGFscmVhZHkgZmluYWxpemVkXCIsXG5cdDExOiBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG5cdDEyOiBcIk9iamVjdC5zZXRQcm90b3R5cGVPZigpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsXG5cdDEzOiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgZGVsZXRpbmcgYXJyYXkgaW5kaWNlc1wiLFxuXHQxNDogXCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsXG5cdDE1KHBhdGg6IHN0cmluZykge1xuXHRcdHJldHVybiBcIkNhbm5vdCBhcHBseSBwYXRjaCwgcGF0aCBkb2Vzbid0IHJlc29sdmU6IFwiICsgcGF0aFxuXHR9LFxuXHQxNjogJ1NldHMgY2Fubm90IGhhdmUgXCJyZXBsYWNlXCIgcGF0Y2hlcy4nLFxuXHQxNyhvcDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIFwiVW5zdXBwb3J0ZWQgcGF0Y2ggb3BlcmF0aW9uOiBcIiArIG9wXG5cdH0sXG5cdDE4KHBsdWdpbjogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGBUaGUgcGx1Z2luIGZvciAnJHtwbHVnaW59JyBoYXMgbm90IGJlZW4gbG9hZGVkIGludG8gSW1tZXIuIFRvIGVuYWJsZSB0aGUgcGx1Z2luLCBpbXBvcnQgYW5kIGNhbGwgXFxgZW5hYmxlJHtwbHVnaW59KClcXGAgd2hlbiBpbml0aWFsaXppbmcgeW91ciBhcHBsaWNhdGlvbi5gXG5cdH0sXG5cdDE5OiBcInBsdWdpbiBub3QgbG9hZGVkXCIsXG5cdDIwOiBcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIixcblx0MjEodGhpbmc6IHN0cmluZykge1xuXHRcdHJldHVybiBgcHJvZHVjZSBjYW4gb25seSBiZSBjYWxsZWQgb24gdGhpbmdzIHRoYXQgYXJlIGRyYWZ0YWJsZTogcGxhaW4gb2JqZWN0cywgYXJyYXlzLCBNYXAsIFNldCBvciBjbGFzc2VzIHRoYXQgYXJlIG1hcmtlZCB3aXRoICdbaW1tZXJhYmxlXTogdHJ1ZScuIEdvdCAnJHt0aGluZ30nYFxuXHR9LFxuXHQyMih0aGluZzogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGAnY3VycmVudCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHR9LFxuXHQyMyh0aGluZzogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGAnb3JpZ2luYWwnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiAke3RoaW5nfWBcblx0fVxufSBhcyBjb25zdFxuXG5leHBvcnQgZnVuY3Rpb24gZGllKGVycm9yOiBrZXlvZiB0eXBlb2YgZXJyb3JzLCAuLi5hcmdzOiBhbnlbXSk6IG5ldmVyIHtcblx0aWYgKF9fREVWX18pIHtcblx0XHRjb25zdCBlID0gZXJyb3JzW2Vycm9yXVxuXHRcdGNvbnN0IG1zZyA9ICFlXG5cdFx0XHQ/IFwidW5rbm93biBlcnJvciBucjogXCIgKyBlcnJvclxuXHRcdFx0OiB0eXBlb2YgZSA9PT0gXCJmdW5jdGlvblwiXG5cdFx0XHQ/IGUuYXBwbHkobnVsbCwgYXJncyBhcyBhbnkpXG5cdFx0XHQ6IGVcblx0XHR0aHJvdyBuZXcgRXJyb3IoYFtJbW1lcl0gJHttc2d9YClcblx0fVxuXHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0YFtJbW1lcl0gbWluaWZpZWQgZXJyb3IgbnI6ICR7ZXJyb3J9JHtcblx0XHRcdGFyZ3MubGVuZ3RoID8gXCIgXCIgKyBhcmdzLmpvaW4oXCIsXCIpIDogXCJcIlxuXHRcdH0uIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZgXG5cdClcbn1cbiIsImltcG9ydCB7XG5cdERSQUZUX1NUQVRFLFxuXHREUkFGVEFCTEUsXG5cdGhhc1NldCxcblx0T2JqZWN0aXNoLFxuXHREcmFmdGVkLFxuXHRBbnlPYmplY3QsXG5cdEFueU1hcCxcblx0QW55U2V0LFxuXHRJbW1lclN0YXRlLFxuXHRoYXNNYXAsXG5cdEFyY2h0eXBlT2JqZWN0LFxuXHRBcmNodHlwZUFycmF5LFxuXHRBcmNodHlwZU1hcCxcblx0QXJjaHR5cGVTZXQsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBJbW1lciBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnQodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiAhIXZhbHVlW0RSQUZUX1NUQVRFXVxufVxuXG4vKiogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgZHJhZnRlZCBieSBJbW1lciAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRHJhZnRhYmxlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKCF2YWx1ZSkgcmV0dXJuIGZhbHNlXG5cdHJldHVybiAoXG5cdFx0aXNQbGFpbk9iamVjdCh2YWx1ZSkgfHxcblx0XHRBcnJheS5pc0FycmF5KHZhbHVlKSB8fFxuXHRcdCEhdmFsdWVbRFJBRlRBQkxFXSB8fFxuXHRcdCEhdmFsdWUuY29uc3RydWN0b3JbRFJBRlRBQkxFXSB8fFxuXHRcdGlzTWFwKHZhbHVlKSB8fFxuXHRcdGlzU2V0KHZhbHVlKVxuXHQpXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZVxuXHRjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSlcblx0cmV0dXJuICFwcm90byB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZVxufVxuXG4vKiogR2V0IHRoZSB1bmRlcmx5aW5nIG9iamVjdCB0aGF0IGlzIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiBkcmFmdCAqL1xuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsPFQ+KHZhbHVlOiBUKTogVCB8IHVuZGVmaW5lZFxuZXhwb3J0IGZ1bmN0aW9uIG9yaWdpbmFsKHZhbHVlOiBEcmFmdGVkPGFueT4pOiBhbnkge1xuXHRpZiAoIWlzRHJhZnQodmFsdWUpKSBkaWUoMjMsIHZhbHVlKVxuXHRyZXR1cm4gdmFsdWVbRFJBRlRfU1RBVEVdLmJhc2VfXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBjb25zdCBvd25LZXlzOiAodGFyZ2V0OiBBbnlPYmplY3QpID0+IFByb3BlcnR5S2V5W10gPVxuXHR0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0Lm93bktleXNcblx0XHQ/IFJlZmxlY3Qub3duS2V5c1xuXHRcdDogdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgIT09IFwidW5kZWZpbmVkXCJcblx0XHQ/IG9iaiA9PlxuXHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmNvbmNhdChcblx0XHRcdFx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iaikgYXMgYW55XG5cdFx0XHRcdClcblx0XHQ6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG5cbmV4cG9ydCBjb25zdCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID1cblx0T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcblx0ZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0YXJnZXQ6IGFueSkge1xuXHRcdC8vIFBvbHlmaWxsIG5lZWRlZCBmb3IgSGVybWVzIGFuZCBJRSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9oZXJtZXMvaXNzdWVzLzI3NFxuXHRcdGNvbnN0IHJlczogYW55ID0ge31cblx0XHRvd25LZXlzKHRhcmdldCkuZm9yRWFjaChrZXkgPT4ge1xuXHRcdFx0cmVzW2tleV0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJlc1xuXHR9XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoPFQgZXh0ZW5kcyBPYmplY3Rpc2g+KFxuXHRvYmo6IFQsXG5cdGl0ZXI6IChrZXk6IHN0cmluZyB8IG51bWJlciwgdmFsdWU6IGFueSwgc291cmNlOiBUKSA9PiB2b2lkLFxuXHRlbnVtZXJhYmxlT25seT86IGJvb2xlYW5cbik6IHZvaWRcbmV4cG9ydCBmdW5jdGlvbiBlYWNoKG9iajogYW55LCBpdGVyOiBhbnksIGVudW1lcmFibGVPbmx5ID0gZmFsc2UpIHtcblx0aWYgKGdldEFyY2h0eXBlKG9iaikgPT09IEFyY2h0eXBlT2JqZWN0KSB7XG5cdFx0OyhlbnVtZXJhYmxlT25seSA/IE9iamVjdC5rZXlzIDogb3duS2V5cykob2JqKS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRpZiAoIWVudW1lcmFibGVPbmx5IHx8IHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIpIGl0ZXIoa2V5LCBvYmpba2V5XSwgb2JqKVxuXHRcdH0pXG5cdH0gZWxzZSB7XG5cdFx0b2JqLmZvckVhY2goKGVudHJ5OiBhbnksIGluZGV4OiBhbnkpID0+IGl0ZXIoaW5kZXgsIGVudHJ5LCBvYmopKVxuXHR9XG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBcmNodHlwZSh0aGluZzogYW55KTogMCB8IDEgfCAyIHwgMyB7XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdGNvbnN0IHN0YXRlOiB1bmRlZmluZWQgfCBJbW1lclN0YXRlID0gdGhpbmdbRFJBRlRfU1RBVEVdXG5cdHJldHVybiBzdGF0ZVxuXHRcdD8gc3RhdGUudHlwZV8gPiAzXG5cdFx0XHQ/IHN0YXRlLnR5cGVfIC0gNCAvLyBjYXVzZSBPYmplY3QgYW5kIEFycmF5IG1hcCBiYWNrIGZyb20gNCBhbmQgNVxuXHRcdFx0OiAoc3RhdGUudHlwZV8gYXMgYW55KSAvLyBvdGhlcnMgYXJlIHRoZSBzYW1lXG5cdFx0OiBBcnJheS5pc0FycmF5KHRoaW5nKVxuXHRcdD8gQXJjaHR5cGVBcnJheVxuXHRcdDogaXNNYXAodGhpbmcpXG5cdFx0PyBBcmNodHlwZU1hcFxuXHRcdDogaXNTZXQodGhpbmcpXG5cdFx0PyBBcmNodHlwZVNldFxuXHRcdDogQXJjaHR5cGVPYmplY3Rcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcyh0aGluZzogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gZ2V0QXJjaHR5cGUodGhpbmcpID09PSBBcmNodHlwZU1hcFxuXHRcdD8gdGhpbmcuaGFzKHByb3ApXG5cdFx0OiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpbmcsIHByb3ApXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXQodGhpbmc6IEFueU1hcCB8IEFueU9iamVjdCwgcHJvcDogUHJvcGVydHlLZXkpOiBhbnkge1xuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IEFyY2h0eXBlTWFwID8gdGhpbmcuZ2V0KHByb3ApIDogdGhpbmdbcHJvcF1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIHNldCh0aGluZzogYW55LCBwcm9wT3JPbGRWYWx1ZTogUHJvcGVydHlLZXksIHZhbHVlOiBhbnkpIHtcblx0Y29uc3QgdCA9IGdldEFyY2h0eXBlKHRoaW5nKVxuXHRpZiAodCA9PT0gQXJjaHR5cGVNYXApIHRoaW5nLnNldChwcm9wT3JPbGRWYWx1ZSwgdmFsdWUpXG5cdGVsc2UgaWYgKHQgPT09IEFyY2h0eXBlU2V0KSB7XG5cdFx0dGhpbmcuZGVsZXRlKHByb3BPck9sZFZhbHVlKVxuXHRcdHRoaW5nLmFkZCh2YWx1ZSlcblx0fSBlbHNlIHRoaW5nW3Byb3BPck9sZFZhbHVlXSA9IHZhbHVlXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpcyh4OiBhbnksIHk6IGFueSk6IGJvb2xlYW4ge1xuXHQvLyBGcm9tOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2M2OTkwNGE1MTFiOTAwMjY2OTM1MTY4MjIzMDYzZGQ4NzcyZGZjNDAvcGFja2FnZXMvZmJqcy9zcmMvY29yZS9zaGFsbG93RXF1YWwuanNcblx0aWYgKHggPT09IHkpIHtcblx0XHRyZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHlcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5XG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTWFwKHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueU1hcCB7XG5cdHJldHVybiBoYXNNYXAgJiYgdGFyZ2V0IGluc3RhbmNlb2YgTWFwXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NldCh0YXJnZXQ6IGFueSk6IHRhcmdldCBpcyBBbnlTZXQge1xuXHRyZXR1cm4gaGFzU2V0ICYmIHRhcmdldCBpbnN0YW5jZW9mIFNldFxufVxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGxhdGVzdChzdGF0ZTogSW1tZXJTdGF0ZSk6IGFueSB7XG5cdHJldHVybiBzdGF0ZS5jb3B5XyB8fCBzdGF0ZS5iYXNlX1xufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkoYmFzZTogYW55KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGJhc2UpKSByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYmFzZSlcblx0Y29uc3QgZGVzY3JpcHRvcnMgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGJhc2UpXG5cdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdGxldCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y29uc3Qga2V5OiBhbnkgPSBrZXlzW2ldXG5cdFx0Y29uc3QgZGVzYyA9IGRlc2NyaXB0b3JzW2tleV1cblx0XHRpZiAoZGVzYy53cml0YWJsZSA9PT0gZmFsc2UpIHtcblx0XHRcdGRlc2Mud3JpdGFibGUgPSB0cnVlXG5cdFx0XHRkZXNjLmNvbmZpZ3VyYWJsZSA9IHRydWVcblx0XHR9XG5cdFx0Ly8gbGlrZSBvYmplY3QuYXNzaWduLCB3ZSB3aWxsIHJlYWQgYW55IF9vd25fLCBnZXQvc2V0IGFjY2Vzc29ycy4gVGhpcyBoZWxwcyBpbiBkZWFsaW5nXG5cdFx0Ly8gd2l0aCBsaWJyYXJpZXMgdGhhdCB0cmFwIHZhbHVlcywgbGlrZSBtb2J4IG9yIHZ1ZVxuXHRcdC8vIHVubGlrZSBvYmplY3QuYXNzaWduLCBub24tZW51bWVyYWJsZXMgd2lsbCBiZSBjb3BpZWQgYXMgd2VsbFxuXHRcdGlmIChkZXNjLmdldCB8fCBkZXNjLnNldClcblx0XHRcdGRlc2NyaXB0b3JzW2tleV0gPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsIC8vIGNvdWxkIGxpdmUgd2l0aCAhIWRlc2Muc2V0IGFzIHdlbGwgaGVyZS4uLlxuXHRcdFx0XHRlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG5cdFx0XHRcdHZhbHVlOiBiYXNlW2tleV1cblx0XHRcdH1cblx0fVxuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnJlZXplKG9iajogYW55LCBkZWVwOiBib29sZWFuKTogdm9pZCB7XG5cdGlmIChpc0Zyb3plbihvYmopIHx8IGlzRHJhZnQob2JqKSB8fCAhaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuXG5cdGlmIChnZXRBcmNodHlwZShvYmopID4gMSAvKiBNYXAgb3IgU2V0ICovKSB7XG5cdFx0b2JqLnNldCA9IG9iai5hZGQgPSBvYmouY2xlYXIgPSBvYmouZGVsZXRlID0gZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIGFzIGFueVxuXHR9XG5cdE9iamVjdC5mcmVlemUob2JqKVxuXHRpZiAoZGVlcCkgZWFjaChvYmosIChrZXksIHZhbHVlKSA9PiBmcmVlemUodmFsdWUsIHRydWUpLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMoKSB7XG5cdGRpZSgyKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNGcm96ZW4ob2JqOiBhbnkpOiBib29sZWFuIHtcblx0aWYgKG9iaiA9PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHJldHVybiB0cnVlXG5cdC8vIFNlZSAjNjAwLCBJRSBkaWVzIG9uIG5vbi1vYmplY3RzIGluIE9iamVjdC5pc0Zyb3plblxuXHRyZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iailcbn1cbiIsImltcG9ydCB7XG5cdFNldFN0YXRlLFxuXHRJbW1lclNjb3BlLFxuXHRQcm94eU9iamVjdFN0YXRlLFxuXHRQcm94eUFycmF5U3RhdGUsXG5cdEVTNU9iamVjdFN0YXRlLFxuXHRFUzVBcnJheVN0YXRlLFxuXHRNYXBTdGF0ZSxcblx0RFJBRlRfU1RBVEVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IHR5cGUgT2JqZWN0aXNoID0gQW55T2JqZWN0IHwgQW55QXJyYXkgfCBBbnlNYXAgfCBBbnlTZXRcbmV4cG9ydCB0eXBlIE9iamVjdGlzaE5vU2V0ID0gQW55T2JqZWN0IHwgQW55QXJyYXkgfCBBbnlNYXBcblxuZXhwb3J0IHR5cGUgQW55T2JqZWN0ID0ge1trZXk6IHN0cmluZ106IGFueX1cbmV4cG9ydCB0eXBlIEFueUFycmF5ID0gQXJyYXk8YW55PlxuZXhwb3J0IHR5cGUgQW55U2V0ID0gU2V0PGFueT5cbmV4cG9ydCB0eXBlIEFueU1hcCA9IE1hcDxhbnksIGFueT5cblxuZXhwb3J0IGNvbnN0IEFyY2h0eXBlT2JqZWN0ID0gMFxuZXhwb3J0IGNvbnN0IEFyY2h0eXBlQXJyYXkgPSAxXG5leHBvcnQgY29uc3QgQXJjaHR5cGVNYXAgPSAyXG5leHBvcnQgY29uc3QgQXJjaHR5cGVTZXQgPSAzXG5cbmV4cG9ydCBjb25zdCBQcm94eVR5cGVQcm94eU9iamVjdCA9IDBcbmV4cG9ydCBjb25zdCBQcm94eVR5cGVQcm94eUFycmF5ID0gMVxuZXhwb3J0IGNvbnN0IFByb3h5VHlwZUVTNU9iamVjdCA9IDRcbmV4cG9ydCBjb25zdCBQcm94eVR5cGVFUzVBcnJheSA9IDVcbmV4cG9ydCBjb25zdCBQcm94eVR5cGVNYXAgPSAyXG5leHBvcnQgY29uc3QgUHJveHlUeXBlU2V0ID0gM1xuXG5leHBvcnQgaW50ZXJmYWNlIEltbWVyQmFzZVN0YXRlIHtcblx0cGFyZW50Xz86IEltbWVyU3RhdGVcblx0c2NvcGVfOiBJbW1lclNjb3BlXG5cdG1vZGlmaWVkXzogYm9vbGVhblxuXHRmaW5hbGl6ZWRfOiBib29sZWFuXG5cdGlzTWFudWFsXzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBJbW1lclN0YXRlID1cblx0fCBQcm94eU9iamVjdFN0YXRlXG5cdHwgUHJveHlBcnJheVN0YXRlXG5cdHwgRVM1T2JqZWN0U3RhdGVcblx0fCBFUzVBcnJheVN0YXRlXG5cdHwgTWFwU3RhdGVcblx0fCBTZXRTdGF0ZVxuXG4vLyBUaGUgX2ludGVybmFsXyB0eXBlIHVzZWQgZm9yIGRyYWZ0cyAobm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggRHJhZnQsIHdoaWNoIGlzIHB1YmxpYyBmYWNpbmcpXG5leHBvcnQgdHlwZSBEcmFmdGVkPEJhc2UgPSBhbnksIFQgZXh0ZW5kcyBJbW1lclN0YXRlID0gSW1tZXJTdGF0ZT4gPSB7XG5cdFtEUkFGVF9TVEFURV06IFRcbn0gJiBCYXNlXG4iLCJpbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHRQYXRjaCxcblx0SW1tZXJTY29wZSxcblx0RHJhZnRlZCxcblx0QW55T2JqZWN0LFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdFByb3h5VHlwZUVTNUFycmF5LFxuXHRQcm94eVR5cGVFUzVPYmplY3QsXG5cdFByb3h5VHlwZU1hcCxcblx0UHJveHlUeXBlU2V0LFxuXHRkaWVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuLyoqIFBsdWdpbiB1dGlsaXRpZXMgKi9cbmNvbnN0IHBsdWdpbnM6IHtcblx0UGF0Y2hlcz86IHtcblx0XHRnZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdFx0c3RhdGU6IEltbWVyU3RhdGUsXG5cdFx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdFx0KTogdm9pZFxuXHRcdGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyhcblx0XHRcdHJvb3RTdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRcdHJlcGxhY2VtZW50OiBhbnksXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0YXBwbHlQYXRjaGVzXzxUPihkcmFmdDogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFRcblx0fVxuXHRFUzU/OiB7XG5cdFx0d2lsbEZpbmFsaXplRVM1XyhzY29wZTogSW1tZXJTY29wZSwgcmVzdWx0OiBhbnksIGlzUmVwbGFjZWQ6IGJvb2xlYW4pOiB2b2lkXG5cdFx0Y3JlYXRlRVM1UHJveHlfPFQ+KFxuXHRcdFx0YmFzZTogVCxcblx0XHRcdHBhcmVudD86IEltbWVyU3RhdGVcblx0XHQpOiBEcmFmdGVkPFQsIEVTNU9iamVjdFN0YXRlIHwgRVM1QXJyYXlTdGF0ZT5cblx0XHRoYXNDaGFuZ2VzXyhzdGF0ZTogRVM1QXJyYXlTdGF0ZSB8IEVTNU9iamVjdFN0YXRlKTogYm9vbGVhblxuXHR9XG5cdE1hcFNldD86IHtcblx0XHRwcm94eU1hcF88VCBleHRlbmRzIEFueU1hcD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVFxuXHRcdHByb3h5U2V0XzxUIGV4dGVuZHMgQW55U2V0Pih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUXG5cdH1cbn0gPSB7fVxuXG50eXBlIFBsdWdpbnMgPSB0eXBlb2YgcGx1Z2luc1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGx1Z2luPEsgZXh0ZW5kcyBrZXlvZiBQbHVnaW5zPihcblx0cGx1Z2luS2V5OiBLXG4pOiBFeGNsdWRlPFBsdWdpbnNbS10sIHVuZGVmaW5lZD4ge1xuXHRjb25zdCBwbHVnaW4gPSBwbHVnaW5zW3BsdWdpbktleV1cblx0aWYgKCFwbHVnaW4pIHtcblx0XHRkaWUoX19ERVZfXyA/IDE4IDogMTksIHBsdWdpbktleSlcblx0fVxuXHQvLyBAdHMtaWdub3JlXG5cdHJldHVybiBwbHVnaW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWRQbHVnaW48SyBleHRlbmRzIGtleW9mIFBsdWdpbnM+KFxuXHRwbHVnaW5LZXk6IEssXG5cdGltcGxlbWVudGF0aW9uOiBQbHVnaW5zW0tdXG4pOiB2b2lkIHtcblx0cGx1Z2luc1twbHVnaW5LZXldID0gaW1wbGVtZW50YXRpb25cbn1cblxuLyoqIEVTNSBQbHVnaW4gKi9cblxuaW50ZXJmYWNlIEVTNUJhc2VTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0YXNzaWduZWRfOiB7W2tleTogc3RyaW5nXTogYW55fVxuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRyZXZva2VkXzogYm9vbGVhblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVTNU9iamVjdFN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IHR5cGVvZiBQcm94eVR5cGVFUzVPYmplY3Rcblx0ZHJhZnRfOiBEcmFmdGVkPEFueU9iamVjdCwgRVM1T2JqZWN0U3RhdGU+XG5cdGJhc2VfOiBBbnlPYmplY3Rcblx0Y29weV86IEFueU9iamVjdCB8IG51bGxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFUzVBcnJheVN0YXRlIGV4dGVuZHMgRVM1QmFzZVN0YXRlIHtcblx0dHlwZV86IHR5cGVvZiBQcm94eVR5cGVFUzVBcnJheVxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBFUzVBcnJheVN0YXRlPlxuXHRiYXNlXzogYW55XG5cdGNvcHlfOiBhbnlcbn1cblxuLyoqIE1hcCAvIFNldCBwbHVnaW4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBNYXBTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0dHlwZV86IHR5cGVvZiBQcm94eVR5cGVNYXBcblx0Y29weV86IEFueU1hcCB8IHVuZGVmaW5lZFxuXHRhc3NpZ25lZF86IE1hcDxhbnksIGJvb2xlYW4+IHwgdW5kZWZpbmVkXG5cdGJhc2VfOiBBbnlNYXBcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueU1hcCwgTWFwU3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2V0U3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdHR5cGVfOiB0eXBlb2YgUHJveHlUeXBlU2V0XG5cdGNvcHlfOiBBbnlTZXQgfCB1bmRlZmluZWRcblx0YmFzZV86IEFueVNldFxuXHRkcmFmdHNfOiBNYXA8YW55LCBEcmFmdGVkPiAvLyBtYXBzIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byB0aGUgZHJhZnQgdmFsdWUgaW4gdGhlIG5ldyBzZXRcblx0cmV2b2tlZF86IGJvb2xlYW5cblx0ZHJhZnRfOiBEcmFmdGVkPEFueVNldCwgU2V0U3RhdGU+XG59XG5cbi8qKiBQYXRjaGVzIHBsdWdpbiAqL1xuXG5leHBvcnQgdHlwZSBQYXRjaFBhdGggPSAoc3RyaW5nIHwgbnVtYmVyKVtdXG4iLCJpbXBvcnQge1xuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0RHJhZnRlZCxcblx0SW1tZXIsXG5cdERSQUZUX1NUQVRFLFxuXHRJbW1lclN0YXRlLFxuXHRQcm94eVR5cGVQcm94eU9iamVjdCxcblx0UHJveHlUeXBlUHJveHlBcnJheSxcblx0Z2V0UGx1Z2luXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5pbXBvcnQge2RpZX0gZnJvbSBcIi4uL3V0aWxzL2Vycm9yc1wiXG5cbi8qKiBFYWNoIHNjb3BlIHJlcHJlc2VudHMgYSBgcHJvZHVjZWAgY2FsbC4gKi9cblxuZXhwb3J0IGludGVyZmFjZSBJbW1lclNjb3BlIHtcblx0cGF0Y2hlc18/OiBQYXRjaFtdXG5cdGludmVyc2VQYXRjaGVzXz86IFBhdGNoW11cblx0Y2FuQXV0b0ZyZWV6ZV86IGJvb2xlYW5cblx0ZHJhZnRzXzogYW55W11cblx0cGFyZW50Xz86IEltbWVyU2NvcGVcblx0cGF0Y2hMaXN0ZW5lcl8/OiBQYXRjaExpc3RlbmVyXG5cdGltbWVyXzogSW1tZXJcblx0dW5maW5hbGl6ZWREcmFmdHNfOiBudW1iZXJcbn1cblxubGV0IGN1cnJlbnRTY29wZTogSW1tZXJTY29wZSB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFNjb3BlKCkge1xuXHRpZiAoX19ERVZfXyAmJiAhY3VycmVudFNjb3BlKSBkaWUoMClcblx0cmV0dXJuIGN1cnJlbnRTY29wZSFcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2NvcGUoXG5cdHBhcmVudF86IEltbWVyU2NvcGUgfCB1bmRlZmluZWQsXG5cdGltbWVyXzogSW1tZXJcbik6IEltbWVyU2NvcGUge1xuXHRyZXR1cm4ge1xuXHRcdGRyYWZ0c186IFtdLFxuXHRcdHBhcmVudF8sXG5cdFx0aW1tZXJfLFxuXHRcdC8vIFdoZW5ldmVyIHRoZSBtb2RpZmllZCBkcmFmdCBjb250YWlucyBhIGRyYWZ0IGZyb20gYW5vdGhlciBzY29wZSwgd2Vcblx0XHQvLyBuZWVkIHRvIHByZXZlbnQgYXV0by1mcmVlemluZyBzbyB0aGUgdW5vd25lZCBkcmFmdCBjYW4gYmUgZmluYWxpemVkLlxuXHRcdGNhbkF1dG9GcmVlemVfOiB0cnVlLFxuXHRcdHVuZmluYWxpemVkRHJhZnRzXzogMFxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXRjaGVzSW5TY29wZShcblx0c2NvcGU6IEltbWVyU2NvcGUsXG5cdHBhdGNoTGlzdGVuZXI/OiBQYXRjaExpc3RlbmVyXG4pIHtcblx0aWYgKHBhdGNoTGlzdGVuZXIpIHtcblx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpIC8vIGFzc2VydCB3ZSBoYXZlIHRoZSBwbHVnaW5cblx0XHRzY29wZS5wYXRjaGVzXyA9IFtdXG5cdFx0c2NvcGUuaW52ZXJzZVBhdGNoZXNfID0gW11cblx0XHRzY29wZS5wYXRjaExpc3RlbmVyXyA9IHBhdGNoTGlzdGVuZXJcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmV2b2tlU2NvcGUoc2NvcGU6IEltbWVyU2NvcGUpIHtcblx0bGVhdmVTY29wZShzY29wZSlcblx0c2NvcGUuZHJhZnRzXy5mb3JFYWNoKHJldm9rZURyYWZ0KVxuXHQvLyBAdHMtaWdub3JlXG5cdHNjb3BlLmRyYWZ0c18gPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsZWF2ZVNjb3BlKHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdGlmIChzY29wZSA9PT0gY3VycmVudFNjb3BlKSB7XG5cdFx0Y3VycmVudFNjb3BlID0gc2NvcGUucGFyZW50X1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbnRlclNjb3BlKGltbWVyOiBJbW1lcikge1xuXHRyZXR1cm4gKGN1cnJlbnRTY29wZSA9IGNyZWF0ZVNjb3BlKGN1cnJlbnRTY29wZSwgaW1tZXIpKVxufVxuXG5mdW5jdGlvbiByZXZva2VEcmFmdChkcmFmdDogRHJhZnRlZCkge1xuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXVxuXHRpZiAoXG5cdFx0c3RhdGUudHlwZV8gPT09IFByb3h5VHlwZVByb3h5T2JqZWN0IHx8XG5cdFx0c3RhdGUudHlwZV8gPT09IFByb3h5VHlwZVByb3h5QXJyYXlcblx0KVxuXHRcdHN0YXRlLnJldm9rZV8oKVxuXHRlbHNlIHN0YXRlLnJldm9rZWRfID0gdHJ1ZVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTY29wZSxcblx0RFJBRlRfU1RBVEUsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HLFxuXHRQYXRjaFBhdGgsXG5cdGVhY2gsXG5cdGhhcyxcblx0ZnJlZXplLFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0LFxuXHRTZXRTdGF0ZSxcblx0c2V0LFxuXHRQcm94eVR5cGVFUzVPYmplY3QsXG5cdFByb3h5VHlwZUVTNUFycmF5LFxuXHRQcm94eVR5cGVTZXQsXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRyZXZva2VTY29wZSxcblx0aXNGcm96ZW4sXG5cdHNoYWxsb3dDb3B5XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzUmVzdWx0KHJlc3VsdDogYW55LCBzY29wZTogSW1tZXJTY29wZSkge1xuXHRzY29wZS51bmZpbmFsaXplZERyYWZ0c18gPSBzY29wZS5kcmFmdHNfLmxlbmd0aFxuXHRjb25zdCBiYXNlRHJhZnQgPSBzY29wZS5kcmFmdHNfIVswXVxuXHRjb25zdCBpc1JlcGxhY2VkID0gcmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBiYXNlRHJhZnRcblx0aWYgKCFzY29wZS5pbW1lcl8udXNlUHJveGllc18pXG5cdFx0Z2V0UGx1Z2luKFwiRVM1XCIpLndpbGxGaW5hbGl6ZUVTNV8oc2NvcGUsIHJlc3VsdCwgaXNSZXBsYWNlZClcblx0aWYgKGlzUmVwbGFjZWQpIHtcblx0XHRpZiAoYmFzZURyYWZ0W0RSQUZUX1NUQVRFXS5tb2RpZmllZF8pIHtcblx0XHRcdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRcdFx0ZGllKDQpXG5cdFx0fVxuXHRcdGlmIChpc0RyYWZ0YWJsZShyZXN1bHQpKSB7XG5cdFx0XHQvLyBGaW5hbGl6ZSB0aGUgcmVzdWx0IGluIGNhc2UgaXQgY29udGFpbnMgKG9yIGlzKSBhIHN1YnNldCBvZiB0aGUgZHJhZnQuXG5cdFx0XHRyZXN1bHQgPSBmaW5hbGl6ZShzY29wZSwgcmVzdWx0KVxuXHRcdFx0aWYgKCFzY29wZS5wYXJlbnRfKSBtYXliZUZyZWV6ZShzY29wZSwgcmVzdWx0KVxuXHRcdH1cblx0XHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0XHRiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLFxuXHRcdFx0XHRyZXN1bHQsXG5cdFx0XHRcdHNjb3BlLnBhdGNoZXNfLFxuXHRcdFx0XHRzY29wZS5pbnZlcnNlUGF0Y2hlc18hXG5cdFx0XHQpXG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIEZpbmFsaXplIHRoZSBiYXNlIGRyYWZ0LlxuXHRcdHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCBiYXNlRHJhZnQsIFtdKVxuXHR9XG5cdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRpZiAoc2NvcGUucGF0Y2hlc18pIHtcblx0XHRzY29wZS5wYXRjaExpc3RlbmVyXyEoc2NvcGUucGF0Y2hlc18sIHNjb3BlLmludmVyc2VQYXRjaGVzXyEpXG5cdH1cblx0cmV0dXJuIHJlc3VsdCAhPT0gTk9USElORyA/IHJlc3VsdCA6IHVuZGVmaW5lZFxufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZShyb290U2NvcGU6IEltbWVyU2NvcGUsIHZhbHVlOiBhbnksIHBhdGg/OiBQYXRjaFBhdGgpIHtcblx0Ly8gRG9uJ3QgcmVjdXJzZSBpbiB0aG8gcmVjdXJzaXZlIGRhdGEgc3RydWN0dXJlc1xuXHRpZiAoaXNGcm96ZW4odmFsdWUpKSByZXR1cm4gdmFsdWVcblxuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IHZhbHVlW0RSQUZUX1NUQVRFXVxuXHQvLyBBIHBsYWluIG9iamVjdCwgbWlnaHQgbmVlZCBmcmVlemluZywgbWlnaHQgY29udGFpbiBkcmFmdHNcblx0aWYgKCFzdGF0ZSkge1xuXHRcdGVhY2goXG5cdFx0XHR2YWx1ZSxcblx0XHRcdChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgdmFsdWUsIGtleSwgY2hpbGRWYWx1ZSwgcGF0aCksXG5cdFx0XHR0cnVlIC8vIFNlZSAjNTkwLCBkb24ndCByZWN1cnNlIGludG8gbm9uLWVudW1hcmFibGUgb2Ygbm9uIGRyYWZ0ZWQgb2JqZWN0c1xuXHRcdClcblx0XHRyZXR1cm4gdmFsdWVcblx0fVxuXHQvLyBOZXZlciBmaW5hbGl6ZSBkcmFmdHMgb3duZWQgYnkgYW5vdGhlciBzY29wZS5cblx0aWYgKHN0YXRlLnNjb3BlXyAhPT0gcm9vdFNjb3BlKSByZXR1cm4gdmFsdWVcblx0Ly8gVW5tb2RpZmllZCBkcmFmdCwgcmV0dXJuIHRoZSAoZnJvemVuKSBvcmlnaW5hbFxuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgc3RhdGUuYmFzZV8sIHRydWUpXG5cdFx0cmV0dXJuIHN0YXRlLmJhc2VfXG5cdH1cblx0Ly8gTm90IGZpbmFsaXplZCB5ZXQsIGxldCdzIGRvIHRoYXQgbm93XG5cdGlmICghc3RhdGUuZmluYWxpemVkXykge1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0c3RhdGUuc2NvcGVfLnVuZmluYWxpemVkRHJhZnRzXy0tXG5cdFx0Y29uc3QgcmVzdWx0ID1cblx0XHRcdC8vIEZvciBFUzUsIGNyZWF0ZSBhIGdvb2QgY29weSBmcm9tIHRoZSBkcmFmdCBmaXJzdCwgd2l0aCBhZGRlZCBrZXlzIGFuZCB3aXRob3V0IGRlbGV0ZWQga2V5cy5cblx0XHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGVFUzVPYmplY3QgfHwgc3RhdGUudHlwZV8gPT09IFByb3h5VHlwZUVTNUFycmF5XG5cdFx0XHRcdD8gKHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuZHJhZnRfKSlcblx0XHRcdFx0OiBzdGF0ZS5jb3B5X1xuXHRcdC8vIEZpbmFsaXplIGFsbCBjaGlsZHJlbiBvZiB0aGUgY29weVxuXHRcdC8vIEZvciBzZXRzIHdlIGNsb25lIGJlZm9yZSBpdGVyYXRpbmcsIG90aGVyd2lzZSB3ZSBjYW4gZ2V0IGluIGVuZGxlc3MgbG9vcCBkdWUgdG8gbW9kaWZ5aW5nIGR1cmluZyBpdGVyYXRpb24sIHNlZSAjNjI4XG5cdFx0Ly8gQWx0aG91Z2ggdGhlIG9yaWdpbmFsIHRlc3QgY2FzZSBkb2Vzbid0IHNlZW0gdmFsaWQgYW55d2F5LCBzbyBpZiB0aGlzIGluIHRoZSB3YXkgd2UgY2FuIHR1cm4gdGhlIG5leHQgbGluZVxuXHRcdC8vIGJhY2sgdG8gZWFjaChyZXN1bHQsIC4uLi4pXG5cdFx0ZWFjaChcblx0XHRcdHN0YXRlLnR5cGVfID09PSBQcm94eVR5cGVTZXQgPyBuZXcgU2V0KHJlc3VsdCkgOiByZXN1bHQsXG5cdFx0XHQoa2V5LCBjaGlsZFZhbHVlKSA9PlxuXHRcdFx0XHRmaW5hbGl6ZVByb3BlcnR5KHJvb3RTY29wZSwgc3RhdGUsIHJlc3VsdCwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKVxuXHRcdClcblx0XHQvLyBldmVyeXRoaW5nIGluc2lkZSBpcyBmcm96ZW4sIHdlIGNhbiBmcmVlemUgaGVyZVxuXHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgcmVzdWx0LCBmYWxzZSlcblx0XHQvLyBmaXJzdCB0aW1lIGZpbmFsaXppbmcsIGxldCdzIGNyZWF0ZSB0aG9zZSBwYXRjaGVzXG5cdFx0aWYgKHBhdGggJiYgcm9vdFNjb3BlLnBhdGNoZXNfKSB7XG5cdFx0XHRnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRyb290U2NvcGUucGF0Y2hlc18sXG5cdFx0XHRcdHJvb3RTY29wZS5pbnZlcnNlUGF0Y2hlc18hXG5cdFx0XHQpXG5cdFx0fVxuXHR9XG5cdHJldHVybiBzdGF0ZS5jb3B5X1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnR5KFxuXHRyb290U2NvcGU6IEltbWVyU2NvcGUsXG5cdHBhcmVudFN0YXRlOiB1bmRlZmluZWQgfCBJbW1lclN0YXRlLFxuXHR0YXJnZXRPYmplY3Q6IGFueSxcblx0cHJvcDogc3RyaW5nIHwgbnVtYmVyLFxuXHRjaGlsZFZhbHVlOiBhbnksXG5cdHJvb3RQYXRoPzogUGF0Y2hQYXRoXG4pIHtcblx0aWYgKF9fREVWX18gJiYgY2hpbGRWYWx1ZSA9PT0gdGFyZ2V0T2JqZWN0KSBkaWUoNSlcblx0aWYgKGlzRHJhZnQoY2hpbGRWYWx1ZSkpIHtcblx0XHRjb25zdCBwYXRoID1cblx0XHRcdHJvb3RQYXRoICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSAmJlxuXHRcdFx0cGFyZW50U3RhdGUhLnR5cGVfICE9PSBQcm94eVR5cGVTZXQgJiYgLy8gU2V0IG9iamVjdHMgYXJlIGF0b21pYyBzaW5jZSB0aGV5IGhhdmUgbm8ga2V5cy5cblx0XHRcdCFoYXMoKHBhcmVudFN0YXRlIGFzIEV4Y2x1ZGU8SW1tZXJTdGF0ZSwgU2V0U3RhdGU+KS5hc3NpZ25lZF8hLCBwcm9wKSAvLyBTa2lwIGRlZXAgcGF0Y2hlcyBmb3IgYXNzaWduZWQga2V5cy5cblx0XHRcdFx0PyByb290UGF0aCEuY29uY2F0KHByb3ApXG5cdFx0XHRcdDogdW5kZWZpbmVkXG5cdFx0Ly8gRHJhZnRzIG93bmVkIGJ5IGBzY29wZWAgYXJlIGZpbmFsaXplZCBoZXJlLlxuXHRcdGNvbnN0IHJlcyA9IGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSwgcGF0aClcblx0XHRzZXQodGFyZ2V0T2JqZWN0LCBwcm9wLCByZXMpXG5cdFx0Ly8gRHJhZnRzIGZyb20gYW5vdGhlciBzY29wZSBtdXN0IHByZXZlbnRlZCB0byBiZSBmcm96ZW5cblx0XHQvLyBpZiB3ZSBnb3QgYSBkcmFmdCBiYWNrIGZyb20gZmluYWxpemUsIHdlJ3JlIGluIGEgbmVzdGVkIHByb2R1Y2UgYW5kIHNob3VsZG4ndCBmcmVlemVcblx0XHRpZiAoaXNEcmFmdChyZXMpKSB7XG5cdFx0XHRyb290U2NvcGUuY2FuQXV0b0ZyZWV6ZV8gPSBmYWxzZVxuXHRcdH0gZWxzZSByZXR1cm5cblx0fVxuXHQvLyBTZWFyY2ggbmV3IG9iamVjdHMgZm9yIHVuZmluYWxpemVkIGRyYWZ0cy4gRnJvemVuIG9iamVjdHMgc2hvdWxkIG5ldmVyIGNvbnRhaW4gZHJhZnRzLlxuXHRpZiAoaXNEcmFmdGFibGUoY2hpbGRWYWx1ZSkgJiYgIWlzRnJvemVuKGNoaWxkVmFsdWUpKSB7XG5cdFx0aWYgKCFyb290U2NvcGUuaW1tZXJfLmF1dG9GcmVlemVfICYmIHJvb3RTY29wZS51bmZpbmFsaXplZERyYWZ0c18gPCAxKSB7XG5cdFx0XHQvLyBvcHRpbWl6YXRpb246IGlmIGFuIG9iamVjdCBpcyBub3QgYSBkcmFmdCwgYW5kIHdlIGRvbid0IGhhdmUgdG9cblx0XHRcdC8vIGRlZXBmcmVlemUgZXZlcnl0aGluZywgYW5kIHdlIGFyZSBzdXJlIHRoYXQgbm8gZHJhZnRzIGFyZSBsZWZ0IGluIHRoZSByZW1haW5pbmcgb2JqZWN0XG5cdFx0XHQvLyBjYXVzZSB3ZSBzYXcgYW5kIGZpbmFsaXplZCBhbGwgZHJhZnRzIGFscmVhZHk7IHdlIGNhbiBzdG9wIHZpc2l0aW5nIHRoZSByZXN0IG9mIHRoZSB0cmVlLlxuXHRcdFx0Ly8gVGhpcyBiZW5lZml0cyBlc3BlY2lhbGx5IGFkZGluZyBsYXJnZSBkYXRhIHRyZWUncyB3aXRob3V0IGZ1cnRoZXIgcHJvY2Vzc2luZy5cblx0XHRcdC8vIFNlZSBhZGQtZGF0YS5qcyBwZXJmIHRlc3Rcblx0XHRcdHJldHVyblxuXHRcdH1cblx0XHRmaW5hbGl6ZShyb290U2NvcGUsIGNoaWxkVmFsdWUpXG5cdFx0Ly8gaW1tZXIgZGVlcCBmcmVlemVzIHBsYWluIG9iamVjdHMsIHNvIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBzdGF0ZSwgd2UgZnJlZXplIGFzIHdlbGxcblx0XHRpZiAoIXBhcmVudFN0YXRlIHx8ICFwYXJlbnRTdGF0ZS5zY29wZV8ucGFyZW50Xylcblx0XHRcdG1heWJlRnJlZXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSlcblx0fVxufVxuXG5mdW5jdGlvbiBtYXliZUZyZWV6ZShzY29wZTogSW1tZXJTY29wZSwgdmFsdWU6IGFueSwgZGVlcCA9IGZhbHNlKSB7XG5cdGlmIChzY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgc2NvcGUuY2FuQXV0b0ZyZWV6ZV8pIHtcblx0XHRmcmVlemUodmFsdWUsIGRlZXApXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdGVhY2gsXG5cdGhhcyxcblx0aXMsXG5cdGlzRHJhZnRhYmxlLFxuXHRzaGFsbG93Q29weSxcblx0bGF0ZXN0LFxuXHRJbW1lckJhc2VTdGF0ZSxcblx0SW1tZXJTdGF0ZSxcblx0RHJhZnRlZCxcblx0QW55T2JqZWN0LFxuXHRBbnlBcnJheSxcblx0T2JqZWN0aXNoLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdERSQUZUX1NUQVRFLFxuXHRkaWUsXG5cdGNyZWF0ZVByb3h5LFxuXHRQcm94eVR5cGVQcm94eU9iamVjdCxcblx0UHJveHlUeXBlUHJveHlBcnJheVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5pbnRlcmZhY2UgUHJveHlCYXNlU3RhdGUgZXh0ZW5kcyBJbW1lckJhc2VTdGF0ZSB7XG5cdGFzc2lnbmVkXzoge1xuXHRcdFtwcm9wZXJ0eTogc3RyaW5nXTogYm9vbGVhblxuXHR9XG5cdHBhcmVudF8/OiBJbW1lclN0YXRlXG5cdHJldm9rZV8oKTogdm9pZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb3h5T2JqZWN0U3RhdGUgZXh0ZW5kcyBQcm94eUJhc2VTdGF0ZSB7XG5cdHR5cGVfOiB0eXBlb2YgUHJveHlUeXBlUHJveHlPYmplY3Rcblx0YmFzZV86IGFueVxuXHRjb3B5XzogYW55XG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlPYmplY3QsIFByb3h5T2JqZWN0U3RhdGU+XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlBcnJheVN0YXRlIGV4dGVuZHMgUHJveHlCYXNlU3RhdGUge1xuXHR0eXBlXzogdHlwZW9mIFByb3h5VHlwZVByb3h5QXJyYXlcblx0YmFzZV86IEFueUFycmF5XG5cdGNvcHlfOiBBbnlBcnJheSB8IG51bGxcblx0ZHJhZnRfOiBEcmFmdGVkPEFueUFycmF5LCBQcm94eUFycmF5U3RhdGU+XG59XG5cbnR5cGUgUHJveHlTdGF0ZSA9IFByb3h5T2JqZWN0U3RhdGUgfCBQcm94eUFycmF5U3RhdGVcblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGRyYWZ0IG9mIHRoZSBgYmFzZWAgb2JqZWN0LlxuICpcbiAqIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgdGhlIHBhcmVudCBkcmFmdC1zdGF0ZSAodXNlZCBpbnRlcm5hbGx5KS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb3h5UHJveHk8VCBleHRlbmRzIE9iamVjdGlzaD4oXG5cdGJhc2U6IFQsXG5cdHBhcmVudD86IEltbWVyU3RhdGVcbik6IERyYWZ0ZWQ8VCwgUHJveHlTdGF0ZT4ge1xuXHRjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKVxuXHRjb25zdCBzdGF0ZTogUHJveHlTdGF0ZSA9IHtcblx0XHR0eXBlXzogaXNBcnJheSA/IFByb3h5VHlwZVByb3h5QXJyYXkgOiAoUHJveHlUeXBlUHJveHlPYmplY3QgYXMgYW55KSxcblx0XHQvLyBUcmFjayB3aGljaCBwcm9kdWNlIGNhbGwgdGhpcyBpcyBhc3NvY2lhdGVkIHdpdGguXG5cdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdC8vIFRydWUgZm9yIGJvdGggc2hhbGxvdyBhbmQgZGVlcCBjaGFuZ2VzLlxuXHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0Ly8gVXNlZCBkdXJpbmcgZmluYWxpemF0aW9uLlxuXHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb3BlcnRpZXMgaGF2ZSBiZWVuIGFzc2lnbmVkICh0cnVlKSBvciBkZWxldGVkIChmYWxzZSkuXG5cdFx0YXNzaWduZWRfOiB7fSxcblx0XHQvLyBUaGUgcGFyZW50IGRyYWZ0IHN0YXRlLlxuXHRcdHBhcmVudF86IHBhcmVudCxcblx0XHQvLyBUaGUgYmFzZSBzdGF0ZS5cblx0XHRiYXNlXzogYmFzZSxcblx0XHQvLyBUaGUgYmFzZSBwcm94eS5cblx0XHRkcmFmdF86IG51bGwgYXMgYW55LCAvLyBzZXQgYmVsb3dcblx0XHQvLyBUaGUgYmFzZSBjb3B5IHdpdGggYW55IHVwZGF0ZWQgdmFsdWVzLlxuXHRcdGNvcHlfOiBudWxsLFxuXHRcdC8vIENhbGxlZCBieSB0aGUgYHByb2R1Y2VgIGZ1bmN0aW9uLlxuXHRcdHJldm9rZV86IG51bGwgYXMgYW55LFxuXHRcdGlzTWFudWFsXzogZmFsc2Vcblx0fVxuXG5cdC8vIHRoZSB0cmFwcyBtdXN0IHRhcmdldCBzb21ldGhpbmcsIGEgYml0IGxpa2UgdGhlICdyZWFsJyBiYXNlLlxuXHQvLyBidXQgYWxzbywgd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRldGVybWluZSBmcm9tIHRoZSB0YXJnZXQgd2hhdCB0aGUgcmVsZXZhbnQgc3RhdGUgaXNcblx0Ly8gKHRvIGF2b2lkIGNyZWF0aW5nIHRyYXBzIHBlciBpbnN0YW5jZSB0byBjYXB0dXJlIHRoZSBzdGF0ZSBpbiBjbG9zdXJlLFxuXHQvLyBhbmQgdG8gYXZvaWQgY3JlYXRpbmcgd2VpcmQgaGlkZGVuIHByb3BlcnRpZXMgYXMgd2VsbClcblx0Ly8gU28gdGhlIHRyaWNrIGlzIHRvIHVzZSAnc3RhdGUnIGFzIHRoZSBhY3R1YWwgJ3RhcmdldCchIChhbmQgbWFrZSBzdXJlIHdlIGludGVyY2VwdCBldmVyeXRoaW5nKVxuXHQvLyBOb3RlIHRoYXQgaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXksIHdlIHB1dCB0aGUgc3RhdGUgaW4gYW4gYXJyYXkgdG8gaGF2ZSBiZXR0ZXIgUmVmbGVjdCBkZWZhdWx0cyBvb3RiXG5cdGxldCB0YXJnZXQ6IFQgPSBzdGF0ZSBhcyBhbnlcblx0bGV0IHRyYXBzOiBQcm94eUhhbmRsZXI8b2JqZWN0IHwgQXJyYXk8YW55Pj4gPSBvYmplY3RUcmFwc1xuXHRpZiAoaXNBcnJheSkge1xuXHRcdHRhcmdldCA9IFtzdGF0ZV0gYXMgYW55XG5cdFx0dHJhcHMgPSBhcnJheVRyYXBzXG5cdH1cblxuXHRjb25zdCB7cmV2b2tlLCBwcm94eX0gPSBQcm94eS5yZXZvY2FibGUodGFyZ2V0LCB0cmFwcylcblx0c3RhdGUuZHJhZnRfID0gcHJveHkgYXMgYW55XG5cdHN0YXRlLnJldm9rZV8gPSByZXZva2Vcblx0cmV0dXJuIHByb3h5IGFzIGFueVxufVxuXG4vKipcbiAqIE9iamVjdCBkcmFmdHNcbiAqL1xuZXhwb3J0IGNvbnN0IG9iamVjdFRyYXBzOiBQcm94eUhhbmRsZXI8UHJveHlTdGF0ZT4gPSB7XG5cdGdldChzdGF0ZSwgcHJvcCkge1xuXHRcdGlmIChwcm9wID09PSBEUkFGVF9TVEFURSkgcmV0dXJuIHN0YXRlXG5cblx0XHRjb25zdCBzb3VyY2UgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0aWYgKCFoYXMoc291cmNlLCBwcm9wKSkge1xuXHRcdFx0Ly8gbm9uLWV4aXN0aW5nIG9yIG5vbi1vd24gcHJvcGVydHkuLi5cblx0XHRcdHJldHVybiByZWFkUHJvcEZyb21Qcm90byhzdGF0ZSwgc291cmNlLCBwcm9wKVxuXHRcdH1cblx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtwcm9wXVxuXHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdHJldHVybiB2YWx1ZVxuXHRcdH1cblx0XHQvLyBDaGVjayBmb3IgZXhpc3RpbmcgZHJhZnQgaW4gbW9kaWZpZWQgc3RhdGUuXG5cdFx0Ly8gQXNzaWduZWQgdmFsdWVzIGFyZSBuZXZlciBkcmFmdGVkLiBUaGlzIGNhdGNoZXMgYW55IGRyYWZ0cyB3ZSBjcmVhdGVkLCB0b28uXG5cdFx0aWYgKHZhbHVlID09PSBwZWVrKHN0YXRlLmJhc2VfLCBwcm9wKSkge1xuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gKHN0YXRlLmNvcHlfIVtwcm9wIGFzIGFueV0gPSBjcmVhdGVQcm94eShcblx0XHRcdFx0c3RhdGUuc2NvcGVfLmltbWVyXyxcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdHN0YXRlXG5cdFx0XHQpKVxuXHRcdH1cblx0XHRyZXR1cm4gdmFsdWVcblx0fSxcblx0aGFzKHN0YXRlLCBwcm9wKSB7XG5cdFx0cmV0dXJuIHByb3AgaW4gbGF0ZXN0KHN0YXRlKVxuXHR9LFxuXHRvd25LZXlzKHN0YXRlKSB7XG5cdFx0cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhsYXRlc3Qoc3RhdGUpKVxuXHR9LFxuXHRzZXQoXG5cdFx0c3RhdGU6IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0cHJvcDogc3RyaW5nIC8qIHN0cmljdGx5IG5vdCwgYnV0IGhlbHBzIFRTICovLFxuXHRcdHZhbHVlXG5cdCkge1xuXHRcdGNvbnN0IGRlc2MgPSBnZXREZXNjcmlwdG9yRnJvbVByb3RvKGxhdGVzdChzdGF0ZSksIHByb3ApXG5cdFx0aWYgKGRlc2M/LnNldCkge1xuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlOiBpZiB0aGlzIHdyaXRlIGlzIGNhcHR1cmVkIGJ5IGEgc2V0dGVyLCB3ZSBoYXZlXG5cdFx0XHQvLyB0byB0cmlnZ2VyIGl0IHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuXHRcdFx0ZGVzYy5zZXQuY2FsbChzdGF0ZS5kcmFmdF8sIHZhbHVlKVxuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9XG5cdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdC8vIHRoZSBsYXN0IGNoZWNrIGlzIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIHNldHRpbmcgYSBub24tZXhpc3RpZyB0byB1bmRlZmluZWQgKHdoaWNoIGlzIGEgY2hhbmdlKVxuXHRcdFx0Ly8gZnJvbSBzZXR0aW5nIGFuIGV4aXN0aW5nIHByb3BlcnR5IHdpdGggdmFsdWUgdW5kZWZpbmVkIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgbm90IGEgY2hhbmdlKVxuXHRcdFx0Y29uc3QgY3VycmVudCA9IHBlZWsobGF0ZXN0KHN0YXRlKSwgcHJvcClcblx0XHRcdC8vIHNwZWNpYWwgY2FzZSwgaWYgd2UgYXNzaWduaW5nIHRoZSBvcmlnaW5hbCB2YWx1ZSB0byBhIGRyYWZ0LCB3ZSBjYW4gaWdub3JlIHRoZSBhc3NpZ25tZW50XG5cdFx0XHRjb25zdCBjdXJyZW50U3RhdGU6IFByb3h5T2JqZWN0U3RhdGUgPSBjdXJyZW50Py5bRFJBRlRfU1RBVEVdXG5cdFx0XHRpZiAoY3VycmVudFN0YXRlICYmIGN1cnJlbnRTdGF0ZS5iYXNlXyA9PT0gdmFsdWUpIHtcblx0XHRcdFx0c3RhdGUuY29weV8hW3Byb3BdID0gdmFsdWVcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2Vcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdGlmIChpcyh2YWx1ZSwgY3VycmVudCkgJiYgKHZhbHVlICE9PSB1bmRlZmluZWQgfHwgaGFzKHN0YXRlLmJhc2VfLCBwcm9wKSkpXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdH1cblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0c3RhdGUuY29weV8hW3Byb3BdID0gdmFsdWVcblx0XHRzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSB0cnVlXG5cdFx0cmV0dXJuIHRydWVcblx0fSxcblx0ZGVsZXRlUHJvcGVydHkoc3RhdGUsIHByb3A6IHN0cmluZykge1xuXHRcdC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cdFx0aWYgKHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApICE9PSB1bmRlZmluZWQgfHwgcHJvcCBpbiBzdGF0ZS5iYXNlXykge1xuXHRcdFx0c3RhdGUuYXNzaWduZWRfW3Byb3BdID0gZmFsc2Vcblx0XHRcdHByZXBhcmVDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGlmIGFuIG9yaWdpbmFsbHkgbm90IGFzc2lnbmVkIHByb3BlcnR5IHdhcyBkZWxldGVkXG5cdFx0XHRkZWxldGUgc3RhdGUuYXNzaWduZWRfW3Byb3BdXG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRpZiAoc3RhdGUuY29weV8pIGRlbGV0ZSBzdGF0ZS5jb3B5X1twcm9wXVxuXHRcdHJldHVybiB0cnVlXG5cdH0sXG5cdC8vIE5vdGU6IFdlIG5ldmVyIGNvZXJjZSBgZGVzYy52YWx1ZWAgaW50byBhbiBJbW1lciBkcmFmdCwgYmVjYXVzZSB3ZSBjYW4ndCBtYWtlXG5cdC8vIHRoZSBzYW1lIGd1YXJhbnRlZSBpbiBFUzUgbW9kZS5cblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHN0YXRlLCBwcm9wKSB7XG5cdFx0Y29uc3Qgb3duZXIgPSBsYXRlc3Qoc3RhdGUpXG5cdFx0Y29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG93bmVyLCBwcm9wKVxuXHRcdGlmICghZGVzYykgcmV0dXJuIGRlc2Ncblx0XHRyZXR1cm4ge1xuXHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHN0YXRlLnR5cGVfICE9PSBQcm94eVR5cGVQcm94eUFycmF5IHx8IHByb3AgIT09IFwibGVuZ3RoXCIsXG5cdFx0XHRlbnVtZXJhYmxlOiBkZXNjLmVudW1lcmFibGUsXG5cdFx0XHR2YWx1ZTogb3duZXJbcHJvcF1cblx0XHR9XG5cdH0sXG5cdGRlZmluZVByb3BlcnR5KCkge1xuXHRcdGRpZSgxMSlcblx0fSxcblx0Z2V0UHJvdG90eXBlT2Yoc3RhdGUpIHtcblx0XHRyZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0YXRlLmJhc2VfKVxuXHR9LFxuXHRzZXRQcm90b3R5cGVPZigpIHtcblx0XHRkaWUoMTIpXG5cdH1cbn1cblxuLyoqXG4gKiBBcnJheSBkcmFmdHNcbiAqL1xuXG5jb25zdCBhcnJheVRyYXBzOiBQcm94eUhhbmRsZXI8W1Byb3h5QXJyYXlTdGF0ZV0+ID0ge31cbmVhY2gob2JqZWN0VHJhcHMsIChrZXksIGZuKSA9PiB7XG5cdC8vIEB0cy1pZ25vcmVcblx0YXJyYXlUcmFwc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0YXJndW1lbnRzWzBdID0gYXJndW1lbnRzWzBdWzBdXG5cdFx0cmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fVxufSlcbmFycmF5VHJhcHMuZGVsZXRlUHJvcGVydHkgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCkge1xuXHRpZiAoX19ERVZfXyAmJiBpc05hTihwYXJzZUludChwcm9wIGFzIGFueSkpKSBkaWUoMTMpXG5cdHJldHVybiBvYmplY3RUcmFwcy5kZWxldGVQcm9wZXJ0eSEuY2FsbCh0aGlzLCBzdGF0ZVswXSwgcHJvcClcbn1cbmFycmF5VHJhcHMuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHByb3AsIHZhbHVlKSB7XG5cdGlmIChfX0RFVl9fICYmIHByb3AgIT09IFwibGVuZ3RoXCIgJiYgaXNOYU4ocGFyc2VJbnQocHJvcCBhcyBhbnkpKSkgZGllKDE0KVxuXHRyZXR1cm4gb2JqZWN0VHJhcHMuc2V0IS5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wLCB2YWx1ZSwgc3RhdGVbMF0pXG59XG5cbi8vIEFjY2VzcyBhIHByb3BlcnR5IHdpdGhvdXQgY3JlYXRpbmcgYW4gSW1tZXIgZHJhZnQuXG5mdW5jdGlvbiBwZWVrKGRyYWZ0OiBEcmFmdGVkLCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBzdGF0ZSA9IGRyYWZ0W0RSQUZUX1NUQVRFXVxuXHRjb25zdCBzb3VyY2UgPSBzdGF0ZSA/IGxhdGVzdChzdGF0ZSkgOiBkcmFmdFxuXHRyZXR1cm4gc291cmNlW3Byb3BdXG59XG5cbmZ1bmN0aW9uIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlOiBJbW1lclN0YXRlLCBzb3VyY2U6IGFueSwgcHJvcDogUHJvcGVydHlLZXkpIHtcblx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8oc291cmNlLCBwcm9wKVxuXHRyZXR1cm4gZGVzY1xuXHRcdD8gYHZhbHVlYCBpbiBkZXNjXG5cdFx0XHQ/IGRlc2MudmFsdWVcblx0XHRcdDogLy8gVGhpcyBpcyBhIHZlcnkgc3BlY2lhbCBjYXNlLCBpZiB0aGUgcHJvcCBpcyBhIGdldHRlciBkZWZpbmVkIGJ5IHRoZVxuXHRcdFx0ICAvLyBwcm90b3R5cGUsIHdlIHNob3VsZCBpbnZva2UgaXQgd2l0aCB0aGUgZHJhZnQgYXMgY29udGV4dCFcblx0XHRcdCAgZGVzYy5nZXQ/LmNhbGwoc3RhdGUuZHJhZnRfKVxuXHRcdDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGdldERlc2NyaXB0b3JGcm9tUHJvdG8oXG5cdHNvdXJjZTogYW55LFxuXHRwcm9wOiBQcm9wZXJ0eUtleVxuKTogUHJvcGVydHlEZXNjcmlwdG9yIHwgdW5kZWZpbmVkIHtcblx0Ly8gJ2luJyBjaGVja3MgcHJvdG8hXG5cdGlmICghKHByb3AgaW4gc291cmNlKSkgcmV0dXJuIHVuZGVmaW5lZFxuXHRsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlKVxuXHR3aGlsZSAocHJvdG8pIHtcblx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgcHJvcClcblx0XHRpZiAoZGVzYykgcmV0dXJuIGRlc2Ncblx0XHRwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bylcblx0fVxuXHRyZXR1cm4gdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQ2hhbmdlZChzdGF0ZTogSW1tZXJTdGF0ZSkge1xuXHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdHN0YXRlLm1vZGlmaWVkXyA9IHRydWVcblx0XHRpZiAoc3RhdGUucGFyZW50Xykge1xuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUucGFyZW50Xylcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDb3B5KHN0YXRlOiB7YmFzZV86IGFueTsgY29weV86IGFueX0pIHtcblx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdHN0YXRlLmNvcHlfID0gc2hhbGxvd0NvcHkoc3RhdGUuYmFzZV8pXG5cdH1cbn1cbiIsImltcG9ydCB7XG5cdElQcm9kdWNlV2l0aFBhdGNoZXMsXG5cdElQcm9kdWNlLFxuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRpc0RyYWZ0YWJsZSxcblx0cHJvY2Vzc1Jlc3VsdCxcblx0UGF0Y2gsXG5cdE9iamVjdGlzaCxcblx0RFJBRlRfU1RBVEUsXG5cdERyYWZ0LFxuXHRQYXRjaExpc3RlbmVyLFxuXHRpc0RyYWZ0LFxuXHRpc01hcCxcblx0aXNTZXQsXG5cdGNyZWF0ZVByb3h5UHJveHksXG5cdGdldFBsdWdpbixcblx0ZGllLFxuXHRoYXNQcm94aWVzLFxuXHRpc01pbmlmaWVkLFxuXHRlbnRlclNjb3BlLFxuXHRyZXZva2VTY29wZSxcblx0bGVhdmVTY29wZSxcblx0dXNlUGF0Y2hlc0luU2NvcGUsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0Tk9USElORyxcblx0ZnJlZXplLFxuXHRjdXJyZW50XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmludGVyZmFjZSBQcm9kdWNlcnNGbnMge1xuXHRwcm9kdWNlOiBJUHJvZHVjZVxuXHRwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXNcbn1cblxuZXhwb3J0IGNsYXNzIEltbWVyIGltcGxlbWVudHMgUHJvZHVjZXJzRm5zIHtcblx0dXNlUHJveGllc186IGJvb2xlYW4gPSBoYXNQcm94aWVzXG5cblx0YXV0b0ZyZWV6ZV86IGJvb2xlYW4gPSBfX0RFVl9fID8gdHJ1ZSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA6ICFpc01pbmlmaWVkXG5cblx0Y29uc3RydWN0b3IoY29uZmlnPzoge3VzZVByb3hpZXM/OiBib29sZWFuOyBhdXRvRnJlZXplPzogYm9vbGVhbn0pIHtcblx0XHRpZiAodHlwZW9mIGNvbmZpZz8udXNlUHJveGllcyA9PT0gXCJib29sZWFuXCIpXG5cdFx0XHR0aGlzLnNldFVzZVByb3hpZXMoY29uZmlnIS51c2VQcm94aWVzKVxuXHRcdGlmICh0eXBlb2YgY29uZmlnPy5hdXRvRnJlZXplID09PSBcImJvb2xlYW5cIilcblx0XHRcdHRoaXMuc2V0QXV0b0ZyZWV6ZShjb25maWchLmF1dG9GcmVlemUpXG5cdFx0dGhpcy5wcm9kdWNlID0gdGhpcy5wcm9kdWNlLmJpbmQodGhpcylcblx0XHR0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyA9IHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzLmJpbmQodGhpcylcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHByb2R1Y2VgIGZ1bmN0aW9uIHRha2VzIGEgdmFsdWUgYW5kIGEgXCJyZWNpcGUgZnVuY3Rpb25cIiAod2hvc2Vcblx0ICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG5cdCAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxuXHQgKiBvbmx5IGV2ZXIgYXBwbGllZCB0byBhIF9fY29weV9fIG9mIHRoZSBiYXNlIHN0YXRlLlxuXHQgKlxuXHQgKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3Vcblx0ICogZnJvbSBwYXNzaW5nIHRoZSByZWNpcGUgZnVuY3Rpb24gZXZlcnkgdGltZS5cblx0ICpcblx0ICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXG5cdCAqIGNvbnNpZGVyZWQgdW5jb3B5YWJsZS5cblx0ICpcblx0ICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gcGF0Y2hMaXN0ZW5lciAtIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdGhlIHBhdGNoZXMgcHJvZHVjZWQgaGVyZVxuXHQgKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcblx0ICovXG5cdHByb2R1Y2UoYmFzZTogYW55LCByZWNpcGU/OiBhbnksIHBhdGNoTGlzdGVuZXI/OiBhbnkpIHtcblx0XHQvLyBjdXJyaWVkIGludm9jYXRpb25cblx0XHRpZiAodHlwZW9mIGJhc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdGNvbnN0IGRlZmF1bHRCYXNlID0gcmVjaXBlXG5cdFx0XHRyZWNpcGUgPSBiYXNlXG5cblx0XHRcdGNvbnN0IHNlbGYgPSB0aGlzXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gY3VycmllZFByb2R1Y2UoXG5cdFx0XHRcdHRoaXM6IGFueSxcblx0XHRcdFx0YmFzZSA9IGRlZmF1bHRCYXNlLFxuXHRcdFx0XHQuLi5hcmdzOiBhbnlbXVxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybiBzZWxmLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PiByZWNpcGUuY2FsbCh0aGlzLCBkcmFmdCwgLi4uYXJncykpIC8vIHByZXR0aWVyLWlnbm9yZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YgcmVjaXBlICE9PSBcImZ1bmN0aW9uXCIpIGRpZSg2KVxuXHRcdGlmIChwYXRjaExpc3RlbmVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHBhdGNoTGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIilcblx0XHRcdGRpZSg3KVxuXG5cdFx0bGV0IHJlc3VsdFxuXG5cdFx0Ly8gT25seSBwbGFpbiBvYmplY3RzLCBhcnJheXMsIGFuZCBcImltbWVyYWJsZSBjbGFzc2VzXCIgYXJlIGRyYWZ0ZWQuXG5cdFx0aWYgKGlzRHJhZnRhYmxlKGJhc2UpKSB7XG5cdFx0XHRjb25zdCBzY29wZSA9IGVudGVyU2NvcGUodGhpcylcblx0XHRcdGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKVxuXHRcdFx0bGV0IGhhc0Vycm9yID0gdHJ1ZVxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzdWx0ID0gcmVjaXBlKHByb3h5KVxuXHRcdFx0XHRoYXNFcnJvciA9IGZhbHNlXG5cdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHQvLyBmaW5hbGx5IGluc3RlYWQgb2YgY2F0Y2ggKyByZXRocm93IGJldHRlciBwcmVzZXJ2ZXMgb3JpZ2luYWwgc3RhY2tcblx0XHRcdFx0aWYgKGhhc0Vycm9yKSByZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0ZWxzZSBsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdFx0fVxuXHRcdFx0aWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdC50aGVuKFxuXHRcdFx0XHRcdHJlc3VsdCA9PiB7XG5cdFx0XHRcdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdFx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRlcnJvciA9PiB7XG5cdFx0XHRcdFx0XHRyZXZva2VTY29wZShzY29wZSlcblx0XHRcdFx0XHRcdHRocm93IGVycm9yXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHJlc3VsdCwgc2NvcGUpXG5cdFx0fSBlbHNlIGlmICghYmFzZSB8fCB0eXBlb2YgYmFzZSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0cmVzdWx0ID0gcmVjaXBlKGJhc2UpXG5cdFx0XHRpZiAocmVzdWx0ID09PSBOT1RISU5HKSByZXR1cm4gdW5kZWZpbmVkXG5cdFx0XHRpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHJlc3VsdCA9IGJhc2Vcblx0XHRcdGlmICh0aGlzLmF1dG9GcmVlemVfKSBmcmVlemUocmVzdWx0LCB0cnVlKVxuXHRcdFx0cmV0dXJuIHJlc3VsdFxuXHRcdH0gZWxzZSBkaWUoMjEsIGJhc2UpXG5cdH1cblxuXHRwcm9kdWNlV2l0aFBhdGNoZXMoYXJnMTogYW55LCBhcmcyPzogYW55LCBhcmczPzogYW55KTogYW55IHtcblx0XHRpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0cmV0dXJuIChzdGF0ZTogYW55LCAuLi5hcmdzOiBhbnlbXSkgPT5cblx0XHRcdFx0dGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMoc3RhdGUsIChkcmFmdDogYW55KSA9PiBhcmcxKGRyYWZ0LCAuLi5hcmdzKSlcblx0XHR9XG5cblx0XHRsZXQgcGF0Y2hlczogUGF0Y2hbXSwgaW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHRjb25zdCBuZXh0U3RhdGUgPSB0aGlzLnByb2R1Y2UoYXJnMSwgYXJnMiwgKHA6IFBhdGNoW10sIGlwOiBQYXRjaFtdKSA9PiB7XG5cdFx0XHRwYXRjaGVzID0gcFxuXHRcdFx0aW52ZXJzZVBhdGNoZXMgPSBpcFxuXHRcdH0pXG5cdFx0cmV0dXJuIFtuZXh0U3RhdGUsIHBhdGNoZXMhLCBpbnZlcnNlUGF0Y2hlcyFdXG5cdH1cblxuXHRjcmVhdGVEcmFmdDxUIGV4dGVuZHMgT2JqZWN0aXNoPihiYXNlOiBUKTogRHJhZnQ8VD4ge1xuXHRcdGlmICghaXNEcmFmdGFibGUoYmFzZSkpIGRpZSg4KVxuXHRcdGlmIChpc0RyYWZ0KGJhc2UpKSBiYXNlID0gY3VycmVudChiYXNlKVxuXHRcdGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKVxuXHRcdGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkodGhpcywgYmFzZSwgdW5kZWZpbmVkKVxuXHRcdHByb3h5W0RSQUZUX1NUQVRFXS5pc01hbnVhbF8gPSB0cnVlXG5cdFx0bGVhdmVTY29wZShzY29wZSlcblx0XHRyZXR1cm4gcHJveHkgYXMgYW55XG5cdH1cblxuXHRmaW5pc2hEcmFmdDxEIGV4dGVuZHMgRHJhZnQ8YW55Pj4oXG5cdFx0ZHJhZnQ6IEQsXG5cdFx0cGF0Y2hMaXN0ZW5lcj86IFBhdGNoTGlzdGVuZXJcblx0KTogRCBleHRlbmRzIERyYWZ0PGluZmVyIFQ+ID8gVCA6IG5ldmVyIHtcblx0XHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IGRyYWZ0ICYmIChkcmFmdCBhcyBhbnkpW0RSQUZUX1NUQVRFXVxuXHRcdGlmIChfX0RFVl9fKSB7XG5cdFx0XHRpZiAoIXN0YXRlIHx8ICFzdGF0ZS5pc01hbnVhbF8pIGRpZSg5KVxuXHRcdFx0aWYgKHN0YXRlLmZpbmFsaXplZF8pIGRpZSgxMClcblx0XHR9XG5cdFx0Y29uc3Qge3Njb3BlXzogc2NvcGV9ID0gc3RhdGVcblx0XHR1c2VQYXRjaGVzSW5TY29wZShzY29wZSwgcGF0Y2hMaXN0ZW5lcilcblx0XHRyZXR1cm4gcHJvY2Vzc1Jlc3VsdCh1bmRlZmluZWQsIHNjb3BlKVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbi5cblx0ICovXG5cdHNldEF1dG9GcmVlemUodmFsdWU6IGJvb2xlYW4pIHtcblx0XHR0aGlzLmF1dG9GcmVlemVfID0gdmFsdWVcblx0fVxuXG5cdC8qKlxuXHQgKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcblx0ICogYWx3YXlzIGZhc3RlciB0aGFuIHVzaW5nIEVTNSBwcm94aWVzLlxuXHQgKlxuXHQgKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cblx0ICovXG5cdHNldFVzZVByb3hpZXModmFsdWU6IGJvb2xlYW4pIHtcblx0XHRpZiAodmFsdWUgJiYgIWhhc1Byb3hpZXMpIHtcblx0XHRcdGRpZSgyMClcblx0XHR9XG5cdFx0dGhpcy51c2VQcm94aWVzXyA9IHZhbHVlXG5cdH1cblxuXHRhcHBseVBhdGNoZXMoYmFzZTogT2JqZWN0aXNoLCBwYXRjaGVzOiBQYXRjaFtdKSB7XG5cdFx0Ly8gSWYgYSBwYXRjaCByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCB0YWtlIHRoYXQgcmVwbGFjZW1lbnQgYXMgYmFzZVxuXHRcdC8vIGJlZm9yZSBhcHBseWluZyBwYXRjaGVzXG5cdFx0bGV0IGk6IG51bWJlclxuXHRcdGZvciAoaSA9IHBhdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IHBhdGNoID0gcGF0Y2hlc1tpXVxuXHRcdFx0aWYgKHBhdGNoLnBhdGgubGVuZ3RoID09PSAwICYmIHBhdGNoLm9wID09PSBcInJlcGxhY2VcIikge1xuXHRcdFx0XHRiYXNlID0gcGF0Y2gudmFsdWVcblx0XHRcdFx0YnJlYWtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb25zdCBhcHBseVBhdGNoZXNJbXBsID0gZ2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5hcHBseVBhdGNoZXNfXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIHtcblx0XHRcdC8vIE4uQjogbmV2ZXIgaGl0cyBpZiBzb21lIHBhdGNoIGEgcmVwbGFjZW1lbnQsIHBhdGNoZXMgYXJlIG5ldmVyIGRyYWZ0c1xuXHRcdFx0cmV0dXJuIGFwcGx5UGF0Y2hlc0ltcGwoYmFzZSwgcGF0Y2hlcylcblx0XHR9XG5cdFx0Ly8gT3RoZXJ3aXNlLCBwcm9kdWNlIGEgY29weSBvZiB0aGUgYmFzZSBzdGF0ZS5cblx0XHRyZXR1cm4gdGhpcy5wcm9kdWNlKGJhc2UsIChkcmFmdDogRHJhZnRlZCkgPT5cblx0XHRcdGFwcGx5UGF0Y2hlc0ltcGwoZHJhZnQsIHBhdGNoZXMuc2xpY2UoaSArIDEpKVxuXHRcdClcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJveHk8VCBleHRlbmRzIE9iamVjdGlzaD4oXG5cdGltbWVyOiBJbW1lcixcblx0dmFsdWU6IFQsXG5cdHBhcmVudD86IEltbWVyU3RhdGVcbik6IERyYWZ0ZWQ8VCwgSW1tZXJTdGF0ZT4ge1xuXHQvLyBwcmVjb25kaXRpb246IGNyZWF0ZVByb3h5IHNob3VsZCBiZSBndWFyZGVkIGJ5IGlzRHJhZnRhYmxlLCBzbyB3ZSBrbm93IHdlIGNhbiBzYWZlbHkgZHJhZnRcblx0Y29uc3QgZHJhZnQ6IERyYWZ0ZWQgPSBpc01hcCh2YWx1ZSlcblx0XHQ/IGdldFBsdWdpbihcIk1hcFNldFwiKS5wcm94eU1hcF8odmFsdWUsIHBhcmVudClcblx0XHQ6IGlzU2V0KHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5U2V0Xyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogaW1tZXIudXNlUHJveGllc19cblx0XHQ/IGNyZWF0ZVByb3h5UHJveHkodmFsdWUsIHBhcmVudClcblx0XHQ6IGdldFBsdWdpbihcIkVTNVwiKS5jcmVhdGVFUzVQcm94eV8odmFsdWUsIHBhcmVudClcblxuXHRjb25zdCBzY29wZSA9IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKVxuXHRzY29wZS5kcmFmdHNfLnB1c2goZHJhZnQpXG5cdHJldHVybiBkcmFmdFxufVxuIiwiaW1wb3J0IHtcblx0ZGllLFxuXHRpc0RyYWZ0LFxuXHRzaGFsbG93Q29weSxcblx0ZWFjaCxcblx0RFJBRlRfU1RBVEUsXG5cdGdldCxcblx0c2V0LFxuXHRJbW1lclN0YXRlLFxuXHRpc0RyYWZ0YWJsZSxcblx0QXJjaHR5cGVNYXAsXG5cdEFyY2h0eXBlU2V0LFxuXHRnZXRBcmNodHlwZSxcblx0Z2V0UGx1Z2luXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbi8qKiBUYWtlcyBhIHNuYXBzaG90IG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIGEgZHJhZnQgYW5kIGZpbmFsaXplcyBpdCAoYnV0IHdpdGhvdXQgZnJlZXppbmcpLiBUaGlzIGlzIGEgZ3JlYXQgdXRpbGl0eSB0byBwcmludCB0aGUgY3VycmVudCBzdGF0ZSBkdXJpbmcgZGVidWdnaW5nIChubyBQcm94aWVzIGluIHRoZSB3YXkpLiBUaGUgb3V0cHV0IG9mIGN1cnJlbnQgY2FuIGFsc28gYmUgc2FmZWx5IGxlYWtlZCBvdXRzaWRlIHRoZSBwcm9kdWNlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50PFQ+KHZhbHVlOiBUKTogVFxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnQodmFsdWU6IGFueSk6IGFueSB7XG5cdGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgyMiwgdmFsdWUpXG5cdHJldHVybiBjdXJyZW50SW1wbCh2YWx1ZSlcbn1cblxuZnVuY3Rpb24gY3VycmVudEltcGwodmFsdWU6IGFueSk6IGFueSB7XG5cdGlmICghaXNEcmFmdGFibGUodmFsdWUpKSByZXR1cm4gdmFsdWVcblx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgfCB1bmRlZmluZWQgPSB2YWx1ZVtEUkFGVF9TVEFURV1cblx0bGV0IGNvcHk6IGFueVxuXHRjb25zdCBhcmNoVHlwZSA9IGdldEFyY2h0eXBlKHZhbHVlKVxuXHRpZiAoc3RhdGUpIHtcblx0XHRpZiAoXG5cdFx0XHQhc3RhdGUubW9kaWZpZWRfICYmXG5cdFx0XHQoc3RhdGUudHlwZV8gPCA0IHx8ICFnZXRQbHVnaW4oXCJFUzVcIikuaGFzQ2hhbmdlc18oc3RhdGUgYXMgYW55KSlcblx0XHQpXG5cdFx0XHRyZXR1cm4gc3RhdGUuYmFzZV9cblx0XHQvLyBPcHRpbWl6YXRpb246IGF2b2lkIGdlbmVyYXRpbmcgbmV3IGRyYWZ0cyBkdXJpbmcgY29weWluZ1xuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSB0cnVlXG5cdFx0Y29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKVxuXHRcdHN0YXRlLmZpbmFsaXplZF8gPSBmYWxzZVxuXHR9IGVsc2Uge1xuXHRcdGNvcHkgPSBjb3B5SGVscGVyKHZhbHVlLCBhcmNoVHlwZSlcblx0fVxuXG5cdGVhY2goY29weSwgKGtleSwgY2hpbGRWYWx1ZSkgPT4ge1xuXHRcdGlmIChzdGF0ZSAmJiBnZXQoc3RhdGUuYmFzZV8sIGtleSkgPT09IGNoaWxkVmFsdWUpIHJldHVybiAvLyBubyBuZWVkIHRvIGNvcHkgb3Igc2VhcmNoIGluIHNvbWV0aGluZyB0aGF0IGRpZG4ndCBjaGFuZ2Vcblx0XHRzZXQoY29weSwga2V5LCBjdXJyZW50SW1wbChjaGlsZFZhbHVlKSlcblx0fSlcblx0Ly8gSW4gdGhlIGZ1dHVyZSwgd2UgbWlnaHQgY29uc2lkZXIgZnJlZXppbmcgaGVyZSwgYmFzZWQgb24gdGhlIGN1cnJlbnQgc2V0dGluZ3Ncblx0cmV0dXJuIGFyY2hUeXBlID09PSBBcmNodHlwZVNldCA/IG5ldyBTZXQoY29weSkgOiBjb3B5XG59XG5cbmZ1bmN0aW9uIGNvcHlIZWxwZXIodmFsdWU6IGFueSwgYXJjaFR5cGU6IG51bWJlcik6IGFueSB7XG5cdC8vIGNyZWF0ZXMgYSBzaGFsbG93IGNvcHksIGV2ZW4gaWYgaXQgaXMgYSBtYXAgb3Igc2V0XG5cdHN3aXRjaCAoYXJjaFR5cGUpIHtcblx0XHRjYXNlIEFyY2h0eXBlTWFwOlxuXHRcdFx0cmV0dXJuIG5ldyBNYXAodmFsdWUpXG5cdFx0Y2FzZSBBcmNodHlwZVNldDpcblx0XHRcdC8vIFNldCB3aWxsIGJlIGNsb25lZCBhcyBhcnJheSB0ZW1wb3JhcmlseSwgc28gdGhhdCB3ZSBjYW4gcmVwbGFjZSBpbmRpdmlkdWFsIGl0ZW1zXG5cdFx0XHRyZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSlcblx0fVxuXHRyZXR1cm4gc2hhbGxvd0NvcHkodmFsdWUpXG59XG4iLCJpbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRFUzVBcnJheVN0YXRlLFxuXHRFUzVPYmplY3RTdGF0ZSxcblx0ZWFjaCxcblx0aGFzLFxuXHRpc0RyYWZ0LFxuXHRsYXRlc3QsXG5cdERSQUZUX1NUQVRFLFxuXHRpcyxcblx0bG9hZFBsdWdpbixcblx0SW1tZXJTY29wZSxcblx0UHJveHlUeXBlRVM1QXJyYXksXG5cdFByb3h5VHlwZUVTNU9iamVjdCxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRkaWUsXG5cdG1hcmtDaGFuZ2VkLFxuXHRvYmplY3RUcmFwcyxcblx0b3duS2V5cyxcblx0Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yc1xufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG50eXBlIEVTNVN0YXRlID0gRVM1QXJyYXlTdGF0ZSB8IEVTNU9iamVjdFN0YXRlXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVFUzUoKSB7XG5cdGZ1bmN0aW9uIHdpbGxGaW5hbGl6ZUVTNV8oXG5cdFx0c2NvcGU6IEltbWVyU2NvcGUsXG5cdFx0cmVzdWx0OiBhbnksXG5cdFx0aXNSZXBsYWNlZDogYm9vbGVhblxuXHQpIHtcblx0XHRpZiAoIWlzUmVwbGFjZWQpIHtcblx0XHRcdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdFx0XHRtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KHNjb3BlLmRyYWZ0c18hWzBdKVxuXHRcdFx0fVxuXHRcdFx0Ly8gVGhpcyBpcyBmYXN0ZXIgd2hlbiB3ZSBkb24ndCBjYXJlIGFib3V0IHdoaWNoIGF0dHJpYnV0ZXMgY2hhbmdlZC5cblx0XHRcdG1hcmtDaGFuZ2VzU3dlZXAoc2NvcGUuZHJhZnRzXylcblx0XHR9XG5cdFx0Ly8gV2hlbiBhIGNoaWxkIGRyYWZ0IGlzIHJldHVybmVkLCBsb29rIGZvciBjaGFuZ2VzLlxuXHRcdGVsc2UgaWYgKFxuXHRcdFx0aXNEcmFmdChyZXN1bHQpICYmXG5cdFx0XHQocmVzdWx0W0RSQUZUX1NUQVRFXSBhcyBFUzVTdGF0ZSkuc2NvcGVfID09PSBzY29wZVxuXHRcdCkge1xuXHRcdFx0bWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXk6IGJvb2xlYW4sIGJhc2U6IGFueSkge1xuXHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRjb25zdCBkcmFmdCA9IG5ldyBBcnJheShiYXNlLmxlbmd0aClcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZS5sZW5ndGg7IGkrKylcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBcIlwiICsgaSwgcHJveHlQcm9wZXJ0eShpLCB0cnVlKSlcblx0XHRcdHJldHVybiBkcmFmdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSlcblx0XHRcdGRlbGV0ZSBkZXNjcmlwdG9yc1tEUkFGVF9TVEFURSBhcyBhbnldXG5cdFx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkZXNjcmlwdG9ycylcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBrZXk6IGFueSA9IGtleXNbaV1cblx0XHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHByb3h5UHJvcGVydHkoXG5cdFx0XHRcdFx0a2V5LFxuXHRcdFx0XHRcdGlzQXJyYXkgfHwgISFkZXNjcmlwdG9yc1trZXldLmVudW1lcmFibGVcblx0XHRcdFx0KVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2UpLCBkZXNjcmlwdG9ycylcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0YmFzZTogVCxcblx0XHRwYXJlbnQ/OiBJbW1lclN0YXRlXG5cdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPiB7XG5cdFx0Y29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoYmFzZSlcblx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZUVTNURyYWZ0KGlzQXJyYXksIGJhc2UpXG5cblx0XHRjb25zdCBzdGF0ZTogRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlID0ge1xuXHRcdFx0dHlwZV86IGlzQXJyYXkgPyBQcm94eVR5cGVFUzVBcnJheSA6IChQcm94eVR5cGVFUzVPYmplY3QgYXMgYW55KSxcblx0XHRcdHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpLFxuXHRcdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0YXNzaWduZWRfOiB7fSxcblx0XHRcdHBhcmVudF86IHBhcmVudCxcblx0XHRcdC8vIGJhc2UgaXMgdGhlIG9iamVjdCB3ZSBhcmUgZHJhZnRpbmdcblx0XHRcdGJhc2VfOiBiYXNlLFxuXHRcdFx0Ly8gZHJhZnQgaXMgdGhlIGRyYWZ0IG9iamVjdCBpdHNlbGYsIHRoYXQgdHJhcHMgYWxsIHJlYWRzIGFuZCByZWFkcyBmcm9tIGVpdGhlciB0aGUgYmFzZSAoaWYgdW5tb2RpZmllZCkgb3IgY29weSAoaWYgbW9kaWZpZWQpXG5cdFx0XHRkcmFmdF86IGRyYWZ0LFxuXHRcdFx0Y29weV86IG51bGwsXG5cdFx0XHRyZXZva2VkXzogZmFsc2UsXG5cdFx0XHRpc01hbnVhbF86IGZhbHNlXG5cdFx0fVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRyYWZ0LCBEUkFGVF9TVEFURSwge1xuXHRcdFx0dmFsdWU6IHN0YXRlLFxuXHRcdFx0Ly8gZW51bWVyYWJsZTogZmFsc2UgPC0gdGhlIGRlZmF1bHRcblx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0fSlcblx0XHRyZXR1cm4gZHJhZnRcblx0fVxuXG5cdC8vIHByb3BlcnR5IGRlc2NyaXB0b3JzIGFyZSByZWN5Y2xlZCB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgY3JlYXRlIGEgZ2V0IGFuZCBzZXQgY2xvc3VyZSBwZXIgcHJvcGVydHksXG5cdC8vIGJ1dCBzaGFyZSB0aGVtIGFsbCBpbnN0ZWFkXG5cdGNvbnN0IGRlc2NyaXB0b3JzOiB7W3Byb3A6IHN0cmluZ106IFByb3BlcnR5RGVzY3JpcHRvcn0gPSB7fVxuXG5cdGZ1bmN0aW9uIHByb3h5UHJvcGVydHkoXG5cdFx0cHJvcDogc3RyaW5nIHwgbnVtYmVyLFxuXHRcdGVudW1lcmFibGU6IGJvb2xlYW5cblx0KTogUHJvcGVydHlEZXNjcmlwdG9yIHtcblx0XHRsZXQgZGVzYyA9IGRlc2NyaXB0b3JzW3Byb3BdXG5cdFx0aWYgKGRlc2MpIHtcblx0XHRcdGRlc2MuZW51bWVyYWJsZSA9IGVudW1lcmFibGVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzY3JpcHRvcnNbcHJvcF0gPSBkZXNjID0ge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGVudW1lcmFibGUsXG5cdFx0XHRcdGdldCh0aGlzOiBhbnkpIHtcblx0XHRcdFx0XHRjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRcdFx0aWYgKF9fREVWX18pIGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0cmV0dXJuIG9iamVjdFRyYXBzLmdldChzdGF0ZSwgcHJvcClcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0KHRoaXM6IGFueSwgdmFsdWUpIHtcblx0XHRcdFx0XHRjb25zdCBzdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRcdFx0aWYgKF9fREVWX18pIGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdFx0b2JqZWN0VHJhcHMuc2V0KHN0YXRlLCBwcm9wLCB2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzY1xuXHR9XG5cblx0Ly8gVGhpcyBsb29rcyBleHBlbnNpdmUsIGJ1dCBvbmx5IHByb3hpZXMgYXJlIHZpc2l0ZWQsIGFuZCBvbmx5IG9iamVjdHMgd2l0aG91dCBrbm93biBjaGFuZ2VzIGFyZSBzY2FubmVkLlxuXHRmdW5jdGlvbiBtYXJrQ2hhbmdlc1N3ZWVwKGRyYWZ0czogRHJhZnRlZDxhbnksIEltbWVyU3RhdGU+W10pIHtcblx0XHQvLyBUaGUgbmF0dXJhbCBvcmRlciBvZiBkcmFmdHMgaW4gdGhlIGBzY29wZWAgYXJyYXkgaXMgYmFzZWQgb24gd2hlbiB0aGV5XG5cdFx0Ly8gd2VyZSBhY2Nlc3NlZC4gQnkgcHJvY2Vzc2luZyBkcmFmdHMgaW4gcmV2ZXJzZSBuYXR1cmFsIG9yZGVyLCB3ZSBoYXZlIGFcblx0XHQvLyBiZXR0ZXIgY2hhbmNlIG9mIHByb2Nlc3NpbmcgbGVhZiBub2RlcyBmaXJzdC4gV2hlbiBhIGxlYWYgbm9kZSBpcyBrbm93biB0b1xuXHRcdC8vIGhhdmUgY2hhbmdlZCwgd2UgY2FuIGF2b2lkIGFueSB0cmF2ZXJzYWwgb2YgaXRzIGFuY2VzdG9yIG5vZGVzLlxuXHRcdGZvciAobGV0IGkgPSBkcmFmdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBFUzVTdGF0ZSA9IGRyYWZ0c1tpXVtEUkFGVF9TVEFURV1cblx0XHRcdGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG5cdFx0XHRcdHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcblx0XHRcdFx0XHRjYXNlIFByb3h5VHlwZUVTNUFycmF5OlxuXHRcdFx0XHRcdFx0aWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSkpIG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHRjYXNlIFByb3h5VHlwZUVTNU9iamVjdDpcblx0XHRcdFx0XHRcdGlmIChoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbWFya0NoYW5nZXNSZWN1cnNpdmVseShvYmplY3Q6IGFueSkge1xuXHRcdGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09IFwib2JqZWN0XCIpIHJldHVyblxuXHRcdGNvbnN0IHN0YXRlOiBFUzVTdGF0ZSB8IHVuZGVmaW5lZCA9IG9iamVjdFtEUkFGVF9TVEFURV1cblx0XHRpZiAoIXN0YXRlKSByZXR1cm5cblx0XHRjb25zdCB7YmFzZV8sIGRyYWZ0XywgYXNzaWduZWRfLCB0eXBlX30gPSBzdGF0ZVxuXHRcdGlmICh0eXBlXyA9PT0gUHJveHlUeXBlRVM1T2JqZWN0KSB7XG5cdFx0XHQvLyBMb29rIGZvciBhZGRlZCBrZXlzLlxuXHRcdFx0Ly8gcHJvYmFibHkgdGhlcmUgaXMgYSBmYXN0ZXIgd2F5IHRvIGRldGVjdCBjaGFuZ2VzLCBhcyBzd2VlcCArIHJlY3Vyc2Ugc2VlbXMgdG8gZG8gc29tZVxuXHRcdFx0Ly8gdW5uZWNlc3Nhcnkgd29yay5cblx0XHRcdC8vIGFsc286IHByb2JhYmx5IHdlIGNhbiBzdG9yZSB0aGUgaW5mb3JtYXRpb24gd2UgZGV0ZWN0IGhlcmUsIHRvIHNwZWVkIHVwIHRyZWUgZmluYWxpemF0aW9uIVxuXHRcdFx0ZWFjaChkcmFmdF8sIGtleSA9PiB7XG5cdFx0XHRcdGlmICgoa2V5IGFzIGFueSkgPT09IERSQUZUX1NUQVRFKSByZXR1cm5cblx0XHRcdFx0Ly8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblx0XHRcdFx0aWYgKChiYXNlXyBhcyBhbnkpW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGJhc2VfLCBrZXkpKSB7XG5cdFx0XHRcdFx0YXNzaWduZWRfW2tleV0gPSB0cnVlXG5cdFx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdH0gZWxzZSBpZiAoIWFzc2lnbmVkX1trZXldKSB7XG5cdFx0XHRcdFx0Ly8gT25seSB1bnRvdWNoZWQgcHJvcGVydGllcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cblx0XHRcdFx0XHRtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1trZXldKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdFx0Ly8gTG9vayBmb3IgcmVtb3ZlZCBrZXlzLlxuXHRcdFx0ZWFjaChiYXNlXywga2V5ID0+IHtcblx0XHRcdFx0Ly8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblx0XHRcdFx0aWYgKGRyYWZ0X1trZXldID09PSB1bmRlZmluZWQgJiYgIWhhcyhkcmFmdF8sIGtleSkpIHtcblx0XHRcdFx0XHRhc3NpZ25lZF9ba2V5XSA9IGZhbHNlXG5cdFx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fSBlbHNlIGlmICh0eXBlXyA9PT0gUHJveHlUeXBlRVM1QXJyYXkpIHtcblx0XHRcdGlmIChoYXNBcnJheUNoYW5nZXMoc3RhdGUgYXMgRVM1QXJyYXlTdGF0ZSkpIHtcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdGFzc2lnbmVkXy5sZW5ndGggPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdGlmIChkcmFmdF8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSBkcmFmdF8ubGVuZ3RoOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIGFzc2lnbmVkX1tpXSA9IGZhbHNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgZHJhZnRfLmxlbmd0aDsgaSsrKSBhc3NpZ25lZF9baV0gPSB0cnVlXG5cdFx0XHR9XG5cblx0XHRcdC8vIE1pbmltdW0gY291bnQgaXMgZW5vdWdoLCB0aGUgb3RoZXIgcGFydHMgaGFzIGJlZW4gcHJvY2Vzc2VkLlxuXHRcdFx0Y29uc3QgbWluID0gTWF0aC5taW4oZHJhZnRfLmxlbmd0aCwgYmFzZV8ubGVuZ3RoKVxuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG5cdFx0XHRcdC8vIE9ubHkgdW50b3VjaGVkIGluZGljZXMgdHJpZ2dlciByZWN1cnNpb24uXG5cdFx0XHRcdGlmIChhc3NpZ25lZF9baV0gPT09IHVuZGVmaW5lZCkgbWFya0NoYW5nZXNSZWN1cnNpdmVseShkcmFmdF9baV0pXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzT2JqZWN0Q2hhbmdlcyhzdGF0ZTogRVM1T2JqZWN0U3RhdGUpIHtcblx0XHRjb25zdCB7YmFzZV8sIGRyYWZ0X30gPSBzdGF0ZVxuXG5cdFx0Ly8gU2VhcmNoIGZvciBhZGRlZCBrZXlzIGFuZCBjaGFuZ2VkIGtleXMuIFN0YXJ0IGF0IHRoZSBiYWNrLCBiZWNhdXNlXG5cdFx0Ly8gbm9uLW51bWVyaWMga2V5cyBhcmUgb3JkZXJlZCBieSB0aW1lIG9mIGRlZmluaXRpb24gb24gdGhlIG9iamVjdC5cblx0XHRjb25zdCBrZXlzID0gb3duS2V5cyhkcmFmdF8pXG5cdFx0Zm9yIChsZXQgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGNvbnN0IGtleTogYW55ID0ga2V5c1tpXVxuXHRcdFx0aWYgKGtleSA9PT0gRFJBRlRfU1RBVEUpIGNvbnRpbnVlXG5cdFx0XHRjb25zdCBiYXNlVmFsdWUgPSBiYXNlX1trZXldXG5cdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0aWYgKGJhc2VWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdH1cblx0XHRcdC8vIE9uY2UgYSBiYXNlIGtleSBpcyBkZWxldGVkLCBmdXR1cmUgY2hhbmdlcyBnbyB1bmRldGVjdGVkLCBiZWNhdXNlIGl0c1xuXHRcdFx0Ly8gZGVzY3JpcHRvciBpcyBlcmFzZWQuIFRoaXMgYnJhbmNoIGRldGVjdHMgYW55IG1pc3NlZCBjaGFuZ2VzLlxuXHRcdFx0ZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZHJhZnRfW2tleV1cblx0XHRcdFx0Y29uc3Qgc3RhdGU6IEltbWVyU3RhdGUgPSB2YWx1ZSAmJiB2YWx1ZVtEUkFGVF9TVEFURV1cblx0XHRcdFx0aWYgKHN0YXRlID8gc3RhdGUuYmFzZV8gIT09IGJhc2VWYWx1ZSA6ICFpcyh2YWx1ZSwgYmFzZVZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBdCB0aGlzIHBvaW50LCBubyBrZXlzIHdlcmUgYWRkZWQgb3IgY2hhbmdlZC5cblx0XHQvLyBDb21wYXJlIGtleSBjb3VudCB0byBkZXRlcm1pbmUgaWYga2V5cyB3ZXJlIGRlbGV0ZWQuXG5cdFx0Y29uc3QgYmFzZUlzRHJhZnQgPSAhIWJhc2VfW0RSQUZUX1NUQVRFIGFzIGFueV1cblx0XHRyZXR1cm4ga2V5cy5sZW5ndGggIT09IG93bktleXMoYmFzZV8pLmxlbmd0aCArIChiYXNlSXNEcmFmdCA/IDAgOiAxKSAvLyArIDEgdG8gY29ycmVjdCBmb3IgRFJBRlRfU1RBVEVcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0FycmF5Q2hhbmdlcyhzdGF0ZTogRVM1QXJyYXlTdGF0ZSkge1xuXHRcdGNvbnN0IHtkcmFmdF99ID0gc3RhdGVcblx0XHRpZiAoZHJhZnRfLmxlbmd0aCAhPT0gc3RhdGUuYmFzZV8ubGVuZ3RoKSByZXR1cm4gdHJ1ZVxuXHRcdC8vIFNlZSAjMTE2XG5cdFx0Ly8gSWYgd2UgZmlyc3Qgc2hvcnRlbiB0aGUgbGVuZ3RoLCBvdXIgYXJyYXkgaW50ZXJjZXB0b3JzIHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQvLyBJZiBhZnRlciB0aGF0IG5ldyBpdGVtcyBhcmUgYWRkZWQsIHJlc3VsdCBpbiB0aGUgc2FtZSBvcmlnaW5hbCBsZW5ndGgsXG5cdFx0Ly8gdGhvc2UgbGFzdCBpdGVtcyB3aWxsIGhhdmUgbm8gaW50ZXJjZXB0aW5nIHByb3BlcnR5LlxuXHRcdC8vIFNvIGlmIHRoZXJlIGlzIG5vIG93biBkZXNjcmlwdG9yIG9uIHRoZSBsYXN0IHBvc2l0aW9uLCB3ZSBrbm93IHRoYXQgaXRlbXMgd2VyZSByZW1vdmVkIGFuZCBhZGRlZFxuXHRcdC8vIE4uQi46IHNwbGljZSwgdW5zaGlmdCwgZXRjIG9ubHkgc2hpZnQgdmFsdWVzIGFyb3VuZCwgYnV0IG5vdCBwcm9wIGRlc2NyaXB0b3JzLCBzbyB3ZSBvbmx5IGhhdmUgdG8gY2hlY2tcblx0XHQvLyB0aGUgbGFzdCBvbmVcblx0XHRjb25zdCBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcblx0XHRcdGRyYWZ0Xyxcblx0XHRcdGRyYWZ0Xy5sZW5ndGggLSAxXG5cdFx0KVxuXHRcdC8vIGRlc2NyaXB0b3IgY2FuIGJlIG51bGwsIGJ1dCBvbmx5IGZvciBuZXdseSBjcmVhdGVkIHNwYXJzZSBhcnJheXMsIGVnLiBuZXcgQXJyYXkoMTApXG5cdFx0aWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZ2V0KSByZXR1cm4gdHJ1ZVxuXHRcdC8vIEZvciBhbGwgb3RoZXIgY2FzZXMsIHdlIGRvbid0IGhhdmUgdG8gY29tcGFyZSwgYXMgdGhleSB3b3VsZCBoYXZlIGJlZW4gcGlja2VkIHVwIGJ5IHRoZSBpbmRleCBzZXR0ZXJzXG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRmdW5jdGlvbiBoYXNDaGFuZ2VzXyhzdGF0ZTogRVM1U3RhdGUpIHtcblx0XHRyZXR1cm4gc3RhdGUudHlwZV8gPT09IFByb3h5VHlwZUVTNU9iamVjdFxuXHRcdFx0PyBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlKVxuXHRcdFx0OiBoYXNBcnJheUNoYW5nZXMoc3RhdGUpXG5cdH1cblxuXHRmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGU6IGFueSAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovKSB7XG5cdFx0aWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpXG5cdH1cblxuXHRsb2FkUGx1Z2luKFwiRVM1XCIsIHtcblx0XHRjcmVhdGVFUzVQcm94eV8sXG5cdFx0d2lsbEZpbmFsaXplRVM1Xyxcblx0XHRoYXNDaGFuZ2VzX1xuXHR9KVxufVxuIiwiaW1wb3J0IHtcblx0SW1tZXJTdGF0ZSxcblx0UGF0Y2gsXG5cdFNldFN0YXRlLFxuXHRFUzVBcnJheVN0YXRlLFxuXHRQcm94eUFycmF5U3RhdGUsXG5cdE1hcFN0YXRlLFxuXHRFUzVPYmplY3RTdGF0ZSxcblx0UHJveHlPYmplY3RTdGF0ZSxcblx0UGF0Y2hQYXRoLFxuXHRnZXQsXG5cdGVhY2gsXG5cdGhhcyxcblx0Z2V0QXJjaHR5cGUsXG5cdGlzU2V0LFxuXHRpc01hcCxcblx0bG9hZFBsdWdpbixcblx0UHJveHlUeXBlUHJveHlPYmplY3QsXG5cdFByb3h5VHlwZUVTNU9iamVjdCxcblx0UHJveHlUeXBlTWFwLFxuXHRQcm94eVR5cGVFUzVBcnJheSxcblx0UHJveHlUeXBlUHJveHlBcnJheSxcblx0UHJveHlUeXBlU2V0LFxuXHRBcmNodHlwZU1hcCxcblx0QXJjaHR5cGVTZXQsXG5cdEFyY2h0eXBlQXJyYXksXG5cdGRpZSxcblx0aXNEcmFmdCxcblx0aXNEcmFmdGFibGVcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVBhdGNoZXMoKSB7XG5cdGNvbnN0IFJFUExBQ0UgPSBcInJlcGxhY2VcIlxuXHRjb25zdCBBREQgPSBcImFkZFwiXG5cdGNvbnN0IFJFTU9WRSA9IFwicmVtb3ZlXCJcblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNfKFxuXHRcdHN0YXRlOiBJbW1lclN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpOiB2b2lkIHtcblx0XHRzd2l0Y2ggKHN0YXRlLnR5cGVfKSB7XG5cdFx0XHRjYXNlIFByb3h5VHlwZVByb3h5T2JqZWN0OlxuXHRcdFx0Y2FzZSBQcm94eVR5cGVFUzVPYmplY3Q6XG5cdFx0XHRjYXNlIFByb3h5VHlwZU1hcDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRcdFx0XHRzdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHRcdGNhc2UgUHJveHlUeXBlRVM1QXJyYXk6XG5cdFx0XHRjYXNlIFByb3h5VHlwZVByb3h5QXJyYXk6XG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhzdGF0ZSwgYmFzZVBhdGgsIHBhdGNoZXMsIGludmVyc2VQYXRjaGVzKVxuXHRcdFx0Y2FzZSBQcm94eVR5cGVTZXQ6XG5cdFx0XHRcdHJldHVybiBnZW5lcmF0ZVNldFBhdGNoZXMoXG5cdFx0XHRcdFx0KHN0YXRlIGFzIGFueSkgYXMgU2V0U3RhdGUsXG5cdFx0XHRcdFx0YmFzZVBhdGgsXG5cdFx0XHRcdFx0cGF0Y2hlcyxcblx0XHRcdFx0XHRpbnZlcnNlUGF0Y2hlc1xuXHRcdFx0XHQpXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVBcnJheVBhdGNoZXMoXG5cdFx0c3RhdGU6IEVTNUFycmF5U3RhdGUgfCBQcm94eUFycmF5U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGxldCB7YmFzZV8sIGFzc2lnbmVkX30gPSBzdGF0ZVxuXHRcdGxldCBjb3B5XyA9IHN0YXRlLmNvcHlfIVxuXG5cdFx0Ly8gUmVkdWNlIGNvbXBsZXhpdHkgYnkgZW5zdXJpbmcgYGJhc2VgIGlzIG5ldmVyIGxvbmdlci5cblx0XHRpZiAoY29weV8ubGVuZ3RoIDwgYmFzZV8ubGVuZ3RoKSB7XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHQ7W2Jhc2VfLCBjb3B5X10gPSBbY29weV8sIGJhc2VfXVxuXHRcdFx0O1twYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gPSBbaW52ZXJzZVBhdGNoZXMsIHBhdGNoZXNdXG5cdFx0fVxuXG5cdFx0Ly8gUHJvY2VzcyByZXBsYWNlZCBpbmRpY2VzLlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZV8ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChhc3NpZ25lZF9baV0gJiYgY29weV9baV0gIT09IGJhc2VfW2ldKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0Ly8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIHRoZSBiYXNlL2NvcHkgaW52ZXJzaW9uIGF0IHRoZSBzdGFydCBvZiB0aGlzIGZ1bmN0aW9uXG5cdFx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChiYXNlX1tpXSlcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIGFkZGVkIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IGJhc2VfLmxlbmd0aDsgaSA8IGNvcHlfLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdG9wOiBBREQsXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdC8vIE5lZWQgdG8gbWF5YmUgY2xvbmUgaXQsIGFzIGl0IGNhbiBpbiBmYWN0IGJlIHRoZSBvcmlnaW5hbCB2YWx1ZVxuXHRcdFx0XHQvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGNvcHlfW2ldKVxuXHRcdFx0fSlcblx0XHR9XG5cdFx0aWYgKGJhc2VfLmxlbmd0aCA8IGNvcHlfLmxlbmd0aCkge1xuXHRcdFx0aW52ZXJzZVBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRwYXRoOiBiYXNlUGF0aC5jb25jYXQoW1wibGVuZ3RoXCJdKSxcblx0XHRcdFx0dmFsdWU6IGJhc2VfLmxlbmd0aFxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHQvLyBUaGlzIGlzIHVzZWQgZm9yIGJvdGggTWFwIG9iamVjdHMgYW5kIG5vcm1hbCBvYmplY3RzLlxuXHRmdW5jdGlvbiBnZW5lcmF0ZVBhdGNoZXNGcm9tQXNzaWduZWQoXG5cdFx0c3RhdGU6IE1hcFN0YXRlIHwgRVM1T2JqZWN0U3RhdGUgfCBQcm94eU9iamVjdFN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpIHtcblx0XHRjb25zdCB7YmFzZV8sIGNvcHlffSA9IHN0YXRlXG5cdFx0ZWFjaChzdGF0ZS5hc3NpZ25lZF8hLCAoa2V5LCBhc3NpZ25lZFZhbHVlKSA9PiB7XG5cdFx0XHRjb25zdCBvcmlnVmFsdWUgPSBnZXQoYmFzZV8sIGtleSlcblx0XHRcdGNvbnN0IHZhbHVlID0gZ2V0KGNvcHlfISwga2V5KVxuXHRcdFx0Y29uc3Qgb3AgPSAhYXNzaWduZWRWYWx1ZSA/IFJFTU9WRSA6IGhhcyhiYXNlXywga2V5KSA/IFJFUExBQ0UgOiBBRERcblx0XHRcdGlmIChvcmlnVmFsdWUgPT09IHZhbHVlICYmIG9wID09PSBSRVBMQUNFKSByZXR1cm5cblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoa2V5IGFzIGFueSlcblx0XHRcdHBhdGNoZXMucHVzaChvcCA9PT0gUkVNT1ZFID8ge29wLCBwYXRofSA6IHtvcCwgcGF0aCwgdmFsdWV9KVxuXHRcdFx0aW52ZXJzZVBhdGNoZXMucHVzaChcblx0XHRcdFx0b3AgPT09IEFERFxuXHRcdFx0XHRcdD8ge29wOiBSRU1PVkUsIHBhdGh9XG5cdFx0XHRcdFx0OiBvcCA9PT0gUkVNT1ZFXG5cdFx0XHRcdFx0PyB7b3A6IEFERCwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSl9XG5cdFx0XHRcdFx0OiB7b3A6IFJFUExBQ0UsIHBhdGgsIHZhbHVlOiBjbG9uZVBhdGNoVmFsdWVJZk5lZWRlZChvcmlnVmFsdWUpfVxuXHRcdFx0KVxuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVNldFBhdGNoZXMoXG5cdFx0c3RhdGU6IFNldFN0YXRlLFxuXHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpIHtcblx0XHRsZXQge2Jhc2VfLCBjb3B5X30gPSBzdGF0ZVxuXG5cdFx0bGV0IGkgPSAwXG5cdFx0YmFzZV8uZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xuXHRcdFx0aWYgKCFjb3B5XyEuaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdFx0aW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG5cdFx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRpKytcblx0XHR9KVxuXHRcdGkgPSAwXG5cdFx0Y29weV8hLmZvckVhY2goKHZhbHVlOiBhbnkpID0+IHtcblx0XHRcdGlmICghYmFzZV8uaGFzKHZhbHVlKSkge1xuXHRcdFx0XHRjb25zdCBwYXRoID0gYmFzZVBhdGguY29uY2F0KFtpXSlcblx0XHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdFx0aW52ZXJzZVBhdGNoZXMudW5zaGlmdCh7XG5cdFx0XHRcdFx0b3A6IFJFTU9WRSxcblx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0XHRpKytcblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdHJvb3RTdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRyZXBsYWNlbWVudDogYW55LFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KTogdm9pZCB7XG5cdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0cGF0aDogW10sXG5cdFx0XHR2YWx1ZTogcmVwbGFjZW1lbnRcblx0XHR9KVxuXHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRwYXRoOiBbXSxcblx0XHRcdHZhbHVlOiByb290U3RhdGUuYmFzZV9cblx0XHR9KVxuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlQYXRjaGVzXzxUPihkcmFmdDogVCwgcGF0Y2hlczogUGF0Y2hbXSk6IFQge1xuXHRcdHBhdGNoZXMuZm9yRWFjaChwYXRjaCA9PiB7XG5cdFx0XHRjb25zdCB7cGF0aCwgb3B9ID0gcGF0Y2hcblxuXHRcdFx0bGV0IGJhc2U6IGFueSA9IGRyYWZ0XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG5cdFx0XHRcdGJhc2UgPSBnZXQoYmFzZSwgcGF0aFtpXSlcblx0XHRcdFx0aWYgKHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSBkaWUoMTUsIHBhdGguam9pbihcIi9cIikpXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHR5cGUgPSBnZXRBcmNodHlwZShiYXNlKVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKHBhdGNoLnZhbHVlKSAvLyB1c2VkIHRvIGNsb25lIHBhdGNoIHRvIGVuc3VyZSBvcmlnaW5hbCBwYXRjaCBpcyBub3QgbW9kaWZpZWQsIHNlZSAjNDExXG5cdFx0XHRjb25zdCBrZXkgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1cblx0XHRcdHN3aXRjaCAob3ApIHtcblx0XHRcdFx0Y2FzZSBSRVBMQUNFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZU1hcDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZVNldDpcblx0XHRcdFx0XHRcdFx0ZGllKDE2KVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Ly8gaWYgdmFsdWUgaXMgYW4gb2JqZWN0LCB0aGVuIGl0J3MgYXNzaWduZWQgYnkgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRcdC8vIGluIHRoZSBmb2xsb3dpbmcgYWRkIG9yIHJlbW92ZSBvcHMsIHRoZSB2YWx1ZSBmaWVsZCBpbnNpZGUgdGhlIHBhdGNoIHdpbGwgYWxzbyBiZSBtb2RpZnllZFxuXHRcdFx0XHRcdFx0XHQvLyBzbyB3ZSB1c2UgdmFsdWUgZnJvbSB0aGUgY2xvbmVkIHBhdGNoXG5cdFx0XHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChiYXNlW2tleV0gPSB2YWx1ZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgQUREOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZUFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMCwgdmFsdWUpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGVTZXQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLmFkZCh2YWx1ZSlcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdHJldHVybiAoYmFzZVtrZXldID0gdmFsdWUpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRjYXNlIFJFTU9WRTpcblx0XHRcdFx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGVBcnJheTpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2Uuc3BsaWNlKGtleSBhcyBhbnksIDEpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUoa2V5KVxuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZVNldDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuZGVsZXRlKHBhdGNoLnZhbHVlKVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGRlbGV0ZSBiYXNlW2tleV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZGllKDE3LCBvcClcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0cmV0dXJuIGRyYWZ0XG5cdH1cblxuXHQvLyBvcHRpbWl6ZTogdGhpcyBpcyBxdWl0ZSBhIHBlcmZvcm1hbmNlIGhpdCwgY2FuIHdlIGRldGVjdCBpbnRlbGxpZ2VudGx5IHdoZW4gaXQgaXMgbmVlZGVkP1xuXHQvLyBFLmcuIGF1dG8tZHJhZnQgd2hlbiBuZXcgb2JqZWN0cyBmcm9tIG91dHNpZGUgYXJlIGFzc2lnbmVkIGFuZCBtb2RpZmllZD9cblx0Ly8gKFNlZSBmYWlsaW5nIHRlc3Qgd2hlbiBkZWVwQ2xvbmUganVzdCByZXR1cm5zIG9iailcblx0ZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZTxUPihvYmo6IFQpOiBUXG5cdGZ1bmN0aW9uIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqOiBhbnkpIHtcblx0XHRpZiAoIWlzRHJhZnRhYmxlKG9iaikpIHJldHVybiBvYmpcblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmopKSByZXR1cm4gb2JqLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKVxuXHRcdGlmIChpc01hcChvYmopKVxuXHRcdFx0cmV0dXJuIG5ldyBNYXAoXG5cdFx0XHRcdEFycmF5LmZyb20ob2JqLmVudHJpZXMoKSkubWFwKChbaywgdl0pID0+IFtrLCBkZWVwQ2xvbmVQYXRjaFZhbHVlKHYpXSlcblx0XHRcdClcblx0XHRpZiAoaXNTZXQob2JqKSkgcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShvYmopLm1hcChkZWVwQ2xvbmVQYXRjaFZhbHVlKSlcblx0XHRjb25zdCBjbG9uZWQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKVxuXHRcdGZvciAoY29uc3Qga2V5IGluIG9iaikgY2xvbmVkW2tleV0gPSBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9ialtrZXldKVxuXHRcdHJldHVybiBjbG9uZWRcblx0fVxuXG5cdGZ1bmN0aW9uIGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkPFQ+KG9iajogVCk6IFQge1xuXHRcdGlmIChpc0RyYWZ0KG9iaikpIHtcblx0XHRcdHJldHVybiBkZWVwQ2xvbmVQYXRjaFZhbHVlKG9iailcblx0XHR9IGVsc2UgcmV0dXJuIG9ialxuXHR9XG5cblx0bG9hZFBsdWdpbihcIlBhdGNoZXNcIiwge1xuXHRcdGFwcGx5UGF0Y2hlc18sXG5cdFx0Z2VuZXJhdGVQYXRjaGVzXyxcblx0XHRnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc19cblx0fSlcbn1cbiIsIi8vIHR5cGVzIG9ubHkhXG5pbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHRBbnlNYXAsXG5cdEFueVNldCxcblx0TWFwU3RhdGUsXG5cdFNldFN0YXRlLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHRsYXRlc3QsXG5cdGl0ZXJhdG9yU3ltYm9sLFxuXHRpc0RyYWZ0YWJsZSxcblx0Y3JlYXRlUHJveHksXG5cdGxvYWRQbHVnaW4sXG5cdG1hcmtDaGFuZ2VkLFxuXHRQcm94eVR5cGVNYXAsXG5cdFByb3h5VHlwZVNldCxcblx0ZGllLFxuXHRlYWNoXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVNYXBTZXQoKSB7XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZDogYW55LCBiOiBhbnkpOiBhbnkge1xuXHRcdGV4dGVuZFN0YXRpY3MgPVxuXHRcdFx0T2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdFx0XHQoe19fcHJvdG9fXzogW119IGluc3RhbmNlb2YgQXJyYXkgJiZcblx0XHRcdFx0ZnVuY3Rpb24oZCwgYikge1xuXHRcdFx0XHRcdGQuX19wcm90b19fID0gYlxuXHRcdFx0XHR9KSB8fFxuXHRcdFx0ZnVuY3Rpb24oZCwgYikge1xuXHRcdFx0XHRmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXVxuXHRcdFx0fVxuXHRcdHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpXG5cdH1cblxuXHQvLyBVZ2x5IGhhY2sgdG8gcmVzb2x2ZSAjNTAyIGFuZCBpbmhlcml0IGJ1aWx0IGluIE1hcCAvIFNldFxuXHRmdW5jdGlvbiBfX2V4dGVuZHMoZDogYW55LCBiOiBhbnkpOiBhbnkge1xuXHRcdGV4dGVuZFN0YXRpY3MoZCwgYilcblx0XHRmdW5jdGlvbiBfXyh0aGlzOiBhbnkpOiBhbnkge1xuXHRcdFx0dGhpcy5jb25zdHJ1Y3RvciA9IGRcblx0XHR9XG5cdFx0ZC5wcm90b3R5cGUgPVxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0KChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSksIG5ldyBfXygpKVxuXHR9XG5cblx0Y29uc3QgRHJhZnRNYXAgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKERyYWZ0TWFwLCBfc3VwZXIpXG5cdFx0Ly8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cdFx0ZnVuY3Rpb24gRHJhZnRNYXAodGhpczogYW55LCB0YXJnZXQ6IEFueU1hcCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IGFueSB7XG5cdFx0XHR0aGlzW0RSQUZUX1NUQVRFXSA9IHtcblx0XHRcdFx0dHlwZV86IFByb3h5VHlwZU1hcCxcblx0XHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0XHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0XHRjb3B5XzogdW5kZWZpbmVkLFxuXHRcdFx0XHRhc3NpZ25lZF86IHVuZGVmaW5lZCxcblx0XHRcdFx0YmFzZV86IHRhcmdldCxcblx0XHRcdFx0ZHJhZnRfOiB0aGlzIGFzIGFueSxcblx0XHRcdFx0aXNNYW51YWxfOiBmYWxzZSxcblx0XHRcdFx0cmV2b2tlZF86IGZhbHNlXG5cdFx0XHR9IGFzIE1hcFN0YXRlXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHRjb25zdCBwID0gRHJhZnRNYXAucHJvdG90eXBlXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemVcblx0XHRcdH1cblx0XHRcdC8vIGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdFx0Ly8gY29uZmlndXJhYmxlOiB0cnVlXG5cdFx0fSlcblxuXHRcdHAuaGFzID0gZnVuY3Rpb24oa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmhhcyhrZXkpXG5cdFx0fVxuXG5cdFx0cC5zZXQgPSBmdW5jdGlvbihrZXk6IGFueSwgdmFsdWU6IGFueSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmICghbGF0ZXN0KHN0YXRlKS5oYXMoa2V5KSB8fCBsYXRlc3Qoc3RhdGUpLmdldChrZXkpICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRwcmVwYXJlTWFwQ29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgdHJ1ZSlcblx0XHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIHRydWUpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblxuXHRcdHAuZGVsZXRlID0gZnVuY3Rpb24oa2V5OiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGlmICghdGhpcy5oYXMoa2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIGZhbHNlKVxuXHRcdFx0c3RhdGUuY29weV8hLmRlbGV0ZShrZXkpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblxuXHRcdHAuY2xlYXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRpZiAobGF0ZXN0KHN0YXRlKS5zaXplKSB7XG5cdFx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpXG5cdFx0XHRcdGVhY2goc3RhdGUuYmFzZV8sIGtleSA9PiB7XG5cdFx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCBmYWxzZSlcblx0XHRcdFx0fSlcblx0XHRcdFx0c3RhdGUuY29weV8hLmNsZWFyKClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRwLmZvckVhY2ggPSBmdW5jdGlvbihcblx0XHRcdGNiOiAodmFsdWU6IGFueSwga2V5OiBhbnksIHNlbGY6IGFueSkgPT4gdm9pZCxcblx0XHRcdHRoaXNBcmc/OiBhbnlcblx0XHQpIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRsYXRlc3Qoc3RhdGUpLmZvckVhY2goKF92YWx1ZTogYW55LCBrZXk6IGFueSwgX21hcDogYW55KSA9PiB7XG5cdFx0XHRcdGNiLmNhbGwodGhpc0FyZywgdGhpcy5nZXQoa2V5KSwga2V5LCB0aGlzKVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRwLmdldCA9IGZ1bmN0aW9uKGtleTogYW55KTogYW55IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBNYXBTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSlcblx0XHRcdGlmIChzdGF0ZS5maW5hbGl6ZWRfIHx8ICFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0XHR9XG5cdFx0XHRpZiAodmFsdWUgIT09IHN0YXRlLmJhc2VfLmdldChrZXkpKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZSAvLyBlaXRoZXIgYWxyZWFkeSBkcmFmdGVkIG9yIHJlYXNzaWduZWRcblx0XHRcdH1cblx0XHRcdC8vIGRlc3BpdGUgd2hhdCBpdCBsb29rcywgdGhpcyBjcmVhdGVzIGEgZHJhZnQgb25seSBvbmNlLCBzZWUgYWJvdmUgY29uZGl0aW9uXG5cdFx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSlcblx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0c3RhdGUuY29weV8hLnNldChrZXksIGRyYWZ0KVxuXHRcdFx0cmV0dXJuIGRyYWZ0XG5cdFx0fVxuXG5cdFx0cC5rZXlzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLmtleXMoKVxuXHRcdH1cblxuXHRcdHAudmFsdWVzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKClcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFtpdGVyYXRvclN5bWJvbF06ICgpID0+IHRoaXMudmFsdWVzKCksXG5cdFx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRpZiAoci5kb25lKSByZXR1cm4gclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBhcyBhbnlcblx0XHR9XG5cblx0XHRwLmVudHJpZXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPFthbnksIGFueV0+IHtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5rZXlzKClcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFtpdGVyYXRvclN5bWJvbF06ICgpID0+IHRoaXMuZW50cmllcygpLFxuXHRcdFx0XHRuZXh0OiAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRcdFx0aWYgKHIuZG9uZSkgcmV0dXJuIHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHIudmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGRvbmU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IFtyLnZhbHVlLCB2YWx1ZV1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gYXMgYW55XG5cdFx0fVxuXG5cdFx0cFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLmVudHJpZXMoKVxuXHRcdH1cblxuXHRcdHJldHVybiBEcmFmdE1hcFxuXHR9KShNYXApXG5cblx0ZnVuY3Rpb24gcHJveHlNYXBfPFQgZXh0ZW5kcyBBbnlNYXA+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFQge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gbmV3IERyYWZ0TWFwKHRhcmdldCwgcGFyZW50KVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZU1hcENvcHkoc3RhdGU6IE1hcFN0YXRlKSB7XG5cdFx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdFx0c3RhdGUuYXNzaWduZWRfID0gbmV3IE1hcCgpXG5cdFx0XHRzdGF0ZS5jb3B5XyA9IG5ldyBNYXAoc3RhdGUuYmFzZV8pXG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgRHJhZnRTZXQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG5cdFx0X19leHRlbmRzKERyYWZ0U2V0LCBfc3VwZXIpXG5cdFx0Ly8gQ3JlYXRlIGNsYXNzIG1hbnVhbGx5LCBjYXVzZSAjNTAyXG5cdFx0ZnVuY3Rpb24gRHJhZnRTZXQodGhpczogYW55LCB0YXJnZXQ6IEFueVNldCwgcGFyZW50PzogSW1tZXJTdGF0ZSkge1xuXHRcdFx0dGhpc1tEUkFGVF9TVEFURV0gPSB7XG5cdFx0XHRcdHR5cGVfOiBQcm94eVR5cGVTZXQsXG5cdFx0XHRcdHBhcmVudF86IHBhcmVudCxcblx0XHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCkhLFxuXHRcdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0XHRmaW5hbGl6ZWRfOiBmYWxzZSxcblx0XHRcdFx0Y29weV86IHVuZGVmaW5lZCxcblx0XHRcdFx0YmFzZV86IHRhcmdldCxcblx0XHRcdFx0ZHJhZnRfOiB0aGlzLFxuXHRcdFx0XHRkcmFmdHNfOiBuZXcgTWFwKCksXG5cdFx0XHRcdHJldm9rZWRfOiBmYWxzZSxcblx0XHRcdFx0aXNNYW51YWxfOiBmYWxzZVxuXHRcdFx0fSBhcyBTZXRTdGF0ZVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0Y29uc3QgcCA9IERyYWZ0U2V0LnByb3RvdHlwZVxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHAsIFwic2l6ZVwiLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbGF0ZXN0KHRoaXNbRFJBRlRfU1RBVEVdKS5zaXplXG5cdFx0XHR9XG5cdFx0XHQvLyBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdH0pXG5cblx0XHRwLmhhcyA9IGZ1bmN0aW9uKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHQvLyBiaXQgb2YgdHJpY2tlcnkgaGVyZSwgdG8gYmUgYWJsZSB0byByZWNvZ25pemUgYm90aCB0aGUgdmFsdWUsIGFuZCB0aGUgZHJhZnQgb2YgaXRzIHZhbHVlXG5cdFx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZS5iYXNlXy5oYXModmFsdWUpXG5cdFx0XHR9XG5cdFx0XHRpZiAoc3RhdGUuY29weV8uaGFzKHZhbHVlKSkgcmV0dXJuIHRydWVcblx0XHRcdGlmIChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSkgJiYgc3RhdGUuY29weV8uaGFzKHN0YXRlLmRyYWZ0c18uZ2V0KHZhbHVlKSkpXG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cblx0XHRwLmFkZCA9IGZ1bmN0aW9uKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmICghdGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuY29weV8hLmFkZCh2YWx1ZSlcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0cC5kZWxldGUgPSBmdW5jdGlvbih2YWx1ZTogYW55KTogYW55IHtcblx0XHRcdGlmICghdGhpcy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdHJldHVybiAoXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5kZWxldGUodmFsdWUpIHx8XG5cdFx0XHRcdChzdGF0ZS5kcmFmdHNfLmhhcyh2YWx1ZSlcblx0XHRcdFx0XHQ/IHN0YXRlLmNvcHlfIS5kZWxldGUoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKVxuXHRcdFx0XHRcdDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZmFsc2UpXG5cdFx0XHQpXG5cdFx0fVxuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcblx0XHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuY2xlYXIoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHAudmFsdWVzID0gZnVuY3Rpb24oKTogSXRlcmFibGVJdGVyYXRvcjxhbnk+IHtcblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdHJldHVybiBzdGF0ZS5jb3B5XyEudmFsdWVzKClcblx0XHR9XG5cblx0XHRwLmVudHJpZXMgPSBmdW5jdGlvbiBlbnRyaWVzKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W2FueSwgYW55XT4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0cmV0dXJuIHN0YXRlLmNvcHlfIS5lbnRyaWVzKClcblx0XHR9XG5cblx0XHRwLmtleXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzKClcblx0XHR9XG5cblx0XHRwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudmFsdWVzKClcblx0XHR9XG5cblx0XHRwLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGNiOiBhbnksIHRoaXNBcmc/OiBhbnkpIHtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gdGhpcy52YWx1ZXMoKVxuXHRcdFx0bGV0IHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0d2hpbGUgKCFyZXN1bHQuZG9uZSkge1xuXHRcdFx0XHRjYi5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgcmVzdWx0LnZhbHVlLCB0aGlzKVxuXHRcdFx0XHRyZXN1bHQgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gRHJhZnRTZXRcblx0fSkoU2V0KVxuXG5cdGZ1bmN0aW9uIHByb3h5U2V0XzxUIGV4dGVuZHMgQW55U2V0Pih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUIHtcblx0XHQvLyBAdHMtaWdub3JlXG5cdFx0cmV0dXJuIG5ldyBEcmFmdFNldCh0YXJnZXQsIHBhcmVudClcblx0fVxuXG5cdGZ1bmN0aW9uIHByZXBhcmVTZXRDb3B5KHN0YXRlOiBTZXRTdGF0ZSkge1xuXHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdC8vIGNyZWF0ZSBkcmFmdHMgZm9yIGFsbCBlbnRyaWVzIHRvIHByZXNlcnZlIGluc2VydGlvbiBvcmRlclxuXHRcdFx0c3RhdGUuY29weV8gPSBuZXcgU2V0KClcblx0XHRcdHN0YXRlLmJhc2VfLmZvckVhY2godmFsdWUgPT4ge1xuXHRcdFx0XHRpZiAoaXNEcmFmdGFibGUodmFsdWUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgZHJhZnQgPSBjcmVhdGVQcm94eShzdGF0ZS5zY29wZV8uaW1tZXJfLCB2YWx1ZSwgc3RhdGUpXG5cdFx0XHRcdFx0c3RhdGUuZHJhZnRzXy5zZXQodmFsdWUsIGRyYWZ0KVxuXHRcdFx0XHRcdHN0YXRlLmNvcHlfIS5hZGQoZHJhZnQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdGUuY29weV8hLmFkZCh2YWx1ZSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhc3NlcnRVbnJldm9rZWQoc3RhdGU6IGFueSAvKkVTNVN0YXRlIHwgTWFwU3RhdGUgfCBTZXRTdGF0ZSovKSB7XG5cdFx0aWYgKHN0YXRlLnJldm9rZWRfKSBkaWUoMywgSlNPTi5zdHJpbmdpZnkobGF0ZXN0KHN0YXRlKSkpXG5cdH1cblxuXHRsb2FkUGx1Z2luKFwiTWFwU2V0XCIsIHtwcm94eU1hcF8sIHByb3h5U2V0X30pXG59XG4iLCJpbXBvcnQge2VuYWJsZUVTNX0gZnJvbSBcIi4vZXM1XCJcbmltcG9ydCB7ZW5hYmxlTWFwU2V0fSBmcm9tIFwiLi9tYXBzZXRcIlxuaW1wb3J0IHtlbmFibGVQYXRjaGVzfSBmcm9tIFwiLi9wYXRjaGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUFsbFBsdWdpbnMoKSB7XG5cdGVuYWJsZUVTNSgpXG5cdGVuYWJsZU1hcFNldCgpXG5cdGVuYWJsZVBhdGNoZXMoKVxufVxuIiwiaW1wb3J0IHtcblx0SVByb2R1Y2UsXG5cdElQcm9kdWNlV2l0aFBhdGNoZXMsXG5cdEltbWVyLFxuXHREcmFmdCxcblx0SW1tdXRhYmxlXG59IGZyb20gXCIuL2ludGVybmFsXCJcblxuZXhwb3J0IHtcblx0RHJhZnQsXG5cdEltbXV0YWJsZSxcblx0UGF0Y2gsXG5cdFBhdGNoTGlzdGVuZXIsXG5cdG9yaWdpbmFsLFxuXHRjdXJyZW50LFxuXHRpc0RyYWZ0LFxuXHRpc0RyYWZ0YWJsZSxcblx0Tk9USElORyBhcyBub3RoaW5nLFxuXHREUkFGVEFCTEUgYXMgaW1tZXJhYmxlXG59IGZyb20gXCIuL2ludGVybmFsXCJcblxuY29uc3QgaW1tZXIgPSBuZXcgSW1tZXIoKVxuXG4vKipcbiAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuICogcmV0dXJuIHZhbHVlIG9mdGVuIGRlcGVuZHMgb24gdGhlIGJhc2Ugc3RhdGUpLiBUaGUgcmVjaXBlIGZ1bmN0aW9uIGlzXG4gKiBmcmVlIHRvIG11dGF0ZSBpdHMgZmlyc3QgYXJndW1lbnQgaG93ZXZlciBpdCB3YW50cy4gQWxsIG11dGF0aW9ucyBhcmVcbiAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG4gKlxuICogUGFzcyBvbmx5IGEgZnVuY3Rpb24gdG8gY3JlYXRlIGEgXCJjdXJyaWVkIHByb2R1Y2VyXCIgd2hpY2ggcmVsaWV2ZXMgeW91XG4gKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuICpcbiAqIE9ubHkgcGxhaW4gb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBtYWRlIG11dGFibGUuIEFsbCBvdGhlciBvYmplY3RzIGFyZVxuICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuICpcbiAqIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgX19ib3VuZF9fIHRvIGl0cyBgSW1tZXJgIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7YW55fSBiYXNlIC0gdGhlIGluaXRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb2R1Y2VyIC0gZnVuY3Rpb24gdGhhdCByZWNlaXZlcyBhIHByb3h5IG9mIHRoZSBiYXNlIHN0YXRlIGFzIGZpcnN0IGFyZ3VtZW50IGFuZCB3aGljaCBjYW4gYmUgZnJlZWx5IG1vZGlmaWVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG4gKiBAcmV0dXJucyB7YW55fSBhIG5ldyBzdGF0ZSwgb3IgdGhlIGluaXRpYWwgc3RhdGUgaWYgbm90aGluZyB3YXMgbW9kaWZpZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y2U6IElQcm9kdWNlID0gaW1tZXIucHJvZHVjZVxuZXhwb3J0IGRlZmF1bHQgcHJvZHVjZVxuXG4vKipcbiAqIExpa2UgYHByb2R1Y2VgLCBidXQgYHByb2R1Y2VXaXRoUGF0Y2hlc2AgYWx3YXlzIHJldHVybnMgYSB0dXBsZVxuICogW25leHRTdGF0ZSwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXNdIChpbnN0ZWFkIG9mIGp1c3QgdGhlIG5leHQgc3RhdGUpXG4gKi9cbmV4cG9ydCBjb25zdCBwcm9kdWNlV2l0aFBhdGNoZXM6IElQcm9kdWNlV2l0aFBhdGNoZXMgPSBpbW1lci5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChcblx0aW1tZXJcbilcblxuLyoqXG4gKiBQYXNzIHRydWUgdG8gYXV0b21hdGljYWxseSBmcmVlemUgYWxsIGNvcGllcyBjcmVhdGVkIGJ5IEltbWVyLlxuICpcbiAqIEJ5IGRlZmF1bHQsIGF1dG8tZnJlZXppbmcgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF1dG9GcmVlemUgPSBpbW1lci5zZXRBdXRvRnJlZXplLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogUGFzcyB0cnVlIHRvIHVzZSB0aGUgRVMyMDE1IGBQcm94eWAgY2xhc3Mgd2hlbiBjcmVhdGluZyBkcmFmdHMsIHdoaWNoIGlzXG4gKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXG4gKlxuICogQnkgZGVmYXVsdCwgZmVhdHVyZSBkZXRlY3Rpb24gaXMgdXNlZCwgc28gY2FsbGluZyB0aGlzIGlzIHJhcmVseSBuZWNlc3NhcnkuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVc2VQcm94aWVzID0gaW1tZXIuc2V0VXNlUHJveGllcy5iaW5kKGltbWVyKVxuXG4vKipcbiAqIEFwcGx5IGFuIGFycmF5IG9mIEltbWVyIHBhdGNoZXMgdG8gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBwcm9kdWNlciwgd2hpY2ggbWVhbnMgY29weS1vbi13cml0ZSBpcyBpbiBlZmZlY3QuXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseVBhdGNoZXMgPSBpbW1lci5hcHBseVBhdGNoZXMuYmluZChpbW1lcilcblxuLyoqXG4gKiBDcmVhdGUgYW4gSW1tZXIgZHJhZnQgZnJvbSB0aGUgZ2l2ZW4gYmFzZSBzdGF0ZSwgd2hpY2ggbWF5IGJlIGEgZHJhZnQgaXRzZWxmLlxuICogVGhlIGRyYWZ0IGNhbiBiZSBtb2RpZmllZCB1bnRpbCB5b3UgZmluYWxpemUgaXQgd2l0aCB0aGUgYGZpbmlzaERyYWZ0YCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURyYWZ0ID0gaW1tZXIuY3JlYXRlRHJhZnQuYmluZChpbW1lcilcblxuLyoqXG4gKiBGaW5hbGl6ZSBhbiBJbW1lciBkcmFmdCBmcm9tIGEgYGNyZWF0ZURyYWZ0YCBjYWxsLCByZXR1cm5pbmcgdGhlIGJhc2Ugc3RhdGVcbiAqIChpZiBubyBjaGFuZ2VzIHdlcmUgbWFkZSkgb3IgYSBtb2RpZmllZCBjb3B5LiBUaGUgZHJhZnQgbXVzdCAqbm90KiBiZVxuICogbXV0YXRlZCBhZnRlcndhcmRzLlxuICpcbiAqIFBhc3MgYSBmdW5jdGlvbiBhcyB0aGUgMm5kIGFyZ3VtZW50IHRvIGdlbmVyYXRlIEltbWVyIHBhdGNoZXMgYmFzZWQgb24gdGhlXG4gKiBjaGFuZ2VzIHRoYXQgd2VyZSBtYWRlLlxuICovXG5leHBvcnQgY29uc3QgZmluaXNoRHJhZnQgPSBpbW1lci5maW5pc2hEcmFmdC5iaW5kKGltbWVyKVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWN0dWFsbHkgYSBuby1vcCwgYnV0IGNhbiBiZSB1c2VkIHRvIGNhc3QgYW4gaW1tdXRhYmxlIHR5cGVcbiAqIHRvIGFuIGRyYWZ0IHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2FzdERyYWZ0PFQ+KHZhbHVlOiBUKTogRHJhZnQ8VD4ge1xuXHRyZXR1cm4gdmFsdWUgYXMgYW55XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhIG11dGFibGUgdHlwZVxuICogdG8gYW4gaW1tdXRhYmxlIHR5cGUgYW5kIG1ha2UgVHlwZVNjcmlwdCBoYXBweVxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXN0SW1tdXRhYmxlPFQ+KHZhbHVlOiBUKTogSW1tdXRhYmxlPFQ+IHtcblx0cmV0dXJuIHZhbHVlIGFzIGFueVxufVxuXG5leHBvcnQge0ltbWVyfVxuXG5leHBvcnQge2VuYWJsZUVTNX0gZnJvbSBcIi4vcGx1Z2lucy9lczVcIlxuZXhwb3J0IHtlbmFibGVQYXRjaGVzfSBmcm9tIFwiLi9wbHVnaW5zL3BhdGNoZXNcIlxuZXhwb3J0IHtlbmFibGVNYXBTZXR9IGZyb20gXCIuL3BsdWdpbnMvbWFwc2V0XCJcbmV4cG9ydCB7ZW5hYmxlQWxsUGx1Z2luc30gZnJvbSBcIi4vcGx1Z2lucy9hbGxcIlxuIiwiLy8gU2hvdWxkIGJlIG5vIGltcG9ydHMgaGVyZSFcblxuLy8gU29tZSB0aGluZ3MgdGhhdCBzaG91bGQgYmUgZXZhbHVhdGVkIGJlZm9yZSBhbGwgZWxzZS4uLlxuXG4vLyBXZSBvbmx5IHdhbnQgdG8ga25vdyBpZiBub24tcG9seWZpbGxlZCBzeW1ib2xzIGFyZSBhdmFpbGFibGVcbmNvbnN0IGhhc1N5bWJvbCA9XG5cdHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIFN5bWJvbChcInhcIikgPT09IFwic3ltYm9sXCJcbmV4cG9ydCBjb25zdCBoYXNNYXAgPSB0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiXG5leHBvcnQgY29uc3QgaGFzU2V0ID0gdHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIlxuZXhwb3J0IGNvbnN0IGhhc1Byb3hpZXMgPVxuXHR0eXBlb2YgUHJveHkgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0dHlwZW9mIFByb3h5LnJldm9jYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHR0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIlxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gbWluaSgpIHt9XG5leHBvcnQgY29uc3QgaXNNaW5pZmllZCA9IG1pbmkubmFtZSAhPT0gXCJtaW5pXCJcblxuLyoqXG4gKiBUaGUgc2VudGluZWwgdmFsdWUgcmV0dXJuZWQgYnkgcHJvZHVjZXJzIHRvIHJlcGxhY2UgdGhlIGRyYWZ0IHdpdGggdW5kZWZpbmVkLlxuICovXG5leHBvcnQgY29uc3QgTk9USElORzogTm90aGluZyA9IGhhc1N5bWJvbFxuXHQ/IFN5bWJvbC5mb3IoXCJpbW1lci1ub3RoaW5nXCIpXG5cdDogKHtbXCJpbW1lci1ub3RoaW5nXCJdOiB0cnVlfSBhcyBhbnkpXG5cbi8qKlxuICogVG8gbGV0IEltbWVyIHRyZWF0IHlvdXIgY2xhc3MgaW5zdGFuY2VzIGFzIHBsYWluIGltbXV0YWJsZSBvYmplY3RzXG4gKiAoYWxiZWl0IHdpdGggYSBjdXN0b20gcHJvdG90eXBlKSwgeW91IG11c3QgZGVmaW5lIGVpdGhlciBhbiBpbnN0YW5jZSBwcm9wZXJ0eVxuICogb3IgYSBzdGF0aWMgcHJvcGVydHkgb24gZWFjaCBvZiB5b3VyIGN1c3RvbSBjbGFzc2VzLlxuICpcbiAqIE90aGVyd2lzZSwgeW91ciBjbGFzcyBpbnN0YW5jZSB3aWxsIG5ldmVyIGJlIGRyYWZ0ZWQsIHdoaWNoIG1lYW5zIGl0IHdvbid0IGJlXG4gKiBzYWZlIHRvIG11dGF0ZSBpbiBhIHByb2R1Y2UgY2FsbGJhY2suXG4gKi9cbmV4cG9ydCBjb25zdCBEUkFGVEFCTEU6IHVuaXF1ZSBzeW1ib2wgPSBoYXNTeW1ib2xcblx0PyBTeW1ib2wuZm9yKFwiaW1tZXItZHJhZnRhYmxlXCIpXG5cdDogKFwiX18kaW1tZXJfZHJhZnRhYmxlXCIgYXMgYW55KVxuXG5leHBvcnQgY29uc3QgRFJBRlRfU1RBVEU6IHVuaXF1ZSBzeW1ib2wgPSBoYXNTeW1ib2xcblx0PyBTeW1ib2wuZm9yKFwiaW1tZXItc3RhdGVcIilcblx0OiAoXCJfXyRpbW1lcl9zdGF0ZVwiIGFzIGFueSlcblxuLy8gRXZlbiBhIHBvbHlmaWxsZWQgU3ltYm9sIG1pZ2h0IHByb3ZpZGUgU3ltYm9sLml0ZXJhdG9yXG5leHBvcnQgY29uc3QgaXRlcmF0b3JTeW1ib2w6IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvcikgfHwgKFwiQEBpdGVyYXRvclwiIGFzIGFueSlcblxuLyoqIFVzZSBhIGNsYXNzIHR5cGUgZm9yIGBub3RoaW5nYCBzbyBpdHMgdHlwZSBpcyB1bmlxdWUgKi9cbmV4cG9ydCBjbGFzcyBOb3RoaW5nIHtcblx0Ly8gVGhpcyBsZXRzIHVzIGRvIGBFeGNsdWRlPFQsIE5vdGhpbmc+YFxuXHQvLyBAdHMtaWdub3JlXG5cdHByaXZhdGUgXyE6IHVuaXF1ZSBzeW1ib2xcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCB2YXIgUmVhY3RSZWR1eENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUmVhY3RSZWR1eENvbnRleHQuZGlzcGxheU5hbWUgPSAnUmVhY3RSZWR1eCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlYWN0UmVkdXhDb250ZXh0OyIsImltcG9ydCBSZWFjdCwgeyB1c2VNZW1vLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuXG5mdW5jdGlvbiBQcm92aWRlcihfcmVmKSB7XG4gIHZhciBzdG9yZSA9IF9yZWYuc3RvcmUsXG4gICAgICBjb250ZXh0ID0gX3JlZi5jb250ZXh0LFxuICAgICAgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICB2YXIgY29udGV4dFZhbHVlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oc3RvcmUpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uXG4gICAgfTtcbiAgfSwgW3N0b3JlXSk7XG4gIHZhciBwcmV2aW91c1N0YXRlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0b3JlLmdldFN0YXRlKCk7XG4gIH0sIFtzdG9yZV0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdWJzY3JpcHRpb24gPSBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcblxuICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSBzdG9yZS5nZXRTdGF0ZSgpKSB7XG4gICAgICBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicygpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcbiAgICB9O1xuICB9LCBbY29udGV4dFZhbHVlLCBwcmV2aW91c1N0YXRlXSk7XG4gIHZhciBDb250ZXh0ID0gY29udGV4dCB8fCBSZWFjdFJlZHV4Q29udGV4dDtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gIH0sIGNoaWxkcmVuKTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgUHJvdmlkZXIucHJvcFR5cGVzID0ge1xuICAgIHN0b3JlOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgc3Vic2NyaWJlOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZGlzcGF0Y2g6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gICAgICBnZXRTdGF0ZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLFxuICAgIGNvbnRleHQ6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnlcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUHJvdmlkZXI7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBob2lzdFN0YXRpY3MgZnJvbSAnaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVJlZiwgdXNlUmVkdWNlciB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzVmFsaWRFbGVtZW50VHlwZSwgaXNDb250ZXh0Q29uc3VtZXIgfSBmcm9tICdyZWFjdC1pcyc7XG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vQ29udGV4dCc7IC8vIERlZmluZSBzb21lIGNvbnN0YW50IGFycmF5cyBqdXN0IHRvIGF2b2lkIHJlLWNyZWF0aW5nIHRoZXNlXG5cbnZhciBFTVBUWV9BUlJBWSA9IFtdO1xudmFyIE5PX1NVQlNDUklQVElPTl9BUlJBWSA9IFtudWxsLCBudWxsXTtcblxudmFyIHN0cmluZ2lmeUNvbXBvbmVudCA9IGZ1bmN0aW9uIHN0cmluZ2lmeUNvbXBvbmVudChDb21wKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KENvbXApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nKENvbXApO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzdG9yZVN0YXRlVXBkYXRlc1JlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICB2YXIgdXBkYXRlQ291bnQgPSBzdGF0ZVsxXTtcbiAgcmV0dXJuIFthY3Rpb24ucGF5bG9hZCwgdXBkYXRlQ291bnQgKyAxXTtcbn1cblxuZnVuY3Rpb24gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKGVmZmVjdEZ1bmMsIGVmZmVjdEFyZ3MsIGRlcGVuZGVuY2llcykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZWZmZWN0RnVuYy5hcHBseSh2b2lkIDAsIGVmZmVjdEFyZ3MpO1xuICB9LCBkZXBlbmRlbmNpZXMpO1xufVxuXG5mdW5jdGlvbiBjYXB0dXJlV3JhcHBlclByb3BzKGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBhY3R1YWxDaGlsZFByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzKSB7XG4gIC8vIFdlIHdhbnQgdG8gY2FwdHVyZSB0aGUgd3JhcHBlciBwcm9wcyBhbmQgY2hpbGQgcHJvcHMgd2UgdXNlZCBmb3IgbGF0ZXIgY29tcGFyaXNvbnNcbiAgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50ID0gd3JhcHBlclByb3BzO1xuICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gYWN0dWFsQ2hpbGRQcm9wcztcbiAgcmVuZGVySXNTY2hlZHVsZWQuY3VycmVudCA9IGZhbHNlOyAvLyBJZiB0aGUgcmVuZGVyIHdhcyBmcm9tIGEgc3RvcmUgdXBkYXRlLCBjbGVhciBvdXQgdGhhdCByZWZlcmVuY2UgYW5kIGNhc2NhZGUgdGhlIHN1YnNjcmliZXIgdXBkYXRlXG5cbiAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCkge1xuICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG51bGw7XG4gICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVVwZGF0ZXMoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaCkge1xuICAvLyBJZiB3ZSdyZSBub3Qgc3Vic2NyaWJlZCB0byB0aGUgc3RvcmUsIG5vdGhpbmcgdG8gZG8gaGVyZVxuICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuOyAvLyBDYXB0dXJlIHZhbHVlcyBmb3IgY2hlY2tpbmcgaWYgYW5kIHdoZW4gdGhpcyBjb21wb25lbnQgdW5tb3VudHNcblxuICB2YXIgZGlkVW5zdWJzY3JpYmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RUaHJvd25FcnJvciA9IG51bGw7IC8vIFdlJ2xsIHJ1biB0aGlzIGNhbGxiYWNrIGV2ZXJ5IHRpbWUgYSBzdG9yZSBzdWJzY3JpcHRpb24gdXBkYXRlIHByb3BhZ2F0ZXMgdG8gdGhpcyBjb21wb25lbnRcblxuICB2YXIgY2hlY2tGb3JVcGRhdGVzID0gZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgIGlmIChkaWRVbnN1YnNjcmliZSkge1xuICAgICAgLy8gRG9uJ3QgcnVuIHN0YWxlIGxpc3RlbmVycy5cbiAgICAgIC8vIFJlZHV4IGRvZXNuJ3QgZ3VhcmFudGVlIHVuc3Vic2NyaXB0aW9ucyBoYXBwZW4gdW50aWwgbmV4dCBkaXNwYXRjaC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF0ZXN0U3RvcmVTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgdmFyIG5ld0NoaWxkUHJvcHMsIGVycm9yO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIEFjdHVhbGx5IHJ1biB0aGUgc2VsZWN0b3Igd2l0aCB0aGUgbW9zdCByZWNlbnQgc3RvcmUgc3RhdGUgYW5kIHdyYXBwZXIgcHJvcHNcbiAgICAgIC8vIHRvIGRldGVybWluZSB3aGF0IHRoZSBjaGlsZCBwcm9wcyBzaG91bGQgYmVcbiAgICAgIG5ld0NoaWxkUHJvcHMgPSBjaGlsZFByb3BzU2VsZWN0b3IobGF0ZXN0U3RvcmVTdGF0ZSwgbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvciA9IGU7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBlO1xuICAgIH1cblxuICAgIGlmICghZXJyb3IpIHtcbiAgICAgIGxhc3RUaHJvd25FcnJvciA9IG51bGw7XG4gICAgfSAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgaGF2ZW4ndCBjaGFuZ2VkLCBub3RoaW5nIHRvIGRvIGhlcmUgLSBjYXNjYWRlIHRoZSBzdWJzY3JpcHRpb24gdXBkYXRlXG5cblxuICAgIGlmIChuZXdDaGlsZFByb3BzID09PSBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50KSB7XG4gICAgICBpZiAoIXJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQpIHtcbiAgICAgICAgbm90aWZ5TmVzdGVkU3VicygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTYXZlIHJlZmVyZW5jZXMgdG8gdGhlIG5ldyBjaGlsZCBwcm9wcy4gIE5vdGUgdGhhdCB3ZSB0cmFjayB0aGUgXCJjaGlsZCBwcm9wcyBmcm9tIHN0b3JlIHVwZGF0ZVwiXG4gICAgICAvLyBhcyBhIHJlZiBpbnN0ZWFkIG9mIGEgdXNlU3RhdGUvdXNlUmVkdWNlciBiZWNhdXNlIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZXJtaW5lIGlmIHRoYXQgdmFsdWUgaGFzXG4gICAgICAvLyBiZWVuIHByb2Nlc3NlZC4gIElmIHRoaXMgd2VudCBpbnRvIHVzZVN0YXRlL3VzZVJlZHVjZXIsIHdlIGNvdWxkbid0IGNsZWFyIG91dCB0aGUgdmFsdWUgd2l0aG91dFxuICAgICAgLy8gZm9yY2luZyBhbm90aGVyIHJlLXJlbmRlciwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAgIGxhc3RDaGlsZFByb3BzLmN1cnJlbnQgPSBuZXdDaGlsZFByb3BzO1xuICAgICAgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSB0cnVlOyAvLyBJZiB0aGUgY2hpbGQgcHJvcHMgX2RpZF8gY2hhbmdlIChvciB3ZSBjYXVnaHQgYW4gZXJyb3IpLCB0aGlzIHdyYXBwZXIgY29tcG9uZW50IG5lZWRzIHRvIHJlLXJlbmRlclxuXG4gICAgICBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogJ1NUT1JFX1VQREFURUQnLFxuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTsgLy8gQWN0dWFsbHkgc3Vic2NyaWJlIHRvIHRoZSBuZWFyZXN0IGNvbm5lY3RlZCBhbmNlc3RvciAob3Igc3RvcmUpXG5cblxuICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IGNoZWNrRm9yVXBkYXRlcztcbiAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpOyAvLyBQdWxsIGRhdGEgZnJvbSB0aGUgc3RvcmUgYWZ0ZXIgZmlyc3QgcmVuZGVyIGluIGNhc2UgdGhlIHN0b3JlIGhhc1xuICAvLyBjaGFuZ2VkIHNpbmNlIHdlIGJlZ2FuLlxuXG4gIGNoZWNrRm9yVXBkYXRlcygpO1xuXG4gIHZhciB1bnN1YnNjcmliZVdyYXBwZXIgPSBmdW5jdGlvbiB1bnN1YnNjcmliZVdyYXBwZXIoKSB7XG4gICAgZGlkVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gbnVsbDtcblxuICAgIGlmIChsYXN0VGhyb3duRXJyb3IpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCB3ZSBjYXVnaHQgYW4gZXJyb3IgZHVlIHRvIGEgYmFkIG1hcFN0YXRlIGZ1bmN0aW9uLCBidXQgdGhlXG4gICAgICAvLyBwYXJlbnQgcmUtcmVuZGVyZWQgd2l0aG91dCB0aGlzIGNvbXBvbmVudCBhbmQgd2UncmUgYWJvdXQgdG8gdW5tb3VudC5cbiAgICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiBhcyBsb25nIGFzIHdlIGRvIHRvcC1kb3duIHN1YnNjcmlwdGlvbnMgY29ycmVjdGx5LCBidXRcbiAgICAgIC8vIGlmIHdlIGV2ZXIgZG8gdGhvc2Ugd3JvbmcsIHRoaXMgdGhyb3cgd2lsbCBzdXJmYWNlIHRoZSBlcnJvciBpbiBvdXIgdGVzdHMuXG4gICAgICAvLyBJbiB0aGF0IGNhc2UsIHRocm93IHRoZSBlcnJvciBmcm9tIGhlcmUgc28gaXQgZG9lc24ndCBnZXQgbG9zdC5cbiAgICAgIHRocm93IGxhc3RUaHJvd25FcnJvcjtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHVuc3Vic2NyaWJlV3JhcHBlcjtcbn1cblxudmFyIGluaXRTdGF0ZVVwZGF0ZXMgPSBmdW5jdGlvbiBpbml0U3RhdGVVcGRhdGVzKCkge1xuICByZXR1cm4gW251bGwsIDBdO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29ubmVjdEFkdmFuY2VkKFxuLypcbiAgc2VsZWN0b3JGYWN0b3J5IGlzIGEgZnVuYyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG9cbiAgY29tcHV0ZSBuZXcgcHJvcHMgZnJvbSBzdGF0ZSwgcHJvcHMsIGFuZCBkaXNwYXRjaC4gRm9yIGV4YW1wbGU6XG4gICAgIGV4cG9ydCBkZWZhdWx0IGNvbm5lY3RBZHZhbmNlZCgoZGlzcGF0Y2gsIG9wdGlvbnMpID0+IChzdGF0ZSwgcHJvcHMpID0+ICh7XG4gICAgICB0aGluZzogc3RhdGUudGhpbmdzW3Byb3BzLnRoaW5nSWRdLFxuICAgICAgc2F2ZVRoaW5nOiBmaWVsZHMgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvcnMuc2F2ZVRoaW5nKHByb3BzLnRoaW5nSWQsIGZpZWxkcykpLFxuICAgIH0pKShZb3VyQ29tcG9uZW50KVxuICAgQWNjZXNzIHRvIGRpc3BhdGNoIGlzIHByb3ZpZGVkIHRvIHRoZSBmYWN0b3J5IHNvIHNlbGVjdG9yRmFjdG9yaWVzIGNhbiBiaW5kIGFjdGlvbkNyZWF0b3JzXG4gIG91dHNpZGUgb2YgdGhlaXIgc2VsZWN0b3IgYXMgYW4gb3B0aW1pemF0aW9uLiBPcHRpb25zIHBhc3NlZCB0byBjb25uZWN0QWR2YW5jZWQgYXJlIHBhc3NlZCB0b1xuICB0aGUgc2VsZWN0b3JGYWN0b3J5LCBhbG9uZyB3aXRoIGRpc3BsYXlOYW1lIGFuZCBXcmFwcGVkQ29tcG9uZW50LCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgTm90ZSB0aGF0IHNlbGVjdG9yRmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgYWxsIGNhY2hpbmcvbWVtb2l6YXRpb24gb2YgaW5ib3VuZCBhbmQgb3V0Ym91bmRcbiAgcHJvcHMuIERvIG5vdCB1c2UgY29ubmVjdEFkdmFuY2VkIGRpcmVjdGx5IHdpdGhvdXQgbWVtb2l6aW5nIHJlc3VsdHMgYmV0d2VlbiBjYWxscyB0byB5b3VyXG4gIHNlbGVjdG9yLCBvdGhlcndpc2UgdGhlIENvbm5lY3QgY29tcG9uZW50IHdpbGwgcmUtcmVuZGVyIG9uIGV2ZXJ5IHN0YXRlIG9yIHByb3BzIGNoYW5nZS5cbiovXG5zZWxlY3RvckZhY3RvcnksIC8vIG9wdGlvbnMgb2JqZWN0OlxuX3JlZikge1xuICBpZiAoX3JlZiA9PT0gdm9pZCAwKSB7XG4gICAgX3JlZiA9IHt9O1xuICB9XG5cbiAgdmFyIF9yZWYyID0gX3JlZixcbiAgICAgIF9yZWYyJGdldERpc3BsYXlOYW1lID0gX3JlZjIuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYyJGdldERpc3BsYXlOYW1lID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBcIkNvbm5lY3RBZHZhbmNlZChcIiArIG5hbWUgKyBcIilcIjtcbiAgfSA6IF9yZWYyJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZjIkbWV0aG9kTmFtZSA9IF9yZWYyLm1ldGhvZE5hbWUsXG4gICAgICBtZXRob2ROYW1lID0gX3JlZjIkbWV0aG9kTmFtZSA9PT0gdm9pZCAwID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmMiRtZXRob2ROYW1lLFxuICAgICAgX3JlZjIkcmVuZGVyQ291bnRQcm9wID0gX3JlZjIucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZjIkcmVuZGVyQ291bnRQcm9wID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmMiRyZW5kZXJDb3VudFByb3AsXG4gICAgICBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPSBfcmVmMi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRzaG91bGRIYW5kbGVTdGEsXG4gICAgICBfcmVmMiRzdG9yZUtleSA9IF9yZWYyLnN0b3JlS2V5LFxuICAgICAgc3RvcmVLZXkgPSBfcmVmMiRzdG9yZUtleSA9PT0gdm9pZCAwID8gJ3N0b3JlJyA6IF9yZWYyJHN0b3JlS2V5LFxuICAgICAgX3JlZjIkd2l0aFJlZiA9IF9yZWYyLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZjIkd2l0aFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR3aXRoUmVmLFxuICAgICAgX3JlZjIkZm9yd2FyZFJlZiA9IF9yZWYyLmZvcndhcmRSZWYsXG4gICAgICBmb3J3YXJkUmVmID0gX3JlZjIkZm9yd2FyZFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRmb3J3YXJkUmVmLFxuICAgICAgX3JlZjIkY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXG4gICAgICBjb250ZXh0ID0gX3JlZjIkY29udGV4dCA9PT0gdm9pZCAwID8gUmVhY3RSZWR1eENvbnRleHQgOiBfcmVmMiRjb250ZXh0LFxuICAgICAgY29ubmVjdE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiZ2V0RGlzcGxheU5hbWVcIiwgXCJtZXRob2ROYW1lXCIsIFwicmVuZGVyQ291bnRQcm9wXCIsIFwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzXCIsIFwic3RvcmVLZXlcIiwgXCJ3aXRoUmVmXCIsIFwiZm9yd2FyZFJlZlwiLCBcImNvbnRleHRcIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHJlbmRlckNvdW50UHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJDb3VudFByb3AgaXMgcmVtb3ZlZC4gcmVuZGVyIGNvdW50aW5nIGlzIGJ1aWx0IGludG8gdGhlIGxhdGVzdCBSZWFjdCBEZXYgVG9vbHMgcHJvZmlsaW5nIGV4dGVuc2lvblwiKTtcbiAgICB9XG5cbiAgICBpZiAod2l0aFJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aXRoUmVmIGlzIHJlbW92ZWQuIFRvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgdXNlIGEgcmVmIG9uIHRoZSBjb25uZWN0ZWQgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbVN0b3JlV2FybmluZ01lc3NhZ2UgPSAnVG8gdXNlIGEgY3VzdG9tIFJlZHV4IHN0b3JlIGZvciBzcGVjaWZpYyBjb21wb25lbnRzLCBjcmVhdGUgYSBjdXN0b20gUmVhY3QgY29udGV4dCB3aXRoICcgKyBcIlJlYWN0LmNyZWF0ZUNvbnRleHQoKSwgYW5kIHBhc3MgdGhlIGNvbnRleHQgb2JqZWN0IHRvIFJlYWN0IFJlZHV4J3MgUHJvdmlkZXIgYW5kIHNwZWNpZmljIGNvbXBvbmVudHNcIiArICcgbGlrZTogPFByb3ZpZGVyIGNvbnRleHQ9e015Q29udGV4dH0+PENvbm5lY3RlZENvbXBvbmVudCBjb250ZXh0PXtNeUNvbnRleHR9IC8+PC9Qcm92aWRlcj4uICcgKyAnWW91IG1heSBhbHNvIHBhc3MgYSB7Y29udGV4dCA6IE15Q29udGV4dH0gb3B0aW9uIHRvIGNvbm5lY3QnO1xuXG4gICAgaWYgKHN0b3JlS2V5ICE9PSAnc3RvcmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlS2V5IGhhcyBiZWVuIHJlbW92ZWQgYW5kIGRvZXMgbm90IGRvIGFueXRoaW5nLiAnICsgY3VzdG9tU3RvcmVXYXJuaW5nTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENvbnRleHQgPSBjb250ZXh0O1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBcIiArIChtZXRob2ROYW1lICsgXCIuIEluc3RlYWQgcmVjZWl2ZWQgXCIgKyBzdHJpbmdpZnlDb21wb25lbnQoV3JhcHBlZENvbXBvbmVudCkpKTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZSh3cmFwcGVkQ29tcG9uZW50TmFtZSk7XG5cbiAgICB2YXIgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBjb25uZWN0T3B0aW9ucywge1xuICAgICAgZ2V0RGlzcGxheU5hbWU6IGdldERpc3BsYXlOYW1lLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIHJlbmRlckNvdW50UHJvcDogcmVuZGVyQ291bnRQcm9wLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzdG9yZUtleTogc3RvcmVLZXksXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgcHVyZSA9IGNvbm5lY3RPcHRpb25zLnB1cmU7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFNlbGVjdG9yKHN0b3JlKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICB9IC8vIElmIHdlIGFyZW4ndCBydW5uaW5nIGluIFwicHVyZVwiIG1vZGUsIHdlIGRvbid0IHdhbnQgdG8gbWVtb2l6ZSB2YWx1ZXMuXG4gICAgLy8gVG8gYXZvaWQgY29uZGl0aW9uYWxseSBjYWxsaW5nIGhvb2tzLCB3ZSBmYWxsIGJhY2sgdG8gYSB0aW55IHdyYXBwZXJcbiAgICAvLyB0aGF0IGp1c3QgZXhlY3V0ZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGltbWVkaWF0ZWx5LlxuXG5cbiAgICB2YXIgdXNlUHVyZU9ubHlNZW1vID0gcHVyZSA/IHVzZU1lbW8gOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGFjdHVhbCBcImRhdGFcIiBwcm9wcyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVyIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYW5kIHZhbHVlcyBuZWVkZWQgdG8gY29udHJvbCBiZWhhdmlvciAoZm9yd2FyZGVkIHJlZnMsIGFsdGVybmF0ZSBjb250ZXh0IGluc3RhbmNlcykuXG4gICAgICAgIC8vIFRvIG1haW50YWluIHRoZSB3cmFwcGVyUHJvcHMgb2JqZWN0IHJlZmVyZW5jZSwgbWVtb2l6ZSB0aGlzIGRlc3RydWN0dXJpbmcuXG4gICAgICAgIHZhciByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gcHJvcHMucmVhY3RSZWR1eEZvcndhcmRlZFJlZixcbiAgICAgICAgICAgIHdyYXBwZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXCJdKTtcblxuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc107XG4gICAgICB9LCBbcHJvcHNdKSxcbiAgICAgICAgICBwcm9wc0NvbnRleHQgPSBfdXNlTWVtb1swXSxcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gX3VzZU1lbW9bMV0sXG4gICAgICAgICAgd3JhcHBlclByb3BzID0gX3VzZU1lbW9bMl07XG5cbiAgICAgIHZhciBDb250ZXh0VG9Vc2UgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlcnMgbWF5IG9wdGlvbmFsbHkgcGFzcyBpbiBhIGN1c3RvbSBjb250ZXh0IGluc3RhbmNlIHRvIHVzZSBpbnN0ZWFkIG9mIG91ciBSZWFjdFJlZHV4Q29udGV4dC5cbiAgICAgICAgLy8gTWVtb2l6ZSB0aGUgY2hlY2sgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIGNvbnRleHQgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZS5cbiAgICAgICAgcmV0dXJuIHByb3BzQ29udGV4dCAmJiBwcm9wc0NvbnRleHQuQ29uc3VtZXIgJiYgaXNDb250ZXh0Q29uc3VtZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHByb3BzQ29udGV4dC5Db25zdW1lciwgbnVsbCkpID8gcHJvcHNDb250ZXh0IDogQ29udGV4dDtcbiAgICAgIH0sIFtwcm9wc0NvbnRleHQsIENvbnRleHRdKTsgLy8gUmV0cmlldmUgdGhlIHN0b3JlIGFuZCBhbmNlc3RvciBzdWJzY3JpcHRpb24gdmlhIGNvbnRleHQsIGlmIGF2YWlsYWJsZVxuXG4gICAgICB2YXIgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChDb250ZXh0VG9Vc2UpOyAvLyBUaGUgc3RvcmUgX211c3RfIGV4aXN0IGFzIGVpdGhlciBhIHByb3Agb3IgaW4gY29udGV4dC5cbiAgICAgIC8vIFdlJ2xsIGNoZWNrIHRvIHNlZSBpZiBpdCBfbG9va3NfIGxpa2UgYSBSZWR1eCBzdG9yZSBmaXJzdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHBhc3MgdGhyb3VnaCBhIGBzdG9yZWAgcHJvcCB0aGF0IGlzIGp1c3QgYSBwbGFpbiB2YWx1ZS5cblxuICAgICAgdmFyIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA9IEJvb2xlYW4ocHJvcHMuc3RvcmUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZ2V0U3RhdGUpICYmIEJvb2xlYW4ocHJvcHMuc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgdmFyIGRpZFN0b3JlQ29tZUZyb21Db250ZXh0ID0gQm9vbGVhbihjb250ZXh0VmFsdWUpICYmIEJvb2xlYW4oY29udGV4dFZhbHVlLnN0b3JlKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWRpZFN0b3JlQ29tZUZyb21Qcm9wcyAmJiAhZGlkU3RvcmVDb21lRnJvbUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgXFxcInN0b3JlXFxcIiBpbiB0aGUgY29udGV4dCBvZiBcIiArIChcIlxcXCJcIiArIGRpc3BsYXlOYW1lICsgXCJcXFwiLiBFaXRoZXIgd3JhcCB0aGUgcm9vdCBjb21wb25lbnQgaW4gYSA8UHJvdmlkZXI+LCBcIikgKyBcIm9yIHBhc3MgYSBjdXN0b20gUmVhY3QgY29udGV4dCBwcm92aWRlciB0byA8UHJvdmlkZXI+IGFuZCB0aGUgY29ycmVzcG9uZGluZyBcIiArIChcIlJlYWN0IGNvbnRleHQgY29uc3VtZXIgdG8gXCIgKyBkaXNwbGF5TmFtZSArIFwiIGluIGNvbm5lY3Qgb3B0aW9ucy5cIikpO1xuICAgICAgfSAvLyBCYXNlZCBvbiB0aGUgcHJldmlvdXMgY2hlY2ssIG9uZSBvZiB0aGVzZSBtdXN0IGJlIHRydWVcblxuXG4gICAgICB2YXIgc3RvcmUgPSBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPyBwcm9wcy5zdG9yZSA6IGNvbnRleHRWYWx1ZS5zdG9yZTtcbiAgICAgIHZhciBjaGlsZFByb3BzU2VsZWN0b3IgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhlIGNoaWxkIHByb3BzIHNlbGVjdG9yIG5lZWRzIHRoZSBzdG9yZSByZWZlcmVuY2UgYXMgYW4gaW5wdXQuXG4gICAgICAgIC8vIFJlLWNyZWF0ZSB0aGlzIHNlbGVjdG9yIHdoZW5ldmVyIHRoZSBzdG9yZSBjaGFuZ2VzLlxuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGRTZWxlY3RvcihzdG9yZSk7XG4gICAgICB9LCBbc3RvcmVdKTtcblxuICAgICAgdmFyIF91c2VNZW1vMiA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcykgcmV0dXJuIE5PX1NVQlNDUklQVElPTl9BUlJBWTsgLy8gVGhpcyBTdWJzY3JpcHRpb24ncyBzb3VyY2Ugc2hvdWxkIG1hdGNoIHdoZXJlIHN0b3JlIGNhbWUgZnJvbTogcHJvcHMgdnMuIGNvbnRleHQuIEEgY29tcG9uZW50XG4gICAgICAgIC8vIGNvbm5lY3RlZCB0byB0aGUgc3RvcmUgdmlhIHByb3BzIHNob3VsZG4ndCB1c2Ugc3Vic2NyaXB0aW9uIGZyb20gY29udGV4dCwgb3IgdmljZSB2ZXJzYS5cblxuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbihzdG9yZSwgZGlkU3RvcmVDb21lRnJvbVByb3BzID8gbnVsbCA6IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb24pOyAvLyBgbm90aWZ5TmVzdGVkU3Vic2AgaXMgZHVwbGljYXRlZCB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgaW5cbiAgICAgICAgLy8gdGhlIG1pZGRsZSBvZiB0aGUgbm90aWZpY2F0aW9uIGxvb3AsIHdoZXJlIGBzdWJzY3JpcHRpb25gIHdpbGwgdGhlbiBiZSBudWxsLiBUaGlzIGNhblxuICAgICAgICAvLyBwcm9iYWJseSBiZSBhdm9pZGVkIGlmIFN1YnNjcmlwdGlvbidzIGxpc3RlbmVycyBsb2dpYyBpcyBjaGFuZ2VkIHRvIG5vdCBjYWxsIGxpc3RlbmVyc1xuICAgICAgICAvLyB0aGF0IGhhdmUgYmVlbiB1bnN1YnNjcmliZWQgaW4gdGhlICBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLlxuXG4gICAgICAgIHZhciBub3RpZnlOZXN0ZWRTdWJzID0gc3Vic2NyaXB0aW9uLm5vdGlmeU5lc3RlZFN1YnMuYmluZChzdWJzY3JpcHRpb24pO1xuICAgICAgICByZXR1cm4gW3N1YnNjcmlwdGlvbiwgbm90aWZ5TmVzdGVkU3Vic107XG4gICAgICB9LCBbc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlXSksXG4gICAgICAgICAgc3Vic2NyaXB0aW9uID0gX3VzZU1lbW8yWzBdLFxuICAgICAgICAgIG5vdGlmeU5lc3RlZFN1YnMgPSBfdXNlTWVtbzJbMV07IC8vIERldGVybWluZSB3aGF0IHtzdG9yZSwgc3Vic2NyaXB0aW9ufSB2YWx1ZSBzaG91bGQgYmUgcHV0IGludG8gbmVzdGVkIGNvbnRleHQsIGlmIG5lY2Vzc2FyeSxcbiAgICAgIC8vIGFuZCBtZW1vaXplIHRoYXQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgY29udGV4dCB1cGRhdGVzLlxuXG5cbiAgICAgIHZhciBvdmVycmlkZGVuQ29udGV4dFZhbHVlID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChkaWRTdG9yZUNvbWVGcm9tUHJvcHMpIHtcbiAgICAgICAgICAvLyBUaGlzIGNvbXBvbmVudCBpcyBkaXJlY3RseSBzdWJzY3JpYmVkIHRvIGEgc3RvcmUgZnJvbSBwcm9wcy5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IGRlc2NlbmRhbnRzIHJlYWRpbmcgZnJvbSB0aGlzIHN0b3JlIC0gcGFzcyBkb3duIHdoYXRldmVyXG4gICAgICAgICAgLy8gdGhlIGV4aXN0aW5nIGNvbnRleHQgdmFsdWUgaXMgZnJvbSB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IuXG4gICAgICAgICAgcmV0dXJuIGNvbnRleHRWYWx1ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2UsIHB1dCB0aGlzIGNvbXBvbmVudCdzIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBpbnRvIGNvbnRleHQsIHNvIHRoYXRcbiAgICAgICAgLy8gY29ubmVjdGVkIGRlc2NlbmRhbnRzIHdvbid0IHVwZGF0ZSB1bnRpbCBhZnRlciB0aGlzIGNvbXBvbmVudCBpcyBkb25lXG5cblxuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGNvbnRleHRWYWx1ZSwge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfSwgW2RpZFN0b3JlQ29tZUZyb21Qcm9wcywgY29udGV4dFZhbHVlLCBzdWJzY3JpcHRpb25dKTsgLy8gV2UgbmVlZCB0byBmb3JjZSB0aGlzIHdyYXBwZXIgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuZXZlciBhIFJlZHV4IHN0b3JlIHVwZGF0ZVxuICAgICAgLy8gY2F1c2VzIGEgY2hhbmdlIHRvIHRoZSBjYWxjdWxhdGVkIGNoaWxkIGNvbXBvbmVudCBwcm9wcyAob3Igd2UgY2F1Z2h0IGFuIGVycm9yIGluIG1hcFN0YXRlKVxuXG4gICAgICB2YXIgX3VzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyKHN0b3JlU3RhdGVVcGRhdGVzUmVkdWNlciwgRU1QVFlfQVJSQVksIGluaXRTdGF0ZVVwZGF0ZXMpLFxuICAgICAgICAgIF91c2VSZWR1Y2VyJCA9IF91c2VSZWR1Y2VyWzBdLFxuICAgICAgICAgIHByZXZpb3VzU3RhdGVVcGRhdGVSZXN1bHQgPSBfdXNlUmVkdWNlciRbMF0sXG4gICAgICAgICAgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaCA9IF91c2VSZWR1Y2VyWzFdOyAvLyBQcm9wYWdhdGUgYW55IG1hcFN0YXRlL21hcERpc3BhdGNoIGVycm9ycyB1cHdhcmRzXG5cblxuICAgICAgaWYgKHByZXZpb3VzU3RhdGVVcGRhdGVSZXN1bHQgJiYgcHJldmlvdXNTdGF0ZVVwZGF0ZVJlc3VsdC5lcnJvcikge1xuICAgICAgICB0aHJvdyBwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0LmVycm9yO1xuICAgICAgfSAvLyBTZXQgdXAgcmVmcyB0byBjb29yZGluYXRlIHZhbHVlcyBiZXR3ZWVuIHRoZSBzdWJzY3JpcHRpb24gZWZmZWN0IGFuZCB0aGUgcmVuZGVyIGxvZ2ljXG5cblxuICAgICAgdmFyIGxhc3RDaGlsZFByb3BzID0gdXNlUmVmKCk7XG4gICAgICB2YXIgbGFzdFdyYXBwZXJQcm9wcyA9IHVzZVJlZih3cmFwcGVyUHJvcHMpO1xuICAgICAgdmFyIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUgPSB1c2VSZWYoKTtcbiAgICAgIHZhciByZW5kZXJJc1NjaGVkdWxlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgICB2YXIgYWN0dWFsQ2hpbGRQcm9wcyA9IHVzZVB1cmVPbmx5TWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRyaWNreSBsb2dpYyBoZXJlOlxuICAgICAgICAvLyAtIFRoaXMgcmVuZGVyIG1heSBoYXZlIGJlZW4gdHJpZ2dlcmVkIGJ5IGEgUmVkdXggc3RvcmUgdXBkYXRlIHRoYXQgcHJvZHVjZWQgbmV3IGNoaWxkIHByb3BzXG4gICAgICAgIC8vIC0gSG93ZXZlciwgd2UgbWF5IGhhdmUgZ290dGVuIG5ldyB3cmFwcGVyIHByb3BzIGFmdGVyIHRoYXRcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBuZXcgY2hpbGQgcHJvcHMsIGFuZCB0aGUgc2FtZSB3cmFwcGVyIHByb3BzLCB3ZSBrbm93IHdlIHNob3VsZCB1c2UgdGhlIG5ldyBjaGlsZCBwcm9wcyBhcy1pcy5cbiAgICAgICAgLy8gQnV0LCBpZiB3ZSBoYXZlIG5ldyB3cmFwcGVyIHByb3BzLCB0aG9zZSBtaWdodCBjaGFuZ2UgdGhlIGNoaWxkIHByb3BzLCBzbyB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoaW5ncy5cbiAgICAgICAgLy8gU28sIHdlJ2xsIHVzZSB0aGUgY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGUgb25seSBpZiB0aGUgd3JhcHBlciBwcm9wcyBhcmUgdGhlIHNhbWUgYXMgbGFzdCB0aW1lLlxuICAgICAgICBpZiAoY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZS5jdXJyZW50ICYmIHdyYXBwZXJQcm9wcyA9PT0gbGFzdFdyYXBwZXJQcm9wcy5jdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudDtcbiAgICAgICAgfSAvLyBUT0RPIFdlJ3JlIHJlYWRpbmcgdGhlIHN0b3JlIGRpcmVjdGx5IGluIHJlbmRlcigpIGhlcmUuIEJhZCBpZGVhP1xuICAgICAgICAvLyBUaGlzIHdpbGwgbGlrZWx5IGNhdXNlIEJhZCBUaGluZ3MgKFRNKSB0byBoYXBwZW4gaW4gQ29uY3VycmVudCBNb2RlLlxuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgZG8gdGhpcyBiZWNhdXNlIG9uIHJlbmRlcnMgX25vdF8gY2F1c2VkIGJ5IHN0b3JlIHVwZGF0ZXMsIHdlIG5lZWQgdGhlIGxhdGVzdCBzdG9yZSBzdGF0ZVxuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlLlxuXG5cbiAgICAgICAgcmV0dXJuIGNoaWxkUHJvcHNTZWxlY3RvcihzdG9yZS5nZXRTdGF0ZSgpLCB3cmFwcGVyUHJvcHMpO1xuICAgICAgfSwgW3N0b3JlLCBwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0LCB3cmFwcGVyUHJvcHNdKTsgLy8gV2UgbmVlZCB0aGlzIHRvIGV4ZWN1dGUgc3luY2hyb25vdXNseSBldmVyeSB0aW1lIHdlIHJlLXJlbmRlci4gSG93ZXZlciwgUmVhY3Qgd2FybnNcbiAgICAgIC8vIGFib3V0IHVzZUxheW91dEVmZmVjdCBpbiBTU1IsIHNvIHdlIHRyeSB0byBkZXRlY3QgZW52aXJvbm1lbnQgYW5kIGZhbGwgYmFjayB0b1xuICAgICAgLy8ganVzdCB1c2VFZmZlY3QgaW5zdGVhZCB0byBhdm9pZCB0aGUgd2FybmluZywgc2luY2UgbmVpdGhlciB3aWxsIHJ1biBhbnl3YXkuXG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhjYXB0dXJlV3JhcHBlclByb3BzLCBbbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCB3cmFwcGVyUHJvcHMsIGFjdHVhbENoaWxkUHJvcHMsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnNdKTsgLy8gT3VyIHJlLXN1YnNjcmliZSBsb2dpYyBvbmx5IHJ1bnMgd2hlbiB0aGUgc3RvcmUvc3Vic2NyaXB0aW9uIHNldHVwIGNoYW5nZXNcblxuICAgICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdFdpdGhBcmdzKHN1YnNjcmliZVVwZGF0ZXMsIFtzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsIHN0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3RvciwgbGFzdFdyYXBwZXJQcm9wcywgbGFzdENoaWxkUHJvcHMsIHJlbmRlcklzU2NoZWR1bGVkLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzLCBmb3JjZUNvbXBvbmVudFVwZGF0ZURpc3BhdGNoXSwgW3N0b3JlLCBzdWJzY3JpcHRpb24sIGNoaWxkUHJvcHNTZWxlY3Rvcl0pOyAvLyBOb3cgdGhhdCBhbGwgdGhhdCdzIGRvbmUsIHdlIGNhbiBmaW5hbGx5IHRyeSB0byBhY3R1YWxseSByZW5kZXIgdGhlIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgIC8vIFdlIG1lbW9pemUgdGhlIGVsZW1lbnRzIGZvciB0aGUgcmVuZGVyZWQgY2hpbGQgY29tcG9uZW50IGFzIGFuIG9wdGltaXphdGlvbi5cblxuICAgICAgdmFyIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGFjdHVhbENoaWxkUHJvcHMsIHtcbiAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTsgLy8gSWYgUmVhY3Qgc2VlcyB0aGUgZXhhY3Qgc2FtZSBlbGVtZW50IHJlZmVyZW5jZSBhcyBsYXN0IHRpbWUsIGl0IGJhaWxzIG91dCBvZiByZS1yZW5kZXJpbmdcbiAgICAgIC8vIHRoYXQgY2hpbGQsIHNhbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gUmVhY3QubWVtbygpIG9yIHJldHVybmVkIGZhbHNlIGZyb20gc2hvdWxkQ29tcG9uZW50VXBkYXRlLlxuXG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgaXMgc3Vic2NyaWJlZCB0byBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRvIHBhc3MgaXRzIG93blxuICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBkb3duIHRvIG91ciBkZXNjZW5kYW50cy4gVGhhdCBtZWFucyByZW5kZXJpbmcgdGhlIHNhbWVcbiAgICAgICAgICAvLyBDb250ZXh0IGluc3RhbmNlLCBhbmQgcHV0dGluZyBhIGRpZmZlcmVudCB2YWx1ZSBpbnRvIHRoZSBjb250ZXh0LlxuICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0VG9Vc2UuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHZhbHVlOiBvdmVycmlkZGVuQ29udGV4dFZhbHVlXG4gICAgICAgICAgfSwgcmVuZGVyZWRXcmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICB9LCBbQ29udGV4dFRvVXNlLCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQsIG92ZXJyaWRkZW5Db250ZXh0VmFsdWVdKTtcbiAgICAgIHJldHVybiByZW5kZXJlZENoaWxkO1xuICAgIH0gLy8gSWYgd2UncmUgaW4gXCJwdXJlXCIgbW9kZSwgZW5zdXJlIG91ciB3cmFwcGVyIGNvbXBvbmVudCBvbmx5IHJlLXJlbmRlcnMgd2hlbiBpbmNvbWluZyBwcm9wcyBoYXZlIGNoYW5nZWQuXG5cblxuICAgIHZhciBDb25uZWN0ID0gcHVyZSA/IFJlYWN0Lm1lbW8oQ29ubmVjdEZ1bmN0aW9uKSA6IENvbm5lY3RGdW5jdGlvbjtcbiAgICBDb25uZWN0LldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuICAgIENvbm5lY3QuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcblxuICAgIGlmIChmb3J3YXJkUmVmKSB7XG4gICAgICB2YXIgZm9yd2FyZGVkID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBmb3J3YXJkQ29ubmVjdFJlZihwcm9wcywgcmVmKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb25uZWN0LCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmOiByZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgICBmb3J3YXJkZWQuZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgIGZvcndhcmRlZC5XcmFwcGVkQ29tcG9uZW50ID0gV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIHJldHVybiBob2lzdFN0YXRpY3MoZm9yd2FyZGVkLCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaG9pc3RTdGF0aWNzKENvbm5lY3QsIFdyYXBwZWRDb21wb25lbnQpO1xuICB9O1xufSIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4uL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi4vdXRpbHMvc2hhbGxvd0VxdWFsJztcbmltcG9ydCBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwRGlzcGF0Y2hUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIGZyb20gJy4vbWFwU3RhdGVUb1Byb3BzJztcbmltcG9ydCBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyBmcm9tICcuL21lcmdlUHJvcHMnO1xuaW1wb3J0IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgZnJvbSAnLi9zZWxlY3RvckZhY3RvcnknO1xuLypcbiAgY29ubmVjdCBpcyBhIGZhY2FkZSBvdmVyIGNvbm5lY3RBZHZhbmNlZC4gSXQgdHVybnMgaXRzIGFyZ3MgaW50byBhIGNvbXBhdGlibGVcbiAgc2VsZWN0b3JGYWN0b3J5LCB3aGljaCBoYXMgdGhlIHNpZ25hdHVyZTpcblxuICAgIChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA9PiBuZXh0RmluYWxQcm9wc1xuICBcbiAgY29ubmVjdCBwYXNzZXMgaXRzIGFyZ3MgdG8gY29ubmVjdEFkdmFuY2VkIGFzIG9wdGlvbnMsIHdoaWNoIHdpbGwgaW4gdHVybiBwYXNzIHRoZW0gdG9cbiAgc2VsZWN0b3JGYWN0b3J5IGVhY2ggdGltZSBhIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCBvciBob3QgcmVsb2FkZWQuXG5cbiAgc2VsZWN0b3JGYWN0b3J5IHJldHVybnMgYSBmaW5hbCBwcm9wcyBzZWxlY3RvciBmcm9tIGl0cyBtYXBTdGF0ZVRvUHJvcHMsXG4gIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsIG1lcmdlUHJvcHMsXG4gIG1lcmdlUHJvcHNGYWN0b3JpZXMsIGFuZCBwdXJlIGFyZ3MuXG5cbiAgVGhlIHJlc3VsdGluZyBmaW5hbCBwcm9wcyBzZWxlY3RvciBpcyBjYWxsZWQgYnkgdGhlIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIHdoZW5ldmVyXG4gIGl0IHJlY2VpdmVzIG5ldyBwcm9wcyBvciBzdG9yZSBzdGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBtYXRjaChhcmcsIGZhY3RvcmllcywgbmFtZSkge1xuICBmb3IgKHZhciBpID0gZmFjdG9yaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHJlc3VsdCA9IGZhY3Rvcmllc1tpXShhcmcpO1xuICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGRpc3BhdGNoLCBvcHRpb25zKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBvZiB0eXBlIFwiICsgdHlwZW9mIGFyZyArIFwiIGZvciBcIiArIG5hbWUgKyBcIiBhcmd1bWVudCB3aGVuIGNvbm5lY3RpbmcgY29tcG9uZW50IFwiICsgb3B0aW9ucy53cmFwcGVkQ29tcG9uZW50TmFtZSArIFwiLlwiKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn0gLy8gY3JlYXRlQ29ubmVjdCB3aXRoIGRlZmF1bHQgYXJncyBidWlsZHMgdGhlICdvZmZpY2lhbCcgY29ubmVjdCBiZWhhdmlvci4gQ2FsbGluZyBpdCB3aXRoXG4vLyBkaWZmZXJlbnQgb3B0aW9ucyBvcGVucyB1cCBzb21lIHRlc3RpbmcgYW5kIGV4dGVuc2liaWxpdHkgc2NlbmFyaW9zXG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3QoX3RlbXApIHtcbiAgdmFyIF9yZWYgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgIF9yZWYkY29ubmVjdEhPQyA9IF9yZWYuY29ubmVjdEhPQyxcbiAgICAgIGNvbm5lY3RIT0MgPSBfcmVmJGNvbm5lY3RIT0MgPT09IHZvaWQgMCA/IGNvbm5lY3RBZHZhbmNlZCA6IF9yZWYkY29ubmVjdEhPQyxcbiAgICAgIF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9IF9yZWYubWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBTdGF0ZVRvUHJvcHNGID09PSB2b2lkIDAgPyBkZWZhdWx0TWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBTdGF0ZVRvUHJvcHNGLFxuICAgICAgX3JlZiRtYXBEaXNwYXRjaFRvUHJvID0gX3JlZi5tYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgPSBfcmVmJG1hcERpc3BhdGNoVG9Qcm8gPT09IHZvaWQgMCA/IGRlZmF1bHRNYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1hcERpc3BhdGNoVG9Qcm8sXG4gICAgICBfcmVmJG1lcmdlUHJvcHNGYWN0b3IgPSBfcmVmLm1lcmdlUHJvcHNGYWN0b3JpZXMsXG4gICAgICBtZXJnZVByb3BzRmFjdG9yaWVzID0gX3JlZiRtZXJnZVByb3BzRmFjdG9yID09PSB2b2lkIDAgPyBkZWZhdWx0TWVyZ2VQcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvcixcbiAgICAgIF9yZWYkc2VsZWN0b3JGYWN0b3J5ID0gX3JlZi5zZWxlY3RvckZhY3RvcnksXG4gICAgICBzZWxlY3RvckZhY3RvcnkgPSBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9PT0gdm9pZCAwID8gZGVmYXVsdFNlbGVjdG9yRmFjdG9yeSA6IF9yZWYkc2VsZWN0b3JGYWN0b3J5O1xuXG4gIHJldHVybiBmdW5jdGlvbiBjb25uZWN0KG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBfcmVmMikge1xuICAgIGlmIChfcmVmMiA9PT0gdm9pZCAwKSB7XG4gICAgICBfcmVmMiA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfcmVmMyA9IF9yZWYyLFxuICAgICAgICBfcmVmMyRwdXJlID0gX3JlZjMucHVyZSxcbiAgICAgICAgcHVyZSA9IF9yZWYzJHB1cmUgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMyRwdXJlLFxuICAgICAgICBfcmVmMyRhcmVTdGF0ZXNFcXVhbCA9IF9yZWYzLmFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYzJGFyZVN0YXRlc0VxdWFsID09PSB2b2lkIDAgPyBzdHJpY3RFcXVhbCA6IF9yZWYzJGFyZVN0YXRlc0VxdWFsLFxuICAgICAgICBfcmVmMyRhcmVPd25Qcm9wc0VxdWEgPSBfcmVmMy5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZjMkYXJlT3duUHJvcHNFcXVhID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVPd25Qcm9wc0VxdWEsXG4gICAgICAgIF9yZWYzJGFyZVN0YXRlUHJvcHNFcSA9IF9yZWYzLmFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZjMkYXJlU3RhdGVQcm9wc0VxID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVTdGF0ZVByb3BzRXEsXG4gICAgICAgIF9yZWYzJGFyZU1lcmdlZFByb3BzRSA9IF9yZWYzLmFyZU1lcmdlZFByb3BzRXF1YWwsXG4gICAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWwgPSBfcmVmMyRhcmVNZXJnZWRQcm9wc0UgPT09IHZvaWQgMCA/IHNoYWxsb3dFcXVhbCA6IF9yZWYzJGFyZU1lcmdlZFByb3BzRSxcbiAgICAgICAgZXh0cmFPcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjMsIFtcInB1cmVcIiwgXCJhcmVTdGF0ZXNFcXVhbFwiLCBcImFyZU93blByb3BzRXF1YWxcIiwgXCJhcmVTdGF0ZVByb3BzRXF1YWxcIiwgXCJhcmVNZXJnZWRQcm9wc0VxdWFsXCJdKTtcblxuICAgIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gbWF0Y2gobWFwU3RhdGVUb1Byb3BzLCBtYXBTdGF0ZVRvUHJvcHNGYWN0b3JpZXMsICdtYXBTdGF0ZVRvUHJvcHMnKTtcbiAgICB2YXIgaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyA9IG1hdGNoKG1hcERpc3BhdGNoVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLCAnbWFwRGlzcGF0Y2hUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNZXJnZVByb3BzID0gbWF0Y2gobWVyZ2VQcm9wcywgbWVyZ2VQcm9wc0ZhY3RvcmllcywgJ21lcmdlUHJvcHMnKTtcbiAgICByZXR1cm4gY29ubmVjdEhPQyhzZWxlY3RvckZhY3RvcnksIF9leHRlbmRzKHtcbiAgICAgIC8vIHVzZWQgaW4gZXJyb3IgbWVzc2FnZXNcbiAgICAgIG1ldGhvZE5hbWU6ICdjb25uZWN0JyxcbiAgICAgIC8vIHVzZWQgdG8gY29tcHV0ZSBDb25uZWN0J3MgZGlzcGxheU5hbWUgZnJvbSB0aGUgd3JhcHBlZCBjb21wb25lbnQncyBkaXNwbGF5TmFtZS5cbiAgICAgIGdldERpc3BsYXlOYW1lOiBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiBcIkNvbm5lY3QoXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9LFxuICAgICAgLy8gaWYgbWFwU3RhdGVUb1Byb3BzIGlzIGZhbHN5LCB0aGUgQ29ubmVjdCBjb21wb25lbnQgZG9lc24ndCBzdWJzY3JpYmUgdG8gc3RvcmUgc3RhdGUgY2hhbmdlc1xuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBCb29sZWFuKG1hcFN0YXRlVG9Qcm9wcyksXG4gICAgICAvLyBwYXNzZWQgdGhyb3VnaCB0byBzZWxlY3RvckZhY3RvcnlcbiAgICAgIGluaXRNYXBTdGF0ZVRvUHJvcHM6IGluaXRNYXBTdGF0ZVRvUHJvcHMsXG4gICAgICBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzOiBpbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHM6IGluaXRNZXJnZVByb3BzLFxuICAgICAgcHVyZTogcHVyZSxcbiAgICAgIGFyZVN0YXRlc0VxdWFsOiBhcmVTdGF0ZXNFcXVhbCxcbiAgICAgIGFyZU93blByb3BzRXF1YWw6IGFyZU93blByb3BzRXF1YWwsXG4gICAgICBhcmVTdGF0ZVByb3BzRXF1YWw6IGFyZVN0YXRlUHJvcHNFcXVhbCxcbiAgICAgIGFyZU1lcmdlZFByb3BzRXF1YWw6IGFyZU1lcmdlZFByb3BzRXF1YWxcbiAgICB9LCBleHRyYU9wdGlvbnMpKTtcbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IC8qI19fUFVSRV9fKi9jcmVhdGVDb25uZWN0KCk7IiwiaW1wb3J0IHsgYmluZEFjdGlvbkNyZWF0b3JzIH0gZnJvbSAncmVkdXgnO1xuaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24obWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcobWFwRGlzcGF0Y2hUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwRGlzcGF0Y2hUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoXG4gICAgfTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0KG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gbWFwRGlzcGF0Y2hUb1Byb3BzICYmIHR5cGVvZiBtYXBEaXNwYXRjaFRvUHJvcHMgPT09ICdvYmplY3QnID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoZGlzcGF0Y2gpIHtcbiAgICByZXR1cm4gYmluZEFjdGlvbkNyZWF0b3JzKG1hcERpc3BhdGNoVG9Qcm9wcywgZGlzcGF0Y2gpO1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzTWlzc2luZywgd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzT2JqZWN0XTsiLCJpbXBvcnQgeyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50LCB3cmFwTWFwVG9Qcm9wc0Z1bmMgfSBmcm9tICcuL3dyYXBNYXBUb1Byb3BzJztcbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbihtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtYXBTdGF0ZVRvUHJvcHMgPT09ICdmdW5jdGlvbicgPyB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwU3RhdGVUb1Byb3BzLCAnbWFwU3RhdGVUb1Byb3BzJykgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZyhtYXBTdGF0ZVRvUHJvcHMpIHtcbiAgcmV0dXJuICFtYXBTdGF0ZVRvUHJvcHMgPyB3cmFwTWFwVG9Qcm9wc0NvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge307XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGRlZmF1bHQgW3doZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uLCB3aGVuTWFwU3RhdGVUb1Byb3BzSXNNaXNzaW5nXTsiLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvd25Qcm9wcywgc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBwdXJlID0gX3JlZi5wdXJlLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZi5hcmVNZXJnZWRQcm9wc0VxdWFsO1xuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24sIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkXTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCB2ZXJpZnlTdWJzZWxlY3RvcnMgZnJvbSAnLi92ZXJpZnlTdWJzZWxlY3RvcnMnO1xuZXhwb3J0IGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMobWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyksIG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpLCBvd25Qcm9wcyk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG4gIHZhciBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIHZhciBvd25Qcm9wcztcbiAgdmFyIHN0YXRlUHJvcHM7XG4gIHZhciBkaXNwYXRjaFByb3BzO1xuICB2YXIgbWVyZ2VkUHJvcHM7XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgdmFyIHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwobmV4dFN0YXRlLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn0gLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiaW5pdE1hcFN0YXRlVG9Qcm9wc1wiLCBcImluaXRNYXBEaXNwYXRjaFRvUHJvcHNcIiwgXCJpbml0TWVyZ2VQcm9wc1wiXSk7XG5cbiAgdmFyIG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBvcHRpb25zLmRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZhY3RvcnkgPSBvcHRpb25zLnB1cmUgPyBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA6IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgaW4gXCIgKyBkaXNwbGF5TmFtZSArIFwiLlwiKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCAnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhcIlRoZSBzZWxlY3RvciBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgb2YgXCIgKyBkaXNwbGF5TmFtZSArIFwiIGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5cIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJywgZGlzcGxheU5hbWUpO1xufSIsImltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCwgb3B0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cblxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn0gLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vL1xuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IG51bGwgJiYgbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gdW5kZWZpbmVkID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufSAvLyBVc2VkIGJ5IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uIGFuZCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbixcbi8vIHRoaXMgZnVuY3Rpb24gd3JhcHMgbWFwVG9Qcm9wcyBpbiBhIHByb3h5IGZ1bmN0aW9uIHdoaWNoIGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4vL1xuLy8gICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBkZXBlbmRzIG9uIHByb3BzLCB3aGljaFxuLy8gICAgaXMgdXNlZCBieSBzZWxlY3RvckZhY3RvcnkgdG8gZGVjaWRlIGlmIGl0IHNob3VsZCByZWludm9rZSBvbiBwcm9wcyBjaGFuZ2VzLlxuLy9cbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vL1xuLy8gICogT24gZmlyc3QgY2FsbCwgdmVyaWZpZXMgdGhlIGZpcnN0IHJlc3VsdCBpcyBhIHBsYWluIG9iamVjdCwgaW4gb3JkZXIgdG8gd2FyblxuLy8gICAgdGhlIGRldmVsb3BlciB0aGF0IHRoZWlyIG1hcFRvUHJvcHMgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBhIHZhbGlkIHJlc3VsdC5cbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTsgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcblxuXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn0iLCJpbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VTdG9yZSBhcyB1c2VEZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlSG9vayB9IGZyb20gJy4vdXNlU3RvcmUnO1xuLyoqXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlRGlzcGF0Y2hgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoSG9vayhjb250ZXh0KSB7XG4gIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICBjb250ZXh0ID0gUmVhY3RSZWR1eENvbnRleHQ7XG4gIH1cblxuICB2YXIgdXNlU3RvcmUgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRTdG9yZSA6IGNyZWF0ZVN0b3JlSG9vayhjb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVzZURpc3BhdGNoKCkge1xuICAgIHZhciBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gICAgcmV0dXJuIHN0b3JlLmRpc3BhdGNoO1xuICB9O1xufVxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBgZGlzcGF0Y2hgIGZ1bmN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHthbnl8ZnVuY3Rpb259IHJlZHV4IHN0b3JlJ3MgYGRpc3BhdGNoYCBmdW5jdGlvblxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VEaXNwYXRjaCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xuICogICBjb25zdCBkaXNwYXRjaCA9IHVzZURpc3BhdGNoKClcbiAqICAgY29uc3QgaW5jcmVhc2VDb3VudGVyID0gdXNlQ2FsbGJhY2soKCkgPT4gZGlzcGF0Y2goeyB0eXBlOiAnaW5jcmVhc2UtY291bnRlcicgfSksIFtdKVxuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8c3Bhbj57dmFsdWV9PC9zcGFuPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtpbmNyZWFzZUNvdW50ZXJ9PkluY3JlYXNlIGNvdW50ZXI8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKVxuICogfVxuICovXG5cbmV4cG9ydCB2YXIgdXNlRGlzcGF0Y2ggPSAvKiNfX1BVUkVfXyovY3JlYXRlRGlzcGF0Y2hIb29rKCk7IiwiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi4vY29tcG9uZW50cy9Db250ZXh0Jztcbi8qKlxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgdmFsdWUgb2YgdGhlIGBSZWFjdFJlZHV4Q29udGV4dGAuIFRoaXMgaXMgYSBsb3ctbGV2ZWxcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cbiAqXG4gKiBAcmV0dXJucyB7YW55fSB0aGUgdmFsdWUgb2YgdGhlIGBSZWFjdFJlZHV4Q29udGV4dGBcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xuICogICBjb25zdCB7IHN0b3JlIH0gPSB1c2VSZWR1eENvbnRleHQoKVxuICogICByZXR1cm4gPGRpdj57c3RvcmUuZ2V0U3RhdGUoKX08L2Rpdj5cbiAqIH1cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVkdXhDb250ZXh0KCkge1xuICB2YXIgY29udGV4dFZhbHVlID0gdXNlQ29udGV4dChSZWFjdFJlZHV4Q29udGV4dCk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbnRleHRWYWx1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IGZpbmQgcmVhY3QtcmVkdXggY29udGV4dCB2YWx1ZTsgcGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UHJvdmlkZXI+Jyk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dFZhbHVlO1xufSIsImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVJlZiwgdXNlTWVtbywgdXNlQ29udGV4dCwgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVJlZHV4Q29udGV4dCBhcyB1c2VEZWZhdWx0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi91c2VSZWR1eENvbnRleHQnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuXG52YXIgcmVmRXF1YWxpdHkgPSBmdW5jdGlvbiByZWZFcXVhbGl0eShhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufTtcblxuZnVuY3Rpb24gdXNlU2VsZWN0b3JXaXRoU3RvcmVBbmRTdWJzY3JpcHRpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4sIHN0b3JlLCBjb250ZXh0U3ViKSB7XG4gIHZhciBfdXNlUmVkdWNlciA9IHVzZVJlZHVjZXIoZnVuY3Rpb24gKHMpIHtcbiAgICByZXR1cm4gcyArIDE7XG4gIH0sIDApLFxuICAgICAgZm9yY2VSZW5kZXIgPSBfdXNlUmVkdWNlclsxXTtcblxuICB2YXIgc3Vic2NyaXB0aW9uID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb24oc3RvcmUsIGNvbnRleHRTdWIpO1xuICB9LCBbc3RvcmUsIGNvbnRleHRTdWJdKTtcbiAgdmFyIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdG9yID0gdXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTdG9yZVN0YXRlID0gdXNlUmVmKCk7XG4gIHZhciBsYXRlc3RTZWxlY3RlZFN0YXRlID0gdXNlUmVmKCk7XG4gIHZhciBzdG9yZVN0YXRlID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgfHwgc3RvcmVTdGF0ZSAhPT0gbGF0ZXN0U3RvcmVTdGF0ZS5jdXJyZW50IHx8IGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgc2VsZWN0ZWRTdGF0ZSA9IHNlbGVjdG9yKHN0b3JlU3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gXCJcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcblwiICsgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50LnN0YWNrICsgXCJcXG5cXG5cIjtcbiAgICB9XG5cbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBsYXRlc3RTZWxlY3Rvci5jdXJyZW50ID0gc2VsZWN0b3I7XG4gICAgbGF0ZXN0U3RvcmVTdGF0ZS5jdXJyZW50ID0gc3RvcmVTdGF0ZTtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChzdG9yZS5nZXRTdGF0ZSgpKTtcblxuICAgICAgICBpZiAoZXF1YWxpdHlGbihuZXdTZWxlY3RlZFN0YXRlLCBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHN1YnNjcmlwdGlvbi5vblN0YXRlQ2hhbmdlID0gY2hlY2tGb3JVcGRhdGVzO1xuICAgIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgIH07XG4gIH0sIFtzdG9yZSwgc3Vic2NyaXB0aW9uXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlU2VsZWN0b3JgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VTZWxlY3RvcmAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dDtcbiAgfVxuXG4gIHZhciB1c2VSZWR1eENvbnRleHQgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRSZWR1eENvbnRleHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTZWxlY3RvcihzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgIGlmIChlcXVhbGl0eUZuID09PSB2b2lkIDApIHtcbiAgICAgIGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc2VsZWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvclwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3VzZVJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dCgpLFxuICAgICAgICBzdG9yZSA9IF91c2VSZWR1eENvbnRleHQuc3RvcmUsXG4gICAgICAgIGNvbnRleHRTdWIgPSBfdXNlUmVkdXhDb250ZXh0LnN1YnNjcmlwdGlvbjtcblxuICAgIHZhciBzZWxlY3RlZFN0YXRlID0gdXNlU2VsZWN0b3JXaXRoU3RvcmVBbmRTdWJzY3JpcHRpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4sIHN0b3JlLCBjb250ZXh0U3ViKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xuICB9O1xufVxuLyoqXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBzdG9yZSdzIHN0YXRlLiBUaGlzIGhvb2sgdGFrZXMgYSBzZWxlY3RvciBmdW5jdGlvblxuICogYXMgYW4gYXJndW1lbnQuIFRoZSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgc3RvcmUgc3RhdGUuXG4gKlxuICogVGhpcyBob29rIHRha2VzIGFuIG9wdGlvbmFsIGVxdWFsaXR5IGNvbXBhcmlzb24gZnVuY3Rpb24gYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXJcbiAqIHRoYXQgYWxsb3dzIHlvdSB0byBjdXN0b21pemUgdGhlIHdheSB0aGUgc2VsZWN0ZWQgc3RhdGUgaXMgY29tcGFyZWQgdG8gZGV0ZXJtaW5lXG4gKiB3aGV0aGVyIHRoZSBjb21wb25lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZXF1YWxpdHlGbiB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5XG4gKlxuICogQHJldHVybnMge2FueX0gdGhlIHNlbGVjdGVkIHN0YXRlXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyB1c2VTZWxlY3RvciB9IGZyb20gJ3JlYWN0LXJlZHV4J1xuICpcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBjb3VudGVyID0gdXNlU2VsZWN0b3Ioc3RhdGUgPT4gc3RhdGUuY291bnRlcilcbiAqICAgcmV0dXJuIDxkaXY+e2NvdW50ZXJ9PC9kaXY+XG4gKiB9XG4gKi9cblxuZXhwb3J0IHZhciB1c2VTZWxlY3RvciA9IC8qI19fUFVSRV9fKi9jcmVhdGVTZWxlY3Rvckhvb2soKTsiLCJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuaW1wb3J0IHsgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQgfSBmcm9tICcuL3VzZVJlZHV4Q29udGV4dCc7XG4vKipcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZVN0b3JlYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dDtcbiAgfVxuXG4gIHZhciB1c2VSZWR1eENvbnRleHQgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRSZWR1eENvbnRleHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgICB2YXIgX3VzZVJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dCgpLFxuICAgICAgICBzdG9yZSA9IF91c2VSZWR1eENvbnRleHQuc3RvcmU7XG5cbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG59XG4vKipcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHJlZHV4IHN0b3JlLlxuICpcbiAqIEByZXR1cm5zIHthbnl9IHRoZSByZWR1eCBzdG9yZVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuICogaW1wb3J0IHsgdXNlU3RvcmUgfSBmcm9tICdyZWFjdC1yZWR1eCdcbiAqXG4gKiBleHBvcnQgY29uc3QgRXhhbXBsZUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpXG4gKiAgIHJldHVybiA8ZGl2PntzdG9yZS5nZXRTdGF0ZSgpfTwvZGl2PlxuICogfVxuICovXG5cbmV4cG9ydCB2YXIgdXNlU3RvcmUgPSAvKiNfX1BVUkVfXyovY3JlYXRlU3RvcmVIb29rKCk7IiwiaW1wb3J0IFByb3ZpZGVyIGZyb20gJy4vY29tcG9uZW50cy9Qcm92aWRlcic7XG5pbXBvcnQgY29ubmVjdEFkdmFuY2VkIGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgY29ubmVjdCBmcm9tICcuL2Nvbm5lY3QvY29ubmVjdCc7XG5pbXBvcnQgeyB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rIH0gZnJvbSAnLi9ob29rcy91c2VEaXNwYXRjaCc7XG5pbXBvcnQgeyB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTZWxlY3Rvcic7XG5pbXBvcnQgeyB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rIH0gZnJvbSAnLi9ob29rcy91c2VTdG9yZSc7XG5pbXBvcnQgeyBzZXRCYXRjaCB9IGZyb20gJy4vdXRpbHMvYmF0Y2gnO1xuaW1wb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgYXMgYmF0Y2ggfSBmcm9tICcuL3V0aWxzL3JlYWN0QmF0Y2hlZFVwZGF0ZXMnO1xuaW1wb3J0IHNoYWxsb3dFcXVhbCBmcm9tICcuL3V0aWxzL3NoYWxsb3dFcXVhbCc7XG5zZXRCYXRjaChiYXRjaCk7XG5leHBvcnQgeyBQcm92aWRlciwgY29ubmVjdEFkdmFuY2VkLCBSZWFjdFJlZHV4Q29udGV4dCwgY29ubmVjdCwgYmF0Y2gsIHVzZURpc3BhdGNoLCBjcmVhdGVEaXNwYXRjaEhvb2ssIHVzZVNlbGVjdG9yLCBjcmVhdGVTZWxlY3Rvckhvb2ssIHVzZVN0b3JlLCBjcmVhdGVTdG9yZUhvb2ssIHNoYWxsb3dFcXVhbCB9OyIsImltcG9ydCB7IGdldEJhdGNoIH0gZnJvbSAnLi9iYXRjaCc7IC8vIGVuY2Fwc3VsYXRlcyB0aGUgc3Vic2NyaXB0aW9uIGxvZ2ljIGZvciBjb25uZWN0aW5nIGEgY29tcG9uZW50IHRvIHRoZSByZWR1eCBzdG9yZSwgYXNcbi8vIHdlbGwgYXMgbmVzdGluZyBzdWJzY3JpcHRpb25zIG9mIGRlc2NlbmRhbnQgY29tcG9uZW50cywgc28gdGhhdCB3ZSBjYW4gZW5zdXJlIHRoZVxuLy8gYW5jZXN0b3IgY29tcG9uZW50cyByZS1yZW5kZXIgYmVmb3JlIGRlc2NlbmRhbnRzXG5cbnZhciBudWxsTGlzdGVuZXJzID0ge1xuICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHt9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lckNvbGxlY3Rpb24oKSB7XG4gIHZhciBiYXRjaCA9IGdldEJhdGNoKCk7XG4gIHZhciBmaXJzdCA9IG51bGw7XG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBmaXJzdCA9IG51bGw7XG4gICAgICBsYXN0ID0gbnVsbDtcbiAgICB9LFxuICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgYmF0Y2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBmaXJzdDtcblxuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5jYWxsYmFjaygpO1xuICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGZpcnN0O1xuXG4gICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgfSxcbiAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsYXN0ID0ge1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIG5leHQ6IG51bGwsXG4gICAgICAgIHByZXY6IGxhc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChsaXN0ZW5lci5wcmV2KSB7XG4gICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmlyc3QgPSBsaXN0ZW5lcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZCB8fCBmaXJzdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpc1N1YnNjcmliZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAobGlzdGVuZXIubmV4dCkge1xuICAgICAgICAgIGxpc3RlbmVyLm5leHQucHJldiA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdCA9IGxpc3RlbmVyLnByZXY7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICAgIGxpc3RlbmVyLnByZXYubmV4dCA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3QgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFN1YnNjcmlwdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihzdG9yZSwgcGFyZW50U3ViKSB7XG4gICAgdGhpcy5zdG9yZSA9IHN0b3JlO1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViO1xuICAgIHRoaXMudW5zdWJzY3JpYmUgPSBudWxsO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbnVsbExpc3RlbmVycztcbiAgICB0aGlzLmhhbmRsZUNoYW5nZVdyYXBwZXIgPSB0aGlzLmhhbmRsZUNoYW5nZVdyYXBwZXIuYmluZCh0aGlzKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdWJzY3JpcHRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGROZXN0ZWRTdWIgPSBmdW5jdGlvbiBhZGROZXN0ZWRTdWIobGlzdGVuZXIpIHtcbiAgICB0aGlzLnRyeVN1YnNjcmliZSgpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycy5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICB9O1xuXG4gIF9wcm90by5ub3RpZnlOZXN0ZWRTdWJzID0gZnVuY3Rpb24gbm90aWZ5TmVzdGVkU3VicygpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5ub3RpZnkoKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlQ2hhbmdlV3JhcHBlciA9IGZ1bmN0aW9uIGhhbmRsZUNoYW5nZVdyYXBwZXIoKSB7XG4gICAgaWYgKHRoaXMub25TdGF0ZUNoYW5nZSkge1xuICAgICAgdGhpcy5vblN0YXRlQ2hhbmdlKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5pc1N1YnNjcmliZWQgPSBmdW5jdGlvbiBpc1N1YnNjcmliZWQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy51bnN1YnNjcmliZSk7XG4gIH07XG5cbiAgX3Byb3RvLnRyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zdWJzY3JpYmUpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUgPSB0aGlzLnBhcmVudFN1YiA/IHRoaXMucGFyZW50U3ViLmFkZE5lc3RlZFN1Yih0aGlzLmhhbmRsZUNoYW5nZVdyYXBwZXIpIDogdGhpcy5zdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyKTtcbiAgICAgIHRoaXMubGlzdGVuZXJzID0gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by50cnlVbnN1YnNjcmliZSA9IGZ1bmN0aW9uIHRyeVVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpcHRpb247XG59KCk7XG5cbmV4cG9ydCB7IFN1YnNjcmlwdGlvbiBhcyBkZWZhdWx0IH07IiwiLy8gRGVmYXVsdCB0byBhIGR1bW15IFwiYmF0Y2hcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGp1c3QgcnVucyB0aGUgY2FsbGJhY2tcbmZ1bmN0aW9uIGRlZmF1bHROb29wQmF0Y2goY2FsbGJhY2spIHtcbiAgY2FsbGJhY2soKTtcbn1cblxudmFyIGJhdGNoID0gZGVmYXVsdE5vb3BCYXRjaDsgLy8gQWxsb3cgaW5qZWN0aW5nIGFub3RoZXIgYmF0Y2hpbmcgZnVuY3Rpb24gbGF0ZXJcblxuZXhwb3J0IHZhciBzZXRCYXRjaCA9IGZ1bmN0aW9uIHNldEJhdGNoKG5ld0JhdGNoKSB7XG4gIHJldHVybiBiYXRjaCA9IG5ld0JhdGNoO1xufTsgLy8gU3VwcGx5IGEgZ2V0dGVyIGp1c3QgdG8gc2tpcCBkZWFsaW5nIHdpdGggRVNNIGJpbmRpbmdzXG5cbmV4cG9ydCB2YXIgZ2V0QmF0Y2ggPSBmdW5jdGlvbiBnZXRCYXRjaCgpIHtcbiAgcmV0dXJuIGJhdGNoO1xufTsiLCIvKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gIGlmIChwcm90byA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBiYXNlUHJvdG8gPSBwcm90bztcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90bykgIT09IG51bGwpIHtcbiAgICBiYXNlUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZVByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBwcm90byA9PT0gYmFzZVByb3RvO1xufSIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9uby11bnJlc29sdmVkICovXG5leHBvcnQgeyB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyB9IGZyb20gJ3JlYWN0LWRvbSc7IiwiZnVuY3Rpb24gaXMoeCwgeSkge1xuICBpZiAoeCA9PT0geSkge1xuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCB9IGZyb20gJ3JlYWN0JzsgLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuIFdlIG5lZWQgdXNlTGF5b3V0RWZmZWN0IHRvIGVuc3VyZSB0aGUgc3RvcmVcbi8vIHN1YnNjcmlwdGlvbiBjYWxsYmFjayBhbHdheXMgaGFzIHRoZSBzZWxlY3RvciBmcm9tIHRoZSBsYXRlc3QgcmVuZGVyIGNvbW1pdFxuLy8gYXZhaWxhYmxlLCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IGhhcHBlbiBiZXR3ZWVuIHJlbmRlciBhbmQgdGhlIGVmZmVjdCxcbi8vIHdoaWNoIG1heSBjYXVzZSBtaXNzZWQgdXBkYXRlczsgd2UgYWxzbyBtdXN0IGVuc3VyZSB0aGUgc3RvcmUgc3Vic2NyaXB0aW9uXG4vLyBpcyBjcmVhdGVkIHN5bmNocm9ub3VzbHksIG90aGVyd2lzZSBhIHN0b3JlIHVwZGF0ZSBtYXkgb2NjdXIgYmVmb3JlIHRoZVxuLy8gc3Vic2NyaXB0aW9uIGlzIGNyZWF0ZWQgYW5kIGFuIGluY29uc2lzdGVudCBzdGF0ZSBtYXkgYmUgb2JzZXJ2ZWRcblxuZXhwb3J0IHZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDsiLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnO1xuaW1wb3J0IHdhcm5pbmcgZnJvbSAnLi93YXJuaW5nJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVBsYWluT2JqZWN0KHZhbHVlLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgd2FybmluZyhtZXRob2ROYW1lICsgXCIoKSBpbiBcIiArIGRpc3BsYXlOYW1lICsgXCIgbXVzdCByZXR1cm4gYSBwbGFpbiBvYmplY3QuIEluc3RlYWQgcmVjZWl2ZWQgXCIgKyB2YWx1ZSArIFwiLlwiKTtcbiAgfVxufSIsIi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG59IiwiZnVuY3Rpb24gY3JlYXRlVGh1bmtNaWRkbGV3YXJlKGV4dHJhQXJndW1lbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGRpc3BhdGNoID0gX3JlZi5kaXNwYXRjaCxcbiAgICAgICAgZ2V0U3RhdGUgPSBfcmVmLmdldFN0YXRlO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV4dCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGRpc3BhdGNoLCBnZXRTdGF0ZSwgZXh0cmFBcmd1bWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dChhY3Rpb24pO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgdGh1bmsgPSBjcmVhdGVUaHVua01pZGRsZXdhcmUoKTtcbnRodW5rLndpdGhFeHRyYUFyZ3VtZW50ID0gY3JlYXRlVGh1bmtNaWRkbGV3YXJlO1xuXG5leHBvcnQgZGVmYXVsdCB0aHVuazsiLCJpbXBvcnQgJCRvYnNlcnZhYmxlIGZyb20gJ3N5bWJvbC1vYnNlcnZhYmxlJztcblxuLyoqXG4gKiBUaGVzZSBhcmUgcHJpdmF0ZSBhY3Rpb24gdHlwZXMgcmVzZXJ2ZWQgYnkgUmVkdXguXG4gKiBGb3IgYW55IHVua25vd24gYWN0aW9ucywgeW91IG11c3QgcmV0dXJuIHRoZSBjdXJyZW50IHN0YXRlLlxuICogSWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuXG4gKiBEbyBub3QgcmVmZXJlbmNlIHRoZXNlIGFjdGlvbiB0eXBlcyBkaXJlY3RseSBpbiB5b3VyIGNvZGUuXG4gKi9cbnZhciByYW5kb21TdHJpbmcgPSBmdW5jdGlvbiByYW5kb21TdHJpbmcoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNykuc3BsaXQoJycpLmpvaW4oJy4nKTtcbn07XG5cbnZhciBBY3Rpb25UeXBlcyA9IHtcbiAgSU5JVDogXCJAQHJlZHV4L0lOSVRcIiArIHJhbmRvbVN0cmluZygpLFxuICBSRVBMQUNFOiBcIkBAcmVkdXgvUkVQTEFDRVwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFBST0JFX1VOS05PV05fQUNUSU9OOiBmdW5jdGlvbiBQUk9CRV9VTktOT1dOX0FDVElPTigpIHtcbiAgICByZXR1cm4gXCJAQHJlZHV4L1BST0JFX1VOS05PV05fQUNUSU9OXCIgKyByYW5kb21TdHJpbmcoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBhcmd1bWVudCBhcHBlYXJzIHRvIGJlIGEgcGxhaW4gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IG9iajtcblxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFJlZHV4IHN0b3JlIHRoYXQgaG9sZHMgdGhlIHN0YXRlIHRyZWUuXG4gKiBUaGUgb25seSB3YXkgdG8gY2hhbmdlIHRoZSBkYXRhIGluIHRoZSBzdG9yZSBpcyB0byBjYWxsIGBkaXNwYXRjaCgpYCBvbiBpdC5cbiAqXG4gKiBUaGVyZSBzaG91bGQgb25seSBiZSBhIHNpbmdsZSBzdG9yZSBpbiB5b3VyIGFwcC4gVG8gc3BlY2lmeSBob3cgZGlmZmVyZW50XG4gKiBwYXJ0cyBvZiB0aGUgc3RhdGUgdHJlZSByZXNwb25kIHRvIGFjdGlvbnMsIHlvdSBtYXkgY29tYmluZSBzZXZlcmFsIHJlZHVjZXJzXG4gKiBpbnRvIGEgc2luZ2xlIHJlZHVjZXIgZnVuY3Rpb24gYnkgdXNpbmcgYGNvbWJpbmVSZWR1Y2Vyc2AuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVkdWNlciBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV4dCBzdGF0ZSB0cmVlLCBnaXZlblxuICogdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGFjdGlvbiB0byBoYW5kbGUuXG4gKlxuICogQHBhcmFtIHthbnl9IFtwcmVsb2FkZWRTdGF0ZV0gVGhlIGluaXRpYWwgc3RhdGUuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBoeWRyYXRlIHRoZSBzdGF0ZSBmcm9tIHRoZSBzZXJ2ZXIgaW4gdW5pdmVyc2FsIGFwcHMsIG9yIHRvIHJlc3RvcmUgYVxuICogcHJldmlvdXNseSBzZXJpYWxpemVkIHVzZXIgc2Vzc2lvbi5cbiAqIElmIHlvdSB1c2UgYGNvbWJpbmVSZWR1Y2Vyc2AgdG8gcHJvZHVjZSB0aGUgcm9vdCByZWR1Y2VyIGZ1bmN0aW9uLCB0aGlzIG11c3QgYmVcbiAqIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGFzIGBjb21iaW5lUmVkdWNlcnNgIGtleXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2VuaGFuY2VyXSBUaGUgc3RvcmUgZW5oYW5jZXIuIFlvdSBtYXkgb3B0aW9uYWxseSBzcGVjaWZ5IGl0XG4gKiB0byBlbmhhbmNlIHRoZSBzdG9yZSB3aXRoIHRoaXJkLXBhcnR5IGNhcGFiaWxpdGllcyBzdWNoIGFzIG1pZGRsZXdhcmUsXG4gKiB0aW1lIHRyYXZlbCwgcGVyc2lzdGVuY2UsIGV0Yy4gVGhlIG9ubHkgc3RvcmUgZW5oYW5jZXIgdGhhdCBzaGlwcyB3aXRoIFJlZHV4XG4gKiBpcyBgYXBwbHlNaWRkbGV3YXJlKClgLlxuICpcbiAqIEByZXR1cm5zIHtTdG9yZX0gQSBSZWR1eCBzdG9yZSB0aGF0IGxldHMgeW91IHJlYWQgdGhlIHN0YXRlLCBkaXNwYXRjaCBhY3Rpb25zXG4gKiBhbmQgc3Vic2NyaWJlIHRvIGNoYW5nZXMuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlU3RvcmUocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUsIGVuaGFuY2VyKSB7XG4gIHZhciBfcmVmMjtcblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZW5oYW5jZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSXQgbG9va3MgbGlrZSB5b3UgYXJlIHBhc3Npbmcgc2V2ZXJhbCBzdG9yZSBlbmhhbmNlcnMgdG8gJyArICdjcmVhdGVTdG9yZSgpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEluc3RlYWQsIGNvbXBvc2UgdGhlbSAnICsgJ3RvZ2V0aGVyIHRvIGEgc2luZ2xlIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwcmVsb2FkZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZW5oYW5jZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZW5oYW5jZXIgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgICBwcmVsb2FkZWRTdGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5oYW5jZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgZW5oYW5jZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5oYW5jZXIoY3JlYXRlU3RvcmUpKHJlZHVjZXIsIHByZWxvYWRlZFN0YXRlKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIHJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50UmVkdWNlciA9IHJlZHVjZXI7XG4gIHZhciBjdXJyZW50U3RhdGUgPSBwcmVsb2FkZWRTdGF0ZTtcbiAgdmFyIGN1cnJlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzO1xuICB2YXIgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAvKipcbiAgICogVGhpcyBtYWtlcyBhIHNoYWxsb3cgY29weSBvZiBjdXJyZW50TGlzdGVuZXJzIHNvIHdlIGNhbiB1c2VcbiAgICogbmV4dExpc3RlbmVycyBhcyBhIHRlbXBvcmFyeSBsaXN0IHdoaWxlIGRpc3BhdGNoaW5nLlxuICAgKlxuICAgKiBUaGlzIHByZXZlbnRzIGFueSBidWdzIGFyb3VuZCBjb25zdW1lcnMgY2FsbGluZ1xuICAgKiBzdWJzY3JpYmUvdW5zdWJzY3JpYmUgaW4gdGhlIG1pZGRsZSBvZiBhIGRpc3BhdGNoLlxuICAgKi9cblxuICBmdW5jdGlvbiBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCkge1xuICAgIGlmIChuZXh0TGlzdGVuZXJzID09PSBjdXJyZW50TGlzdGVuZXJzKSB7XG4gICAgICBuZXh0TGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycy5zbGljZSgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVhZHMgdGhlIHN0YXRlIHRyZWUgbWFuYWdlZCBieSB0aGUgc3RvcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIHthbnl9IFRoZSBjdXJyZW50IHN0YXRlIHRyZWUgb2YgeW91ciBhcHBsaWNhdGlvbi5cbiAgICovXG5cblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLmdldFN0YXRlKCkgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1RoZSByZWR1Y2VyIGhhcyBhbHJlYWR5IHJlY2VpdmVkIHRoZSBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gJyArICdQYXNzIGl0IGRvd24gZnJvbSB0aGUgdG9wIHJlZHVjZXIgaW5zdGVhZCBvZiByZWFkaW5nIGl0IGZyb20gdGhlIHN0b3JlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gIH1cbiAgLyoqXG4gICAqIEFkZHMgYSBjaGFuZ2UgbGlzdGVuZXIuIEl0IHdpbGwgYmUgY2FsbGVkIGFueSB0aW1lIGFuIGFjdGlvbiBpcyBkaXNwYXRjaGVkLFxuICAgKiBhbmQgc29tZSBwYXJ0IG9mIHRoZSBzdGF0ZSB0cmVlIG1heSBwb3RlbnRpYWxseSBoYXZlIGNoYW5nZWQuIFlvdSBtYXkgdGhlblxuICAgKiBjYWxsIGBnZXRTdGF0ZSgpYCB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIHRyZWUgaW5zaWRlIHRoZSBjYWxsYmFjay5cbiAgICpcbiAgICogWW91IG1heSBjYWxsIGBkaXNwYXRjaCgpYCBmcm9tIGEgY2hhbmdlIGxpc3RlbmVyLCB3aXRoIHRoZSBmb2xsb3dpbmdcbiAgICogY2F2ZWF0czpcbiAgICpcbiAgICogMS4gVGhlIHN1YnNjcmlwdGlvbnMgYXJlIHNuYXBzaG90dGVkIGp1c3QgYmVmb3JlIGV2ZXJ5IGBkaXNwYXRjaCgpYCBjYWxsLlxuICAgKiBJZiB5b3Ugc3Vic2NyaWJlIG9yIHVuc3Vic2NyaWJlIHdoaWxlIHRoZSBsaXN0ZW5lcnMgYXJlIGJlaW5nIGludm9rZWQsIHRoaXNcbiAgICogd2lsbCBub3QgaGF2ZSBhbnkgZWZmZWN0IG9uIHRoZSBgZGlzcGF0Y2goKWAgdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAqIEhvd2V2ZXIsIHRoZSBuZXh0IGBkaXNwYXRjaCgpYCBjYWxsLCB3aGV0aGVyIG5lc3RlZCBvciBub3QsIHdpbGwgdXNlIGEgbW9yZVxuICAgKiByZWNlbnQgc25hcHNob3Qgb2YgdGhlIHN1YnNjcmlwdGlvbiBsaXN0LlxuICAgKlxuICAgKiAyLiBUaGUgbGlzdGVuZXIgc2hvdWxkIG5vdCBleHBlY3QgdG8gc2VlIGFsbCBzdGF0ZSBjaGFuZ2VzLCBhcyB0aGUgc3RhdGVcbiAgICogbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIGEgbmVzdGVkIGBkaXNwYXRjaCgpYCBiZWZvcmVcbiAgICogdGhlIGxpc3RlbmVyIGlzIGNhbGxlZC4gSXQgaXMsIGhvd2V2ZXIsIGd1YXJhbnRlZWQgdGhhdCBhbGwgc3Vic2NyaWJlcnNcbiAgICogcmVnaXN0ZXJlZCBiZWZvcmUgdGhlIGBkaXNwYXRjaCgpYCBzdGFydGVkIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxhdGVzdFxuICAgKiBzdGF0ZSBieSB0aGUgdGltZSBpdCBleGl0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgQSBjYWxsYmFjayB0byBiZSBpbnZva2VkIG9uIGV2ZXJ5IGRpc3BhdGNoLlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gcmVtb3ZlIHRoaXMgY2hhbmdlIGxpc3RlbmVyLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG1heSBub3QgY2FsbCBzdG9yZS5zdWJzY3JpYmUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnSWYgeW91IHdvdWxkIGxpa2UgdG8gYmUgbm90aWZpZWQgYWZ0ZXIgdGhlIHN0b3JlIGhhcyBiZWVuIHVwZGF0ZWQsIHN1YnNjcmliZSBmcm9tIGEgJyArICdjb21wb25lbnQgYW5kIGludm9rZSBzdG9yZS5nZXRTdGF0ZSgpIGluIHRoZSBjYWxsYmFjayB0byBhY2Nlc3MgdGhlIGxhdGVzdCBzdGF0ZS4gJyArICdTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvYXBpLXJlZmVyZW5jZS9zdG9yZSNzdWJzY3JpYmVsaXN0ZW5lciBmb3IgbW9yZSBkZXRhaWxzLicpO1xuICAgIH1cblxuICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKTtcbiAgICBuZXh0TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIGlmICghaXNTdWJzY3JpYmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRGlzcGF0Y2hpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCB1bnN1YnNjcmliZSBmcm9tIGEgc3RvcmUgbGlzdGVuZXIgd2hpbGUgdGhlIHJlZHVjZXIgaXMgZXhlY3V0aW5nLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGktcmVmZXJlbmNlL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgICB9XG5cbiAgICAgIGlzU3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgICAgdmFyIGluZGV4ID0gbmV4dExpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIG5leHRMaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGN1cnJlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYW4gYWN0aW9uLiBJdCBpcyB0aGUgb25seSB3YXkgdG8gdHJpZ2dlciBhIHN0YXRlIGNoYW5nZS5cbiAgICpcbiAgICogVGhlIGByZWR1Y2VyYCBmdW5jdGlvbiwgdXNlZCB0byBjcmVhdGUgdGhlIHN0b3JlLCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZVxuICAgKiBjdXJyZW50IHN0YXRlIHRyZWUgYW5kIHRoZSBnaXZlbiBgYWN0aW9uYC4gSXRzIHJldHVybiB2YWx1ZSB3aWxsXG4gICAqIGJlIGNvbnNpZGVyZWQgdGhlICoqbmV4dCoqIHN0YXRlIG9mIHRoZSB0cmVlLCBhbmQgdGhlIGNoYW5nZSBsaXN0ZW5lcnNcbiAgICogd2lsbCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb25seSBzdXBwb3J0cyBwbGFpbiBvYmplY3QgYWN0aW9ucy4gSWYgeW91IHdhbnQgdG9cbiAgICogZGlzcGF0Y2ggYSBQcm9taXNlLCBhbiBPYnNlcnZhYmxlLCBhIHRodW5rLCBvciBzb21ldGhpbmcgZWxzZSwgeW91IG5lZWQgdG9cbiAgICogd3JhcCB5b3VyIHN0b3JlIGNyZWF0aW5nIGZ1bmN0aW9uIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgbWlkZGxld2FyZS4gRm9yXG4gICAqIGV4YW1wbGUsIHNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgdGhlIGByZWR1eC10aHVua2AgcGFja2FnZS4gRXZlbiB0aGVcbiAgICogbWlkZGxld2FyZSB3aWxsIGV2ZW50dWFsbHkgZGlzcGF0Y2ggcGxhaW4gb2JqZWN0IGFjdGlvbnMgdXNpbmcgdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY3Rpb24gQSBwbGFpbiBvYmplY3QgcmVwcmVzZW50aW5nIOKAnHdoYXQgY2hhbmdlZOKAnS4gSXQgaXNcbiAgICogYSBnb29kIGlkZWEgdG8ga2VlcCBhY3Rpb25zIHNlcmlhbGl6YWJsZSBzbyB5b3UgY2FuIHJlY29yZCBhbmQgcmVwbGF5IHVzZXJcbiAgICogc2Vzc2lvbnMsIG9yIHVzZSB0aGUgdGltZSB0cmF2ZWxsaW5nIGByZWR1eC1kZXZ0b29sc2AuIEFuIGFjdGlvbiBtdXN0IGhhdmVcbiAgICogYSBgdHlwZWAgcHJvcGVydHkgd2hpY2ggbWF5IG5vdCBiZSBgdW5kZWZpbmVkYC4gSXQgaXMgYSBnb29kIGlkZWEgdG8gdXNlXG4gICAqIHN0cmluZyBjb25zdGFudHMgZm9yIGFjdGlvbiB0eXBlcy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gRm9yIGNvbnZlbmllbmNlLCB0aGUgc2FtZSBhY3Rpb24gb2JqZWN0IHlvdSBkaXNwYXRjaGVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQsIGlmIHlvdSB1c2UgYSBjdXN0b20gbWlkZGxld2FyZSwgaXQgbWF5IHdyYXAgYGRpc3BhdGNoKClgIHRvXG4gICAqIHJldHVybiBzb21ldGhpbmcgZWxzZSAoZm9yIGV4YW1wbGUsIGEgUHJvbWlzZSB5b3UgY2FuIGF3YWl0KS5cbiAgICovXG5cblxuICBmdW5jdGlvbiBkaXNwYXRjaChhY3Rpb24pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYWN0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG11c3QgYmUgcGxhaW4gb2JqZWN0cy4gJyArICdVc2UgY3VzdG9tIG1pZGRsZXdhcmUgZm9yIGFzeW5jIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWN0aW9ucyBtYXkgbm90IGhhdmUgYW4gdW5kZWZpbmVkIFwidHlwZVwiIHByb3BlcnR5LiAnICsgJ0hhdmUgeW91IG1pc3NwZWxsZWQgYSBjb25zdGFudD8nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWR1Y2VycyBtYXkgbm90IGRpc3BhdGNoIGFjdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlO1xuICAgICAgY3VycmVudFN0YXRlID0gY3VycmVudFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnMgPSBuZXh0TGlzdGVuZXJzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIHJlZHVjZXIgY3VycmVudGx5IHVzZWQgYnkgdGhlIHN0b3JlIHRvIGNhbGN1bGF0ZSB0aGUgc3RhdGUuXG4gICAqXG4gICAqIFlvdSBtaWdodCBuZWVkIHRoaXMgaWYgeW91ciBhcHAgaW1wbGVtZW50cyBjb2RlIHNwbGl0dGluZyBhbmQgeW91IHdhbnQgdG9cbiAgICogbG9hZCBzb21lIG9mIHRoZSByZWR1Y2VycyBkeW5hbWljYWxseS4gWW91IG1pZ2h0IGFsc28gbmVlZCB0aGlzIGlmIHlvdVxuICAgKiBpbXBsZW1lbnQgYSBob3QgcmVsb2FkaW5nIG1lY2hhbmlzbSBmb3IgUmVkdXguXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IG5leHRSZWR1Y2VyIFRoZSByZWR1Y2VyIGZvciB0aGUgc3RvcmUgdG8gdXNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VSZWR1Y2VyKG5leHRSZWR1Y2VyKSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0UmVkdWNlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbmV4dFJlZHVjZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBjdXJyZW50UmVkdWNlciA9IG5leHRSZWR1Y2VyOyAvLyBUaGlzIGFjdGlvbiBoYXMgYSBzaW1pbGlhciBlZmZlY3QgdG8gQWN0aW9uVHlwZXMuSU5JVC5cbiAgICAvLyBBbnkgcmVkdWNlcnMgdGhhdCBleGlzdGVkIGluIGJvdGggdGhlIG5ldyBhbmQgb2xkIHJvb3RSZWR1Y2VyXG4gICAgLy8gd2lsbCByZWNlaXZlIHRoZSBwcmV2aW91cyBzdGF0ZS4gVGhpcyBlZmZlY3RpdmVseSBwb3B1bGF0ZXNcbiAgICAvLyB0aGUgbmV3IHN0YXRlIHRyZWUgd2l0aCBhbnkgcmVsZXZhbnQgZGF0YSBmcm9tIHRoZSBvbGQgb25lLlxuXG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogQWN0aW9uVHlwZXMuUkVQTEFDRVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm9wZXJhYmlsaXR5IHBvaW50IGZvciBvYnNlcnZhYmxlL3JlYWN0aXZlIGxpYnJhcmllcy5cbiAgICogQHJldHVybnMge29ic2VydmFibGV9IEEgbWluaW1hbCBvYnNlcnZhYmxlIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAqIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlIG9ic2VydmFibGUgcHJvcG9zYWw6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9ic2VydmFibGVcbiAgICovXG5cblxuICBmdW5jdGlvbiBvYnNlcnZhYmxlKCkge1xuICAgIHZhciBfcmVmO1xuXG4gICAgdmFyIG91dGVyU3Vic2NyaWJlID0gc3Vic2NyaWJlO1xuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbWluaW1hbCBvYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JzZXJ2ZXIgQW55IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIGFuIG9ic2VydmVyLlxuICAgICAgICogVGhlIG9ic2VydmVyIG9iamVjdCBzaG91bGQgaGF2ZSBhIGBuZXh0YCBtZXRob2QuXG4gICAgICAgKiBAcmV0dXJucyB7c3Vic2NyaXB0aW9ufSBBbiBvYmplY3Qgd2l0aCBhbiBgdW5zdWJzY3JpYmVgIG1ldGhvZCB0aGF0IGNhblxuICAgICAgICogYmUgdXNlZCB0byB1bnN1YnNjcmliZSB0aGUgb2JzZXJ2YWJsZSBmcm9tIHRoZSBzdG9yZSwgYW5kIHByZXZlbnQgZnVydGhlclxuICAgICAgICogZW1pc3Npb24gb2YgdmFsdWVzIGZyb20gdGhlIG9ic2VydmFibGUuXG4gICAgICAgKi9cbiAgICAgIHN1YnNjcmliZTogZnVuY3Rpb24gc3Vic2NyaWJlKG9ic2VydmVyKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZXIgIT09ICdvYmplY3QnIHx8IG9ic2VydmVyID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIG9ic2VydmVyIHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9ic2VydmVTdGF0ZSgpIHtcbiAgICAgICAgICBpZiAob2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChnZXRTdGF0ZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZlU3RhdGUoKTtcbiAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gb3V0ZXJTdWJzY3JpYmUob2JzZXJ2ZVN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB1bnN1YnNjcmliZTogdW5zdWJzY3JpYmVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCBfcmVmWyQkb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LCBfcmVmO1xuICB9IC8vIFdoZW4gYSBzdG9yZSBpcyBjcmVhdGVkLCBhbiBcIklOSVRcIiBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBzbyB0aGF0IGV2ZXJ5XG4gIC8vIHJlZHVjZXIgcmV0dXJucyB0aGVpciBpbml0aWFsIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAvLyB0aGUgaW5pdGlhbCBzdGF0ZSB0cmVlLlxuXG5cbiAgZGlzcGF0Y2goe1xuICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgfSk7XG4gIHJldHVybiBfcmVmMiA9IHtcbiAgICBkaXNwYXRjaDogZGlzcGF0Y2gsXG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIHJlcGxhY2VSZWR1Y2VyOiByZXBsYWNlUmVkdWNlclxuICB9LCBfcmVmMlskJG9ic2VydmFibGVdID0gb2JzZXJ2YWJsZSwgX3JlZjI7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIHdhcm5pbmcgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCBpZiB5b3UgZW5hYmxlXG4gICAgLy8gXCJicmVhayBvbiBhbGwgZXhjZXB0aW9uc1wiIGluIHlvdXIgY29uc29sZSxcbiAgICAvLyBpdCB3b3VsZCBwYXVzZSB0aGUgZXhlY3V0aW9uIGF0IHRoaXMgbGluZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcblxufVxuXG5mdW5jdGlvbiBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShrZXksIGFjdGlvbikge1xuICB2YXIgYWN0aW9uVHlwZSA9IGFjdGlvbiAmJiBhY3Rpb24udHlwZTtcbiAgdmFyIGFjdGlvbkRlc2NyaXB0aW9uID0gYWN0aW9uVHlwZSAmJiBcImFjdGlvbiBcXFwiXCIgKyBTdHJpbmcoYWN0aW9uVHlwZSkgKyBcIlxcXCJcIiB8fCAnYW4gYWN0aW9uJztcbiAgcmV0dXJuIFwiR2l2ZW4gXCIgKyBhY3Rpb25EZXNjcmlwdGlvbiArIFwiLCByZWR1Y2VyIFxcXCJcIiArIGtleSArIFwiXFxcIiByZXR1cm5lZCB1bmRlZmluZWQuIFwiICsgXCJUbyBpZ25vcmUgYW4gYWN0aW9uLCB5b3UgbXVzdCBleHBsaWNpdGx5IHJldHVybiB0aGUgcHJldmlvdXMgc3RhdGUuIFwiICsgXCJJZiB5b3Ugd2FudCB0aGlzIHJlZHVjZXIgdG8gaG9sZCBubyB2YWx1ZSwgeW91IGNhbiByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIHVuZGVmaW5lZC5cIjtcbn1cblxuZnVuY3Rpb24gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShpbnB1dFN0YXRlLCByZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgYXJndW1lbnROYW1lID0gYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5JTklUID8gJ3ByZWxvYWRlZFN0YXRlIGFyZ3VtZW50IHBhc3NlZCB0byBjcmVhdGVTdG9yZScgOiAncHJldmlvdXMgc3RhdGUgcmVjZWl2ZWQgYnkgdGhlIHJlZHVjZXInO1xuXG4gIGlmIChyZWR1Y2VyS2V5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJ1N0b3JlIGRvZXMgbm90IGhhdmUgYSB2YWxpZCByZWR1Y2VyLiBNYWtlIHN1cmUgdGhlIGFyZ3VtZW50IHBhc3NlZCAnICsgJ3RvIGNvbWJpbmVSZWR1Y2VycyBpcyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSByZWR1Y2Vycy4nO1xuICB9XG5cbiAgaWYgKCFpc1BsYWluT2JqZWN0KGlucHV0U3RhdGUpKSB7XG4gICAgcmV0dXJuIFwiVGhlIFwiICsgYXJndW1lbnROYW1lICsgXCIgaGFzIHVuZXhwZWN0ZWQgdHlwZSBvZiBcXFwiXCIgKyB7fS50b1N0cmluZy5jYWxsKGlucHV0U3RhdGUpLm1hdGNoKC9cXHMoW2EtenxBLVpdKykvKVsxXSArIFwiXFxcIi4gRXhwZWN0ZWQgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBcIiArIChcImtleXM6IFxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiXCIpO1xuICB9XG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlzID0gT2JqZWN0LmtleXMoaW5wdXRTdGF0ZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gIXJlZHVjZXJzLmhhc093blByb3BlcnR5KGtleSkgJiYgIXVuZXhwZWN0ZWRLZXlDYWNoZVtrZXldO1xuICB9KTtcbiAgdW5leHBlY3RlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlW2tleV0gPSB0cnVlO1xuICB9KTtcbiAgaWYgKGFjdGlvbiAmJiBhY3Rpb24udHlwZSA9PT0gQWN0aW9uVHlwZXMuUkVQTEFDRSkgcmV0dXJuO1xuXG4gIGlmICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIFwiVW5leHBlY3RlZCBcIiArICh1bmV4cGVjdGVkS2V5cy5sZW5ndGggPiAxID8gJ2tleXMnIDogJ2tleScpICsgXCIgXCIgKyAoXCJcXFwiXCIgKyB1bmV4cGVjdGVkS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIiBmb3VuZCBpbiBcIiArIGFyZ3VtZW50TmFtZSArIFwiLiBcIikgKyBcIkV4cGVjdGVkIHRvIGZpbmQgb25lIG9mIHRoZSBrbm93biByZWR1Y2VyIGtleXMgaW5zdGVhZDogXCIgKyAoXCJcXFwiXCIgKyByZWR1Y2VyS2V5cy5qb2luKCdcIiwgXCInKSArIFwiXFxcIi4gVW5leHBlY3RlZCBrZXlzIHdpbGwgYmUgaWdub3JlZC5cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0UmVkdWNlclNoYXBlKHJlZHVjZXJzKSB7XG4gIE9iamVjdC5rZXlzKHJlZHVjZXJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVkdWNlciA9IHJlZHVjZXJzW2tleV07XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5JTklUXG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIGluaXRpYWxTdGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZHVjZXIgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZCBkdXJpbmcgaW5pdGlhbGl6YXRpb24uIFwiICsgXCJJZiB0aGUgc3RhdGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VyIGlzIHVuZGVmaW5lZCwgeW91IG11c3QgXCIgKyBcImV4cGxpY2l0bHkgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLiBUaGUgaW5pdGlhbCBzdGF0ZSBtYXkgXCIgKyBcIm5vdCBiZSB1bmRlZmluZWQuIElmIHlvdSBkb24ndCB3YW50IHRvIHNldCBhIHZhbHVlIGZvciB0aGlzIHJlZHVjZXIsIFwiICsgXCJ5b3UgY2FuIHVzZSBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXIodW5kZWZpbmVkLCB7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5QUk9CRV9VTktOT1dOX0FDVElPTigpXG4gICAgfSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWR1Y2VyIFxcXCJcIiArIGtleSArIFwiXFxcIiByZXR1cm5lZCB1bmRlZmluZWQgd2hlbiBwcm9iZWQgd2l0aCBhIHJhbmRvbSB0eXBlLiBcIiArIChcIkRvbid0IHRyeSB0byBoYW5kbGUgXCIgKyBBY3Rpb25UeXBlcy5JTklUICsgXCIgb3Igb3RoZXIgYWN0aW9ucyBpbiBcXFwicmVkdXgvKlxcXCIgXCIpICsgXCJuYW1lc3BhY2UuIFRoZXkgYXJlIGNvbnNpZGVyZWQgcHJpdmF0ZS4gSW5zdGVhZCwgeW91IG11c3QgcmV0dXJuIHRoZSBcIiArIFwiY3VycmVudCBzdGF0ZSBmb3IgYW55IHVua25vd24gYWN0aW9ucywgdW5sZXNzIGl0IGlzIHVuZGVmaW5lZCwgXCIgKyBcImluIHdoaWNoIGNhc2UgeW91IG11c3QgcmV0dXJuIHRoZSBpbml0aWFsIHN0YXRlLCByZWdhcmRsZXNzIG9mIHRoZSBcIiArIFwiYWN0aW9uIHR5cGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBub3QgYmUgdW5kZWZpbmVkLCBidXQgY2FuIGJlIG51bGwuXCIpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGRpZmZlcmVudCByZWR1Y2VyIGZ1bmN0aW9ucywgaW50byBhIHNpbmdsZVxuICogcmVkdWNlciBmdW5jdGlvbi4gSXQgd2lsbCBjYWxsIGV2ZXJ5IGNoaWxkIHJlZHVjZXIsIGFuZCBnYXRoZXIgdGhlaXIgcmVzdWx0c1xuICogaW50byBhIHNpbmdsZSBzdGF0ZSBvYmplY3QsIHdob3NlIGtleXMgY29ycmVzcG9uZCB0byB0aGUga2V5cyBvZiB0aGUgcGFzc2VkXG4gKiByZWR1Y2VyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVkdWNlcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBjb3JyZXNwb25kIHRvIGRpZmZlcmVudFxuICogcmVkdWNlciBmdW5jdGlvbnMgdGhhdCBuZWVkIHRvIGJlIGNvbWJpbmVkIGludG8gb25lLiBPbmUgaGFuZHkgd2F5IHRvIG9idGFpblxuICogaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXMgcmVkdWNlcnNgIHN5bnRheC4gVGhlIHJlZHVjZXJzIG1heSBuZXZlciByZXR1cm5cbiAqIHVuZGVmaW5lZCBmb3IgYW55IGFjdGlvbi4gSW5zdGVhZCwgdGhleSBzaG91bGQgcmV0dXJuIHRoZWlyIGluaXRpYWwgc3RhdGVcbiAqIGlmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlbSB3YXMgdW5kZWZpbmVkLCBhbmQgdGhlIGN1cnJlbnQgc3RhdGUgZm9yIGFueVxuICogdW5yZWNvZ25pemVkIGFjdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgcmVkdWNlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgZXZlcnkgcmVkdWNlciBpbnNpZGUgdGhlXG4gKiBwYXNzZWQgb2JqZWN0LCBhbmQgYnVpbGRzIGEgc3RhdGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gKi9cblxuXG5mdW5jdGlvbiBjb21iaW5lUmVkdWNlcnMocmVkdWNlcnMpIHtcbiAgdmFyIHJlZHVjZXJLZXlzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpO1xuICB2YXIgZmluYWxSZWR1Y2VycyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkdWNlcktleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gcmVkdWNlcktleXNbaV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKHR5cGVvZiByZWR1Y2Vyc1trZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuaW5nKFwiTm8gcmVkdWNlciBwcm92aWRlZCBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZpbmFsUmVkdWNlcnNba2V5XSA9IHJlZHVjZXJzW2tleV07XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpbmFsUmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhmaW5hbFJlZHVjZXJzKTsgLy8gVGhpcyBpcyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCB3YXJuIGFib3V0IHRoZSBzYW1lXG4gIC8vIGtleXMgbXVsdGlwbGUgdGltZXMuXG5cbiAgdmFyIHVuZXhwZWN0ZWRLZXlDYWNoZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHVuZXhwZWN0ZWRLZXlDYWNoZSA9IHt9O1xuICB9XG5cbiAgdmFyIHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG5cbiAgdHJ5IHtcbiAgICBhc3NlcnRSZWR1Y2VyU2hhcGUoZmluYWxSZWR1Y2Vycyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzaGFwZUFzc2VydGlvbkVycm9yID0gZTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiBjb21iaW5hdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0ge307XG4gICAgfVxuXG4gICAgaWYgKHNoYXBlQXNzZXJ0aW9uRXJyb3IpIHtcbiAgICAgIHRocm93IHNoYXBlQXNzZXJ0aW9uRXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IGdldFVuZXhwZWN0ZWRTdGF0ZVNoYXBlV2FybmluZ01lc3NhZ2Uoc3RhdGUsIGZpbmFsUmVkdWNlcnMsIGFjdGlvbiwgdW5leHBlY3RlZEtleUNhY2hlKTtcblxuICAgICAgaWYgKHdhcm5pbmdNZXNzYWdlKSB7XG4gICAgICAgIHdhcm5pbmcod2FybmluZ01lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBoYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHt9O1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2tleSA9IGZpbmFsUmVkdWNlcktleXNbX2ldO1xuICAgICAgdmFyIHJlZHVjZXIgPSBmaW5hbFJlZHVjZXJzW19rZXldO1xuICAgICAgdmFyIHByZXZpb3VzU3RhdGVGb3JLZXkgPSBzdGF0ZVtfa2V5XTtcbiAgICAgIHZhciBuZXh0U3RhdGVGb3JLZXkgPSByZWR1Y2VyKHByZXZpb3VzU3RhdGVGb3JLZXksIGFjdGlvbik7XG5cbiAgICAgIGlmICh0eXBlb2YgbmV4dFN0YXRlRm9yS2V5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZ2V0VW5kZWZpbmVkU3RhdGVFcnJvck1lc3NhZ2UoX2tleSwgYWN0aW9uKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIG5leHRTdGF0ZVtfa2V5XSA9IG5leHRTdGF0ZUZvcktleTtcbiAgICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IG5leHRTdGF0ZUZvcktleSAhPT0gcHJldmlvdXNTdGF0ZUZvcktleTtcbiAgICB9XG5cbiAgICBoYXNDaGFuZ2VkID0gaGFzQ2hhbmdlZCB8fCBmaW5hbFJlZHVjZXJLZXlzLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc3RhdGUpLmxlbmd0aDtcbiAgICByZXR1cm4gaGFzQ2hhbmdlZCA/IG5leHRTdGF0ZSA6IHN0YXRlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9yLCBkaXNwYXRjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNwYXRjaChhY3Rpb25DcmVhdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuLyoqXG4gKiBUdXJucyBhbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGFyZSBhY3Rpb24gY3JlYXRvcnMsIGludG8gYW4gb2JqZWN0IHdpdGggdGhlXG4gKiBzYW1lIGtleXMsIGJ1dCB3aXRoIGV2ZXJ5IGZ1bmN0aW9uIHdyYXBwZWQgaW50byBhIGBkaXNwYXRjaGAgY2FsbCBzbyB0aGV5XG4gKiBtYXkgYmUgaW52b2tlZCBkaXJlY3RseS4gVGhpcyBpcyBqdXN0IGEgY29udmVuaWVuY2UgbWV0aG9kLCBhcyB5b3UgY2FuIGNhbGxcbiAqIGBzdG9yZS5kaXNwYXRjaChNeUFjdGlvbkNyZWF0b3JzLmRvU29tZXRoaW5nKCkpYCB5b3Vyc2VsZiBqdXN0IGZpbmUuXG4gKlxuICogRm9yIGNvbnZlbmllbmNlLCB5b3UgY2FuIGFsc28gcGFzcyBhbiBhY3Rpb24gY3JlYXRvciBhcyB0aGUgZmlyc3QgYXJndW1lbnQsXG4gKiBhbmQgZ2V0IGEgZGlzcGF0Y2ggd3JhcHBlZCBmdW5jdGlvbiBpbiByZXR1cm4uXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IGFjdGlvbkNyZWF0b3JzIEFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvblxuICogY3JlYXRvciBmdW5jdGlvbnMuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluIGl0IGlzIHRvIHVzZSBFUzYgYGltcG9ydCAqIGFzYFxuICogc3ludGF4LiBZb3UgbWF5IGFsc28gcGFzcyBhIHNpbmdsZSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkaXNwYXRjaCBUaGUgYGRpc3BhdGNoYCBmdW5jdGlvbiBhdmFpbGFibGUgb24geW91ciBSZWR1eFxuICogc3RvcmUuXG4gKlxuICogQHJldHVybnMge0Z1bmN0aW9ufE9iamVjdH0gVGhlIG9iamVjdCBtaW1pY2tpbmcgdGhlIG9yaWdpbmFsIG9iamVjdCwgYnV0IHdpdGhcbiAqIGV2ZXJ5IGFjdGlvbiBjcmVhdG9yIHdyYXBwZWQgaW50byB0aGUgYGRpc3BhdGNoYCBjYWxsLiBJZiB5b3UgcGFzc2VkIGFcbiAqIGZ1bmN0aW9uIGFzIGBhY3Rpb25DcmVhdG9yc2AsIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBhbHNvIGJlIGEgc2luZ2xlXG4gKiBmdW5jdGlvbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9ycyhhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBiaW5kQWN0aW9uQ3JlYXRvcihhY3Rpb25DcmVhdG9ycywgZGlzcGF0Y2gpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhY3Rpb25DcmVhdG9ycyAhPT0gJ29iamVjdCcgfHwgYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiaW5kQWN0aW9uQ3JlYXRvcnMgZXhwZWN0ZWQgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24sIGluc3RlYWQgcmVjZWl2ZWQgXCIgKyAoYWN0aW9uQ3JlYXRvcnMgPT09IG51bGwgPyAnbnVsbCcgOiB0eXBlb2YgYWN0aW9uQ3JlYXRvcnMpICsgXCIuIFwiICsgXCJEaWQgeW91IHdyaXRlIFxcXCJpbXBvcnQgQWN0aW9uQ3JlYXRvcnMgZnJvbVxcXCIgaW5zdGVhZCBvZiBcXFwiaW1wb3J0ICogYXMgQWN0aW9uQ3JlYXRvcnMgZnJvbVxcXCI/XCIpO1xuICB9XG5cbiAgdmFyIGJvdW5kQWN0aW9uQ3JlYXRvcnMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gYWN0aW9uQ3JlYXRvcnMpIHtcbiAgICB2YXIgYWN0aW9uQ3JlYXRvciA9IGFjdGlvbkNyZWF0b3JzW2tleV07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGJvdW5kQWN0aW9uQ3JlYXRvcnNba2V5XSA9IGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRBY3Rpb25DcmVhdG9ycztcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKTtcbiAgfVxuXG4gIGlmIChlbnVtZXJhYmxlT25seSkga2V5cyA9IGtleXMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgfSk7XG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcblxuICAgIGlmIChpICUgMikge1xuICAgICAgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIENvbXBvc2VzIHNpbmdsZS1hcmd1bWVudCBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LiBUaGUgcmlnaHRtb3N0XG4gKiBmdW5jdGlvbiBjYW4gdGFrZSBtdWx0aXBsZSBhcmd1bWVudHMgYXMgaXQgcHJvdmlkZXMgdGhlIHNpZ25hdHVyZSBmb3JcbiAqIHRoZSByZXN1bHRpbmcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmNzIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiBvYnRhaW5lZCBieSBjb21wb3NpbmcgdGhlIGFyZ3VtZW50IGZ1bmN0aW9uc1xuICogZnJvbSByaWdodCB0byBsZWZ0LiBGb3IgZXhhbXBsZSwgY29tcG9zZShmLCBnLCBoKSBpcyBpZGVudGljYWwgdG8gZG9pbmdcbiAqICguLi5hcmdzKSA9PiBmKGcoaCguLi5hcmdzKSkpLlxuICovXG5mdW5jdGlvbiBjb21wb3NlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZnVuY3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgIHJldHVybiBhcmc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZnVuY3NbMF07XG4gIH1cblxuICByZXR1cm4gZnVuY3MucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhKGIuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RvcmUgZW5oYW5jZXIgdGhhdCBhcHBsaWVzIG1pZGRsZXdhcmUgdG8gdGhlIGRpc3BhdGNoIG1ldGhvZFxuICogb2YgdGhlIFJlZHV4IHN0b3JlLiBUaGlzIGlzIGhhbmR5IGZvciBhIHZhcmlldHkgb2YgdGFza3MsIHN1Y2ggYXMgZXhwcmVzc2luZ1xuICogYXN5bmNocm9ub3VzIGFjdGlvbnMgaW4gYSBjb25jaXNlIG1hbm5lciwgb3IgbG9nZ2luZyBldmVyeSBhY3Rpb24gcGF5bG9hZC5cbiAqXG4gKiBTZWUgYHJlZHV4LXRodW5rYCBwYWNrYWdlIGFzIGFuIGV4YW1wbGUgb2YgdGhlIFJlZHV4IG1pZGRsZXdhcmUuXG4gKlxuICogQmVjYXVzZSBtaWRkbGV3YXJlIGlzIHBvdGVudGlhbGx5IGFzeW5jaHJvbm91cywgdGhpcyBzaG91bGQgYmUgdGhlIGZpcnN0XG4gKiBzdG9yZSBlbmhhbmNlciBpbiB0aGUgY29tcG9zaXRpb24gY2hhaW4uXG4gKlxuICogTm90ZSB0aGF0IGVhY2ggbWlkZGxld2FyZSB3aWxsIGJlIGdpdmVuIHRoZSBgZGlzcGF0Y2hgIGFuZCBgZ2V0U3RhdGVgIGZ1bmN0aW9uc1xuICogYXMgbmFtZWQgYXJndW1lbnRzLlxuICpcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IG1pZGRsZXdhcmVzIFRoZSBtaWRkbGV3YXJlIGNoYWluIHRvIGJlIGFwcGxpZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgc3RvcmUgZW5oYW5jZXIgYXBwbHlpbmcgdGhlIG1pZGRsZXdhcmUuXG4gKi9cblxuZnVuY3Rpb24gYXBwbHlNaWRkbGV3YXJlKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWlkZGxld2FyZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKGNyZWF0ZVN0b3JlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdG9yZSA9IGNyZWF0ZVN0b3JlLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcblxuICAgICAgdmFyIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rpc3BhdGNoaW5nIHdoaWxlIGNvbnN0cnVjdGluZyB5b3VyIG1pZGRsZXdhcmUgaXMgbm90IGFsbG93ZWQuICcgKyAnT3RoZXIgbWlkZGxld2FyZSB3b3VsZCBub3QgYmUgYXBwbGllZCB0byB0aGlzIGRpc3BhdGNoLicpO1xuICAgICAgfTtcblxuICAgICAgdmFyIG1pZGRsZXdhcmVBUEkgPSB7XG4gICAgICAgIGdldFN0YXRlOiBzdG9yZS5nZXRTdGF0ZSxcbiAgICAgICAgZGlzcGF0Y2g6IGZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICAgICAgICAgIHJldHVybiBfZGlzcGF0Y2guYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGNoYWluID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgICAgIHJldHVybiBtaWRkbGV3YXJlKG1pZGRsZXdhcmVBUEkpO1xuICAgICAgfSk7XG4gICAgICBfZGlzcGF0Y2ggPSBjb21wb3NlLmFwcGx5KHZvaWQgMCwgY2hhaW4pKHN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkMih7fSwgc3RvcmUsIHtcbiAgICAgICAgZGlzcGF0Y2g6IF9kaXNwYXRjaFxuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkdW1teSBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZnVuY3Rpb24gbmFtZSBoYXMgYmVlbiBhbHRlcmVkIGJ5IG1pbmlmaWNhdGlvbi5cbiAqIElmIHRoZSBmdW5jdGlvbiBoYXMgYmVlbiBtaW5pZmllZCBhbmQgTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJywgd2FybiB0aGUgdXNlci5cbiAqL1xuXG5mdW5jdGlvbiBpc0NydXNoZWQoKSB7fVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgaXNDcnVzaGVkLm5hbWUgPT09ICdzdHJpbmcnICYmIGlzQ3J1c2hlZC5uYW1lICE9PSAnaXNDcnVzaGVkJykge1xuICB3YXJuaW5nKCdZb3UgYXJlIGN1cnJlbnRseSB1c2luZyBtaW5pZmllZCBjb2RlIG91dHNpZGUgb2YgTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiLiAnICsgJ1RoaXMgbWVhbnMgdGhhdCB5b3UgYXJlIHJ1bm5pbmcgYSBzbG93ZXIgZGV2ZWxvcG1lbnQgYnVpbGQgb2YgUmVkdXguICcgKyAnWW91IGNhbiB1c2UgbG9vc2UtZW52aWZ5IChodHRwczovL2dpdGh1Yi5jb20vemVydG9zaC9sb29zZS1lbnZpZnkpIGZvciBicm93c2VyaWZ5ICcgKyAnb3Igc2V0dGluZyBtb2RlIHRvIHByb2R1Y3Rpb24gaW4gd2VicGFjayAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25jZXB0cy9tb2RlLykgJyArICd0byBlbnN1cmUgeW91IGhhdmUgdGhlIGNvcnJlY3QgY29kZSBmb3IgeW91ciBwcm9kdWN0aW9uIGJ1aWxkLicpO1xufVxuXG5leHBvcnQgeyBBY3Rpb25UeXBlcyBhcyBfX0RPX05PVF9VU0VfX0FjdGlvblR5cGVzLCBhcHBseU1pZGRsZXdhcmUsIGJpbmRBY3Rpb25DcmVhdG9ycywgY29tYmluZVJlZHVjZXJzLCBjb21wb3NlLCBjcmVhdGVTdG9yZSB9O1xuIiwiZnVuY3Rpb24gZGVmYXVsdEVxdWFsaXR5Q2hlY2soYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuZnVuY3Rpb24gYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgcHJldiwgbmV4dCkge1xuICBpZiAocHJldiA9PT0gbnVsbCB8fCBuZXh0ID09PSBudWxsIHx8IHByZXYubGVuZ3RoICE9PSBuZXh0Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIERvIHRoaXMgaW4gYSBmb3IgbG9vcCAoYW5kIG5vdCBhIGBmb3JFYWNoYCBvciBhbiBgZXZlcnlgKSBzbyB3ZSBjYW4gZGV0ZXJtaW5lIGVxdWFsaXR5IGFzIGZhc3QgYXMgcG9zc2libGUuXG4gIHZhciBsZW5ndGggPSBwcmV2Lmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICghZXF1YWxpdHlDaGVjayhwcmV2W2ldLCBuZXh0W2ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdE1lbW9pemUoZnVuYykge1xuICB2YXIgZXF1YWxpdHlDaGVjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZGVmYXVsdEVxdWFsaXR5Q2hlY2s7XG5cbiAgdmFyIGxhc3RBcmdzID0gbnVsbDtcbiAgdmFyIGxhc3RSZXN1bHQgPSBudWxsO1xuICAvLyB3ZSByZWZlcmVuY2UgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIHRoZW0gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWFyZUFyZ3VtZW50c1NoYWxsb3dseUVxdWFsKGVxdWFsaXR5Q2hlY2ssIGxhc3RBcmdzLCBhcmd1bWVudHMpKSB7XG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgbGFzdFJlc3VsdCA9IGZ1bmMuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbGFzdFJlc3VsdDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVwZW5kZW5jaWVzKGZ1bmNzKSB7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSBBcnJheS5pc0FycmF5KGZ1bmNzWzBdKSA/IGZ1bmNzWzBdIDogZnVuY3M7XG5cbiAgaWYgKCFkZXBlbmRlbmNpZXMuZXZlcnkoZnVuY3Rpb24gKGRlcCkge1xuICAgIHJldHVybiB0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nO1xuICB9KSkge1xuICAgIHZhciBkZXBlbmRlbmN5VHlwZXMgPSBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgZGVwO1xuICAgIH0pLmpvaW4oJywgJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWxlY3RvciBjcmVhdG9ycyBleHBlY3QgYWxsIGlucHV0LXNlbGVjdG9ycyB0byBiZSBmdW5jdGlvbnMsICcgKyAoJ2luc3RlYWQgcmVjZWl2ZWQgdGhlIGZvbGxvd2luZyB0eXBlczogWycgKyBkZXBlbmRlbmN5VHlwZXMgKyAnXScpKTtcbiAgfVxuXG4gIHJldHVybiBkZXBlbmRlbmNpZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWxlY3RvckNyZWF0b3IobWVtb2l6ZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVtb2l6ZU9wdGlvbnMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVtb2l6ZU9wdGlvbnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmNzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGZ1bmNzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgdmFyIHJlY29tcHV0YXRpb25zID0gMDtcbiAgICB2YXIgcmVzdWx0RnVuYyA9IGZ1bmNzLnBvcCgpO1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBnZXREZXBlbmRlbmNpZXMoZnVuY3MpO1xuXG4gICAgdmFyIG1lbW9pemVkUmVzdWx0RnVuYyA9IG1lbW9pemUuYXBwbHkodW5kZWZpbmVkLCBbZnVuY3Rpb24gKCkge1xuICAgICAgcmVjb21wdXRhdGlvbnMrKztcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICByZXR1cm4gcmVzdWx0RnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1dLmNvbmNhdChtZW1vaXplT3B0aW9ucykpO1xuXG4gICAgLy8gSWYgYSBzZWxlY3RvciBpcyBjYWxsZWQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBhcmd1bWVudHMgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSBvdXIgZGVwZW5kZW5jaWVzIGFnYWluLlxuICAgIHZhciBzZWxlY3RvciA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGRlcGVuZGVuY2llcy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGFuZCBtdXRhdGUgYSBsb2NhbCBsaXN0IG9mIHBhcmFtcyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICAgIHBhcmFtcy5wdXNoKGRlcGVuZGVuY2llc1tpXS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIHJldHVybiBtZW1vaXplZFJlc3VsdEZ1bmMuYXBwbHkobnVsbCwgcGFyYW1zKTtcbiAgICB9KTtcblxuICAgIHNlbGVjdG9yLnJlc3VsdEZ1bmMgPSByZXN1bHRGdW5jO1xuICAgIHNlbGVjdG9yLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcztcbiAgICBzZWxlY3Rvci5yZWNvbXB1dGF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWNvbXB1dGF0aW9ucztcbiAgICB9O1xuICAgIHNlbGVjdG9yLnJlc2V0UmVjb21wdXRhdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIH07XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9O1xufVxuXG5leHBvcnQgdmFyIGNyZWF0ZVNlbGVjdG9yID0gY3JlYXRlU2VsZWN0b3JDcmVhdG9yKGRlZmF1bHRNZW1vaXplKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgdmFyIHNlbGVjdG9yQ3JlYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogY3JlYXRlU2VsZWN0b3I7XG5cbiAgaWYgKHR5cGVvZiBzZWxlY3RvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVTdHJ1Y3R1cmVkU2VsZWN0b3IgZXhwZWN0cyBmaXJzdCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QgJyArICgnd2hlcmUgZWFjaCBwcm9wZXJ0eSBpcyBhIHNlbGVjdG9yLCBpbnN0ZWFkIHJlY2VpdmVkIGEgJyArIHR5cGVvZiBzZWxlY3RvcnMpKTtcbiAgfVxuICB2YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzKHNlbGVjdG9ycyk7XG4gIHJldHVybiBzZWxlY3RvckNyZWF0b3Iob2JqZWN0S2V5cy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBzZWxlY3RvcnNba2V5XTtcbiAgfSksIGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbHVlcyA9IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICB2YWx1ZXNbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoY29tcG9zaXRpb24sIHZhbHVlLCBpbmRleCkge1xuICAgICAgY29tcG9zaXRpb25bb2JqZWN0S2V5c1tpbmRleF1dID0gdmFsdWU7XG4gICAgICByZXR1cm4gY29tcG9zaXRpb247XG4gICAgfSwge30pO1xuICB9KTtcbn0iLCJmdW5jdGlvbiBpc0Fic29sdXRlKHBhdGhuYW1lKSB7XG4gIHJldHVybiBwYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJztcbn1cblxuLy8gQWJvdXQgMS41eCBmYXN0ZXIgdGhhbiB0aGUgdHdvLWFyZyB2ZXJzaW9uIG9mIEFycmF5I3NwbGljZSgpXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKSB7XG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIH1cblxuICBsaXN0LnBvcCgpO1xufVxuXG4vLyBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIGhlYXZpbHkgb24gbm9kZSdzIHVybC5wYXJzZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGhuYW1lKHRvKSB7XG4gIHZhciBmcm9tID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnJztcblxuICB2YXIgdG9QYXJ0cyA9IHRvICYmIHRvLnNwbGl0KCcvJykgfHwgW107XG4gIHZhciBmcm9tUGFydHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy8nKSB8fCBbXTtcblxuICB2YXIgaXNUb0FicyA9IHRvICYmIGlzQWJzb2x1dGUodG8pO1xuICB2YXIgaXNGcm9tQWJzID0gZnJvbSAmJiBpc0Fic29sdXRlKGZyb20pO1xuICB2YXIgbXVzdEVuZEFicyA9IGlzVG9BYnMgfHwgaXNGcm9tQWJzO1xuXG4gIGlmICh0byAmJiBpc0Fic29sdXRlKHRvKSkge1xuICAgIC8vIHRvIGlzIGFic29sdXRlXG4gICAgZnJvbVBhcnRzID0gdG9QYXJ0cztcbiAgfSBlbHNlIGlmICh0b1BhcnRzLmxlbmd0aCkge1xuICAgIC8vIHRvIGlzIHJlbGF0aXZlLCBkcm9wIHRoZSBmaWxlbmFtZVxuICAgIGZyb21QYXJ0cy5wb3AoKTtcbiAgICBmcm9tUGFydHMgPSBmcm9tUGFydHMuY29uY2F0KHRvUGFydHMpO1xuICB9XG5cbiAgaWYgKCFmcm9tUGFydHMubGVuZ3RoKSByZXR1cm4gJy8nO1xuXG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gdm9pZCAwO1xuICBpZiAoZnJvbVBhcnRzLmxlbmd0aCkge1xuICAgIHZhciBsYXN0ID0gZnJvbVBhcnRzW2Zyb21QYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gbGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicgfHwgbGFzdCA9PT0gJyc7XG4gIH0gZWxzZSB7XG4gICAgaGFzVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIHBhcnQgPSBmcm9tUGFydHNbaV07XG5cbiAgICBpZiAocGFydCA9PT0gJy4nKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcGxpY2VPbmUoZnJvbVBhcnRzLCBpKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXN0RW5kQWJzKSBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICBmcm9tUGFydHMudW5zaGlmdCgnLi4nKTtcbiAgfWlmIChtdXN0RW5kQWJzICYmIGZyb21QYXJ0c1swXSAhPT0gJycgJiYgKCFmcm9tUGFydHNbMF0gfHwgIWlzQWJzb2x1dGUoZnJvbVBhcnRzWzBdKSkpIGZyb21QYXJ0cy51bnNoaWZ0KCcnKTtcblxuICB2YXIgcmVzdWx0ID0gZnJvbVBhcnRzLmpvaW4oJy8nKTtcblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiByZXN1bHQuc3Vic3RyKC0xKSAhPT0gJy8nKSByZXN1bHQgKz0gJy8nO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVQYXRobmFtZTsiLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgcG9ueWZpbGwgZnJvbSAnLi9wb255ZmlsbC5qcyc7XG5cbnZhciByb290O1xuXG5pZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBzZWxmO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICByb290ID0gbW9kdWxlO1xufSBlbHNlIHtcbiAgcm9vdCA9IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG59XG5cbnZhciByZXN1bHQgPSBwb255ZmlsbChyb290KTtcbmV4cG9ydCBkZWZhdWx0IHJlc3VsdDtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHN5bWJvbE9ic2VydmFibGVQb255ZmlsbChyb290KSB7XG5cdHZhciByZXN1bHQ7XG5cdHZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuXHRpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGlmIChTeW1ib2wub2JzZXJ2YWJsZSkge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sLm9ic2VydmFibGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuXHRcdFx0U3ltYm9sLm9ic2VydmFibGUgPSByZXN1bHQ7XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICdAQG9ic2VydmFibGUnO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbmZ1bmN0aW9uIHZhbHVlRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoaXRlbSwgYltpbmRleF0pO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGFUeXBlID0gdHlwZW9mIGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGEpO1xuICB2YXIgYlR5cGUgPSB0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYik7XG5cbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChhVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgYVZhbHVlID0gYS52YWx1ZU9mKCk7XG4gICAgdmFyIGJWYWx1ZSA9IGIudmFsdWVPZigpO1xuXG4gICAgaWYgKGFWYWx1ZSAhPT0gYSB8fCBiVmFsdWUgIT09IGIpIHJldHVybiB2YWx1ZUVxdWFsKGFWYWx1ZSwgYlZhbHVlKTtcblxuICAgIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIHZhciBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuXG4gICAgaWYgKGFLZXlzLmxlbmd0aCAhPT0gYktleXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gYUtleXMuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIHZhbHVlRXF1YWwoYVtrZXldLCBiW2tleV0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZUVxdWFsOyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcmlnaW5hbE1vZHVsZSkge1xuXHRpZiAoIW9yaWdpbmFsTW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdHZhciBtb2R1bGUgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsTW9kdWxlKTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJleHBvcnRzXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbi8vICBDb21wYW55VHlwZVNsaWNlLnRzIC0gR2J0Y1xyXG4vL1xyXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vXHJcbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXHJcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXHJcbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXHJcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcclxuLy9cclxuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXHJcbi8vXHJcbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcclxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxyXG4vL1xyXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcclxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gIDEwLzIwLzIwMjAgLSBCaWxseSBFcm5lc3RcclxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXHJcbi8vXHJcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblxyXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgeyBTeXN0ZW1DZW50ZXIgfSBmcm9tICcuLi9nbG9iYWwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZldGNoQ29tcGFueVR5cGVzID0gY3JlYXRlQXN5bmNUaHVuaygnQ29tcGFueXMvRmV0Y2hDb21wYW55VHlwZXMnLCBhc3luYyAoXywgeyBkaXNwYXRjaCB9KSA9PiB7XHJcbiAgICByZXR1cm4gYXdhaXQgR2V0Q29tcGFueVR5cGVzKClcclxufSk7XHJcblxyXG5leHBvcnQgY29uc3QgQ29tcGFueVR5cGVTbGljZSA9IGNyZWF0ZVNsaWNlKHtcclxuICAgIG5hbWU6ICdDb21wYW55VHlwZScsXHJcbiAgICBpbml0aWFsU3RhdGU6IHtcclxuICAgICAgICBTdGF0dXM6ICd1bml0aWF0ZWQnIGFzIFN5c3RlbUNlbnRlci5TdGF0dXMsXHJcbiAgICAgICAgQ29tcGFueVR5cGU6IFtdIGFzIFN5c3RlbUNlbnRlci5Db21wYW55VHlwZVtdLFxyXG4gICAgICAgIEVycm9yOiBudWxsXHJcbiAgICB9LFxyXG4gICAgcmVkdWNlcnM6IHtcclxuICAgIH0sXHJcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xyXG5cclxuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hDb21wYW55VHlwZXMuZnVsZmlsbGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnaWRsZSc7XHJcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgc3RhdGUuQ29tcGFueVR5cGUucHVzaCguLi5hY3Rpb24ucGF5bG9hZCk7XHJcbiAgICAgICAgICAgIEZldGNoQ29tcGFueVR5cGVzKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoQ29tcGFueVR5cGVzLnBlbmRpbmcsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcclxuICAgICAgICB9KTtcclxuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hDb21wYW55VHlwZXMucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdlcnJvcic7XHJcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gYWN0aW9uLmVycm9yLm1lc3NhZ2U7XHJcblxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IHt9ID0gQ29tcGFueVR5cGVTbGljZS5hY3Rpb25zO1xyXG5leHBvcnQgZGVmYXVsdCBDb21wYW55VHlwZVNsaWNlLnJlZHVjZXI7XHJcbmV4cG9ydCBjb25zdCBTZWxlY3RDb21wYW55VHlwZXMgPSBzdGF0ZSA9PiBzdGF0ZS5Db21wYW55VHlwZS5Db21wYW55VHlwZSBhcyBTeXN0ZW1DZW50ZXIuQ29tcGFueVR5cGVbXVxyXG5leHBvcnQgY29uc3QgU2VsZWN0Q29tcGFueVR5cGVzU3RhdHVzID0gc3RhdGUgPT4gc3RhdGUuQ29tcGFueVR5cGUuU3RhdHVzIGFzIFN5c3RlbUNlbnRlci5TdGF0dXNcclxuXHJcbmZ1bmN0aW9uIEdldENvbXBhbnlUeXBlcygpOiBKUXVlcnkuanFYSFI8U3lzdGVtQ2VudGVyLkNvbXBhbnlUeXBlW10+IHtcclxuICAgIHJldHVybiAkLmFqYXgoe1xyXG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvU3lzdGVtQ2VudGVyL0NvbXBhbnlUeXBlYCxcclxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXHJcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcclxuICAgICAgICBjYWNoZTogdHJ1ZSxcclxuICAgICAgICBhc3luYzogdHJ1ZVxyXG4gICAgfSk7XHJcbn1cclxuXHJcblxyXG4iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyAgU3RvcmUudHMgLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMTAvMjAvMjAyMCAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCB7IGNvbmZpZ3VyZVN0b3JlIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XHJcbmltcG9ydCBDb21wYW55VHlwZVJlZHVjZXIgZnJvbSAnLi4vQ29tcGFueS9Db21wYW55VHlwZVNsaWNlJ1xyXG5leHBvcnQgZGVmYXVsdCBjb25maWd1cmVTdG9yZSh7XHJcbiAgICByZWR1Y2VyOiB7XHJcbiAgICAgICAgQ29tcGFueVR5cGU6IENvbXBhbnlUeXBlUmVkdWNlcixcclxuICAgIH1cclxufSk7IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gIFN5c3RlbUNlbnRlci50c3ggLSBHYnRjXHJcbi8vXHJcbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy9cclxuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcclxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cclxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcclxuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxyXG4vL1xyXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcclxuLy9cclxuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxyXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXHJcbi8vXHJcbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxyXG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyAgMDgvMjIvMjAxOSAtIEJpbGx5IEVybmVzdFxyXG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cclxuLy9cclxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHsgQnJvd3NlclJvdXRlciBhcyBSb3V0ZXIsIFJvdXRlLCBOYXZMaW5rLCBTd2l0Y2ggfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuXHJcbmltcG9ydCBxdWVyeVN0cmluZyBmcm9tIFwicXVlcnlzdHJpbmdcIjtcclxuaW1wb3J0IHsgY3JlYXRlQnJvd3Nlckhpc3RvcnkgfSBmcm9tIFwiaGlzdG9yeVwiXHJcbmltcG9ydCB7IFN5c3RlbUNlbnRlciB9IGZyb20gJy4vZ2xvYmFsJztcclxuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XHJcbmltcG9ydCBzdG9yZSBmcm9tICcuL1N0b3JlL1N0b3JlJztcclxuXHJcbi8vaW1wb3J0IEJ5TWV0ZXIgZnJvbSAnLi9NZXRlci9CeU1ldGVyJ1xyXG4vL2ltcG9ydCBCeUxvY2F0aW9uIGZyb20gJy4vTG9jYXRpb24vQnlMb2NhdGlvbidcclxuLy9pbXBvcnQgQnlBc3NldCBmcm9tICcuL0Fzc2V0L0J5QXNzZXQnXHJcbi8vaW1wb3J0IEJ5Q3VzdG9tZXIgZnJvbSAnLi9DdXN0b21lci9CeUN1c3RvbWVyJ1xyXG4vL2ltcG9ydCBCeVVzZXIgZnJvbSAnLi9Vc2VyL0J5VXNlcidcclxuLy9pbXBvcnQgVXNlclN0YXRpc3RpY3MgZnJvbSAnLi9Vc2VyU3RhdGlzdGljcy9Vc2VyU3RhdGlzdGljcydcclxuLy9pbXBvcnQgQ3VzdG9tZXIgZnJvbSAnLi9DdXN0b21lci9DdXN0b21lcidcclxuLy9pbXBvcnQgVXNlciBmcm9tICcuL1VzZXIvVXNlcidcclxuLy9pbXBvcnQgQXNzZXQgZnJvbSAnLi9Bc3NldC9Bc3NldCdcclxuLy9pbXBvcnQgTmV3TWV0ZXJXaXphcmQgZnJvbSAnLi9OZXdNZXRlcldpemFyZC9OZXdNZXRlcldpemFyZCdcclxuLy9pbXBvcnQgQ29uZmlndXJhdGlvbkhpc3RvcnkgZnJvbSAnLi9Db25maWd1cmF0aW9uSGlzdG9yeS9Db25maWd1cmF0aW9uSGlzdG9yeSdcclxuLy9pbXBvcnQgTWV0ZXIgZnJvbSAnLi9NZXRlci9NZXRlcidcclxuLy9pbXBvcnQgTG9jYXRpb24gZnJvbSAnLi9Mb2NhdGlvbi9Mb2NhdGlvbidcclxuLy9pbXBvcnQgQnlBc3NldEdyb3VwIGZyb20gJy4vQXNzZXRHcm91cHMvQnlBc3NldEdyb3VwJztcclxuLy9pbXBvcnQgQXNzZXRHcm91cCBmcm9tICcuL0Fzc2V0R3JvdXBzL0Fzc2V0Z3JvdXAnO1xyXG4vL2ltcG9ydCBCeUNvbXBhbnkgZnJvbSAnLi9Db21wYW55L0J5Q29tcGFueSc7XHJcbi8vaW1wb3J0IENvbXBhbnkgZnJvbSAnLi9Db21wYW55L0NvbXBhbnknO1xyXG5cclxuZGVjbGFyZSB2YXIgaG9tZVBhdGg6IHN0cmluZztcclxuZGVjbGFyZSB2YXIgY29udHJvbGxlclZpZXdQYXRoOiBzdHJpbmc7XHJcblxyXG5jb25zdCBTeXN0ZW1DZW50ZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50ID0gKHByb3BzOiB7fSkgPT4ge1xyXG4gICAgY29uc3QgaGlzdG9yeSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCk7XHJcbiAgICBjb25zdCBCeU1ldGVyID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyp3ZWJwYWNrQ2h1bmtOYW1lOiBcIkJ5TWV0ZXJcIiovJy4vTWV0ZXIvQnlNZXRlcicpKTtcclxuICAgIGNvbnN0IEJ5TG9jYXRpb24gPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkJ5TG9jYXRpb25cIiAqLyAnLi9Mb2NhdGlvbi9CeUxvY2F0aW9uJykpO1xyXG4gICAgY29uc3QgQnlBc3NldCA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQnlBc3NldFwiICovICcuL0Fzc2V0L0J5QXNzZXQnKSk7XHJcbiAgICBjb25zdCBCeUN1c3RvbWVyID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJCeUN1c3RvbWVyXCIgKi8gJy4vQ3VzdG9tZXIvQnlDdXN0b21lcicpKTtcclxuICAgIGNvbnN0IEJ5VXNlciA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQnlVc2VyXCIgKi8gJy4vVXNlci9CeVVzZXInKSk7XHJcbiAgICBjb25zdCBVc2VyU3RhdGlzdGljcyA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiVXNlclN0YXRpc3RpY3NcIiAqLyAnLi9Vc2VyU3RhdGlzdGljcy9Vc2VyU3RhdGlzdGljcycpKTtcclxuICAgIGNvbnN0IEN1c3RvbWVyID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJDdXN0b21lclwiICovICcuL0N1c3RvbWVyL0N1c3RvbWVyJykpO1xyXG4gICAgY29uc3QgVXNlciA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiVXNlclwiICovICcuL1VzZXIvVXNlcicpKTtcclxuICAgIGNvbnN0IEFzc2V0ID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJBc3NldFwiICovICcuL0Fzc2V0L0Fzc2V0JykpO1xyXG4gICAgY29uc3QgTmV3TWV0ZXJXaXphcmQgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCggLyogd2VicGFja0NodW5rTmFtZTogXCJOZXdNZXRlcldpemFyZFwiICovICcuL05ld01ldGVyV2l6YXJkL05ld01ldGVyV2l6YXJkJykpO1xyXG4gICAgY29uc3QgQ29uZmlndXJhdGlvbkhpc3RvcnkgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkNvbmZpZ3VyYXRpb25IaXN0b3J5XCIgKi8gJy4vQ29uZmlndXJhdGlvbkhpc3RvcnkvQ29uZmlndXJhdGlvbkhpc3RvcnknKSk7XHJcbiAgICBjb25zdCBNZXRlciA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiTWV0ZXJcIiAqLyAnLi9NZXRlci9NZXRlcicpKTtcclxuICAgIGNvbnN0IExvY2F0aW9uID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJMb2NhdGlvblwiICovICcuL0xvY2F0aW9uL0xvY2F0aW9uJykpO1xyXG4gICAgY29uc3QgQnlBc3NldEdyb3VwID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJCeUFzc2V0R3JvdXBcIiAqLyAnLi9Bc3NldEdyb3Vwcy9CeUFzc2V0R3JvdXAnKSk7XHJcbiAgICBjb25zdCBBc3NldEdyb3VwID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJBc3NldEdyb3VwXCIgKi8gJy4vQXNzZXRHcm91cHMvQXNzZXRHcm91cCcpKTtcclxuICAgIGNvbnN0IEJ5Q29tcGFueSA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQnlDb21wYW55XCIgKi8gJy4vQ29tcGFueS9CeUNvbXBhbnknKSk7XHJcbiAgICBjb25zdCBDb21wYW55ID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJDb21wYW55XCIgKi8gJy4vQ29tcGFueS9Db21wYW55JykpO1xyXG5cclxuICAgIGNvbnN0IFtyb2xlcywgc2V0Um9sZXNdID0gUmVhY3QudXNlU3RhdGU8QXJyYXk8U3lzdGVtQ2VudGVyLlN5c3RlbUNlbmV0ZXJTZWN1cml0eVJvbGVOYW1lPj4oW10pO1xyXG4gICAgY29uc3QgW2lnbm9yZWQsIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7IC8vIGludGVnZXIgc3RhdGUgZm9yIHJlc2l6ZSByZW5kZXJzXHJcblxyXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBsZXQgaGFuZGxlID0gZ2V0Um9sZXMoKTtcclxuICAgICAgICBoYW5kbGUuZG9uZShycyA9PiBzZXRSb2xlcyhycykpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCAoZXZ0KSA9PiBmb3JjZVVwZGF0ZSgpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFudXAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIGhhbmRsZS5hYm9ydCgpO1xyXG5cclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChldnQpID0+IHsgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRSb2xlcygpOiBKUXVlcnkuanFYSFI8QXJyYXk8U3lzdGVtQ2VudGVyLlN5c3RlbUNlbmV0ZXJTZWN1cml0eVJvbGVOYW1lPj4ge1xyXG4gICAgICAgcmV0dXJuICQuYWpheCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXHJcbiAgICAgICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1N5c3RlbUNlbnRlci9TZWN1cml0eVJvbGVzYCxcclxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxyXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxyXG4gICAgICAgICAgICBjYWNoZTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKE9iamVjdC5rZXlzKHF1ZXJ5U3RyaW5nLnBhcnNlKGhpc3RvcnkubG9jYXRpb24uc2VhcmNoKSkubGVuZ3RoID09IDApXHJcbiAgICAgICAgaGlzdG9yeS5wdXNoKHsgcGF0aG5hbWU6IGhvbWVQYXRoICsgJ2luZGV4LmNzaHRtbCcsIHNlYXJjaDogJ25hbWU9TWV0ZXJzJywgc3RhdGU6IHt9IH0pXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8Um91dGVyPlxyXG4gICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdmJhciBuYXZiYXItZGFyayBmaXhlZC10b3AgYmctZGFyayBmbGV4LW1kLW5vd3JhcCBwLTAgc2hhZG93XCIgc3R5bGU9e3toZWlnaHQ6IDc1fX0+XHJcbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJjb2wtc20tMyBjb2wtbWQtMiBtci0wXCIgc3R5bGU9e3t0ZXh0QWxpZ246J2NlbnRlcid9fWhyZWY9XCJodHRwczovL3d3dy5ncmlkcHJvdGVjdGlvbmFsbGlhbmNlLm9yZ1wiPjxpbWcgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgbWFyZ2luOiAtNSB9fSBzcmM9e1wiLi4vSW1hZ2VzL1N5c3RlbUNlbnRlci1Ub3BMZWZ0LnBuZ1wifSAvPjwvYT5cclxuICAgICAgICAgICAgICAgIHsvKjxpbnB1dCBjbGFzc05hbWU9XCJmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLWRhcmsgdy0xMDBcIiB0eXBlPVwidGV4dFwiIHBsYWNlaG9sZGVyPVwiU2VhcmNoXCIgYXJpYS1sYWJlbD1cIlNlYXJjaFwiLz4qL31cclxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXZiYXItbmF2IHB4LTNcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW0gdGV4dC1ub3dyYXBcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBocmVmPVwiI1wiPlNpZ24gb3V0PC9hPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8L25hdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXItZmx1aWRcIiBzdHlsZT17eyB0b3A6IDc1LCAgcG9zaXRpb246ICdhYnNvbHV0ZScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2NhbGMoMTAwJSAtIDc1cHgpJywgb3ZlcmZsb3c6ICdoaWRkZW4nIH19PlxyXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIiBzdHlsZT17e2hlaWdodDogJzEwMCUnfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPG5hdiBjbGFzc05hbWU9XCJjb2wgYmctbGlnaHQgc2lkZWJhclwiIHN0eWxlPXt7IG1heFdpZHRoOiAyNTAgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2lkZWJhci1zdGlja3lcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgbWFyZ2luVG9wOiA1LCB0ZXh0QWxpZ246ICdjZW50ZXInIH19PjxoMz5TeXN0ZW0gQ2VudGVyPC9oMz48L2Rpdj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxociAvPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cInNpZGViYXItaGVhZGluZ1wiPk1vbml0b3JzIGFuZCBBc3NldHM8L2g2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHN0eWxlPXt7IG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cIm5hdiBmbGV4LWNvbHVtblwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1NZXRlcnNcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9TWV0ZXJzXCJ9Pk1ldGVyczwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Mb2NhdGlvbnNcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9TG9jYXRpb25zXCJ9PlN1YnN0YXRpb25zPC9OYXZMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPUFzc2V0c1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Bc3NldHNcIn0+VHJhbnNtaXNzaW9uIEFzc2V0czwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Bc3NldEdyb3Vwc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Bc3NldEdyb3Vwc1wifT5Bc3NldCBHcm91cHM8L05hdkxpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAxMCB9fSBjbGFzc05hbWU9XCJzaWRlYmFyLWhlYWRpbmdcIj5FeHRlcm5hbCBMaW5rczwvaDY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbWFyZ2luTGVmdDogMTAgfX0gY2xhc3NOYW1lPVwibmF2IGZsZXgtY29sdW1uXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPUNvbXBhbmllc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Db21wYW5pZXNcIn0+Q29tcGFuaWVzPC9OYXZMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVBRVmlld0N1c3RvbWVyc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdDdXN0b21lcnNcIn0+UFFWaWV3IEN1c3RvbWVyIEFjY2VzczwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdTaXRlc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdTaXRlc1wifT5QUVZpZXcgU2l0ZXM8L05hdkxpbms+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgc3R5bGU9e3tmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6IDEwfX0gY2xhc3NOYW1lPVwic2lkZWJhci1oZWFkaW5nXCIgaGlkZGVuPXtyb2xlcy5pbmRleE9mKCdBZG1pbmlzdHJhdG9yJykgPCAwfT5TeXN0ZW0gU2V0dGluZ3M8L2g2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHN0eWxlPXt7IG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cIm5hdiBmbGV4LWNvbHVtblwiIGhpZGRlbj17cm9sZXMuaW5kZXhPZignQWRtaW5pc3RyYXRvcicpIDwgMH0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVZhbHVlTGlzdHNcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9VmFsdWVMaXN0c1wifT5WYWx1ZSBMaXN0czwvTmF2TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHIgLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNiBzdHlsZT17eyBmb250V2VpZ2h0OiAnYm9sZCcsIG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cInNpZGViYXItaGVhZGluZ1wiIGhpZGRlbj17cm9sZXMuaW5kZXhPZignQWRtaW5pc3RyYXRvcicpIDwgMH0+VXNlciBTZXR0aW5nczwvaDY+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbWFyZ2luTGVmdDogMTAgfX0gY2xhc3NOYW1lPVwibmF2IGZsZXgtY29sdW1uXCIgaGlkZGVuPXtyb2xlcy5pbmRleE9mKCdBZG1pbmlzdHJhdG9yJykgPCAwfT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgaXNBY3RpdmU9eyhtYXRjaCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoID09IGNvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9VXNlclN0YXRpc3RpY3NcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9VXNlclN0YXRpc3RpY3NcIn0+VXNlciBTdGF0aXN0aWNzPC9OYXZMaW5rPlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Vc2Vyc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Vc2Vyc1wifT5Vc2VyczwvTmF2TGluaz5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHRleHRBbGlnbjogJ2NlbnRlcicsIHBvc2l0aW9uOidhYnNvbHV0ZScsIGJvdHRvbTogNTAgfX0+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlZlcnNpb24gMC4xPC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxiciAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPjwvc3Bhbj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPC9uYXY+XHJcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2xcIiBzdHlsZT17eyB3aWR0aDogJzEwMCUnLCBoZWlnaHQ6ICdpbmhlcml0JywgcGFkZGluZzogJzAgMCAwIDAnLCBvdmVyZmxvdzogJ2hpZGRlbicgfX0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxSZWFjdC5TdXNwZW5zZSBmYWxsYmFjaz17PGRpdj5Mb2FkaW5nLi4uPC9kaXY+fT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2g+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Um91dGUgY2hpbGRyZW49eyh7IG1hdGNoLCAuLi5yZXN0IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcXMgPSBxdWVyeVN0cmluZy5wYXJzZShyZXN0LmxvY2F0aW9uLnNlYXJjaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHFzWyc/bmFtZSddID09IHVuZGVmaW5lZCB8fCBxc1snP25hbWUnXSA9PSBcIk1ldGVyc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlNZXRlciBSb2xlcz17cm9sZXN9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiTG9jYXRpb25zXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxCeUxvY2F0aW9uIFJvbGVzPXtyb2xlc30gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJBc3NldHNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxCeUFzc2V0IFJvbGVzPXtyb2xlc30gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIkFzc2V0R3JvdXBzXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlBc3NldEdyb3VwIFJvbGVzPXtyb2xlc30gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIlVzZXJzXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlVc2VyIFJvbGVzPXtyb2xlc30gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIkNvbXBhbmllc1wiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEJ5Q29tcGFueSBSb2xlcz17cm9sZXN9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJVc2VyXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8VXNlciBVc2VySUQ9e3FzLlVzZXJBY2NvdW50SUQgYXMgc3RyaW5nfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiVXNlclN0YXRpc3RpY3NcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxVc2VyU3RhdGlzdGljcyBSb2xlcz17cm9sZXN9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJNZXRlclwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPE1ldGVyIE1ldGVySUQ9e3BhcnNlSW50KHFzLk1ldGVySUQgYXMgc3RyaW5nKX0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIkxvY2F0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8TG9jYXRpb24gTG9jYXRpb25JRD17cGFyc2VJbnQocXMuTG9jYXRpb25JRCBhcyBzdHJpbmcpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiQXNzZXRcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxBc3NldCBBc3NldElEPXtwYXJzZUludChxcy5Bc3NldElEIGFzIHN0cmluZyl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJBc3NldEdyb3VwXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QXNzZXRHcm91cCBBc3NldEdyb3VwSUQ9e3BhcnNlSW50KHFzLkFzc2V0R3JvdXBJRCBhcyBzdHJpbmcpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiQ3VzdG9tZXJcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDdXN0b21lciBDdXN0b21lcklEPXtwYXJzZUludChxcy5DdXN0b21lcklEIGFzIHN0cmluZyl9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJDb21wYW55XCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8Q29tcGFueSBDb21wYW55SUQ9e3BhcnNlSW50KHFzLkNvbXBhbnlJRCBhcyBzdHJpbmcpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiUFFWaWV3U2l0ZXNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxpZnJhbWUgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX0gc3JjPXtob21lUGF0aCArICdQUVZpZXdEYXRhTG9hZGVyLmNzaHRtbCd9PjwvaWZyYW1lPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiUFFWaWV3Q3VzdG9tZXJzXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlDdXN0b21lciBSb2xlcz17cm9sZXN9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJOZXdNZXRlcldpemFyZFwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPE5ld01ldGVyV2l6YXJkIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGNoaWxkcmVuPXsoeyBtYXRjaCwgLi4ucmVzdCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvbGVzLmluZGV4T2YoJ0FkbWluaXN0cmF0b3InKSA8IDApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3RyaW5nLnBhcnNlKHJlc3QubG9jYXRpb24uc2VhcmNoKVsnP25hbWUnXSA9PSBcIlZhbHVlTGlzdHNcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxpZnJhbWUgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScgfX0gc3JjPXtob21lUGF0aCArICdWYWx1ZUxpc3RHcm91cHMuY3NodG1sJ30+PC9pZnJhbWU+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH19IC8+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGNoaWxkcmVuPXsoeyBtYXRjaCwgLi4ucmVzdCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvbGVzLmluZGV4T2YoJ0FkbWluaXN0cmF0b3InKSA8IDAgJiYgcm9sZXMuaW5kZXhPZignVHJhbnNtaXNzaW9uIFNNRScpIDwgMCkgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXVlcnlTdHJpbmcucGFyc2UocmVzdC5sb2NhdGlvbi5zZWFyY2gpWyc/bmFtZSddID09IFwiQ29uZmlndXJhdGlvbkhpc3RvcnlcIilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDb25maWd1cmF0aW9uSGlzdG9yeSBNZXRlckNvbmZpZ3VyYXRpb25JRD17cGFyc2VJbnQocXVlcnlTdHJpbmcucGFyc2UocmVzdC5sb2NhdGlvbi5zZWFyY2gpLk1ldGVyQ29uZmlndXJhdGlvbklEIGFzIHN0cmluZyl9IE1ldGVyS2V5PXtxdWVyeVN0cmluZy5wYXJzZShyZXN0LmxvY2F0aW9uLnNlYXJjaCkuTWV0ZXJLZXkgYXMgc3RyaW5nfS8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9Td2l0Y2g+XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1JlYWN0LlN1c3BlbnNlPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L1JvdXRlcj5cclxuICAgIClcclxufVxyXG5cclxuUmVhY3RET00ucmVuZGVyKDxQcm92aWRlciBzdG9yZT17c3RvcmV9PjxTeXN0ZW1DZW50ZXIgLz48L1Byb3ZpZGVyPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpbmRvdycpKTtcclxuIiwibW9kdWxlLmV4cG9ydHMgPSBkMzsiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0OyIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3RET007IiwibW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJvdXRlckRPTTsiXSwic291cmNlUm9vdCI6IiJ9