/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 	};
/******/
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"SystemCenter": 0
/******/ 	};
/******/
/******/
/******/
/******/ 	// script path function
/******/ 	function jsonpScriptSrc(chunkId) {
/******/ 		return __webpack_require__.p + "" + ({"vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171":"vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171","AssetGroup~ByAssetGroup":"AssetGroup~ByAssetGroup","AssetGroup":"AssetGroup","ByAssetGroup":"ByAssetGroup","Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard":"Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard","Asset~ByAsset~Location~Meter~NewMeterWizard":"Asset~ByAsset~Location~Meter~NewMeterWizard","Asset~ByAsset":"Asset~ByAsset","ByAsset":"ByAsset","Asset~Company~Customer~Location~Meter":"Asset~Company~Customer~Location~Meter","Asset":"Asset","Location":"Location","Meter":"Meter","NewMeterWizard":"NewMeterWizard","Customer":"Customer","ByLocation":"ByLocation","ByCustomer":"ByCustomer","ByMeter":"ByMeter","ByUser~User":"ByUser~User","ByUser":"ByUser","User":"User","ConfigurationHistory":"ConfigurationHistory","UserStatistics":"UserStatistics","vendors~ByCompany~Company":"vendors~ByCompany~Company","Company":"Company","ByCompany":"ByCompany"}[chunkId]||chunkId) + ".js"
/******/ 	}
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		var promises = [];
/******/
/******/
/******/ 		// JSONP chunk loading for javascript
/******/
/******/ 		var installedChunkData = installedChunks[chunkId];
/******/ 		if(installedChunkData !== 0) { // 0 means "already installed".
/******/
/******/ 			// a Promise means "currently loading".
/******/ 			if(installedChunkData) {
/******/ 				promises.push(installedChunkData[2]);
/******/ 			} else {
/******/ 				// setup Promise in chunk cache
/******/ 				var promise = new Promise(function(resolve, reject) {
/******/ 					installedChunkData = installedChunks[chunkId] = [resolve, reject];
/******/ 				});
/******/ 				promises.push(installedChunkData[2] = promise);
/******/
/******/ 				// start chunk loading
/******/ 				var script = document.createElement('script');
/******/ 				var onScriptComplete;
/******/
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.src = jsonpScriptSrc(chunkId);
/******/
/******/ 				onScriptComplete = function (event) {
/******/ 					// avoid mem leaks in IE.
/******/ 					script.onerror = script.onload = null;
/******/ 					clearTimeout(timeout);
/******/ 					var chunk = installedChunks[chunkId];
/******/ 					if(chunk !== 0) {
/******/ 						if(chunk) {
/******/ 							var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 							var realSrc = event && event.target && event.target.src;
/******/ 							var error = new Error('Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')');
/******/ 							error.type = errorType;
/******/ 							error.request = realSrc;
/******/ 							chunk[1](error);
/******/ 						}
/******/ 						installedChunks[chunkId] = undefined;
/******/ 					}
/******/ 				};
/******/ 				var timeout = setTimeout(function(){
/******/ 					onScriptComplete({ type: 'timeout', target: script });
/******/ 				}, 120000);
/******/ 				script.onerror = script.onload = onScriptComplete;
/******/ 				document.head.appendChild(script);
/******/ 			}
/******/ 		}
/******/ 		return Promise.all(promises);
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "Scripts/";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./TSX/SystemCenter/SystemCenter.tsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/extends.js":
/*!********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*****************************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*****************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js":
/*!*************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js ***!
  \*************************************************************************************************************************/
/*! exports provided: createNextState, current, __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore, createSelector, MiddlewareArray, configureStore, createAction, createAsyncThunk, createEntityAdapter, createImmutableStateInvariantMiddleware, createReducer, createSerializableStateInvariantMiddleware, createSlice, findNonSerializableValue, getDefaultMiddleware, getType, isImmutableDefault, isPlain, nanoid, unwrapResult */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MiddlewareArray", function() { return MiddlewareArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configureStore", function() { return configureStore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAction", function() { return createAction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAsyncThunk", function() { return createAsyncThunk; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createEntityAdapter", function() { return createEntityAdapter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createImmutableStateInvariantMiddleware", function() { return createImmutableStateInvariantMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReducer", function() { return createReducer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSerializableStateInvariantMiddleware", function() { return createSerializableStateInvariantMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSlice", function() { return createSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findNonSerializableValue", function() { return findNonSerializableValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultMiddleware", function() { return getDefaultMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getType", function() { return getType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImmutableDefault", function() { return isImmutableDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPlain", function() { return isPlain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nanoid", function() { return nanoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unwrapResult", function() { return unwrapResult; });
/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! immer */ "../../node_modules/immer/dist/immer.esm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createNextState", function() { return immer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "current", function() { return immer__WEBPACK_IMPORTED_MODULE_0__["current"]; });

/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! redux */ "../../node_modules/redux/es/redux.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["__DO_NOT_USE__ActionTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["applyMiddleware"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["bindActionCreators"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["combineReducers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["compose"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return redux__WEBPACK_IMPORTED_MODULE_1__["createStore"]; });

/* harmony import */ var reselect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! reselect */ "../../node_modules/reselect/es/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSelector", function() { return reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"]; });

/* harmony import */ var redux_thunk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! redux-thunk */ "../../node_modules/redux-thunk/es/index.js");








function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/**
 * @public
 */

var composeWithDevTools = typeof window !== 'undefined' && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
  if (arguments.length === 0) return undefined;
  if (typeof arguments[0] === 'object') return redux__WEBPACK_IMPORTED_MODULE_1__["compose"];
  return redux__WEBPACK_IMPORTED_MODULE_1__["compose"].apply(null, arguments);
};

/**
 * Returns true if the passed value is "plain" object, i.e. an object whose
 * protoype is the root `Object.prototype`. This includes objects created
 * using object literals, but not for instance for class instances.
 *
 * @param {any} value The value to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(value) {
  if (typeof value !== 'object' || value === null) return false;
  var proto = value;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(value) === proto;
}

function getTimeMeasureUtils(maxDelay, fnName) {
  var elapsed = 0;
  return {
    measureTime: function measureTime(fn) {
      var started = Date.now();

      try {
        return fn();
      } finally {
        var finished = Date.now();
        elapsed += finished - started;
      }
    },
    warnIfExceeded: function warnIfExceeded() {
      if (elapsed > maxDelay) {
        console.warn(fnName + " took " + elapsed + "ms, which is more than the warning threshold of " + maxDelay + "ms. \nIf your state or actions are very large, you may want to disable the middleware as it might cause too much of a slowdown in development mode. See https://redux-toolkit.js.org/api/getDefaultMiddleware for instructions.\nIt is disabled in production builds, so you don't need to worry about that.");
      }
    }
  };
}
/**
 * @public
 */

var MiddlewareArray =
/*#__PURE__*/
function (_Array) {
  _inheritsLoose(MiddlewareArray, _Array);

  function MiddlewareArray() {
    return _Array.apply(this, arguments) || this;
  }

  var _proto = MiddlewareArray.prototype;

  _proto.concat = function concat() {
    var _Array$prototype$conc;

    for (var _len = arguments.length, arr = new Array(_len), _key = 0; _key < _len; _key++) {
      arr[_key] = arguments[_key];
    }

    return _construct(MiddlewareArray, (_Array$prototype$conc = _Array.prototype.concat).call.apply(_Array$prototype$conc, [this].concat(arr)));
  };

  _proto.prepend = function prepend() {
    for (var _len2 = arguments.length, arr = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      arr[_key2] = arguments[_key2];
    }

    if (arr.length === 1 && Array.isArray(arr[0])) {
      return _construct(MiddlewareArray, arr[0].concat(this));
    }

    return _construct(MiddlewareArray, arr.concat(this));
  };

  return MiddlewareArray;
}(
/*#__PURE__*/
_wrapNativeSuper(Array));

var isProduction = "development" === 'production';
var prefix = 'Invariant failed'; // Throw an error if the condition fails
// Strip out error messages for production
// > Not providing an inline default argument for message as the result is smaller

function invariant(condition, message) {
  if (condition) {
    return;
  } // Condition not passed
  // In production we strip the message but still throw


  if (isProduction) {
    throw new Error(prefix);
  } // When not in production we allow the message to pass through
  // *This block will be removed in production builds*


  throw new Error(prefix + ": " + (message || ''));
}

function stringify(obj, serializer, indent, decycler) {
  return JSON.stringify(obj, getSerialize(serializer, decycler), indent);
}

function getSerialize(serializer, decycler) {
  var stack = [],
      keys = [];
  if (!decycler) decycler = function decycler(_, value) {
    if (stack[0] === value) return '[Circular ~]';
    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';
  };
  return function (key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
      if (~stack.indexOf(value)) value = decycler.call(this, key, value);
    } else stack.push(value);

    return serializer == null ? value : serializer.call(this, key, value);
  };
}
/**
 * The default `isImmutable` function.
 *
 * @public
 */


function isImmutableDefault(value) {
  return typeof value !== 'object' || value === null || typeof value === 'undefined';
}
function trackForMutations(isImmutable, ignorePaths, obj) {
  var trackedProperties = trackProperties(isImmutable, ignorePaths, obj);
  return {
    detectMutations: function detectMutations() {
      return _detectMutations(isImmutable, ignorePaths, trackedProperties, obj);
    }
  };
}

function trackProperties(isImmutable, ignorePaths, obj, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }

  if (path === void 0) {
    path = [];
  }

  var tracked = {
    value: obj
  };

  if (!isImmutable(obj)) {
    tracked.children = {};

    for (var key in obj) {
      var childPath = path.concat(key);

      if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {
        continue;
      }

      tracked.children[key] = trackProperties(isImmutable, ignorePaths, obj[key], childPath);
    }
  }

  return tracked;
}

function _detectMutations(isImmutable, ignorePaths, trackedProperty, obj, sameParentRef, path) {
  if (ignorePaths === void 0) {
    ignorePaths = [];
  }

  if (sameParentRef === void 0) {
    sameParentRef = false;
  }

  if (path === void 0) {
    path = [];
  }

  var prevObj = trackedProperty ? trackedProperty.value : undefined;
  var sameRef = prevObj === obj;

  if (sameParentRef && !sameRef && !Number.isNaN(obj)) {
    return {
      wasMutated: true,
      path: path
    };
  }

  if (isImmutable(prevObj) || isImmutable(obj)) {
    return {
      wasMutated: false
    };
  } // Gather all keys from prev (tracked) and after objs


  var keysToDetect = {};
  Object.keys(trackedProperty.children).forEach(function (key) {
    keysToDetect[key] = true;
  });
  Object.keys(obj).forEach(function (key) {
    keysToDetect[key] = true;
  });
  var keys = Object.keys(keysToDetect);

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var childPath = path.concat(key);

    if (ignorePaths.length && ignorePaths.indexOf(childPath.join('.')) !== -1) {
      continue;
    }

    var result = _detectMutations(isImmutable, ignorePaths, trackedProperty.children[key], obj[key], sameRef, childPath);

    if (result.wasMutated) {
      return result;
    }
  }

  return {
    wasMutated: false
  };
}
/**
 * Creates a middleware that checks whether any state was mutated in between
 * dispatches or during a dispatch. If any mutations are detected, an error is
 * thrown.
 *
 * @param options Middleware options.
 *
 * @public
 */


function createImmutableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  if (false) {}

  var _options = options,
      _options$isImmutable = _options.isImmutable,
      isImmutable = _options$isImmutable === void 0 ? isImmutableDefault : _options$isImmutable,
      ignoredPaths = _options.ignoredPaths,
      _options$warnAfter = _options.warnAfter,
      warnAfter = _options$warnAfter === void 0 ? 32 : _options$warnAfter,
      ignore = _options.ignore; // Alias ignore->ignoredPaths, but prefer ignoredPaths if present

  ignoredPaths = ignoredPaths || ignore;
  var track = trackForMutations.bind(null, isImmutable, ignoredPaths);
  return function (_ref) {
    var getState = _ref.getState;
    var state = getState();
    var tracker = track(state);
    var result;
    return function (next) {
      return function (action) {
        var measureUtils = getTimeMeasureUtils(warnAfter, 'ImmutableStateInvariantMiddleware');
        measureUtils.measureTime(function () {
          state = getState();
          result = tracker.detectMutations(); // Track before potentially not meeting the invariant

          tracker = track(state);
          !!result.wasMutated ?  true ? invariant(false, "A state mutation was detected between dispatches, in the path '" + (result.path || []).join('.') + "'.  This may cause incorrect behavior. (https://redux.js.org/troubleshooting#never-mutate-reducer-arguments)") : undefined : void 0;
        });
        var dispatchedAction = next(action);
        measureUtils.measureTime(function () {
          state = getState();
          result = tracker.detectMutations(); // Track before potentially not meeting the invariant

          tracker = track(state);
          result.wasMutated && (!!result.wasMutated ?  true ? invariant(false, "A state mutation was detected inside a dispatch, in the path: " + (result.path || []).join('.') + ". Take a look at the reducer(s) handling the action " + stringify(action) + ". (https://redux.js.org/troubleshooting#never-mutate-reducer-arguments)") : undefined : void 0);
        });
        measureUtils.warnIfExceeded();
        return dispatchedAction;
      };
    };
  };
}

/**
 * Returns true if the passed value is "plain", i.e. a value that is either
 * directly JSON-serializable (boolean, number, string, array, plain object)
 * or `undefined`.
 *
 * @param val The value to check.
 *
 * @public
 */

function isPlain(val) {
  return typeof val === 'undefined' || val === null || typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number' || Array.isArray(val) || isPlainObject(val);
}
/**
 * @public
 */

function findNonSerializableValue(value, path, isSerializable, getEntries, ignoredPaths) {
  if (path === void 0) {
    path = [];
  }

  if (isSerializable === void 0) {
    isSerializable = isPlain;
  }

  if (ignoredPaths === void 0) {
    ignoredPaths = [];
  }

  var foundNestedSerializable;

  if (!isSerializable(value)) {
    return {
      keyPath: path.join('.') || '<root>',
      value: value
    };
  }

  if (typeof value !== 'object' || value === null) {
    return false;
  }

  var entries = getEntries != null ? getEntries(value) : Object.entries(value);
  var hasIgnoredPaths = ignoredPaths.length > 0;

  for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _ref2 = _ref,
        property = _ref2[0],
        nestedValue = _ref2[1];
    var nestedPath = path.concat(property);

    if (hasIgnoredPaths && ignoredPaths.indexOf(nestedPath.join('.')) >= 0) {
      continue;
    }

    if (!isSerializable(nestedValue)) {
      return {
        keyPath: nestedPath.join('.'),
        value: nestedValue
      };
    }

    if (typeof nestedValue === 'object') {
      foundNestedSerializable = findNonSerializableValue(nestedValue, nestedPath, isSerializable, getEntries, ignoredPaths);

      if (foundNestedSerializable) {
        return foundNestedSerializable;
      }
    }
  }

  return false;
}
/**
 * Creates a middleware that, after every state change, checks if the new
 * state is serializable. If a non-serializable value is found within the
 * state, an error is printed to the console.
 *
 * @param options Middleware options.
 *
 * @public
 */

function createSerializableStateInvariantMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  if (false) {}

  var _options = options,
      _options$isSerializab = _options.isSerializable,
      isSerializable = _options$isSerializab === void 0 ? isPlain : _options$isSerializab,
      getEntries = _options.getEntries,
      _options$ignoredActio = _options.ignoredActions,
      ignoredActions = _options$ignoredActio === void 0 ? [] : _options$ignoredActio,
      _options$ignoredActio2 = _options.ignoredActionPaths,
      ignoredActionPaths = _options$ignoredActio2 === void 0 ? ['meta.arg'] : _options$ignoredActio2,
      _options$ignoredPaths = _options.ignoredPaths,
      ignoredPaths = _options$ignoredPaths === void 0 ? [] : _options$ignoredPaths,
      _options$warnAfter = _options.warnAfter,
      warnAfter = _options$warnAfter === void 0 ? 32 : _options$warnAfter;
  return function (storeAPI) {
    return function (next) {
      return function (action) {
        if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {
          return next(action);
        }

        var measureUtils = getTimeMeasureUtils(warnAfter, 'SerializableStateInvariantMiddleware');
        measureUtils.measureTime(function () {
          var foundActionNonSerializableValue = findNonSerializableValue(action, [], isSerializable, getEntries, ignoredActionPaths);

          if (foundActionNonSerializableValue) {
            var keyPath = foundActionNonSerializableValue.keyPath,
                value = foundActionNonSerializableValue.value;
            console.error("A non-serializable value was detected in an action, in the path: `" + keyPath + "`. Value:", value, '\nTake a look at the logic that dispatched this action: ', action, '\n(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)', '\n(To allow non-serializable values see: https://redux-toolkit.js.org/usage/usage-guide#working-with-non-serializable-data)');
          }
        });
        var result = next(action);
        measureUtils.measureTime(function () {
          var state = storeAPI.getState();
          var foundStateNonSerializableValue = findNonSerializableValue(state, [], isSerializable, getEntries, ignoredPaths);

          if (foundStateNonSerializableValue) {
            var keyPath = foundStateNonSerializableValue.keyPath,
                value = foundStateNonSerializableValue.value;
            console.error("A non-serializable value was detected in the state, in the path: `" + keyPath + "`. Value:", value, "\nTake a look at the reducer(s) handling this action type: " + action.type + ".\n(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)");
          }
        });
        measureUtils.warnIfExceeded();
        return result;
      };
    };
  };
}

function isBoolean(x) {
  return typeof x === 'boolean';
}

function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
/**
 * Returns any array containing the default middleware installed by
 * `configureStore()`. Useful if you want to configure your store with a custom
 * `middleware` array but still keep the default set.
 *
 * @return The default middleware used by `configureStore()`.
 *
 * @public
 */

function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$thunk = _options.thunk,
      thunk = _options$thunk === void 0 ? true : _options$thunk,
      _options$immutableChe = _options.immutableCheck,
      immutableCheck = _options$immutableChe === void 0 ? true : _options$immutableChe,
      _options$serializable = _options.serializableCheck,
      serializableCheck = _options$serializable === void 0 ? true : _options$serializable;
  var middlewareArray = new MiddlewareArray();

  if (thunk) {
    if (isBoolean(thunk)) {
      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"]);
    } else {
      middlewareArray.push(redux_thunk__WEBPACK_IMPORTED_MODULE_3__["default"].withExtraArgument(thunk.extraArgument));
    }
  }

  if (true) {
    if (immutableCheck) {
      /* PROD_START_REMOVE_UMD */
      var immutableOptions = {};

      if (!isBoolean(immutableCheck)) {
        immutableOptions = immutableCheck;
      }

      middlewareArray.unshift(createImmutableStateInvariantMiddleware(immutableOptions));
      /* PROD_STOP_REMOVE_UMD */
    }

    if (serializableCheck) {
      var serializableOptions = {};

      if (!isBoolean(serializableCheck)) {
        serializableOptions = serializableCheck;
      }

      middlewareArray.push(createSerializableStateInvariantMiddleware(serializableOptions));
    }
  }

  return middlewareArray;
}

var IS_PRODUCTION = "development" === 'production';
/**
 * A friendly abstraction over the standard Redux `createStore()` function.
 *
 * @param config The store configuration.
 * @returns A configured Redux store.
 *
 * @public
 */

function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();

  var _ref = options || {},
      _ref$reducer = _ref.reducer,
      reducer = _ref$reducer === void 0 ? undefined : _ref$reducer,
      _ref$middleware = _ref.middleware,
      middleware = _ref$middleware === void 0 ? curriedGetDefaultMiddleware() : _ref$middleware,
      _ref$devTools = _ref.devTools,
      devTools = _ref$devTools === void 0 ? true : _ref$devTools,
      _ref$preloadedState = _ref.preloadedState,
      preloadedState = _ref$preloadedState === void 0 ? undefined : _ref$preloadedState,
      _ref$enhancers = _ref.enhancers,
      enhancers = _ref$enhancers === void 0 ? undefined : _ref$enhancers;

  var rootReducer;

  if (typeof reducer === 'function') {
    rootReducer = reducer;
  } else if (isPlainObject(reducer)) {
    rootReducer = Object(redux__WEBPACK_IMPORTED_MODULE_1__["combineReducers"])(reducer);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }

  var middlewareEnhancer = redux__WEBPACK_IMPORTED_MODULE_1__["applyMiddleware"].apply(void 0, typeof middleware === 'function' ? middleware(curriedGetDefaultMiddleware) : middleware);
  var finalCompose = redux__WEBPACK_IMPORTED_MODULE_1__["compose"];

  if (devTools) {
    finalCompose = composeWithDevTools(_extends({
      // Enable capture of stack traces for dispatched Redux actions
      trace: !IS_PRODUCTION
    }, typeof devTools === 'object' && devTools));
  }

  var storeEnhancers = [middlewareEnhancer];

  if (Array.isArray(enhancers)) {
    storeEnhancers = [middlewareEnhancer].concat(enhancers);
  } else if (typeof enhancers === 'function') {
    storeEnhancers = enhancers(storeEnhancers);
  }

  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return Object(redux__WEBPACK_IMPORTED_MODULE_1__["createStore"])(rootReducer, preloadedState, composedEnhancer);
}

function createAction(type, prepareAction) {
  function actionCreator() {
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, arguments);

      if (!prepared) {
        throw new Error('prepareAction did not return an object');
      }

      return _extends({
        type: type,
        payload: prepared.payload
      }, 'meta' in prepared && {
        meta: prepared.meta
      }, {}, 'error' in prepared && {
        error: prepared.error
      });
    }

    return {
      type: type,
      payload: arguments.length <= 0 ? undefined : arguments[0]
    };
  }

  actionCreator.toString = function () {
    return "" + type;
  };

  actionCreator.type = type;

  actionCreator.match = function (action) {
    return action.type === type;
  };

  return actionCreator;
}
function isFSA(action) {
  return isPlainObject(action) && typeof action.type === 'string' && Object.keys(action).every(isValidKey);
}

function isValidKey(key) {
  return ['type', 'payload', 'error', 'meta'].indexOf(key) > -1;
}
/**
 * Returns the action type of the actions created by the passed
 * `createAction()`-generated action creator (arbitrary action creators
 * are not supported).
 *
 * @param action The action creator whose action type to get.
 * @returns The action type used by the action creator.
 *
 * @public
 */


function getType(actionCreator) {
  return "" + actionCreator;
}

function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function addCase(typeOrActionCreator, reducer) {
      if (true) {
        /*
         to keep the definition by the user in line with actual behavior,
         we enforce `addCase` to always be called before calling `addMatcher`
         as matching cases take precedence over matchers
         */
        if (actionMatchers.length > 0) {
          throw new Error('`builder.addCase` should only be called before calling `builder.addMatcher`');
        }

        if (defaultCaseReducer) {
          throw new Error('`builder.addCase` should only be called before calling `builder.addDefaultCase`');
        }
      }

      var type = typeof typeOrActionCreator === 'string' ? typeOrActionCreator : typeOrActionCreator.type;

      if (type in actionsMap) {
        throw new Error('addCase cannot be called with two reducers for the same action type');
      }

      actionsMap[type] = reducer;
      return builder;
    },
    addMatcher: function addMatcher(matcher, reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error('`builder.addMatcher` should only be called before calling `builder.addDefaultCase`');
        }
      }

      actionMatchers.push({
        matcher: matcher,
        reducer: reducer
      });
      return builder;
    },
    addDefaultCase: function addDefaultCase(reducer) {
      if (true) {
        if (defaultCaseReducer) {
          throw new Error('`builder.addDefaultCase` can only be called once');
        }
      }

      defaultCaseReducer = reducer;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}

function createReducer(initialState, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }

  var _ref = typeof mapOrBuilderCallback === 'function' ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer],
      actionsMap = _ref[0],
      finalActionMatchers = _ref[1],
      finalDefaultCaseReducer = _ref[2];

  return function (state, action) {
    if (state === void 0) {
      state = initialState;
    }

    var caseReducers = [actionsMap[action.type]].concat(finalActionMatchers.filter(function (_ref2) {
      var matcher = _ref2.matcher;
      return matcher(action);
    }).map(function (_ref3) {
      var reducer = _ref3.reducer;
      return reducer;
    }));

    if (caseReducers.filter(function (cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }

    return caseReducers.reduce(function (previousState, caseReducer) {
      if (caseReducer) {
        if (Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraft"])(previousState)) {
          // If it's already a draft, we must already be inside a `createNextState` call,
          // likely because this is being wrapped in `createReducer`, `createSlice`, or nested
          // inside an existing draft. It's safe to just pass the draft to the mutator.
          var draft = previousState; // We can assume this is already a draft

          var result = caseReducer(draft, action);

          if (typeof result === 'undefined') {
            return previousState;
          }

          return result;
        } else if (!Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraftable"])(previousState)) {
          // If state is not draftable (ex: a primitive, such as 0), we want to directly
          // return the caseReducer func and not wrap it with produce.
          var _result = caseReducer(previousState, action);

          if (typeof _result === 'undefined') {
            throw Error('A case reducer on a non-draftable value must not return undefined');
          }

          return _result;
        } else {
          // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather
          // than an Immutable<S>, and TypeScript cannot find out how to reconcile
          // these two types.
          return Object(immer__WEBPACK_IMPORTED_MODULE_0__["default"])(previousState, function (draft) {
            return caseReducer(draft, action);
          });
        }
      }

      return previousState;
    }, state);
  };
}

function getType$1(slice, actionKey) {
  return slice + "/" + actionKey;
}
/**
 * A function that accepts an initial state, an object full of reducer
 * functions, and a "slice name", and automatically generates
 * action creators and action types that correspond to the
 * reducers and state.
 *
 * The `reducer` argument is passed to `createReducer()`.
 *
 * @public
 */


function createSlice(options) {
  var name = options.name,
      initialState = options.initialState;

  if (!name) {
    throw new Error('`name` is a required option for createSlice');
  }

  var reducers = options.reducers || {};

  var _ref = typeof options.extraReducers === 'undefined' ? [] : typeof options.extraReducers === 'function' ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers],
      _ref$ = _ref[0],
      extraReducers = _ref$ === void 0 ? {} : _ref$,
      _ref$2 = _ref[1],
      actionMatchers = _ref$2 === void 0 ? [] : _ref$2,
      _ref$3 = _ref[2],
      defaultCaseReducer = _ref$3 === void 0 ? undefined : _ref$3;

  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function (reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type = getType$1(name, reducerName);
    var caseReducer;
    var prepareCallback;

    if ('reducer' in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }

    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });

  var finalCaseReducers = _extends({}, extraReducers, {}, sliceCaseReducersByType);

  var reducer = createReducer(initialState, finalCaseReducers, actionMatchers, defaultCaseReducer);
  return {
    name: name,
    reducer: reducer,
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName
  };
}

function getInitialEntityState() {
  return {
    ids: [],
    entities: {}
  };
}
function createInitialStateFactory() {
  function getInitialState(additionalState) {
    if (additionalState === void 0) {
      additionalState = {};
    }

    return Object.assign(getInitialEntityState(), additionalState);
  }

  return {
    getInitialState: getInitialState
  };
}

function createSelectorsFactory() {
  function getSelectors(selectState) {
    var selectIds = function selectIds(state) {
      return state.ids;
    };

    var selectEntities = function selectEntities(state) {
      return state.entities;
    };

    var selectAll = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectIds, selectEntities, function (ids, entities) {
      return ids.map(function (id) {
        return entities[id];
      });
    });

    var selectId = function selectId(_, id) {
      return id;
    };

    var selectById = function selectById(entities, id) {
      return entities[id];
    };

    var selectTotal = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectIds, function (ids) {
      return ids.length;
    });

    if (!selectState) {
      return {
        selectIds: selectIds,
        selectEntities: selectEntities,
        selectAll: selectAll,
        selectTotal: selectTotal,
        selectById: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectEntities, selectId, selectById)
      };
    }

    var selectGlobalizedEntities = Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectEntities);
    return {
      selectIds: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectIds),
      selectEntities: selectGlobalizedEntities,
      selectAll: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectAll),
      selectTotal: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectState, selectTotal),
      selectById: Object(reselect__WEBPACK_IMPORTED_MODULE_2__["createSelector"])(selectGlobalizedEntities, selectId, selectById)
    };
  }

  return {
    getSelectors: getSelectors
  };
}

function createSingleArgumentStateOperator(mutator) {
  var operator = createStateOperator(function (_, state) {
    return mutator(state);
  });
  return function operation(state) {
    return operator(state, undefined);
  };
}
function createStateOperator(mutator) {
  return function operation(state, arg) {
    function isPayloadActionArgument(arg) {
      return isFSA(arg);
    }

    var runMutator = function runMutator(draft) {
      if (isPayloadActionArgument(arg)) {
        mutator(arg.payload, draft);
      } else {
        mutator(arg, draft);
      }
    };

    if (Object(immer__WEBPACK_IMPORTED_MODULE_0__["isDraft"])(state)) {
      // we must already be inside a `createNextState` call, likely because
      // this is being wrapped in `createReducer` or `createSlice`.
      // It's safe to just pass the draft to the mutator.
      runMutator(state); // since it's a draft, we'll just return it

      return state;
    } else {
      // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather
      // than an Immutable<S>, and TypeScript cannot find out how to reconcile
      // these two types.
      return Object(immer__WEBPACK_IMPORTED_MODULE_0__["default"])(state, runMutator);
    }
  };
}

function selectIdValue(entity, selectId) {
  var key = selectId(entity);

  if ( true && key === undefined) {
    console.warn('The entity passed to the `selectId` implementation returned undefined.', 'You should probably provide your own `selectId` implementation.', 'The entity that was passed:', entity, 'The `selectId` implementation:', selectId.toString());
  }

  return key;
}

function createUnsortedStateAdapter(selectId) {
  function addOneMutably(entity, state) {
    var key = selectIdValue(entity, selectId);

    if (key in state.entities) {
      return;
    }

    state.ids.push(key);
    state.entities[key] = entity;
  }

  function addManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    for (var _iterator = entities, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var entity = _ref;
      addOneMutably(entity, state);
    }
  }

  function setAllMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    state.ids = [];
    state.entities = {};
    addManyMutably(entities, state);
  }

  function removeOneMutably(key, state) {
    return removeManyMutably([key], state);
  }

  function removeManyMutably(keys, state) {
    var didMutate = false;
    keys.forEach(function (key) {
      if (key in state.entities) {
        delete state.entities[key];
        didMutate = true;
      }
    });

    if (didMutate) {
      state.ids = state.ids.filter(function (id) {
        return id in state.entities;
      });
    }
  }

  function removeAllMutably(state) {
    Object.assign(state, {
      ids: [],
      entities: {}
    });
  }

  function takeNewKey(keys, update, state) {
    var original = state.entities[update.id];
    var updated = Object.assign({}, original, update.changes);
    var newKey = selectIdValue(updated, selectId);
    var hasNewKey = newKey !== update.id;

    if (hasNewKey) {
      keys[update.id] = newKey;
      delete state.entities[update.id];
    }

    state.entities[newKey] = updated;
    return hasNewKey;
  }

  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }

  function updateManyMutably(updates, state) {
    var newKeys = {};
    var updatesPerEntity = {};
    updates.forEach(function (update) {
      // Only apply updates to entities that currently exist
      if (update.id in state.entities) {
        // If there are multiple updates to one entity, merge them together
        updatesPerEntity[update.id] = {
          id: update.id,
          // Spreads ignore falsy values, so this works even if there isn't
          // an existing update already at this key
          changes: _extends({}, updatesPerEntity[update.id] ? updatesPerEntity[update.id].changes : null, {}, update.changes)
        };
      }
    });
    updates = Object.values(updatesPerEntity);
    var didMutateEntities = updates.length > 0;

    if (didMutateEntities) {
      var didMutateIds = updates.filter(function (update) {
        return takeNewKey(newKeys, update, state);
      }).length > 0;

      if (didMutateIds) {
        state.ids = state.ids.map(function (id) {
          return newKeys[id] || id;
        });
      }
    }
  }

  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }

  function upsertManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    var added = [];
    var updated = [];

    for (var _iterator2 = entities, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var entity = _ref2;
      var id = selectIdValue(entity, selectId);

      if (id in state.entities) {
        updated.push({
          id: id,
          changes: entity
        });
      } else {
        added.push(entity);
      }
    }

    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }

  return {
    removeAll: createSingleArgumentStateOperator(removeAllMutably),
    addOne: createStateOperator(addOneMutably),
    addMany: createStateOperator(addManyMutably),
    setAll: createStateOperator(setAllMutably),
    updateOne: createStateOperator(updateOneMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    upsertMany: createStateOperator(upsertManyMutably),
    removeOne: createStateOperator(removeOneMutably),
    removeMany: createStateOperator(removeManyMutably)
  };
}

function createSortedStateAdapter(selectId, sort) {
  var _createUnsortedStateA = createUnsortedStateAdapter(selectId),
      removeOne = _createUnsortedStateA.removeOne,
      removeMany = _createUnsortedStateA.removeMany,
      removeAll = _createUnsortedStateA.removeAll;

  function addOneMutably(entity, state) {
    return addManyMutably([entity], state);
  }

  function addManyMutably(newModels, state) {
    if (!Array.isArray(newModels)) {
      newModels = Object.values(newModels);
    }

    var models = newModels.filter(function (model) {
      return !(selectIdValue(model, selectId) in state.entities);
    });

    if (models.length !== 0) {
      merge(models, state);
    }
  }

  function setAllMutably(models, state) {
    if (!Array.isArray(models)) {
      models = Object.values(models);
    }

    state.entities = {};
    state.ids = [];
    addManyMutably(models, state);
  }

  function updateOneMutably(update, state) {
    return updateManyMutably([update], state);
  }

  function takeUpdatedModel(models, update, state) {
    if (!(update.id in state.entities)) {
      return false;
    }

    var original = state.entities[update.id];
    var updated = Object.assign({}, original, update.changes);
    var newKey = selectIdValue(updated, selectId);
    delete state.entities[update.id];
    models.push(updated);
    return newKey !== update.id;
  }

  function updateManyMutably(updates, state) {
    var models = [];
    updates.forEach(function (update) {
      return takeUpdatedModel(models, update, state);
    });

    if (models.length !== 0) {
      merge(models, state);
    }
  }

  function upsertOneMutably(entity, state) {
    return upsertManyMutably([entity], state);
  }

  function upsertManyMutably(entities, state) {
    if (!Array.isArray(entities)) {
      entities = Object.values(entities);
    }

    var added = [];
    var updated = [];

    for (var _iterator = entities, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var entity = _ref;
      var id = selectIdValue(entity, selectId);

      if (id in state.entities) {
        updated.push({
          id: id,
          changes: entity
        });
      } else {
        added.push(entity);
      }
    }

    updateManyMutably(updated, state);
    addManyMutably(added, state);
  }

  function areArraysEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length && i < b.length; i++) {
      if (a[i] === b[i]) {
        continue;
      }

      return false;
    }

    return true;
  }

  function merge(models, state) {
    models.sort(sort); // Insert/overwrite all new/updated

    models.forEach(function (model) {
      state.entities[selectId(model)] = model;
    });
    var allEntities = Object.values(state.entities);
    allEntities.sort(sort);
    var newSortedIds = allEntities.map(selectId);
    var ids = state.ids;

    if (!areArraysEqual(ids, newSortedIds)) {
      state.ids = newSortedIds;
    }
  }

  return {
    removeOne: removeOne,
    removeMany: removeMany,
    removeAll: removeAll,
    addOne: createStateOperator(addOneMutably),
    updateOne: createStateOperator(updateOneMutably),
    upsertOne: createStateOperator(upsertOneMutably),
    setAll: createStateOperator(setAllMutably),
    addMany: createStateOperator(addManyMutably),
    updateMany: createStateOperator(updateManyMutably),
    upsertMany: createStateOperator(upsertManyMutably)
  };
}

/**
 *
 * @param options
 *
 * @public
 */

function createEntityAdapter(options) {
  if (options === void 0) {
    options = {};
  }

  var _sortComparer$selectI = _extends({
    sortComparer: false,
    selectId: function selectId(instance) {
      return instance.id;
    }
  }, options),
      selectId = _sortComparer$selectI.selectId,
      sortComparer = _sortComparer$selectI.sortComparer;

  var stateFactory = createInitialStateFactory();
  var selectorsFactory = createSelectorsFactory();
  var stateAdapter = sortComparer ? createSortedStateAdapter(selectId, sortComparer) : createUnsortedStateAdapter(selectId);
  return _extends({
    selectId: selectId,
    sortComparer: sortComparer
  }, stateFactory, {}, selectorsFactory, {}, stateAdapter);
}

// A type of promise-like that resolves synchronously and supports only one observer

const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator"))) : "@@iterator";

const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== "undefined" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator"))) : "@@asyncIterator";

// Asynchronously call a function and send errors to recovery continuation
function _catch(body, recover) {
	try {
		var result = body();
	} catch(e) {
		return recover(e);
	}
	if (result && result.then) {
		return result.then(void 0, recover);
	}
	return result;
}

// Borrowed from https://github.com/ai/nanoid/blob/3.0.2/non-secure/index.js
// This alphabet uses `A-Za-z0-9_-` symbols. A genetic algorithm helped
// optimize the gzip compression for this alphabet.
var urlAlphabet = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW';
/**
 *
 * @public
 */

var nanoid = function nanoid(size) {
  if (size === void 0) {
    size = 21;
  }

  var id = ''; // A compact alternative for `for (var i = 0; i < step; i++)`.

  var i = size;

  while (i--) {
    // `| 0` is more compact and faster than `Math.floor()`.
    id += urlAlphabet[Math.random() * 64 | 0];
  }

  return id;
};

var commonProperties = ['name', 'message', 'stack', 'code'];

var RejectWithValue = function RejectWithValue(value) {
  this.value = value;
}; // Reworked from https://github.com/sindresorhus/serialize-error


var miniSerializeError = function miniSerializeError(value) {
  if (typeof value === 'object' && value !== null) {
    var simpleError = {};

    for (var _iterator = commonProperties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var property = _ref;

      if (typeof value[property] === 'string') {
        simpleError[property] = value[property];
      }
    }

    return simpleError;
  }

  return {
    message: String(value)
  };
};
/**
 *
 * @param typePrefix
 * @param payloadCreator
 * @param options
 *
 * @public
 */

function createAsyncThunk(typePrefix, payloadCreator, options) {
  var fulfilled = createAction(typePrefix + '/fulfilled', function (result, requestId, arg) {
    return {
      payload: result,
      meta: {
        arg: arg,
        requestId: requestId
      }
    };
  });
  var pending = createAction(typePrefix + '/pending', function (requestId, arg) {
    return {
      payload: undefined,
      meta: {
        arg: arg,
        requestId: requestId
      }
    };
  });
  var rejected = createAction(typePrefix + '/rejected', function (error, requestId, arg, payload) {
    var aborted = !!error && error.name === 'AbortError';
    var condition = !!error && error.name === 'ConditionError';
    return {
      payload: payload,
      error: miniSerializeError(error || 'Rejected'),
      meta: {
        arg: arg,
        requestId: requestId,
        aborted: aborted,
        condition: condition
      }
    };
  });
  var displayedWarning = false;
  var AC = typeof AbortController !== 'undefined' ? AbortController :
  /*#__PURE__*/
  function () {
    function _class() {
      this.signal = {
        aborted: false,
        addEventListener: function addEventListener() {},
        dispatchEvent: function dispatchEvent() {
          return false;
        },
        onabort: function onabort() {},
        removeEventListener: function removeEventListener() {}
      };
    }

    var _proto = _class.prototype;

    _proto.abort = function abort() {
      if (true) {
        if (!displayedWarning) {
          displayedWarning = true;
          console.info("This platform does not implement AbortController. \nIf you want to use the AbortController to react to `abort` events, please consider importing a polyfill like 'abortcontroller-polyfill/dist/abortcontroller-polyfill-only'.");
        }
      }
    };

    return _class;
  }();

  function actionCreator(arg) {
    return function (dispatch, getState, extra) {
      var requestId = nanoid();
      var abortController = new AC();
      var abortReason;
      var abortedPromise = new Promise(function (_, reject) {
        return abortController.signal.addEventListener('abort', function () {
          return reject({
            name: 'AbortError',
            message: abortReason || 'Aborted'
          });
        });
      });
      var started = false;

      function abort(reason) {
        if (started) {
          abortReason = reason;
          abortController.abort();
        }
      }

      var promise = function () {
        try {
          var _temp3 = function _temp3(_result) {
            if (_exit2) return _result;
            // We dispatch the result action _after_ the catch, to avoid having any errors
            // here get swallowed by the try/catch block,
            // per https://twitter.com/dan_abramov/status/770914221638942720
            // and https://redux-toolkit.js.org/tutorials/advanced-tutorial#async-error-handling-logic-in-thunks
            var skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;

            if (!skipDispatch) {
              dispatch(finalAction);
            }

            return finalAction;
          };

          var _exit2 = false;
          var finalAction;

          var _temp4 = _catch(function () {
            if (options && options.condition && options.condition(arg, {
              getState: getState,
              extra: extra
            }) === false) {
              // eslint-disable-next-line no-throw-literal
              throw {
                name: 'ConditionError',
                message: 'Aborted due to condition callback returning false.'
              };
            }

            started = true;
            dispatch(pending(requestId, arg));
            return Promise.resolve(Promise.race([abortedPromise, Promise.resolve(payloadCreator(arg, {
              dispatch: dispatch,
              getState: getState,
              extra: extra,
              requestId: requestId,
              signal: abortController.signal,
              rejectWithValue: function rejectWithValue(value) {
                return new RejectWithValue(value);
              }
            })).then(function (result) {
              if (result instanceof RejectWithValue) {
                return rejected(null, requestId, arg, result.value);
              }

              return fulfilled(result, requestId, arg);
            })])).then(function (_Promise$race) {
              finalAction = _Promise$race;
            });
          }, function (err) {
            finalAction = rejected(err, requestId, arg);
          });

          return Promise.resolve(_temp4 && _temp4.then ? _temp4.then(_temp3) : _temp3(_temp4));
        } catch (e) {
          return Promise.reject(e);
        }
      }();

      return Object.assign(promise, {
        abort: abort
      });
    };
  }

  return Object.assign(actionCreator, {
    pending: pending,
    rejected: rejected,
    fulfilled: fulfilled,
    typePrefix: typePrefix
  });
}
/**
 * @public
 */

function unwrapResult(returned) {
  if ('error' in returned) {
    throw returned.error;
  }

  return returned.payload;
}

// we assume RTK will be used with React Native and other Proxy-less
// environments.  In addition, that's how Immer 4 behaved, and since
// we want to ship this in an RTK minor, we should keep the same behavior.

Object(immer__WEBPACK_IMPORTED_MODULE_0__["enableES5"])();




/***/ }),

/***/ "../../node_modules/history/es/DOMUtils.js":
/*!*****************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/DOMUtils.js ***!
  \*****************************************************************************************************/
/*! exports provided: canUseDOM, addEventListener, removeEventListener, getConfirmation, supportsHistory, supportsPopStateOnHashChange, supportsGoWithoutReloadUsingHash, isExtraneousPopstateEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canUseDOM", function() { return canUseDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addEventListener", function() { return addEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeEventListener", function() { return removeEventListener; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getConfirmation", function() { return getConfirmation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsHistory", function() { return supportsHistory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsPopStateOnHashChange", function() { return supportsPopStateOnHashChange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsGoWithoutReloadUsingHash", function() { return supportsGoWithoutReloadUsingHash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isExtraneousPopstateEvent", function() { return isExtraneousPopstateEvent; });
var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

var addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent('on' + event, listener);
};

var removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent('on' + event, listener);
};

var getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
 *
 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
 * changed to avoid false negatives for Windows Phones: https://github.com/reactjs/react-router/issues/586
 */
var supportsHistory = function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) return false;

  return window.history && 'pushState' in window.history;
};

/**
 * Returns true if browser fires popstate on hash change.
 * IE10 and IE11 do not.
 */
var supportsPopStateOnHashChange = function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1;
};

/**
 * Returns false if using go(n) with hash history causes a full page reload.
 */
var supportsGoWithoutReloadUsingHash = function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1;
};

/**
 * Returns true if a given popstate event is an extraneous WebKit event.
 * Accounts for the fact that Chrome on iOS fires real popstate events
 * containing undefined state when pressing the back button.
 */
var isExtraneousPopstateEvent = function isExtraneousPopstateEvent(event) {
  return event.state === undefined && navigator.userAgent.indexOf('CriOS') === -1;
};

/***/ }),

/***/ "../../node_modules/history/es/LocationUtils.js":
/*!**********************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/LocationUtils.js ***!
  \**********************************************************************************************************/
/*! exports provided: createLocation, locationsAreEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return createLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return locationsAreEqual; });
/* harmony import */ var resolve_pathname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! resolve-pathname */ "../../node_modules/resolve-pathname/index.js");
/* harmony import */ var value_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! value-equal */ "../../node_modules/value-equal/index.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };





var createLocation = function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === 'string') {
    // Two-arg form: push(path, state)
    location = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_2__["parsePath"])(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = '';

    if (location.search) {
      if (location.search.charAt(0) !== '?') location.search = '?' + location.search;
    } else {
      location.search = '';
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== '#') location.hash = '#' + location.hash;
    } else {
      location.hash = '';
    }

    if (state !== undefined && location.state === undefined) location.state = state;
  }

  try {
    location.pathname = decodeURI(location.pathname);
  } catch (e) {
    if (e instanceof URIError) {
      throw new URIError('Pathname "' + location.pathname + '" could not be decoded. ' + 'This is likely caused by an invalid percent-encoding.');
    } else {
      throw e;
    }
  }

  if (key) location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== '/') {
      location.pathname = Object(resolve_pathname__WEBPACK_IMPORTED_MODULE_0__["default"])(location.pathname, currentLocation.pathname);
    }
  } else {
    // When there is no prior location and pathname is empty, set it to /
    if (!location.pathname) {
      location.pathname = '/';
    }
  }

  return location;
};

var locationsAreEqual = function locationsAreEqual(a, b) {
  return a.pathname === b.pathname && a.search === b.search && a.hash === b.hash && a.key === b.key && Object(value_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(a.state, b.state);
};

/***/ }),

/***/ "../../node_modules/history/es/PathUtils.js":
/*!******************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/PathUtils.js ***!
  \******************************************************************************************************/
/*! exports provided: addLeadingSlash, stripLeadingSlash, hasBasename, stripBasename, stripTrailingSlash, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLeadingSlash", function() { return addLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripLeadingSlash", function() { return stripLeadingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasBasename", function() { return hasBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripBasename", function() { return stripBasename; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripTrailingSlash", function() { return stripTrailingSlash; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return parsePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return createPath; });
var addLeadingSlash = function addLeadingSlash(path) {
  return path.charAt(0) === '/' ? path : '/' + path;
};

var stripLeadingSlash = function stripLeadingSlash(path) {
  return path.charAt(0) === '/' ? path.substr(1) : path;
};

var hasBasename = function hasBasename(path, prefix) {
  return new RegExp('^' + prefix + '(\\/|\\?|#|$)', 'i').test(path);
};

var stripBasename = function stripBasename(path, prefix) {
  return hasBasename(path, prefix) ? path.substr(prefix.length) : path;
};

var stripTrailingSlash = function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === '/' ? path.slice(0, -1) : path;
};

var parsePath = function parsePath(path) {
  var pathname = path || '/';
  var search = '';
  var hash = '';

  var hashIndex = pathname.indexOf('#');
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf('?');
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  return {
    pathname: pathname,
    search: search === '?' ? '' : search,
    hash: hash === '#' ? '' : hash
  };
};

var createPath = function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = pathname || '/';

  if (search && search !== '?') path += search.charAt(0) === '?' ? search : '?' + search;

  if (hash && hash !== '#') path += hash.charAt(0) === '#' ? hash : '#' + hash;

  return path;
};

/***/ }),

/***/ "../../node_modules/history/es/createBrowserHistory.js":
/*!*****************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createBrowserHistory.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ "../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ "../../node_modules/history/es/DOMUtils.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var PopStateEvent = 'popstate';
var HashChangeEvent = 'hashchange';

var getHistoryState = function getHistoryState() {
  try {
    return window.history.state || {};
  } catch (e) {
    // IE 11 sometimes throws when accessing window.history.state
    // See https://github.com/ReactTraining/history/pull/289
    return {};
  }
};

/**
 * Creates a history object that uses the HTML5 history API including
 * pushState, replaceState, and the popstate event.
 */
var createBrowserHistory = function createBrowserHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["canUseDOM"], 'Browser history needs a DOM');

  var globalHistory = window.history;
  var canUseHistory = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsHistory"])();
  var needsHashChangeListener = !Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsPopStateOnHashChange"])();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__["getConfirmation"] : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripTrailingSlash"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"])(props.basename)) : '';

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["hasBasename"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripBasename"])(path, basename);

    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, key);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if (Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["isExtraneousPopstateEvent"])(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we've seen in sessionStorage.
    // Instead, we just default to 0 for keys we don't know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
  };

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.pushState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.href = href;
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);
          var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

          nextKeys.push(location.key);
          allKeys = nextKeys;

          setState({ action: action, location: location });
        }
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history');

        window.location.href = href;
      }
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = location.key,
          state = location.state;


      if (canUseHistory) {
        globalHistory.replaceState({ key: key, state: state }, null, href);

        if (forceRefresh) {
          window.location.replace(href);
        } else {
          var prevIndex = allKeys.indexOf(history.location.key);

          if (prevIndex !== -1) allKeys[prevIndex] = location.key;

          setState({ action: action, location: location });
        }
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history');

        window.location.replace(href);
      }
    });
  };

  var go = function go(n) {
    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, PopStateEvent, handlePopState);

      if (needsHashChangeListener) Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createBrowserHistory);

/***/ }),

/***/ "../../node_modules/history/es/createHashHistory.js":
/*!**************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createHashHistory.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! invariant */ "../../node_modules/invariant/browser.js");
/* harmony import */ var invariant__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(invariant__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
/* harmony import */ var _DOMUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DOMUtils */ "../../node_modules/history/es/DOMUtils.js");
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };








var HashChangeEvent = 'hashchange';

var HashPathCoders = {
  hashbang: {
    encodePath: function encodePath(path) {
      return path.charAt(0) === '!' ? path : '!/' + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripLeadingSlash"])(path);
    },
    decodePath: function decodePath(path) {
      return path.charAt(0) === '!' ? path.substr(1) : path;
    }
  },
  noslash: {
    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripLeadingSlash"],
    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"]
  },
  slash: {
    encodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"],
    decodePath: _PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"]
  }
};

var getHashPath = function getHashPath() {
  // We can't use window.location.hash here because it's not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var hashIndex = href.indexOf('#');
  return hashIndex === -1 ? '' : href.substring(hashIndex + 1);
};

var pushHashPath = function pushHashPath(path) {
  return window.location.hash = path;
};

var replaceHashPath = function replaceHashPath(path) {
  var hashIndex = window.location.href.indexOf('#');

  window.location.replace(window.location.href.slice(0, hashIndex >= 0 ? hashIndex : 0) + '#' + path);
};

var createHashHistory = function createHashHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  invariant__WEBPACK_IMPORTED_MODULE_1___default()(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["canUseDOM"], 'Hash history needs a DOM');

  var globalHistory = window.history;
  var canGoWithoutReload = Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["supportsGoWithoutReloadUsingHash"])();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils__WEBPACK_IMPORTED_MODULE_5__["getConfirmation"] : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? 'slash' : _props$hashType;

  var basename = props.basename ? Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripTrailingSlash"])(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["addLeadingSlash"])(props.basename)) : '';

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    warning__WEBPACK_IMPORTED_MODULE_0___default()(!basename || Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["hasBasename"])(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".');

    if (basename) path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["stripBasename"])(path, basename);

    return Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path);
  };

  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_4__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop && Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["locationsAreEqual"])(prevLocation, location)) return; // A hashchange doesn't always == location change.

      if (ignorePath === Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location)) return; // Ignore this change; we already setState in push/replace.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = 'POP';

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we've seen in sessionStorage.
    // Instead, we just default to 0 for paths we don't know.

    var toIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return '#' + encodePath(basename + Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location));
  };

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot push state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a PUSH, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        pushHashPath(encodedPath);

        var prevIndex = allPaths.lastIndexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(history.location));
        var nextPaths = allPaths.slice(0, prevIndex === -1 ? 0 : prevIndex + 1);

        nextPaths.push(path);
        allPaths = nextPaths;

        setState({ action: action, location: location });
      } else {
        warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'Hash history cannot PUSH the same path; a new entry will not be added to the history stack');

        setState();
      }
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(state === undefined, 'Hash history cannot replace state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(location);
      var encodedPath = encodePath(basename + path);
      var hashChanged = getHashPath() !== encodedPath;

      if (hashChanged) {
        // We cannot tell if a hashchange was caused by a REPLACE, so we'd
        // rather setState here and ignore the hashchange. The caveat here
        // is that other hash histories in the page will consider it a POP.
        ignorePath = path;
        replaceHashPath(encodedPath);
      }

      var prevIndex = allPaths.indexOf(Object(_PathUtils__WEBPACK_IMPORTED_MODULE_3__["createPath"])(history.location));

      if (prevIndex !== -1) allPaths[prevIndex] = path;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(canGoWithoutReload, 'Hash history go(n) causes a full page reload in this browser');

    globalHistory.go(n);
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var listenerCount = 0;

  var checkDOMListeners = function checkDOMListeners(delta) {
    listenerCount += delta;

    if (listenerCount === 1) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["addEventListener"])(window, HashChangeEvent, handleHashChange);
    } else if (listenerCount === 0) {
      Object(_DOMUtils__WEBPACK_IMPORTED_MODULE_5__["removeEventListener"])(window, HashChangeEvent, handleHashChange);
    }
  };

  var isBlocked = false;

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    var unblock = transitionManager.setPrompt(prompt);

    if (!isBlocked) {
      checkDOMListeners(1);
      isBlocked = true;
    }

    return function () {
      if (isBlocked) {
        isBlocked = false;
        checkDOMListeners(-1);
      }

      return unblock();
    };
  };

  var listen = function listen(listener) {
    var unlisten = transitionManager.appendListener(listener);
    checkDOMListeners(1);

    return function () {
      checkDOMListeners(-1);
      unlisten();
    };
  };

  var history = {
    length: globalHistory.length,
    action: 'POP',
    location: initialLocation,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createHashHistory);

/***/ }),

/***/ "../../node_modules/history/es/createMemoryHistory.js":
/*!****************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createMemoryHistory.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony import */ var _createTransitionManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createTransitionManager */ "../../node_modules/history/es/createTransitionManager.js");
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };






var clamp = function clamp(n, lowerBound, upperBound) {
  return Math.min(Math.max(n, lowerBound), upperBound);
};

/**
 * Creates a history object that stores locations in memory.
 */
var createMemoryHistory = function createMemoryHistory() {
  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? ['/'] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = Object(_createTransitionManager__WEBPACK_IMPORTED_MODULE_3__["default"])();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === 'string' ? Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(entry, undefined, createKey()) : Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils__WEBPACK_IMPORTED_MODULE_1__["createPath"];

  var push = function push(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'PUSH';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length > nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored');

    var action = 'REPLACE';
    var location = Object(_LocationUtils__WEBPACK_IMPORTED_MODULE_2__["createLocation"])(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = 'POP';
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex >= 0 && nextIndex < history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    return transitionManager.setPrompt(prompt);
  };

  var listen = function listen(listener) {
    return transitionManager.appendListener(listener);
  };

  var history = {
    length: entries.length,
    action: 'POP',
    location: entries[index],
    index: index,
    entries: entries,
    createHref: createHref,
    push: push,
    replace: replace,
    go: go,
    goBack: goBack,
    goForward: goForward,
    canGo: canGo,
    block: block,
    listen: listen
  };

  return history;
};

/* harmony default export */ __webpack_exports__["default"] = (createMemoryHistory);

/***/ }),

/***/ "../../node_modules/history/es/createTransitionManager.js":
/*!********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/createTransitionManager.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! warning */ "../../node_modules/warning/browser.js");
/* harmony import */ var warning__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(warning__WEBPACK_IMPORTED_MODULE_0__);


var createTransitionManager = function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    warning__WEBPACK_IMPORTED_MODULE_0___default()(prompt == null, 'A history supports only one prompt at a time');

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we're still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;

      if (typeof result === 'string') {
        if (typeof getUserConfirmation === 'function') {
          getUserConfirmation(result, callback);
        } else {
          warning__WEBPACK_IMPORTED_MODULE_0___default()(false, 'A history needs a getUserConfirmation function in order to use a prompt message');

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
};

/* harmony default export */ __webpack_exports__["default"] = (createTransitionManager);

/***/ }),

/***/ "../../node_modules/history/es/index.js":
/*!**************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/history/es/index.js ***!
  \**************************************************************************************************/
/*! exports provided: createBrowserHistory, createHashHistory, createMemoryHistory, createLocation, locationsAreEqual, parsePath, createPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createBrowserHistory */ "../../node_modules/history/es/createBrowserHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createBrowserHistory", function() { return _createBrowserHistory__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _createHashHistory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createHashHistory */ "../../node_modules/history/es/createHashHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createHashHistory", function() { return _createHashHistory__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createMemoryHistory */ "../../node_modules/history/es/createMemoryHistory.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createMemoryHistory", function() { return _createMemoryHistory__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _LocationUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LocationUtils */ "../../node_modules/history/es/LocationUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createLocation", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__["createLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "locationsAreEqual", function() { return _LocationUtils__WEBPACK_IMPORTED_MODULE_3__["locationsAreEqual"]; });

/* harmony import */ var _PathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PathUtils */ "../../node_modules/history/es/PathUtils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parsePath", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__["parsePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createPath", function() { return _PathUtils__WEBPACK_IMPORTED_MODULE_4__["createPath"]; });











/***/ }),

/***/ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js":
/*!******************************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var reactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;


/***/ }),

/***/ "../../node_modules/immer/dist/immer.esm.js":
/*!******************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/immer/dist/immer.esm.js ***!
  \******************************************************************************************************/
/*! exports provided: default, Immer, applyPatches, castDraft, castImmutable, createDraft, current, enableAllPlugins, enableES5, enableMapSet, enablePatches, finishDraft, immerable, isDraft, isDraftable, nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Immer", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyPatches", function() { return vn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castDraft", function() { return K; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castImmutable", function() { return $; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDraft", function() { return pn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "current", function() { return D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableAllPlugins", function() { return J; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableES5", function() { return T; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enableMapSet", function() { return C; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "enablePatches", function() { return F; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "finishDraft", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "immerable", function() { return L; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraft", function() { return t; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isDraftable", function() { return r; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nothing", function() { return H; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "original", function() { return e; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produce", function() { return an; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "produceWithPatches", function() { return fn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAutoFreeze", function() { return cn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setUseProxies", function() { return sn; });
function n(n){for(var t=arguments.length,r=Array(t>1?t-1:0),e=1;e<t;e++)r[e-1]=arguments[e];if(true){var i=Y[n],o=i?"function"==typeof i?i.apply(null,r):i:"unknown error nr: "+n;throw Error("[Immer] "+o)}throw Error("[Immer] minified error nr: "+n+(r.length?" "+r.join(","):"")+". Find the full error at: https://bit.ly/3cXEKWf")}function t(n){return!!n&&!!n[Q]}function r(n){return!!n&&(function(n){if(!n||"object"!=typeof n)return!1;var t=Object.getPrototypeOf(n);return!t||t===Object.prototype}(n)||Array.isArray(n)||!!n[L]||!!n.constructor[L]||s(n)||v(n))}function e(r){return t(r)||n(23,r),r[Q].t}function i(n,t,r){void 0===r&&(r=!1),0===o(n)?(r?Object.keys:Z)(n).forEach((function(e){r&&"symbol"==typeof e||t(e,n[e],n)})):n.forEach((function(r,e){return t(e,r,n)}))}function o(n){var t=n[Q];return t?t.i>3?t.i-4:t.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,t){return 2===o(n)?n.has(t):Object.prototype.hasOwnProperty.call(n,t)}function a(n,t){return 2===o(n)?n.get(t):n[t]}function f(n,t,r){var e=o(n);2===e?n.set(t,r):3===e?(n.delete(t),n.add(r)):n[t]=r}function c(n,t){return n===t?0!==n||1/n==1/t:n!=n&&t!=t}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var t=nn(n);delete t[Q];for(var r=Z(t),e=0;e<r.length;e++){var i=r[e],o=t[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(t[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),t)}function d(n,e){y(n)||t(n)||!r(n)||(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,t){return d(t,!0)}),!0))}function h(){n(2)}function y(n){return null==n||"object"!=typeof n||Object.isFrozen(n)}function b(t){var r=tn[t];return r||n( true?18:undefined,t),r}function m(n,t){tn[n]=t}function _(){return false||U||n(0),U}function j(n,t){t&&(b("Patches"),n.u=[],n.s=[],n.v=t)}function g(n){O(n),n.p.forEach(S),n.p=null}function O(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var t=n[Q];0===t.i||1===t.i?t.j():t.g=!0}function P(t,e){e._=e.p.length;var i=e.p[0],o=void 0!==t&&t!==i;return e.h.O||b("ES5").S(e,t,o),o?(i[Q].P&&(g(e),n(4)),r(t)&&(t=M(e,t),e.l||x(e,t)),e.u&&b("Patches").M(i[Q],t,e.u,e.s)):t=M(e,i,[]),g(e),e.u&&e.v(e.u,e.s),t!==H?t:void 0}function M(n,t,r){if(y(t))return t;var e=t[Q];if(!e)return i(t,(function(i,o){return A(n,e,t,i,o,r)}),!0),t;if(e.A!==n)return t;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(t,i){return A(n,e,o,t,i,r)})),x(n,o,!1),r&&n.u&&b("Patches").R(e,r,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if( true&&c===o&&n(5),t(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!t(v))return;e.m=!1}if(r(c)&&!y(c)){if(!e.h.N&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,t,r){void 0===r&&(r=!1),n.h.N&&n.m&&d(t,r)}function z(n,t){var r=n[Q];return(r?p(r):n)[t]}function I(n,t){if(t in n)for(var r=Object.getPrototypeOf(n);r;){var e=Object.getOwnPropertyDescriptor(r,t);if(e)return e;r=Object.getPrototypeOf(r)}}function E(n){n.P||(n.P=!0,n.l&&E(n.l))}function k(n){n.o||(n.o=l(n.t))}function R(n,t,r){var e=s(t)?b("MapSet").T(t,r):v(t)?b("MapSet").F(t,r):n.O?function(n,t){var r=Array.isArray(n),e={i:r?1:0,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:null,o:null,j:null,C:!1},i=e,o=rn;r&&(i=[e],o=en);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(t,r):b("ES5").J(t,r);return(r?r.A:_()).p.push(e),e}function D(e){return t(e)||n(22,e),function n(t){if(!r(t))return t;var e,u=t[Q],c=o(t);if(u){if(!u.P&&(u.i<4||!b("ES5").K(u)))return u.t;u.I=!0,e=N(t,c),u.I=!1}else e=N(t,c);return i(e,(function(t,r){u&&a(u.t,t)===r||f(e,t,n(r))})),3===c?new Set(e):e}(e)}function N(n,t){switch(t){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function T(){function r(n,t){var r=s[n];return r?r.enumerable=t:s[n]=r={configurable:!0,enumerable:t,get:function(){var t=this[Q];return true&&f(t),rn.get(t,n)},set:function(t){var r=this[Q]; true&&f(r),rn.set(r,n,t)}},r}function e(n){for(var t=n.length-1;t>=0;t--){var r=n[t][Q];if(!r.P)switch(r.i){case 5:a(r)&&E(r);break;case 4:o(r)&&E(r)}}}function o(n){for(var t=n.t,r=n.k,e=Z(r),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=t[o];if(void 0===a&&!u(t,o))return!0;var f=r[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!t[Q];return e.length!==Z(t).length+(v?0:1)}function a(n){var t=n.k;if(t.length!==n.t.length)return!0;var r=Object.getOwnPropertyDescriptor(t,t.length-1);return!(!r||r.get)}function f(t){t.g&&n(3,JSON.stringify(p(t)))}var s={};m("ES5",{J:function(n,t){var e=Array.isArray(n),i=function(n,t){if(n){for(var e=Array(t.length),i=0;i<t.length;i++)Object.defineProperty(e,""+i,r(i,!0));return e}var o=nn(t);delete o[Q];for(var u=Z(o),a=0;a<u.length;a++){var f=u[a];o[f]=r(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(t),o)}(e,n),o={i:e?5:4,A:t?t.A:_(),P:!1,I:!1,D:{},l:t,t:n,k:i,o:null,g:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,r,o){o?t(r)&&r[Q].A===n&&e(n.p):(n.u&&function n(t){if(t&&"object"==typeof t){var r=t[Q];if(r){var e=r.t,o=r.k,f=r.D,c=r.i;if(4===c)i(o,(function(t){t!==Q&&(void 0!==e[t]||u(e,t)?f[t]||n(o[t]):(f[t]=!0,E(r)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,E(r))}));else if(5===c){if(a(r)&&(E(r),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function F(){function e(n){if(!r(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var t=Object.create(Object.getPrototypeOf(n));for(var i in n)t[i]=e(n[i]);return t}function f(n){return t(n)?e(n):n}var c="add";m("Patches",{$:function(t,r){return r.forEach((function(r){for(var i=r.path,u=r.op,f=t,s=0;s<i.length-1;s++)"object"!=typeof(f=a(f,i[s]))&&n(15,i.join("/"));var v=o(f),p=e(r.value),l=i[i.length-1];switch(u){case"replace":switch(v){case 2:return f.set(l,p);case 3:n(16);default:return f[l]=p}case c:switch(v){case 1:return f.splice(l,0,p);case 2:return f.set(l,p);case 3:return f.add(p);default:return f[l]=p}case"remove":switch(v){case 1:return f.splice(l,1);case 2:return f.delete(l);case 3:return f.delete(r.value);default:return delete f[l]}default:n(17,u)}})),t},R:function(n,t,r,e){switch(n.i){case 0:case 4:case 2:return function(n,t,r,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?"replace":c:"remove";if(v!==p||"replace"!==l){var d=t.concat(n);r.push("remove"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:"remove",path:d}:"remove"===l?{op:c,path:d,value:f(v)}:{op:"replace",path:d,value:f(v)})}}))}(n,t,r,e);case 5:case 1:return function(n,t,r,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,r];r=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=t.concat([v]);r.push({op:"replace",path:p,value:f(u[v])}),e.push({op:"replace",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=t.concat([l]);r.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:"replace",path:t.concat(["length"]),value:i.length})}(n,t,r,e);case 3:return function(n,t,r,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=t.concat([u]);r.push({op:"remove",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=t.concat([u]);r.push({op:c,path:o,value:n}),e.unshift({op:"remove",path:o,value:n})}u++}))}(n,t,r,e)}},M:function(n,t,r,e){r.push({op:"replace",path:[],value:t}),e.push({op:"replace",path:[],value:n.t})}})}function C(){function t(n,t){function r(){this.constructor=n}a(n,t),n.prototype=(r.prototype=t.prototype,new r)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(t){if(r(t)){var e=R(n.A.h,t,n);n.p.set(t,e),n.o.add(e)}else n.o.add(t)})))}function u(t){t.g&&n(3,JSON.stringify(p(t)))}var a=function(n,t){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,t){n.__proto__=t}||function(n,t){for(var r in t)t.hasOwnProperty(r)&&(n[r]=t[r])})(n,t)},f=function(){function n(n,t){return this[Q]={i:2,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,g:!1},this}t(n,Map);var o=n.prototype;return Object.defineProperty(o,"size",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,t){var r=this[Q];return u(r),p(r).has(n)&&p(r).get(n)===t||(e(r),E(r),r.D.set(n,!0),r.o.set(n,t),r.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),e(t),E(t),t.D.set(n,!1),t.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),E(n),n.D=new Map,i(n.t,(function(t){n.D.set(t,!1)})),n.o.clear())},o.forEach=function(n,t){var r=this;p(this[Q]).forEach((function(e,i){n.call(t,r.get(i),i,r)}))},o.get=function(n){var t=this[Q];u(t);var i=p(t).get(n);if(t.I||!r(i))return i;if(i!==t.t.get(n))return i;var o=R(t.A.h,i,t);return e(t),t.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.values()},n.next=function(){var n=r.next();return n.done?n:{done:!1,value:t.get(n.value)}},n},o.entries=function(){var n,t=this,r=this.keys();return(n={})[V]=function(){return t.entries()},n.next=function(){var n=r.next();if(n.done)return n;var e=t.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,t){return this[Q]={i:3,l:t,A:t?t.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,g:!1,C:!1},this}t(n,Set);var r=n.prototype;return Object.defineProperty(r,"size",{get:function(){return p(this[Q]).size}}),r.has=function(n){var t=this[Q];return u(t),t.o?!!t.o.has(n)||!(!t.p.has(n)||!t.o.has(t.p.get(n))):t.t.has(n)},r.add=function(n){var t=this[Q];return u(t),this.has(n)||(o(t),E(t),t.o.add(n)),this},r.delete=function(n){if(!this.has(n))return!1;var t=this[Q];return u(t),o(t),E(t),t.o.delete(n)||!!t.p.has(n)&&t.o.delete(t.p.get(n))},r.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),E(n),n.o.clear())},r.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},r.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},r.keys=function(){return this.values()},r[V]=function(){return this.values()},r.forEach=function(n,t){for(var r=this.values(),e=r.next();!e.done;)n.call(t,e.value,e.value,this),e=r.next()},n}();m("MapSet",{T:function(n,t){return new f(n,t)},F:function(n,t){return new c(n,t)}})}function J(){T(),C(),F()}function K(n){return n}function $(n){return n}var G,U,W="undefined"!=typeof Symbol&&"symbol"==typeof Symbol("x"),X="undefined"!=typeof Map,q="undefined"!=typeof Set,B="undefined"!=typeof Proxy&&void 0!==Proxy.revocable&&"undefined"!=typeof Reflect,H=W?Symbol.for("immer-nothing"):((G={})["immer-nothing"]=!0,G),L=W?Symbol.for("immer-draftable"):"__$immer_draftable",Q=W?Symbol.for("immer-state"):"__$immer_state",V="undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator",Y={0:"Illegal state",1:"Immer drafts cannot have computed properties",2:"This object has been frozen and should not be mutated",3:function(n){return"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? "+n},4:"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",5:"Immer forbids circular references",6:"The first or second argument to `produce` must be a function",7:"The third argument to `produce` must be a function or undefined",8:"First argument to `createDraft` must be a plain object, an array, or an immerable object",9:"First argument to `finishDraft` must be a draft returned by `createDraft`",10:"The given draft is already finalized",11:"Object.defineProperty() cannot be used on an Immer draft",12:"Object.setPrototypeOf() cannot be used on an Immer draft",13:"Immer only supports deleting array indices",14:"Immer only supports setting array indices and the 'length' property",15:function(n){return"Cannot apply patch, path doesn't resolve: "+n},16:'Sets cannot have "replace" patches.',17:function(n){return"Unsupported patch operation: "+n},18:function(n){return"The plugin for '"+n+"' has not been loaded into Immer. To enable the plugin, import and call `enable"+n+"()` when initializing your application."},19:"plugin not loaded",20:"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available",21:function(n){return"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '"+n+"'"},22:function(n){return"'current' expects a draft, got: "+n},23:function(n){return"'original' expects a draft, got: "+n}},Z="undefined"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,nn=Object.getOwnPropertyDescriptors||function(n){var t={};return Z(n).forEach((function(r){t[r]=Object.getOwnPropertyDescriptor(n,r)})),t},tn={},rn={get:function(n,t){if(t===Q)return n;var e=p(n);if(!u(e,t))return function(n,t,r){var e,i=I(t,r);return i?"value"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,t);var i=e[t];return n.I||!r(i)?i:i===z(n.t,t)?(k(n),n.o[t]=R(n.A.h,i,n)):i},has:function(n,t){return t in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,t,r){var e=I(p(n),t);if(null==e?void 0:e.set)return e.set.call(n.k,r),!0;if(!n.P){var i=z(p(n),t),o=null==i?void 0:i[Q];if(o&&o.t===r)return n.o[t]=r,n.D[t]=!1,!0;if(c(r,i)&&(void 0!==r||u(n.t,t)))return!0;k(n),E(n)}return n.o[t]=r,n.D[t]=!0,!0},deleteProperty:function(n,t){return void 0!==z(n.t,t)||t in n.t?(n.D[t]=!1,k(n),E(n)):delete n.D[t],n.o&&delete n.o[t],!0},getOwnPropertyDescriptor:function(n,t){var r=p(n),e=Reflect.getOwnPropertyDescriptor(r,t);return e?{writable:!0,configurable:1!==n.i||"length"!==t,enumerable:e.enumerable,value:r[t]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},en={};i(rn,(function(n,t){en[n]=function(){return arguments[0]=arguments[0][0],t.apply(this,arguments)}})),en.deleteProperty=function(t,r){return true&&isNaN(parseInt(r))&&n(13),rn.deleteProperty.call(this,t[0],r)},en.set=function(t,r,e){return true&&"length"!==r&&isNaN(parseInt(r))&&n(14),rn.set.call(this,t[0],r,e,t[0])};var on=function(){function e(n){this.O=B,this.N="production"!=="development","boolean"==typeof(null==n?void 0:n.useProxies)&&this.setUseProxies(n.useProxies),"boolean"==typeof(null==n?void 0:n.autoFreeze)&&this.setAutoFreeze(n.autoFreeze),this.produce=this.produce.bind(this),this.produceWithPatches=this.produceWithPatches.bind(this)}var i=e.prototype;return i.produce=function(t,e,i){if("function"==typeof t&&"function"!=typeof e){var o=e;e=t;var u=this;return function(n){var t=this;void 0===n&&(n=o);for(var r=arguments.length,i=Array(r>1?r-1:0),a=1;a<r;a++)i[a-1]=arguments[a];return u.produce(n,(function(n){var r;return(r=e).call.apply(r,[t,n].concat(i))}))}}var a;if("function"!=typeof e&&n(6),void 0!==i&&"function"!=typeof i&&n(7),r(t)){var f=w(this),c=R(this,t,void 0),s=!0;try{a=e(c),s=!1}finally{s?g(f):O(f)}return"undefined"!=typeof Promise&&a instanceof Promise?a.then((function(n){return j(f,i),P(n,f)}),(function(n){throw g(f),n})):(j(f,i),P(a,f))}if(!t||"object"!=typeof t){if((a=e(t))===H)return;return void 0===a&&(a=t),this.N&&d(a,!0),a}n(21,t)},i.produceWithPatches=function(n,t){var r,e,i=this;return"function"==typeof n?function(t){for(var r=arguments.length,e=Array(r>1?r-1:0),o=1;o<r;o++)e[o-1]=arguments[o];return i.produceWithPatches(t,(function(t){return n.apply(void 0,[t].concat(e))}))}:[this.produce(n,t,(function(n,t){r=n,e=t})),r,e]},i.createDraft=function(e){r(e)||n(8),t(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,O(i),o},i.finishDraft=function(t,r){var e=t&&t[Q]; true&&(e&&e.C||n(9),e.I&&n(10));var i=e.A;return j(i,r),P(void 0,i)},i.setAutoFreeze=function(n){this.N=n},i.setUseProxies=function(t){t&&!B&&n(20),this.O=t},i.applyPatches=function(n,r){var e;for(e=r.length-1;e>=0;e--){var i=r[e];if(0===i.path.length&&"replace"===i.op){n=i.value;break}}var o=b("Patches").$;return t(n)?o(n,r):this.produce(n,(function(n){return o(n,r.slice(e+1))}))},e}(),un=new on,an=un.produce,fn=un.produceWithPatches.bind(un),cn=un.setAutoFreeze.bind(un),sn=un.setUseProxies.bind(un),vn=un.applyPatches.bind(un),pn=un.createDraft.bind(un),ln=un.finishDraft.bind(un);/* harmony default export */ __webpack_exports__["default"] = (an);


/***/ }),

/***/ "../../node_modules/invariant/browser.js":
/*!***************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/invariant/browser.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (true) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;


/***/ }),

/***/ "../../node_modules/object-assign/index.js":
/*!*****************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/object-assign/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),

/***/ "../../node_modules/prop-types/checkPropTypes.js":
/*!***********************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/checkPropTypes.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),

/***/ "../../node_modules/prop-types/factoryWithTypeCheckers.js":
/*!********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "../../node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "../../node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "../../node_modules/prop-types/index.js":
/*!**************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/index.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "../../node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "../../node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),

/***/ "../../node_modules/querystring-es3/decode.js":
/*!********************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/decode.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../../node_modules/querystring-es3/encode.js":
/*!********************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/encode.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "../../node_modules/querystring-es3/index.js":
/*!*******************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/querystring-es3/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "../../node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "../../node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "../../node_modules/react-is/cjs/react-is.development.js":
/*!*******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-is/cjs/react-is.development.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "../../node_modules/react-is/index.js":
/*!************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-is/index.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "../../node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "../../node_modules/react-redux/es/components/Context.js":
/*!*******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/Context.js ***!
  \*******************************************************************************************************************/
/*! exports provided: ReactReduxContext, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactReduxContext", function() { return ReactReduxContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

var ReactReduxContext =
/*#__PURE__*/
react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext(null);

if (true) {
  ReactReduxContext.displayName = 'ReactRedux';
}

/* harmony default export */ __webpack_exports__["default"] = (ReactReduxContext);

/***/ }),

/***/ "../../node_modules/react-redux/es/components/Provider.js":
/*!********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/Provider.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "../../node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");





function Provider(_ref) {
  var store = _ref.store,
      context = _ref.context,
      children = _ref.children;
  var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    var subscription = new _utils_Subscription__WEBPACK_IMPORTED_MODULE_3__["default"](store);
    subscription.onStateChange = subscription.notifyNestedSubs;
    return {
      store: store,
      subscription: subscription
    };
  }, [store]);
  var previousState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return store.getState();
  }, [store]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var subscription = contextValue.subscription;
    subscription.trySubscribe();

    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }

    return function () {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || _Context__WEBPACK_IMPORTED_MODULE_2__["ReactReduxContext"];
  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Context.Provider, {
    value: contextValue
  }, children);
}

if (true) {
  Provider.propTypes = {
    store: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.shape({
      subscribe: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
      dispatch: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,
      getState: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired
    }),
    context: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
    children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.any
  };
}

/* harmony default export */ __webpack_exports__["default"] = (Provider);

/***/ }),

/***/ "../../node_modules/react-redux/es/components/connectAdvanced.js":
/*!***************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/components/connectAdvanced.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return connectAdvanced; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! hoist-non-react-statics */ "../../node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js");
/* harmony import */ var hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-is */ "../../node_modules/react-is/index.js");
/* harmony import */ var react_is__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_is__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");
/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js");
/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Context */ "../../node_modules/react-redux/es/components/Context.js");







 // Define some constant arrays just to avoid re-creating these

var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];

var stringifyComponent = function stringifyComponent(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};

function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}

function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_6__["useIsomorphicLayoutEffect"])(function () {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}

function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  // We want to capture the wrapper props and child props we used for later comparisons
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false; // If the render was from a store update, clear out that reference and cascade the subscriber update

  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}

function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  // If we're not subscribed to the store, nothing to do here
  if (!shouldHandleStateChanges) return; // Capture values for checking if and when this component unmounts

  var didUnsubscribe = false;
  var lastThrownError = null; // We'll run this callback every time a store subscription update propagates to this component

  var checkForUpdates = function checkForUpdates() {
    if (didUnsubscribe) {
      // Don't run stale listeners.
      // Redux doesn't guarantee unsubscriptions happen until next dispatch.
      return;
    }

    var latestStoreState = store.getState();
    var newChildProps, error;

    try {
      // Actually run the selector with the most recent store state and wrapper props
      // to determine what the child props should be
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e) {
      error = e;
      lastThrownError = e;
    }

    if (!error) {
      lastThrownError = null;
    } // If the child props haven't changed, nothing to do here - cascade the subscription update


    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      // Save references to the new child props.  Note that we track the "child props from store update"
      // as a ref instead of a useState/useReducer because we need a way to determine if that value has
      // been processed.  If this went into useState/useReducer, we couldn't clear out the value without
      // forcing another re-render, which we don't want.
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true; // If the child props _did_ change (or we caught an error), this wrapper component needs to re-render

      forceComponentUpdateDispatch({
        type: 'STORE_UPDATED',
        payload: {
          error: error
        }
      });
    }
  }; // Actually subscribe to the nearest connected ancestor (or store)


  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe(); // Pull data from the store after first render in case the store has
  // changed since we began.

  checkForUpdates();

  var unsubscribeWrapper = function unsubscribeWrapper() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;

    if (lastThrownError) {
      // It's possible that we caught an error due to a bad mapState function, but the
      // parent re-rendered without this component and we're about to unmount.
      // This shouldn't happen as long as we do top-down subscriptions correctly, but
      // if we ever do those wrong, this throw will surface the error in our tests.
      // In that case, throw the error from here so it doesn't get lost.
      throw lastThrownError;
    }
  };

  return unsubscribeWrapper;
}

var initStateUpdates = function initStateUpdates() {
  return [null, 0];
};

function connectAdvanced(
/*
  selectorFactory is a func that is responsible for returning the selector function used to
  compute new props from state, props, and dispatch. For example:
      export default connectAdvanced((dispatch, options) => (state, props) => ({
      thing: state.things[props.thingId],
      saveThing: fields => dispatch(actionCreators.saveThing(props.thingId, fields)),
    }))(YourComponent)
    Access to dispatch is provided to the factory so selectorFactories can bind actionCreators
  outside of their selector as an optimization. Options passed to connectAdvanced are passed to
  the selectorFactory, along with displayName and WrappedComponent, as the second argument.
    Note that selectorFactory is responsible for all caching/memoization of inbound and outbound
  props. Do not use connectAdvanced directly without memoizing results between calls to your
  selector, otherwise the Connect component will re-render on every state or props change.
*/
selectorFactory, // options object:
_ref) {
  if (_ref === void 0) {
    _ref = {};
  }

  var _ref2 = _ref,
      _ref2$getDisplayName = _ref2.getDisplayName,
      getDisplayName = _ref2$getDisplayName === void 0 ? function (name) {
    return "ConnectAdvanced(" + name + ")";
  } : _ref2$getDisplayName,
      _ref2$methodName = _ref2.methodName,
      methodName = _ref2$methodName === void 0 ? 'connectAdvanced' : _ref2$methodName,
      _ref2$renderCountProp = _ref2.renderCountProp,
      renderCountProp = _ref2$renderCountProp === void 0 ? undefined : _ref2$renderCountProp,
      _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges,
      shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta,
      _ref2$storeKey = _ref2.storeKey,
      storeKey = _ref2$storeKey === void 0 ? 'store' : _ref2$storeKey,
      _ref2$withRef = _ref2.withRef,
      withRef = _ref2$withRef === void 0 ? false : _ref2$withRef,
      _ref2$forwardRef = _ref2.forwardRef,
      forwardRef = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef,
      _ref2$context = _ref2.context,
      context = _ref2$context === void 0 ? _Context__WEBPACK_IMPORTED_MODULE_7__["ReactReduxContext"] : _ref2$context,
      connectOptions = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref2, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"]);

  if (true) {
    if (renderCountProp !== undefined) {
      throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    }

    if (withRef) {
      throw new Error('withRef is removed. To access the wrapped instance, use a ref on the connected component');
    }

    var customStoreWarningMessage = 'To use a custom Redux store for specific components, create a custom React context with ' + "React.createContext(), and pass the context object to React Redux's Provider and specific components" + ' like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. ' + 'You may also pass a {context : MyContext} option to connect';

    if (storeKey !== 'store') {
      throw new Error('storeKey has been removed and does not do anything. ' + customStoreWarningMessage);
    }
  }

  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if ( true && !Object(react_is__WEBPACK_IMPORTED_MODULE_4__["isValidElementType"])(WrappedComponent)) {
      throw new Error("You must pass a component to the function returned by " + (methodName + ". Instead received " + stringifyComponent(WrappedComponent)));
    }

    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
    var displayName = getDisplayName(wrappedComponentName);

    var selectorFactoryOptions = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, connectOptions, {
      getDisplayName: getDisplayName,
      methodName: methodName,
      renderCountProp: renderCountProp,
      shouldHandleStateChanges: shouldHandleStateChanges,
      storeKey: storeKey,
      displayName: displayName,
      wrappedComponentName: wrappedComponentName,
      WrappedComponent: WrappedComponent
    });

    var pure = connectOptions.pure;

    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    } // If we aren't running in "pure" mode, we don't want to memoize values.
    // To avoid conditionally calling hooks, we fall back to a tiny wrapper
    // that just executes the given callback immediately.


    var usePureOnlyMemo = pure ? react__WEBPACK_IMPORTED_MODULE_3__["useMemo"] : function (callback) {
      return callback();
    };

    function ConnectFunction(props) {
      var _useMemo = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // Distinguish between actual "data" props that were passed to the wrapper component,
        // and values needed to control behavior (forwarded refs, alternate context instances).
        // To maintain the wrapperProps object reference, memoize this destructuring.
        var reactReduxForwardedRef = props.reactReduxForwardedRef,
            wrapperProps = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(props, ["reactReduxForwardedRef"]);

        return [props.context, reactReduxForwardedRef, wrapperProps];
      }, [props]),
          propsContext = _useMemo[0],
          reactReduxForwardedRef = _useMemo[1],
          wrapperProps = _useMemo[2];

      var ContextToUse = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // Users may optionally pass in a custom context instance to use instead of our ReactReduxContext.
        // Memoize the check that determines which context instance we should use.
        return propsContext && propsContext.Consumer && Object(react_is__WEBPACK_IMPORTED_MODULE_4__["isContextConsumer"])(react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]); // Retrieve the store and ancestor subscription via context, if available

      var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_3__["useContext"])(ContextToUse); // The store _must_ exist as either a prop or in context.
      // We'll check to see if it _looks_ like a Redux store first.
      // This allows us to pass through a `store` prop that is just a plain value.

      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);

      if ( true && !didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error("Could not find \"store\" in the context of " + ("\"" + displayName + "\". Either wrap the root component in a <Provider>, ") + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
      } // Based on the previous check, one of these must be true


      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        // The child props selector needs the store reference as an input.
        // Re-create this selector whenever the store changes.
        return createChildSelector(store);
      }, [store]);

      var _useMemo2 = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (!shouldHandleStateChanges) return NO_SUBSCRIPTION_ARRAY; // This Subscription's source should match where store came from: props vs. context. A component
        // connected to the store via props shouldn't use subscription from context, or vice versa.

        var subscription = new _utils_Subscription__WEBPACK_IMPORTED_MODULE_5__["default"](store, didStoreComeFromProps ? null : contextValue.subscription); // `notifyNestedSubs` is duplicated to handle the case where the component is unmounted in
        // the middle of the notification loop, where `subscription` will then be null. This can
        // probably be avoided if Subscription's listeners logic is changed to not call listeners
        // that have been unsubscribed in the  middle of the notification loop.

        var notifyNestedSubs = subscription.notifyNestedSubs.bind(subscription);
        return [subscription, notifyNestedSubs];
      }, [store, didStoreComeFromProps, contextValue]),
          subscription = _useMemo2[0],
          notifyNestedSubs = _useMemo2[1]; // Determine what {store, subscription} value should be put into nested context, if necessary,
      // and memoize that value to avoid unnecessary context updates.


      var overriddenContextValue = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (didStoreComeFromProps) {
          // This component is directly subscribed to a store from props.
          // We don't want descendants reading from this store - pass down whatever
          // the existing context value is from the nearest connected ancestor.
          return contextValue;
        } // Otherwise, put this component's subscription instance into context, so that
        // connected descendants won't update until after this component is done


        return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, contextValue, {
          subscription: subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]); // We need to force this wrapper component to re-render whenever a Redux store update
      // causes a change to the calculated child component props (or we caught an error in mapState)

      var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_3__["useReducer"])(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates),
          _useReducer$ = _useReducer[0],
          previousStateUpdateResult = _useReducer$[0],
          forceComponentUpdateDispatch = _useReducer[1]; // Propagate any mapState/mapDispatch errors upwards


      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      } // Set up refs to coordinate values between the subscription effect and the render logic


      var lastChildProps = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])();
      var lastWrapperProps = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(wrapperProps);
      var childPropsFromStoreUpdate = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])();
      var renderIsScheduled = Object(react__WEBPACK_IMPORTED_MODULE_3__["useRef"])(false);
      var actualChildProps = usePureOnlyMemo(function () {
        // Tricky logic here:
        // - This render may have been triggered by a Redux store update that produced new child props
        // - However, we may have gotten new wrapper props after that
        // If we have new child props, and the same wrapper props, we know we should use the new child props as-is.
        // But, if we have new wrapper props, those might change the child props, so we have to recalculate things.
        // So, we'll use the child props from store update only if the wrapper props are the same as last time.
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        } // TODO We're reading the store directly in render() here. Bad idea?
        // This will likely cause Bad Things (TM) to happen in Concurrent Mode.
        // Note that we do this because on renders _not_ caused by store updates, we need the latest store state
        // to determine what the child props should be.


        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]); // We need this to execute synchronously every time we re-render. However, React warns
      // about useLayoutEffect in SSR, so we try to detect environment and fall back to
      // just useEffect instead to avoid the warning, since neither will run anyway.

      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]); // Our re-subscribe logic only runs when the store/subscription setup changes

      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]); // Now that all that's done, we can finally try to actually render the child component.
      // We memoize the elements for the rendered child component as an optimization.

      var renderedWrappedComponent = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(WrappedComponent, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]); // If React sees the exact same element reference as last time, it bails out of re-rendering
      // that child, same as if it was wrapped in React.memo() or returned false from shouldComponentUpdate.

      var renderedChild = Object(react__WEBPACK_IMPORTED_MODULE_3__["useMemo"])(function () {
        if (shouldHandleStateChanges) {
          // If this component is subscribed to store updates, we need to pass its own
          // subscription instance down to our descendants. That means rendering the same
          // Context instance, and putting a different value into the context.
          return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }

        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    } // If we're in "pure" mode, ensure our wrapper component only re-renders when incoming props have changed.


    var Connect = pure ? react__WEBPACK_IMPORTED_MODULE_3___default.a.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = displayName;

    if (forwardRef) {
      var forwarded = react__WEBPACK_IMPORTED_MODULE_3___default.a.forwardRef(function forwardConnectRef(props, ref) {
        return react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(Connect, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
          reactReduxForwardedRef: ref
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(forwarded, WrappedComponent);
    }

    return hoist_non_react_statics__WEBPACK_IMPORTED_MODULE_2___default()(Connect, WrappedComponent);
  };
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/connect.js":
/*!****************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/connect.js ***!
  \****************************************************************************************************************/
/*! exports provided: createConnect, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createConnect", function() { return createConnect; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/connectAdvanced */ "../../node_modules/react-redux/es/components/connectAdvanced.js");
/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/shallowEqual */ "../../node_modules/react-redux/es/utils/shallowEqual.js");
/* harmony import */ var _mapDispatchToProps__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapDispatchToProps */ "../../node_modules/react-redux/es/connect/mapDispatchToProps.js");
/* harmony import */ var _mapStateToProps__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mapStateToProps */ "../../node_modules/react-redux/es/connect/mapStateToProps.js");
/* harmony import */ var _mergeProps__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mergeProps */ "../../node_modules/react-redux/es/connect/mergeProps.js");
/* harmony import */ var _selectorFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./selectorFactory */ "../../node_modules/react-redux/es/connect/selectorFactory.js");








/*
  connect is a facade over connectAdvanced. It turns its args into a compatible
  selectorFactory, which has the signature:

    (dispatch, options) => (nextState, nextOwnProps) => nextFinalProps
  
  connect passes its args to connectAdvanced as options, which will in turn pass them to
  selectorFactory each time a Connect component instance is instantiated or hot reloaded.

  selectorFactory returns a final props selector from its mapStateToProps,
  mapStateToPropsFactories, mapDispatchToProps, mapDispatchToPropsFactories, mergeProps,
  mergePropsFactories, and pure args.

  The resulting final props selector is called by the Connect component instance whenever
  it receives new props or store state.
 */

function match(arg, factories, name) {
  for (var i = factories.length - 1; i >= 0; i--) {
    var result = factories[i](arg);
    if (result) return result;
  }

  return function (dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}

function strictEqual(a, b) {
  return a === b;
} // createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios


function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$connectHOC = _ref.connectHOC,
      connectHOC = _ref$connectHOC === void 0 ? _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_2__["default"] : _ref$connectHOC,
      _ref$mapStateToPropsF = _ref.mapStateToPropsFactories,
      mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? _mapStateToProps__WEBPACK_IMPORTED_MODULE_5__["default"] : _ref$mapStateToPropsF,
      _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories,
      mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? _mapDispatchToProps__WEBPACK_IMPORTED_MODULE_4__["default"] : _ref$mapDispatchToPro,
      _ref$mergePropsFactor = _ref.mergePropsFactories,
      mergePropsFactories = _ref$mergePropsFactor === void 0 ? _mergeProps__WEBPACK_IMPORTED_MODULE_6__["default"] : _ref$mergePropsFactor,
      _ref$selectorFactory = _ref.selectorFactory,
      selectorFactory = _ref$selectorFactory === void 0 ? _selectorFactory__WEBPACK_IMPORTED_MODULE_7__["default"] : _ref$selectorFactory;

  return function connect(mapStateToProps, mapDispatchToProps, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }

    var _ref3 = _ref2,
        _ref3$pure = _ref3.pure,
        pure = _ref3$pure === void 0 ? true : _ref3$pure,
        _ref3$areStatesEqual = _ref3.areStatesEqual,
        areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual,
        _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual,
        areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areOwnPropsEqua,
        _ref3$areStatePropsEq = _ref3.areStatePropsEqual,
        areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areStatePropsEq,
        _ref3$areMergedPropsE = _ref3.areMergedPropsEqual,
        areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_3__["default"] : _ref3$areMergedPropsE,
        extraOptions = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_ref3, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"]);

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
    return connectHOC(selectorFactory, Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      // used in error messages
      methodName: 'connect',
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name) {
        return "Connect(" + name + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps: initMapStateToProps,
      initMapDispatchToProps: initMapDispatchToProps,
      initMergeProps: initMergeProps,
      pure: pure,
      areStatesEqual: areStatesEqual,
      areOwnPropsEqual: areOwnPropsEqual,
      areStatePropsEqual: areStatePropsEqual,
      areMergedPropsEqual: areMergedPropsEqual
    }, extraOptions));
  };
}
/* harmony default export */ __webpack_exports__["default"] = (/*#__PURE__*/createConnect());

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mapDispatchToProps.js":
/*!***************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mapDispatchToProps.js ***!
  \***************************************************************************************************************************/
/*! exports provided: whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsFunction", function() { return whenMapDispatchToPropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsMissing", function() { return whenMapDispatchToPropsIsMissing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapDispatchToPropsIsObject", function() { return whenMapDispatchToPropsIsObject; });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! redux */ "../../node_modules/redux/es/redux.js");
/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wrapMapToProps */ "../../node_modules/react-redux/es/connect/wrapMapToProps.js");


function whenMapDispatchToPropsIsFunction(mapDispatchToProps) {
  return typeof mapDispatchToProps === 'function' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsFunc"])(mapDispatchToProps, 'mapDispatchToProps') : undefined;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps) {
  return !mapDispatchToProps ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsConstant"])(function (dispatch) {
    return {
      dispatch: dispatch
    };
  }) : undefined;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps) {
  return mapDispatchToProps && typeof mapDispatchToProps === 'object' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_1__["wrapMapToPropsConstant"])(function (dispatch) {
    return Object(redux__WEBPACK_IMPORTED_MODULE_0__["bindActionCreators"])(mapDispatchToProps, dispatch);
  }) : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mapStateToProps.js":
/*!************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mapStateToProps.js ***!
  \************************************************************************************************************************/
/*! exports provided: whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapStateToPropsIsFunction", function() { return whenMapStateToPropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMapStateToPropsIsMissing", function() { return whenMapStateToPropsIsMissing; });
/* harmony import */ var _wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wrapMapToProps */ "../../node_modules/react-redux/es/connect/wrapMapToProps.js");

function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === 'function' ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__["wrapMapToPropsFunc"])(mapStateToProps, 'mapStateToProps') : undefined;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? Object(_wrapMapToProps__WEBPACK_IMPORTED_MODULE_0__["wrapMapToPropsConstant"])(function () {
    return {};
  }) : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/mergeProps.js":
/*!*******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/mergeProps.js ***!
  \*******************************************************************************************************************/
/*! exports provided: defaultMergeProps, wrapMergePropsFunc, whenMergePropsIsFunction, whenMergePropsIsOmitted, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMergeProps", function() { return defaultMergeProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMergePropsFunc", function() { return wrapMergePropsFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMergePropsIsFunction", function() { return whenMergePropsIsFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "whenMergePropsIsOmitted", function() { return whenMergePropsIsOmitted; });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "../../node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/verifyPlainObject */ "../../node_modules/react-redux/es/utils/verifyPlainObject.js");


function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, ownProps, {}, stateProps, {}, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName,
        pure = _ref.pure,
        areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);

      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true) Object(_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_1__["default"])(mergedProps, displayName, 'mergeProps');
      }

      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function () {
    return defaultMergeProps;
  } : undefined;
}
/* harmony default export */ __webpack_exports__["default"] = ([whenMergePropsIsFunction, whenMergePropsIsOmitted]);

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/selectorFactory.js":
/*!************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/selectorFactory.js ***!
  \************************************************************************************************************************/
/*! exports provided: impureFinalPropsSelectorFactory, pureFinalPropsSelectorFactory, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "impureFinalPropsSelectorFactory", function() { return impureFinalPropsSelectorFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pureFinalPropsSelectorFactory", function() { return pureFinalPropsSelectorFactory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return finalPropsSelectorFactory; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _verifySubselectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./verifySubselectors */ "../../node_modules/react-redux/es/connect/verifySubselectors.js");


function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual,
      areOwnPropsEqual = _ref.areOwnPropsEqual,
      areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;

  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }

  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps) stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps.dependsOnOwnProps) dispatchProps = mapDispatchToProps(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged) mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }

  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged) return handleNewPropsAndNewState();
    if (propsChanged) return handleNewProps();
    if (stateChanged) return handleNewState();
    return mergedProps;
  }

  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
} // TODO: Add more comments
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.

function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps,
      initMapDispatchToProps = _ref2.initMapDispatchToProps,
      initMergeProps = _ref2.initMergeProps,
      options = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref2, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"]);

  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);

  if (true) {
    Object(_verifySubselectors__WEBPACK_IMPORTED_MODULE_1__["default"])(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);
  }

  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/verifySubselectors.js":
/*!***************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/verifySubselectors.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return verifySubselectors; });
/* harmony import */ var _utils_warning__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/warning */ "../../node_modules/react-redux/es/utils/warning.js");


function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
  } else if (methodName === 'mapStateToProps' || methodName === 'mapDispatchToProps') {
    if (!Object.prototype.hasOwnProperty.call(selector, 'dependsOnOwnProps')) {
      Object(_utils_warning__WEBPACK_IMPORTED_MODULE_0__["default"])("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
    }
  }
}

function verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, displayName) {
  verify(mapStateToProps, 'mapStateToProps', displayName);
  verify(mapDispatchToProps, 'mapDispatchToProps', displayName);
  verify(mergeProps, 'mergeProps', displayName);
}

/***/ }),

/***/ "../../node_modules/react-redux/es/connect/wrapMapToProps.js":
/*!***********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/connect/wrapMapToProps.js ***!
  \***********************************************************************************************************************/
/*! exports provided: wrapMapToPropsConstant, getDependsOnOwnProps, wrapMapToPropsFunc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMapToPropsConstant", function() { return wrapMapToPropsConstant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDependsOnOwnProps", function() { return getDependsOnOwnProps; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapMapToPropsFunc", function() { return wrapMapToPropsFunc; });
/* harmony import */ var _utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/verifyPlainObject */ "../../node_modules/react-redux/es/utils/verifyPlainObject.js");

function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant = getConstant(dispatch, options);

    function constantSelector() {
      return constant;
    }

    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
} // dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
//
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..

function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
} // Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
//
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//

function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;

    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    }; // allow detectFactoryAndVerify to get ownProps


    proxy.dependsOnOwnProps = true;

    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);

      if (typeof props === 'function') {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }

      if (true) Object(_utils_verifyPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(props, displayName, methodName);
      return props;
    };

    return proxy;
  };
}

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useDispatch.js":
/*!******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useDispatch.js ***!
  \******************************************************************************************************************/
/*! exports provided: createDispatchHook, useDispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDispatchHook", function() { return createDispatchHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useDispatch", function() { return useDispatch; });
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _useStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useStore */ "../../node_modules/react-redux/es/hooks/useStore.js");


/**
 * Hook factory, which creates a `useDispatch` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useDispatch` hook bound to the specified context.
 */

function createDispatchHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_0__["ReactReduxContext"];
  }

  var useStore = context === _components_Context__WEBPACK_IMPORTED_MODULE_0__["ReactReduxContext"] ? _useStore__WEBPACK_IMPORTED_MODULE_1__["useStore"] : Object(_useStore__WEBPACK_IMPORTED_MODULE_1__["createStoreHook"])(context);
  return function useDispatch() {
    var store = useStore();
    return store.dispatch;
  };
}
/**
 * A hook to access the redux `dispatch` function.
 *
 * @returns {any|function} redux store's `dispatch` function
 *
 * @example
 *
 * import React, { useCallback } from 'react'
 * import { useDispatch } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const dispatch = useDispatch()
 *   const increaseCounter = useCallback(() => dispatch({ type: 'increase-counter' }), [])
 *   return (
 *     <div>
 *       <span>{value}</span>
 *       <button onClick={increaseCounter}>Increase counter</button>
 *     </div>
 *   )
 * }
 */

var useDispatch =
/*#__PURE__*/
createDispatchHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useReduxContext.js":
/*!**********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useReduxContext.js ***!
  \**********************************************************************************************************************/
/*! exports provided: useReduxContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useReduxContext", function() { return useReduxContext; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");


/**
 * A hook to access the value of the `ReactReduxContext`. This is a low-level
 * hook that you should usually not need to call directly.
 *
 * @returns {any} the value of the `ReactReduxContext`
 *
 * @example
 *
 * import React from 'react'
 * import { useReduxContext } from 'react-redux'
 *
 * export const CounterComponent = ({ value }) => {
 *   const { store } = useReduxContext()
 *   return <div>{store.getState()}</div>
 * }
 */

function useReduxContext() {
  var contextValue = Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(_components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"]);

  if ( true && !contextValue) {
    throw new Error('could not find react-redux context value; please ensure the component is wrapped in a <Provider>');
  }

  return contextValue;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useSelector.js":
/*!******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useSelector.js ***!
  \******************************************************************************************************************/
/*! exports provided: createSelectorHook, useSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelectorHook", function() { return createSelectorHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useSelector", function() { return useSelector; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useReduxContext */ "../../node_modules/react-redux/es/hooks/useReduxContext.js");
/* harmony import */ var _utils_Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/Subscription */ "../../node_modules/react-redux/es/utils/Subscription.js");
/* harmony import */ var _utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/useIsomorphicLayoutEffect */ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js");
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");






var refEquality = function refEquality(a, b) {
  return a === b;
};

function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(function (s) {
    return s + 1;
  }, 0),
      forceRender = _useReducer[1];

  var subscription = Object(react__WEBPACK_IMPORTED_MODULE_0__["useMemo"])(function () {
    return new _utils_Subscription__WEBPACK_IMPORTED_MODULE_2__["default"](store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestSelector = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestStoreState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var latestSelectedState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])();
  var storeState = store.getState();
  var selectedState;

  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      selectedState = selector(storeState);
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }

    throw err;
  }

  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__["useIsomorphicLayoutEffect"])(function () {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = undefined;
  });
  Object(_utils_useIsomorphicLayoutEffect__WEBPACK_IMPORTED_MODULE_3__["useIsomorphicLayoutEffect"])(function () {
    function checkForUpdates() {
      try {
        var newSelectedState = latestSelector.current(store.getState());

        if (equalityFn(newSelectedState, latestSelectedState.current)) {
          return;
        }

        latestSelectedState.current = newSelectedState;
      } catch (err) {
        // we ignore all errors here, since when the component
        // is re-rendered, the selectors are called again, and
        // will throw again, if neither props nor store state
        // changed
        latestSubscriptionCallbackError.current = err;
      }

      forceRender();
    }

    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function () {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
/**
 * Hook factory, which creates a `useSelector` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useSelector` hook bound to the specified context.
 */


function createSelectorHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_4__["ReactReduxContext"];
  }

  var useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_4__["ReactReduxContext"] ? _useReduxContext__WEBPACK_IMPORTED_MODULE_1__["useReduxContext"] : function () {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(context);
  };
  return function useSelector(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }

    if ( true && !selector) {
      throw new Error("You must pass a selector to useSelector");
    }

    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store,
        contextSub = _useReduxContext.subscription;

    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    Object(react__WEBPACK_IMPORTED_MODULE_0__["useDebugValue"])(selectedState);
    return selectedState;
  };
}
/**
 * A hook to access the redux store's state. This hook takes a selector function
 * as an argument. The selector is called with the store state.
 *
 * This hook takes an optional equality comparison function as the second parameter
 * that allows you to customize the way the selected state is compared to determine
 * whether the component needs to be re-rendered.
 *
 * @param {Function} selector the selector function
 * @param {Function=} equalityFn the function that will be used to determine equality
 *
 * @returns {any} the selected state
 *
 * @example
 *
 * import React from 'react'
 * import { useSelector } from 'react-redux'
 *
 * export const CounterComponent = () => {
 *   const counter = useSelector(state => state.counter)
 *   return <div>{counter}</div>
 * }
 */

var useSelector =
/*#__PURE__*/
createSelectorHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/hooks/useStore.js":
/*!***************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/hooks/useStore.js ***!
  \***************************************************************************************************************/
/*! exports provided: createStoreHook, useStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStoreHook", function() { return createStoreHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useStore", function() { return useStore; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony import */ var _useReduxContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useReduxContext */ "../../node_modules/react-redux/es/hooks/useReduxContext.js");



/**
 * Hook factory, which creates a `useStore` hook bound to a given context.
 *
 * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
 * @returns {Function} A `useStore` hook bound to the specified context.
 */

function createStoreHook(context) {
  if (context === void 0) {
    context = _components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"];
  }

  var useReduxContext = context === _components_Context__WEBPACK_IMPORTED_MODULE_1__["ReactReduxContext"] ? _useReduxContext__WEBPACK_IMPORTED_MODULE_2__["useReduxContext"] : function () {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["useContext"])(context);
  };
  return function useStore() {
    var _useReduxContext = useReduxContext(),
        store = _useReduxContext.store;

    return store;
  };
}
/**
 * A hook to access the redux store.
 *
 * @returns {any} the redux store
 *
 * @example
 *
 * import React from 'react'
 * import { useStore } from 'react-redux'
 *
 * export const ExampleComponent = () => {
 *   const store = useStore()
 *   return <div>{store.getState()}</div>
 * }
 */

var useStore =
/*#__PURE__*/
createStoreHook();

/***/ }),

/***/ "../../node_modules/react-redux/es/index.js":
/*!******************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/index.js ***!
  \******************************************************************************************************/
/*! exports provided: Provider, connectAdvanced, ReactReduxContext, connect, batch, useDispatch, createDispatchHook, useSelector, createSelectorHook, useStore, createStoreHook, shallowEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_Provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Provider */ "../../node_modules/react-redux/es/components/Provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return _components_Provider__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/connectAdvanced */ "../../node_modules/react-redux/es/components/connectAdvanced.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "connectAdvanced", function() { return _components_connectAdvanced__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _components_Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Context */ "../../node_modules/react-redux/es/components/Context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReactReduxContext", function() { return _components_Context__WEBPACK_IMPORTED_MODULE_2__["ReactReduxContext"]; });

/* harmony import */ var _connect_connect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./connect/connect */ "../../node_modules/react-redux/es/connect/connect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "connect", function() { return _connect_connect__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hooks/useDispatch */ "../../node_modules/react-redux/es/hooks/useDispatch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useDispatch", function() { return _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__["useDispatch"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createDispatchHook", function() { return _hooks_useDispatch__WEBPACK_IMPORTED_MODULE_4__["createDispatchHook"]; });

/* harmony import */ var _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hooks/useSelector */ "../../node_modules/react-redux/es/hooks/useSelector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useSelector", function() { return _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__["useSelector"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createSelectorHook", function() { return _hooks_useSelector__WEBPACK_IMPORTED_MODULE_5__["createSelectorHook"]; });

/* harmony import */ var _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useStore */ "../../node_modules/react-redux/es/hooks/useStore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "useStore", function() { return _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__["useStore"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createStoreHook", function() { return _hooks_useStore__WEBPACK_IMPORTED_MODULE_6__["createStoreHook"]; });

/* harmony import */ var _utils_batch__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/batch */ "../../node_modules/react-redux/es/utils/batch.js");
/* harmony import */ var _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/reactBatchedUpdates */ "../../node_modules/react-redux/es/utils/reactBatchedUpdates.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "batch", function() { return _utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__["unstable_batchedUpdates"]; });

/* harmony import */ var _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/shallowEqual */ "../../node_modules/react-redux/es/utils/shallowEqual.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowEqual", function() { return _utils_shallowEqual__WEBPACK_IMPORTED_MODULE_9__["default"]; });











Object(_utils_batch__WEBPACK_IMPORTED_MODULE_7__["setBatch"])(_utils_reactBatchedUpdates__WEBPACK_IMPORTED_MODULE_8__["unstable_batchedUpdates"]);


/***/ }),

/***/ "../../node_modules/react-redux/es/utils/Subscription.js":
/*!*******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/Subscription.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Subscription; });
/* harmony import */ var _batch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./batch */ "../../node_modules/react-redux/es/utils/batch.js");
 // encapsulates the subscription logic for connecting a component to the redux store, as
// well as nesting subscriptions of descendant components, so that we can ensure the
// ancestor components re-render before descendants

var nullListeners = {
  notify: function notify() {}
};

function createListenerCollection() {
  var batch = Object(_batch__WEBPACK_IMPORTED_MODULE_0__["getBatch"])();
  var first = null;
  var last = null;
  return {
    clear: function clear() {
      first = null;
      last = null;
    },
    notify: function notify() {
      batch(function () {
        var listener = first;

        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get() {
      var listeners = [];
      var listener = first;

      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }

      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last = {
        callback: callback,
        next: null,
        prev: last
      };

      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }

      return function unsubscribe() {
        if (!isSubscribed || first === null) return;
        isSubscribed = false;

        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }

        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}

var Subscription =
/*#__PURE__*/
function () {
  function Subscription(store, parentSub) {
    this.store = store;
    this.parentSub = parentSub;
    this.unsubscribe = null;
    this.listeners = nullListeners;
    this.handleChangeWrapper = this.handleChangeWrapper.bind(this);
  }

  var _proto = Subscription.prototype;

  _proto.addNestedSub = function addNestedSub(listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
  };

  _proto.notifyNestedSubs = function notifyNestedSubs() {
    this.listeners.notify();
  };

  _proto.handleChangeWrapper = function handleChangeWrapper() {
    if (this.onStateChange) {
      this.onStateChange();
    }
  };

  _proto.isSubscribed = function isSubscribed() {
    return Boolean(this.unsubscribe);
  };

  _proto.trySubscribe = function trySubscribe() {
    if (!this.unsubscribe) {
      this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.handleChangeWrapper) : this.store.subscribe(this.handleChangeWrapper);
      this.listeners = createListenerCollection();
    }
  };

  _proto.tryUnsubscribe = function tryUnsubscribe() {
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
      this.listeners.clear();
      this.listeners = nullListeners;
    }
  };

  return Subscription;
}();



/***/ }),

/***/ "../../node_modules/react-redux/es/utils/batch.js":
/*!************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/batch.js ***!
  \************************************************************************************************************/
/*! exports provided: setBatch, getBatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setBatch", function() { return setBatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBatch", function() { return getBatch; });
// Default to a dummy "batch" implementation that just runs the callback
function defaultNoopBatch(callback) {
  callback();
}

var batch = defaultNoopBatch; // Allow injecting another batching function later

var setBatch = function setBatch(newBatch) {
  return batch = newBatch;
}; // Supply a getter just to skip dealing with ESM bindings

var getBatch = function getBatch() {
  return batch;
};

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/isPlainObject.js":
/*!********************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/isPlainObject.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isPlainObject; });
/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = Object.getPrototypeOf(obj);
  if (proto === null) return true;
  var baseProto = proto;

  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }

  return proto === baseProto;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/reactBatchedUpdates.js":
/*!**************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/reactBatchedUpdates.js ***!
  \**************************************************************************************************************************/
/*! exports provided: unstable_batchedUpdates */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unstable_batchedUpdates", function() { return react_dom__WEBPACK_IMPORTED_MODULE_0__["unstable_batchedUpdates"]; });

/* eslint-disable import/no-unresolved */


/***/ }),

/***/ "../../node_modules/react-redux/es/utils/shallowEqual.js":
/*!*******************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/shallowEqual.js ***!
  \*******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return shallowEqual; });
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function shallowEqual(objA, objB) {
  if (is(objA, objB)) return true;

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) return false;

  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js":
/*!********************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js ***!
  \********************************************************************************************************************************/
/*! exports provided: useIsomorphicLayoutEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useIsomorphicLayoutEffect", function() { return useIsomorphicLayoutEffect; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
 // React currently throws a warning when using useLayoutEffect on the server.
// To get around it, we can conditionally useEffect on the server (no-op) and
// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
// subscription callback always has the selector from the latest render commit
// available, otherwise a store update may happen between render and the effect,
// which may cause missed updates; we also must ensure the store subscription
// is created synchronously, otherwise a store update may occur before the
// subscription is created and an inconsistent state may be observed

var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__["useLayoutEffect"] : react__WEBPACK_IMPORTED_MODULE_0__["useEffect"];

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/verifyPlainObject.js":
/*!************************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/verifyPlainObject.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return verifyPlainObject; });
/* harmony import */ var _isPlainObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isPlainObject */ "../../node_modules/react-redux/es/utils/isPlainObject.js");
/* harmony import */ var _warning__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./warning */ "../../node_modules/react-redux/es/utils/warning.js");


function verifyPlainObject(value, displayName, methodName) {
  if (!Object(_isPlainObject__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    Object(_warning__WEBPACK_IMPORTED_MODULE_1__["default"])(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
  }
}

/***/ }),

/***/ "../../node_modules/react-redux/es/utils/warning.js":
/*!**************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/react-redux/es/utils/warning.js ***!
  \**************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return warning; });
/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
    /* eslint-disable no-empty */
  } catch (e) {}
  /* eslint-enable no-empty */

}

/***/ }),

/***/ "../../node_modules/redux-thunk/es/index.js":
/*!******************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/redux-thunk/es/index.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

/* harmony default export */ __webpack_exports__["default"] = (thunk);

/***/ }),

/***/ "../../node_modules/redux/es/redux.js":
/*!************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/redux/es/redux.js ***!
  \************************************************************************************************/
/*! exports provided: __DO_NOT_USE__ActionTypes, applyMiddleware, bindActionCreators, combineReducers, compose, createStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__DO_NOT_USE__ActionTypes", function() { return ActionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "applyMiddleware", function() { return applyMiddleware; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bindActionCreators", function() { return bindActionCreators; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineReducers", function() { return combineReducers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compose", function() { return compose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStore", function() { return createStore; });
/* harmony import */ var symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! symbol-observable */ "../../node_modules/symbol-observable/es/index.js");


/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[symbol_observable__WEBPACK_IMPORTED_MODULE_0__["default"]] = observable, _ref2;
}

/**
 * Prints a warning in the console if it exists.
 *
 * @param {String} message The warning message.
 * @returns {void}
 */
function warning(message) {
  /* eslint-disable no-console */
  if (typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error(message);
  }
  /* eslint-enable no-console */


  try {
    // This error was thrown as a convenience so that if you enable
    // "break on all exceptions" in your console,
    // it would pause the execution at this line.
    throw new Error(message);
  } catch (e) {} // eslint-disable-line no-empty

}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
  var reducerKeys = Object.keys(reducers);
  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

  if (reducerKeys.length === 0) {
    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
  }

  if (!isPlainObject(inputState)) {
    return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
  }

  var unexpectedKeys = Object.keys(inputState).filter(function (key) {
    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
  });
  unexpectedKeys.forEach(function (key) {
    unexpectedKeyCache[key] = true;
  });
  if (action && action.type === ActionTypes.REPLACE) return;

  if (unexpectedKeys.length > 0) {
    return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
  }
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (true) {
      if (typeof reducers[key] === 'undefined') {
        warning("No reducer provided for key \"" + key + "\"");
      }
    }

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
  // keys multiple times.

  var unexpectedKeyCache;

  if (true) {
    unexpectedKeyCache = {};
  }

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    if (true) {
      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

      if (warningMessage) {
        warning(warningMessage);
      }
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}

/*
 * This is a dummy function to check if the function name has been altered by minification.
 * If the function has been minified and NODE_ENV !== 'production', warn the user.
 */

function isCrushed() {}

if ( true && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
  warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
}




/***/ }),

/***/ "../../node_modules/reselect/es/index.js":
/*!***************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/reselect/es/index.js ***!
  \***************************************************************************************************/
/*! exports provided: defaultMemoize, createSelectorCreator, createSelector, createStructuredSelector */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultMemoize", function() { return defaultMemoize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelectorCreator", function() { return createSelectorCreator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createSelector", function() { return createSelector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createStructuredSelector", function() { return createStructuredSelector; });
function defaultEqualityCheck(a, b) {
  return a === b;
}

function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep;
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = memoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.dependencies = dependencies;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var createSelector = createSelectorCreator(defaultMemoize);

function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}

/***/ }),

/***/ "../../node_modules/resolve-pathname/index.js":
/*!********************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/resolve-pathname/index.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function isAbsolute(pathname) {
  return pathname.charAt(0) === '/';
}

// About 1.5x faster than the two-arg version of Array#splice()
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) {
    list[i] = list[k];
  }

  list.pop();
}

// This implementation is based heavily on node's url.parse
function resolvePathname(to) {
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  var toParts = to && to.split('/') || [];
  var fromParts = from && from.split('/') || [];

  var isToAbs = to && isAbsolute(to);
  var isFromAbs = from && isAbsolute(from);
  var mustEndAbs = isToAbs || isFromAbs;

  if (to && isAbsolute(to)) {
    // to is absolute
    fromParts = toParts;
  } else if (toParts.length) {
    // to is relative, drop the filename
    fromParts.pop();
    fromParts = fromParts.concat(toParts);
  }

  if (!fromParts.length) return '/';

  var hasTrailingSlash = void 0;
  if (fromParts.length) {
    var last = fromParts[fromParts.length - 1];
    hasTrailingSlash = last === '.' || last === '..' || last === '';
  } else {
    hasTrailingSlash = false;
  }

  var up = 0;
  for (var i = fromParts.length; i >= 0; i--) {
    var part = fromParts[i];

    if (part === '.') {
      spliceOne(fromParts, i);
    } else if (part === '..') {
      spliceOne(fromParts, i);
      up++;
    } else if (up) {
      spliceOne(fromParts, i);
      up--;
    }
  }

  if (!mustEndAbs) for (; up--; up) {
    fromParts.unshift('..');
  }if (mustEndAbs && fromParts[0] !== '' && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift('');

  var result = fromParts.join('/');

  if (hasTrailingSlash && result.substr(-1) !== '/') result += '/';

  return result;
}

/* harmony default export */ __webpack_exports__["default"] = (resolvePathname);

/***/ }),

/***/ "../../node_modules/symbol-observable/es/index.js":
/*!************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/symbol-observable/es/index.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ponyfill.js */ "../../node_modules/symbol-observable/es/ponyfill.js");
/* global window */


var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (true) {
  root = module;
} else {}

var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__["default"])(root);
/* harmony default export */ __webpack_exports__["default"] = (result);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../webpack/buildin/harmony-module.js */ "../../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../../node_modules/symbol-observable/es/ponyfill.js":
/*!***************************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/symbol-observable/es/ponyfill.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return symbolObservablePonyfill; });
function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};


/***/ }),

/***/ "../../node_modules/value-equal/index.js":
/*!***************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/value-equal/index.js ***!
  \***************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function valueEqual(a, b) {
  if (a === b) return true;

  if (a == null || b == null) return false;

  if (Array.isArray(a)) {
    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
      return valueEqual(item, b[index]);
    });
  }

  var aType = typeof a === 'undefined' ? 'undefined' : _typeof(a);
  var bType = typeof b === 'undefined' ? 'undefined' : _typeof(b);

  if (aType !== bType) return false;

  if (aType === 'object') {
    var aValue = a.valueOf();
    var bValue = b.valueOf();

    if (aValue !== a || bValue !== b) return valueEqual(aValue, bValue);

    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);

    if (aKeys.length !== bKeys.length) return false;

    return aKeys.every(function (key) {
      return valueEqual(a[key], b[key]);
    });
  }

  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (valueEqual);

/***/ }),

/***/ "../../node_modules/warning/browser.js":
/*!*************************************************************************************************!*\
  !*** C:/Projects/SystemCenter/Source/Applications/SystemCenter/node_modules/warning/browser.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */



/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (true) {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./TSX/SystemCenter/Company/CompanyTypeSlice.ts":
/*!******************************************************!*\
  !*** ./TSX/SystemCenter/Company/CompanyTypeSlice.ts ***!
  \******************************************************/
/*! exports provided: FetchCompanyTypes, CompanyTypeSlice, _b, default, SelectCompanyTypes, SelectCompanyTypesStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchCompanyTypes", function() { return FetchCompanyTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompanyTypeSlice", function() { return CompanyTypeSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectCompanyTypes", function() { return SelectCompanyTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectCompanyTypesStatus", function() { return SelectCompanyTypesStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  CompanyTypeSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var _a;

var FetchCompanyTypes = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Companys/FetchCompanyTypes', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetCompanyTypes()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var CompanyTypeSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'CompanyType',
    initialState: {
        Status: 'unintiated',
        CompanyType: [],
        Error: null
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchCompanyTypes.fulfilled, function (state, action) {
            var _a;
            state.Status = 'idle';
            state.Error = null;
            (_a = state.CompanyType).push.apply(_a, __spread(action.payload));
            FetchCompanyTypes();
        });
        builder.addCase(FetchCompanyTypes.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchCompanyTypes.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = CompanyTypeSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (CompanyTypeSlice.reducer);
var SelectCompanyTypes = function (state) { return state.CompanyType.CompanyType; };
var SelectCompanyTypesStatus = function (state) { return state.CompanyType.Status; };
function GetCompanyTypes() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/SystemCenter/CompanyType",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/AssetConnectionTypeSlice.ts":
/*!************************************************************!*\
  !*** ./TSX/SystemCenter/Store/AssetConnectionTypeSlice.ts ***!
  \************************************************************/
/*! exports provided: FetchAssetConnectionType, AssetConnectionTypeSlice, _b, default, SelectAssetConnectionTypes, SelectAssetConnectionTypeStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchAssetConnectionType", function() { return FetchAssetConnectionType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetConnectionTypeSlice", function() { return AssetConnectionTypeSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetConnectionTypes", function() { return SelectAssetConnectionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetConnectionTypeStatus", function() { return SelectAssetConnectionTypeStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  AssetConnectionTypeSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchAssetConnectionType = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('AssetConnectionType/FetchAssetConnectionType', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetAssetConnectionType()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var AssetConnectionTypeSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'AssetConnectionType',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchAssetConnectionType.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchAssetConnectionType.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchAssetConnectionType.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = AssetConnectionTypeSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (AssetConnectionTypeSlice.reducer);
var SelectAssetConnectionTypes = function (state) { return state.AssetConnectionType.Data; };
var SelectAssetConnectionTypeStatus = function (state) { return state.AssetConnectionType.Status; };
function GetAssetConnectionType() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/AssetConnectionType",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/AssetSlice.ts":
/*!**********************************************!*\
  !*** ./TSX/SystemCenter/Store/AssetSlice.ts ***!
  \**********************************************/
/*! exports provided: FetchAsset, AssetSlice, _b, default, SelectAssets, SelectAssetStatus, SelectAssetKeysLowerCase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchAsset", function() { return FetchAsset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetSlice", function() { return AssetSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssets", function() { return SelectAssets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetStatus", function() { return SelectAssetStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetKeysLowerCase", function() { return SelectAssetKeysLowerCase; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  AssetSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchAsset = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Asset/FetchAsset', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetAsset()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var AssetSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'Asset',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchAsset.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchAsset.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchAsset.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = AssetSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (AssetSlice.reducer);
var SelectAssets = function (state) { return state.Asset.Data; };
var SelectAssetStatus = function (state) { return state.Asset.Status; };
var SelectAssetKeysLowerCase = function (state) { return state.Asset.Data.map(function (a) { return a.AssetKey.toLowerCase(); }); };
function GetAsset() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/Asset",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/AssetTypeSlice.ts":
/*!**************************************************!*\
  !*** ./TSX/SystemCenter/Store/AssetTypeSlice.ts ***!
  \**************************************************/
/*! exports provided: FetchAssetType, AssetTypeSlice, _b, default, SelectAssetTypes, SelectAssetTypeStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchAssetType", function() { return FetchAssetType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AssetTypeSlice", function() { return AssetTypeSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetTypes", function() { return SelectAssetTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectAssetTypeStatus", function() { return SelectAssetTypeStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  AssetTypeSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchAssetType = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('AssetType/FetchAssetType', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetAssetType()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var AssetTypeSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'AssetType',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchAssetType.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchAssetType.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchAssetType.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = AssetTypeSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (AssetTypeSlice.reducer);
var SelectAssetTypes = function (state) { return state.AssetType.Data; };
var SelectAssetTypeStatus = function (state) { return state.AssetType.Status; };
function GetAssetType() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/AssetType",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/LocationSlice.ts":
/*!*************************************************!*\
  !*** ./TSX/SystemCenter/Store/LocationSlice.ts ***!
  \*************************************************/
/*! exports provided: FetchLocation, LocationSlice, _b, default, SelectLocations, SelectLocationStatus, SelectLocationKeysLowerCase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchLocation", function() { return FetchLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LocationSlice", function() { return LocationSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectLocations", function() { return SelectLocations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectLocationStatus", function() { return SelectLocationStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectLocationKeysLowerCase", function() { return SelectLocationKeysLowerCase; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  LocationSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchLocation = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Location/FetchLocation', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetLocation()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var LocationSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'Location',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchLocation.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchLocation.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchLocation.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = LocationSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (LocationSlice.reducer);
var SelectLocations = function (state) { return state.Location.Data; };
var SelectLocationStatus = function (state) { return state.Location.Status; };
var SelectLocationKeysLowerCase = function (state) { return state.Location.Data.map(function (a) { return a.LocationKey.toLowerCase(); }); };
function GetLocation() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/Location",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/MeasurementTypeSlice.ts":
/*!********************************************************!*\
  !*** ./TSX/SystemCenter/Store/MeasurementTypeSlice.ts ***!
  \********************************************************/
/*! exports provided: FetchMeasurementType, MeasurementTypeSlice, _b, default, SelectMeasurementTypes, SelectMeasurementTypeStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchMeasurementType", function() { return FetchMeasurementType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeasurementTypeSlice", function() { return MeasurementTypeSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectMeasurementTypes", function() { return SelectMeasurementTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectMeasurementTypeStatus", function() { return SelectMeasurementTypeStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  MeasurementTypeSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchMeasurementType = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('MeasurementType/FetchMeasurementType', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetMeasurementType()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var MeasurementTypeSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'MeasurementType',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchMeasurementType.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchMeasurementType.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchMeasurementType.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = MeasurementTypeSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (MeasurementTypeSlice.reducer);
var SelectMeasurementTypes = function (state) { return state.MeasurementType.Data; };
var SelectMeasurementTypeStatus = function (state) { return state.MeasurementType.Status; };
function GetMeasurementType() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/MeasurementType",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/MeterSlice.ts":
/*!**********************************************!*\
  !*** ./TSX/SystemCenter/Store/MeterSlice.ts ***!
  \**********************************************/
/*! exports provided: FetchMeter, MeterSlice, _b, default, SelectMeters, SelectMeterStatus, SelectMeterKeysLowerCase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchMeter", function() { return FetchMeter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeterSlice", function() { return MeterSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectMeters", function() { return SelectMeters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectMeterStatus", function() { return SelectMeterStatus; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectMeterKeysLowerCase", function() { return SelectMeterKeysLowerCase; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  MeterSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchMeter = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Meter/FetchMeter', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetMeter()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var MeterSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'Meter',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchMeter.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchMeter.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchMeter.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = MeterSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (MeterSlice.reducer);
var SelectMeters = function (state) { return state.Meter.Data; };
var SelectMeterStatus = function (state) { return state.Meter.Status; };
var SelectMeterKeysLowerCase = function (state) { return state.Meter.Data.map(function (a) { return a.AssetKey.toLowerCase(); }); };
function GetMeter() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/Meter",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/PhaseSlice.ts":
/*!**********************************************!*\
  !*** ./TSX/SystemCenter/Store/PhaseSlice.ts ***!
  \**********************************************/
/*! exports provided: FetchPhase, PhaseSlice, _b, default, SelectPhases, SelectPhaseStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchPhase", function() { return FetchPhase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PhaseSlice", function() { return PhaseSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectPhases", function() { return SelectPhases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectPhaseStatus", function() { return SelectPhaseStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  PhaseSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchPhase = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('Phase/FetchPhase', function (_, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetPhase()];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var PhaseSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'Phase',
    initialState: {
        Status: 'unintiated',
        Error: null,
        Data: []
    },
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchPhase.fulfilled, function (state, action) {
            state.Status = 'idle';
            state.Error = null;
            state.Data = action.payload; //.sort((a, b) => a.Name - b.Name);
        });
        builder.addCase(FetchPhase.pending, function (state, action) {
            state.Status = 'loading';
        });
        builder.addCase(FetchPhase.rejected, function (state, action) {
            state.Status = 'error';
            state.Error = action.error.message;
        });
    }
});
var _b = _a = PhaseSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (PhaseSlice.reducer);
var SelectPhases = function (state) { return state.Phase.Data; };
var SelectPhaseStatus = function (state) { return state.Phase.Status; };
function GetPhase() {
    return $.ajax({
        type: "GET",
        url: homePath + "api/OpenXDA/Phase",
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/Store/Store.ts":
/*!*****************************************!*\
  !*** ./TSX/SystemCenter/Store/Store.ts ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
/* harmony import */ var _Company_CompanyTypeSlice__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Company/CompanyTypeSlice */ "./TSX/SystemCenter/Company/CompanyTypeSlice.ts");
/* harmony import */ var _ValueListSlice__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ValueListSlice */ "./TSX/SystemCenter/Store/ValueListSlice.ts");
/* harmony import */ var _MeasurementTypeSlice__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MeasurementTypeSlice */ "./TSX/SystemCenter/Store/MeasurementTypeSlice.ts");
/* harmony import */ var _PhaseSlice__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PhaseSlice */ "./TSX/SystemCenter/Store/PhaseSlice.ts");
/* harmony import */ var _AssetTypeSlice__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AssetTypeSlice */ "./TSX/SystemCenter/Store/AssetTypeSlice.ts");
/* harmony import */ var _AssetConnectionTypeSlice__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AssetConnectionTypeSlice */ "./TSX/SystemCenter/Store/AssetConnectionTypeSlice.ts");
/* harmony import */ var _MeterSlice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MeterSlice */ "./TSX/SystemCenter/Store/MeterSlice.ts");
/* harmony import */ var _LocationSlice__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./LocationSlice */ "./TSX/SystemCenter/Store/LocationSlice.ts");
/* harmony import */ var _AssetSlice__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./AssetSlice */ "./TSX/SystemCenter/Store/AssetSlice.ts");
//******************************************************************************************************
//  Store.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  10/20/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************










/* harmony default export */ __webpack_exports__["default"] = (Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["configureStore"])({
    reducer: {
        CompanyType: _Company_CompanyTypeSlice__WEBPACK_IMPORTED_MODULE_1__["default"],
        ValueList: _ValueListSlice__WEBPACK_IMPORTED_MODULE_2__["default"],
        MeasurementType: _MeasurementTypeSlice__WEBPACK_IMPORTED_MODULE_3__["default"],
        Phase: _PhaseSlice__WEBPACK_IMPORTED_MODULE_4__["default"],
        AssetType: _AssetTypeSlice__WEBPACK_IMPORTED_MODULE_5__["default"],
        AssetConnectionType: _AssetConnectionTypeSlice__WEBPACK_IMPORTED_MODULE_6__["default"],
        Meter: _MeterSlice__WEBPACK_IMPORTED_MODULE_7__["default"],
        Asset: _AssetSlice__WEBPACK_IMPORTED_MODULE_9__["default"],
        Location: _LocationSlice__WEBPACK_IMPORTED_MODULE_8__["default"],
    }
}));


/***/ }),

/***/ "./TSX/SystemCenter/Store/ValueListSlice.ts":
/*!**************************************************!*\
  !*** ./TSX/SystemCenter/Store/ValueListSlice.ts ***!
  \**************************************************/
/*! exports provided: FetchValueList, ValueListSlice, _b, default, SelectValueList, SelectValueListStatus */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FetchValueList", function() { return FetchValueList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ValueListSlice", function() { return ValueListSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_b", function() { return _b; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectValueList", function() { return SelectValueList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectValueListStatus", function() { return SelectValueListStatus; });
/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @reduxjs/toolkit */ "../../node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js");
//******************************************************************************************************
//  ValueListSlice.ts - Gbtc
//
//  Copyright © 2020, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  11/04/2020 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _a;

var FetchValueList = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createAsyncThunk"])('ValueList/FetchValueList', function (vl, _a) {
    var dispatch = _a.dispatch;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0: return [4 /*yield*/, GetValueList(vl.group)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    });
});
var ValueListSlice = Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_0__["createSlice"])({
    name: 'ValueList',
    initialState: {},
    reducers: {},
    extraReducers: function (builder) {
        builder.addCase(FetchValueList.fulfilled, function (state, action) {
            if (state[action.meta.arg.group] === undefined) {
                state[action.meta.arg.group] = {
                    Status: 'unitiated',
                    Data: [],
                    Error: null
                };
            }
            state[action.meta.arg.group].Status = 'idle';
            state[action.meta.arg.group].Error = null;
            state[action.meta.arg.group].Data = action.payload.sort(function (a, b) { return a.SortOrder - b.SortOrder; });
        });
        builder.addCase(FetchValueList.pending, function (state, action) {
            if (state[action.meta.arg.group] === undefined) {
                state[action.meta.arg.group] = {
                    Status: 'unitiated',
                    Data: [],
                    Error: null
                };
            }
            state[action.meta.arg.group].Status = 'loading';
        });
        builder.addCase(FetchValueList.rejected, function (state, action) {
            if (state[action.meta.arg.group] === undefined) {
                state[action.meta.arg.group] = {
                    Status: 'unitiated',
                    Data: [],
                    Error: null
                };
            }
            state[action.meta.arg.group].Status = 'error';
            state[action.meta.arg.group].Error = action.error.message;
        });
    }
});
var _b = _a = ValueListSlice.actions;
/* harmony default export */ __webpack_exports__["default"] = (ValueListSlice.reducer);
var SelectValueList = function (state, group) { return state.ValueList[group] !== undefined ? state.ValueList[group].Data : []; };
var SelectValueListStatus = function (state, group) { return state.ValueList[group] !== undefined ? state.ValueList[group].Status : 'unintiated'; };
function GetValueList(group) {
    return $.ajax({
        type: "GET",
        url: homePath + "api/ValueList/Group/" + group,
        contentType: "application/json; charset=utf-8",
        dataType: 'json',
        cache: true,
        async: true
    });
}


/***/ }),

/***/ "./TSX/SystemCenter/SystemCenter.tsx":
/*!*******************************************!*\
  !*** ./TSX/SystemCenter/SystemCenter.tsx ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "react-dom");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-router-dom */ "react-router-dom");
/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_router_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! querystring */ "../../node_modules/querystring-es3/index.js");
/* harmony import */ var querystring__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(querystring__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var history__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! history */ "../../node_modules/history/es/index.js");
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-redux */ "../../node_modules/react-redux/es/index.js");
/* harmony import */ var _Store_Store__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Store/Store */ "./TSX/SystemCenter/Store/Store.ts");
//******************************************************************************************************
//  SystemCenter.tsx - Gbtc
//
//  Copyright © 2019, Grid Protection Alliance.  All Rights Reserved.
//
//  Licensed to the Grid Protection Alliance (GPA) under one or more contributor license agreements. See
//  the NOTICE file distributed with this work for additional information regarding copyright ownership.
//  The GPA licenses this file to you under the MIT License (MIT), the "License"; you may not use this
//  file except in compliance with the License. You may obtain a copy of the License at:
//
//      http://opensource.org/licenses/MIT
//
//  Unless agreed to in writing, the subject software distributed under the License is distributed on an
//  "AS-IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. Refer to the
//  License for the specific language governing permissions and limitations.
//
//  Code Modification History:
//  ----------------------------------------------------------------------------------------------------
//  08/22/2019 - Billy Ernest
//       Generated original version of source code.
//
//******************************************************************************************************
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};







var SystemCenter = function (props) {
    var history = Object(history__WEBPACK_IMPORTED_MODULE_4__["createBrowserHistory"])();
    var ByMeter = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByMeter */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByMeter")]).then(__webpack_require__.bind(null, /*! ./Meter/ByMeter */ "./TSX/SystemCenter/Meter/ByMeter.tsx")); });
    var ByLocation = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByLocation */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("ByLocation")]).then(__webpack_require__.bind(null, /*! ./Location/ByLocation */ "./TSX/SystemCenter/Location/ByLocation.tsx")); });
    var ByAsset = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByAsset */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset"), __webpack_require__.e("ByAsset")]).then(__webpack_require__.bind(null, /*! ./Asset/ByAsset */ "./TSX/SystemCenter/Asset/ByAsset.tsx")); });
    var ByCustomer = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByCustomer */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByCustomer")]).then(__webpack_require__.bind(null, /*! ./Customer/ByCustomer */ "./TSX/SystemCenter/Customer/ByCustomer.tsx")); });
    var ByUser = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByUser */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByUser~User"), __webpack_require__.e("ByUser")]).then(__webpack_require__.bind(null, /*! ./User/ByUser */ "./TSX/SystemCenter/User/ByUser.tsx")); });
    var UserStatistics = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | UserStatistics */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("UserStatistics")]).then(__webpack_require__.bind(null, /*! ./UserStatistics/UserStatistics */ "./TSX/SystemCenter/UserStatistics/UserStatistics.tsx")); });
    var Customer = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Customer */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Customer")]).then(__webpack_require__.bind(null, /*! ./Customer/Customer */ "./TSX/SystemCenter/Customer/Customer.tsx")); });
    var User = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | User */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ByUser~User"), __webpack_require__.e("User")]).then(__webpack_require__.bind(null, /*! ./User/User */ "./TSX/SystemCenter/User/User.tsx")); });
    var Asset = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Asset */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Asset~ByAsset"), __webpack_require__.e("Asset")]).then(__webpack_require__.bind(null, /*! ./Asset/Asset */ "./TSX/SystemCenter/Asset/Asset.tsx")); });
    var NewMeterWizard = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | NewMeterWizard */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("NewMeterWizard")]).then(__webpack_require__.bind(null, /*! ./NewMeterWizard/NewMeterWizard */ "./TSX/SystemCenter/NewMeterWizard/NewMeterWizard.tsx")); });
    var ConfigurationHistory = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ConfigurationHistory */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("ConfigurationHistory")]).then(__webpack_require__.bind(null, /*! ./ConfigurationHistory/ConfigurationHistory */ "./TSX/SystemCenter/ConfigurationHistory/ConfigurationHistory.tsx")); });
    var Meter = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Meter */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Meter")]).then(__webpack_require__.bind(null, /*! ./Meter/Meter */ "./TSX/SystemCenter/Meter/Meter.tsx")); });
    var Location = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Location */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~ByAsset~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Location")]).then(__webpack_require__.bind(null, /*! ./Location/Location */ "./TSX/SystemCenter/Location/Location.tsx")); });
    var ByAssetGroup = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByAssetGroup */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("AssetGroup~ByAssetGroup"), __webpack_require__.e("ByAssetGroup")]).then(__webpack_require__.bind(null, /*! ./AssetGroups/ByAssetGroup */ "./TSX/SystemCenter/AssetGroups/ByAssetGroup.tsx")); });
    var AssetGroup = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | AssetGroup */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("AssetGroup~ByAssetGroup"), __webpack_require__.e("AssetGroup")]).then(__webpack_require__.bind(null, /*! ./AssetGroups/AssetGroup */ "./TSX/SystemCenter/AssetGroups/AssetGroup.tsx")); });
    var ByCompany = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | ByCompany */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("vendors~ByCompany~Company"), __webpack_require__.e("ByCompany")]).then(__webpack_require__.bind(null, /*! ./Company/ByCompany */ "./TSX/SystemCenter/Company/ByCompany.tsx")); });
    var Company = react__WEBPACK_IMPORTED_MODULE_0__["lazy"](function () { return Promise.all(/*! import() | Company */[__webpack_require__.e("vendors~Asset~AssetGroup~ByAsset~ByAssetGroup~ByCompany~ByCustomer~ByLocation~ByMeter~ByUser~Company~159a7171"), __webpack_require__.e("vendors~ByCompany~Company"), __webpack_require__.e("Asset~ByAsset~ByLocation~Company~Customer~Location~Meter~NewMeterWizard"), __webpack_require__.e("Asset~Company~Customer~Location~Meter"), __webpack_require__.e("Company")]).then(__webpack_require__.bind(null, /*! ./Company/Company */ "./TSX/SystemCenter/Company/Company.tsx")); });
    var _a = __read(react__WEBPACK_IMPORTED_MODULE_0__["useState"]([]), 2), roles = _a[0], setRoles = _a[1];
    var _b = __read(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"](function (x) { return x + 1; }, 0), 2), ignored = _b[0], forceUpdate = _b[1]; // integer state for resize renders
    react__WEBPACK_IMPORTED_MODULE_0__["useEffect"](function () {
        var handle = getRoles();
        handle.done(function (rs) { return setRoles(rs); });
        window.addEventListener('resize', function (evt) { return forceUpdate(1); });
        return function cleanup() {
            if (handle.abort != null)
                handle.abort();
            window.removeEventListener('resize', function (evt) { });
        };
    }, []);
    function getRoles() {
        return $.ajax({
            type: "GET",
            url: homePath + "api/SystemCenter/SecurityRoles",
            contentType: "application/json; charset=utf-8",
            dataType: 'json',
            cache: false,
            async: true
        });
    }
    if (Object.keys(querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(history.location.search)).length == 0)
        history.push({ pathname: homePath + 'index.cshtml', search: 'name=Meters', state: {} });
    return (react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["BrowserRouter"], null,
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "navbar navbar-dark fixed-top bg-dark flex-md-nowrap p-0 shadow", style: { height: 75 } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { className: "col-sm-3 col-md-2 mr-0", style: { textAlign: 'center' }, href: "https://www.gridprotectionalliance.org" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("img", { style: { width: '100%', margin: -5 }, src: "../Images/SystemCenter-TopLeft.png" })),
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { className: "navbar-nav px-3" },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item text-nowrap" },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("a", { className: "nav-link", href: "#" }, "Sign out")))),
        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "container-fluid", style: { top: 75, position: 'absolute', width: '100%', height: 'calc(100% - 75px)', overflow: 'hidden' } },
            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "row", style: { height: '100%' } },
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("nav", { className: "col bg-light sidebar", style: { maxWidth: 250 } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "sidebar-sticky" },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', marginTop: 5, textAlign: 'center' } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h3", null, "System Center")),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading" }, "Monitors and Assets"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column" },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Meters"; }, to: controllerViewPath + "?name=Meters" }, "Meters")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Locations"; }, to: controllerViewPath + "?name=Locations" }, "Substations")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Assets"; }, to: controllerViewPath + "?name=Assets" }, "Transmission Assets")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=AssetGroups"; }, to: controllerViewPath + "?name=AssetGroups" }, "Asset Groups"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading" }, "External Links"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column" },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Companies"; }, to: controllerViewPath + "?name=Companies" }, "Companies")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=PQViewCustomers"; }, to: controllerViewPath + "?name=PQViewCustomers" }, "PQView Customer Access")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=PQViewSites"; }, to: controllerViewPath + "?name=PQViewSites" }, "PQView Sites"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading", hidden: roles.indexOf('Administrator') < 0 }, "System Settings"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column", hidden: roles.indexOf('Administrator') < 0 },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=ValueLists"; }, to: controllerViewPath + "?name=ValueLists" }, "Value Lists"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("hr", null),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("h6", { style: { fontWeight: 'bold', marginLeft: 10 }, className: "sidebar-heading", hidden: roles.indexOf('Administrator') < 0 }, "User Settings"),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("ul", { style: { marginLeft: 10 }, className: "nav flex-column", hidden: roles.indexOf('Administrator') < 0 },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=UserStatistics"; }, to: controllerViewPath + "?name=UserStatistics" }, "User Statistics")),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("li", { className: "nav-item" },
                                react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["NavLink"], { activeClassName: 'nav-link active', className: "nav-link", isActive: function (match, location) { return location.pathname + location.search == controllerViewPath + "?name=Users"; }, to: controllerViewPath + "?name=Users" }, "Users"))),
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { style: { width: '100%', textAlign: 'center', position: 'absolute', bottom: 50 } },
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null,
                                "Version ",
                                version),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("br", null),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", null)))),
                react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", { className: "col", style: { width: '100%', height: 'inherit', padding: '0 0 0 0', overflow: 'hidden' } },
                    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react__WEBPACK_IMPORTED_MODULE_0__["Suspense"], { fallback: react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", null, "Loading...") },
                        react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Switch"], null,
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    var qs = querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search);
                                    if (qs['?name'] == undefined || qs['?name'] == "Meters") {
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByMeter, { Roles: roles });
                                    }
                                    else if (qs['?name'] == "Locations") {
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByLocation, { Roles: roles });
                                    }
                                    else if (qs['?name'] == "Assets")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByAsset, { Roles: roles });
                                    else if (qs['?name'] == "AssetGroups")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByAssetGroup, { Roles: roles });
                                    else if (qs['?name'] == "Users")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByUser, { Roles: roles });
                                    else if (qs['?name'] == "Companies")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByCompany, { Roles: roles });
                                    else if (qs['?name'] == "User")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](User, { UserID: qs.UserAccountID });
                                    else if (qs['?name'] == "UserStatistics")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](UserStatistics, { Roles: roles });
                                    else if (qs['?name'] == "Meter")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Meter, { MeterID: parseInt(qs.MeterID) });
                                    else if (qs['?name'] == "Location")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Location, { LocationID: parseInt(qs.LocationID) });
                                    else if (qs['?name'] == "Asset")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Asset, { AssetID: parseInt(qs.AssetID) });
                                    else if (qs['?name'] == "AssetGroup")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](AssetGroup, { AssetGroupID: parseInt(qs.AssetGroupID) });
                                    else if (qs['?name'] == "Customer")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Customer, { CustomerID: parseInt(qs.CustomerID) });
                                    else if (qs['?name'] == "Company")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Company, { CompanyID: parseInt(qs.CompanyID) });
                                    else if (qs['?name'] == "PQViewSites")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("iframe", { style: { width: '100%', height: '100%' }, src: homePath + 'PQViewDataLoader.cshtml' });
                                    else if (qs['?name'] == "PQViewCustomers")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ByCustomer, { Roles: roles });
                                    else if (qs['?name'] == "NewMeterWizard")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](NewMeterWizard, null);
                                    else
                                        return null;
                                } }),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    if (roles.indexOf('Administrator') < 0)
                                        return null;
                                    else if (querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search)['?name'] == "ValueLists")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("iframe", { style: { width: '100%', height: '100%' }, src: homePath + 'ValueListGroups.cshtml' });
                                    else
                                        return null;
                                } }),
                            react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_2__["Route"], { children: function (_a) {
                                    var match = _a.match, rest = __rest(_a, ["match"]);
                                    if (roles.indexOf('Administrator') < 0 && roles.indexOf('Transmission SME') < 0)
                                        return null;
                                    else if (querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search)['?name'] == "ConfigurationHistory")
                                        return react__WEBPACK_IMPORTED_MODULE_0__["createElement"](ConfigurationHistory, { MeterConfigurationID: parseInt(querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search).MeterConfigurationID), MeterKey: querystring__WEBPACK_IMPORTED_MODULE_3___default.a.parse(rest.location.search).MeterKey });
                                    else
                                        return null;
                                } }))))))));
};
react_dom__WEBPACK_IMPORTED_MODULE_1__["render"](react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_redux__WEBPACK_IMPORTED_MODULE_5__["Provider"], { store: _Store_Store__WEBPACK_IMPORTED_MODULE_6__["default"] },
    react__WEBPACK_IMPORTED_MODULE_0__["createElement"](SystemCenter, null)), document.getElementById('window'));


/***/ }),

/***/ "d3":
/*!*********************!*\
  !*** external "d3" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = d3;

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "React" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = React;

/***/ }),

/***/ "react-dom":
/*!***************************!*\
  !*** external "ReactDOM" ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactDOM;

/***/ }),

/***/ "react-router-dom":
/*!*********************************!*\
  !*** external "ReactRouterDOM" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = ReactRouterDOM;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uLi9zcmMvZGV2dG9vbHNFeHRlbnNpb24udHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pc1BsYWluT2JqZWN0LnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9nZXREZWZhdWx0TWlkZGxld2FyZS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvbmZpZ3VyZVN0b3JlLnRzIiwid2VicGFjazovLy8uLi9zcmMvY3JlYXRlQWN0aW9uLnRzIiwid2VicGFjazovLy8uLi9zcmMvbWFwQnVpbGRlcnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jcmVhdGVSZWR1Y2VyLnRzIiwid2VicGFjazovLy8uLi9zcmMvY3JlYXRlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9lbnRpdHlfc3RhdGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9zdGF0ZV9zZWxlY3RvcnMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9zdGF0ZV9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvZW50aXRpZXMvdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy91bnNvcnRlZF9zdGF0ZV9hZGFwdGVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvZW50aXRpZXMvc29ydGVkX3N0YXRlX2FkYXB0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9lbnRpdGllcy9jcmVhdGVfYWRhcHRlci50cyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLXBsdWdpbi10cmFuc2Zvcm0tYXN5bmMtdG8tcHJvbWlzZXMvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL25hbm9pZC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NyZWF0ZUFzeW5jVGh1bmsudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9pbmRleC50cyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvTG9jYXRpb25VdGlscy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL1BhdGhVdGlscy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9oaXN0b3J5L2VzL2NyZWF0ZUJyb3dzZXJIaXN0b3J5LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlSGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9jcmVhdGVNZW1vcnlIaXN0b3J5LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2hpc3RvcnkvZXMvY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvaGlzdG9yeS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyIsIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2Vycm9ycy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3V0aWxzL2NvbW1vbi50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3R5cGVzL3R5cGVzLWludGVybmFsLnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMvcGx1Z2lucy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvc2NvcGUudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9jb3JlL2ZpbmFsaXplLnRzIiwid2VicGFjazovLy8uLi9zcmMvY29yZS9wcm94eS50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvaW1tZXJDbGFzcy50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2NvcmUvY3VycmVudC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL3BsdWdpbnMvZXM1LnRzIiwid2VicGFjazovLy8uLi9zcmMvcGx1Z2lucy9wYXRjaGVzLnRzIiwid2VicGFjazovLy8uLi9zcmMvcGx1Z2lucy9tYXBzZXQudHMiLCJ3ZWJwYWNrOi8vLy4uL3NyYy9wbHVnaW5zL2FsbC50cyIsIndlYnBhY2s6Ly8vLi4vc3JjL2ltbWVyLnRzIiwid2VicGFjazovLy8uLi9zcmMvdXRpbHMvZW52LnRzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL2ludmFyaWFudC9icm93c2VyLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9Db250ZXh0LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2NvbXBvbmVudHMvUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29tcG9uZW50cy9jb25uZWN0QWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvY29ubmVjdC9jb25uZWN0LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwRGlzcGF0Y2hUb1Byb3BzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWFwU3RhdGVUb1Byb3BzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2Nvbm5lY3QvbWVyZ2VQcm9wcy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3NlbGVjdG9yRmFjdG9yeS5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3ZlcmlmeVN1YnNlbGVjdG9ycy5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9jb25uZWN0L3dyYXBNYXBUb1Byb3BzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2hvb2tzL3VzZURpc3BhdGNoLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL2hvb2tzL3VzZVJlZHV4Q29udGV4dC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9ob29rcy91c2VTdG9yZS5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvYmF0Y2guanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVhY3QtcmVkdXgvZXMvdXRpbHMvaXNQbGFpbk9iamVjdC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzLmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3NoYWxsb3dFcXVhbC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9yZWFjdC1yZWR1eC9lcy91dGlscy91c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3ZlcmlmeVBsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy9DOi9Qcm9qZWN0cy9TeXN0ZW1DZW50ZXIvU291cmNlL0FwcGxpY2F0aW9ucy9TeXN0ZW1DZW50ZXIvbm9kZV9tb2R1bGVzL3JlYWN0LXJlZHV4L2VzL3V0aWxzL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVkdXgtdGh1bmsvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVkdXgvZXMvcmVkdXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVzZWxlY3QvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL0M6L1Byb2plY3RzL1N5c3RlbUNlbnRlci9Tb3VyY2UvQXBwbGljYXRpb25zL1N5c3RlbUNlbnRlci9ub2RlX21vZHVsZXMvcmVzb2x2ZS1wYXRobmFtZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy9zeW1ib2wtb2JzZXJ2YWJsZS9lcy9wb255ZmlsbC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy92YWx1ZS1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vQzovUHJvamVjdHMvU3lzdGVtQ2VudGVyL1NvdXJjZS9BcHBsaWNhdGlvbnMvU3lzdGVtQ2VudGVyL25vZGVfbW9kdWxlcy93YXJuaW5nL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9Db21wYW55L0NvbXBhbnlUeXBlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TdG9yZS9Bc3NldENvbm5lY3Rpb25UeXBlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TdG9yZS9Bc3NldFNsaWNlLnRzIiwid2VicGFjazovLy8uL1RTWC9TeXN0ZW1DZW50ZXIvU3RvcmUvQXNzZXRUeXBlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TdG9yZS9Mb2NhdGlvblNsaWNlLnRzIiwid2VicGFjazovLy8uL1RTWC9TeXN0ZW1DZW50ZXIvU3RvcmUvTWVhc3VyZW1lbnRUeXBlU2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TdG9yZS9NZXRlclNsaWNlLnRzIiwid2VicGFjazovLy8uL1RTWC9TeXN0ZW1DZW50ZXIvU3RvcmUvUGhhc2VTbGljZS50cyIsIndlYnBhY2s6Ly8vLi9UU1gvU3lzdGVtQ2VudGVyL1N0b3JlL1N0b3JlLnRzIiwid2VicGFjazovLy8uL1RTWC9TeXN0ZW1DZW50ZXIvU3RvcmUvVmFsdWVMaXN0U2xpY2UudHMiLCJ3ZWJwYWNrOi8vLy4vVFNYL1N5c3RlbUNlbnRlci9TeXN0ZW1DZW50ZXIudHN4Iiwid2VicGFjazovLy9leHRlcm5hbCBcImQzXCIiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUmVhY3RcIiIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJSZWFjdERPTVwiIiwid2VicGFjazovLy9leHRlcm5hbCBcIlJlYWN0Um91dGVyRE9NXCIiXSwibmFtZXMiOlsiY29tcG9zZVdpdGhEZXZUb29scyIsIndpbmRvdyIsIl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX0NPTVBPU0VfXyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInVuZGVmaW5lZCIsImNvbXBvc2UiLCJhcHBseSIsImlzUGxhaW5PYmplY3QiLCJ2YWx1ZSIsInByb3RvIiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJnZXRUaW1lTWVhc3VyZVV0aWxzIiwibWF4RGVsYXkiLCJmbk5hbWUiLCJlbGFwc2VkIiwibWVhc3VyZVRpbWUiLCJmbiIsInN0YXJ0ZWQiLCJEYXRlIiwibm93IiwiZmluaXNoZWQiLCJ3YXJuSWZFeGNlZWRlZCIsImNvbnNvbGUiLCJ3YXJuIiwiTWlkZGxld2FyZUFycmF5IiwiY29uY2F0IiwiYXJyIiwicHJlcGVuZCIsIkFycmF5IiwiaXNBcnJheSIsImlzUHJvZHVjdGlvbiIsInByb2Nlc3MiLCJwcmVmaXgiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJtZXNzYWdlIiwiRXJyb3IiLCJzdHJpbmdpZnkiLCJvYmoiLCJzZXJpYWxpemVyIiwiaW5kZW50IiwiZGVjeWNsZXIiLCJKU09OIiwiZ2V0U2VyaWFsaXplIiwic3RhY2siLCJrZXlzIiwiXyIsInNsaWNlIiwiaW5kZXhPZiIsImpvaW4iLCJrZXkiLCJ0aGlzUG9zIiwic3BsaWNlIiwicHVzaCIsIkluZmluaXR5IiwiY2FsbCIsImlzSW1tdXRhYmxlRGVmYXVsdCIsInRyYWNrRm9yTXV0YXRpb25zIiwiaXNJbW11dGFibGUiLCJpZ25vcmVQYXRocyIsInRyYWNrZWRQcm9wZXJ0aWVzIiwidHJhY2tQcm9wZXJ0aWVzIiwiZGV0ZWN0TXV0YXRpb25zIiwicGF0aCIsInRyYWNrZWQiLCJjaGlsZHJlbiIsImNoaWxkUGF0aCIsInRyYWNrZWRQcm9wZXJ0eSIsInNhbWVQYXJlbnRSZWYiLCJwcmV2T2JqIiwic2FtZVJlZiIsIk51bWJlciIsImlzTmFOIiwid2FzTXV0YXRlZCIsImtleXNUb0RldGVjdCIsImZvckVhY2giLCJpIiwicmVzdWx0IiwiY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwib3B0aW9ucyIsImlnbm9yZWRQYXRocyIsIndhcm5BZnRlciIsImlnbm9yZSIsInRyYWNrIiwiYmluZCIsImdldFN0YXRlIiwic3RhdGUiLCJ0cmFja2VyIiwibmV4dCIsImFjdGlvbiIsIm1lYXN1cmVVdGlscyIsImRpc3BhdGNoZWRBY3Rpb24iLCJpc1BsYWluIiwidmFsIiwiZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlIiwiaXNTZXJpYWxpemFibGUiLCJnZXRFbnRyaWVzIiwiZm91bmROZXN0ZWRTZXJpYWxpemFibGUiLCJrZXlQYXRoIiwiZW50cmllcyIsImhhc0lnbm9yZWRQYXRocyIsInByb3BlcnR5IiwibmVzdGVkVmFsdWUiLCJuZXN0ZWRQYXRoIiwiY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlIiwiaWdub3JlZEFjdGlvbnMiLCJpZ25vcmVkQWN0aW9uUGF0aHMiLCJzdG9yZUFQSSIsInR5cGUiLCJmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlIiwiZXJyb3IiLCJmb3VuZFN0YXRlTm9uU2VyaWFsaXphYmxlVmFsdWUiLCJpc0Jvb2xlYW4iLCJ4IiwiY3VycnlHZXREZWZhdWx0TWlkZGxld2FyZSIsImN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZSIsImdldERlZmF1bHRNaWRkbGV3YXJlIiwidGh1bmsiLCJpbW11dGFibGVDaGVjayIsInNlcmlhbGl6YWJsZUNoZWNrIiwibWlkZGxld2FyZUFycmF5IiwidGh1bmtNaWRkbGV3YXJlIiwid2l0aEV4dHJhQXJndW1lbnQiLCJleHRyYUFyZ3VtZW50IiwiaW1tdXRhYmxlT3B0aW9ucyIsInVuc2hpZnQiLCJzZXJpYWxpemFibGVPcHRpb25zIiwiSVNfUFJPRFVDVElPTiIsImNvbmZpZ3VyZVN0b3JlIiwicmVkdWNlciIsIm1pZGRsZXdhcmUiLCJkZXZUb29scyIsInByZWxvYWRlZFN0YXRlIiwiZW5oYW5jZXJzIiwicm9vdFJlZHVjZXIiLCJjb21iaW5lUmVkdWNlcnMiLCJtaWRkbGV3YXJlRW5oYW5jZXIiLCJhcHBseU1pZGRsZXdhcmUiLCJmaW5hbENvbXBvc2UiLCJ0cmFjZSIsInN0b3JlRW5oYW5jZXJzIiwiY29tcG9zZWRFbmhhbmNlciIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlQWN0aW9uIiwicHJlcGFyZUFjdGlvbiIsImFjdGlvbkNyZWF0b3IiLCJwcmVwYXJlZCIsInBheWxvYWQiLCJtZXRhIiwidG9TdHJpbmciLCJtYXRjaCIsImlzRlNBIiwiZXZlcnkiLCJpc1ZhbGlkS2V5IiwiZ2V0VHlwZSIsImV4ZWN1dGVSZWR1Y2VyQnVpbGRlckNhbGxiYWNrIiwiYnVpbGRlckNhbGxiYWNrIiwiYWN0aW9uc01hcCIsImFjdGlvbk1hdGNoZXJzIiwiZGVmYXVsdENhc2VSZWR1Y2VyIiwiYnVpbGRlciIsImFkZENhc2UiLCJ0eXBlT3JBY3Rpb25DcmVhdG9yIiwiYWRkTWF0Y2hlciIsIm1hdGNoZXIiLCJhZGREZWZhdWx0Q2FzZSIsImNyZWF0ZVJlZHVjZXIiLCJpbml0aWFsU3RhdGUiLCJtYXBPckJ1aWxkZXJDYWxsYmFjayIsImZpbmFsQWN0aW9uTWF0Y2hlcnMiLCJmaW5hbERlZmF1bHRDYXNlUmVkdWNlciIsImNhc2VSZWR1Y2VycyIsImZpbHRlciIsIm1hcCIsImNyIiwicmVkdWNlIiwicHJldmlvdXNTdGF0ZSIsImNhc2VSZWR1Y2VyIiwiaXNEcmFmdCIsImRyYWZ0IiwiaXNEcmFmdGFibGUiLCJjcmVhdGVOZXh0U3RhdGUiLCJhY3Rpb25LZXkiLCJjcmVhdGVTbGljZSIsIm5hbWUiLCJyZWR1Y2VycyIsImV4dHJhUmVkdWNlcnMiLCJyZWR1Y2VyTmFtZXMiLCJzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSIsInNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlIiwiYWN0aW9uQ3JlYXRvcnMiLCJyZWR1Y2VyTmFtZSIsIm1heWJlUmVkdWNlcldpdGhQcmVwYXJlIiwicHJlcGFyZUNhbGxiYWNrIiwicHJlcGFyZSIsImZpbmFsQ2FzZVJlZHVjZXJzIiwiYWN0aW9ucyIsImdldEluaXRpYWxFbnRpdHlTdGF0ZSIsImlkcyIsImVudGl0aWVzIiwiY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeSIsImdldEluaXRpYWxTdGF0ZSIsImFkZGl0aW9uYWxTdGF0ZSIsImFzc2lnbiIsImNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkiLCJnZXRTZWxlY3RvcnMiLCJzZWxlY3RTdGF0ZSIsInNlbGVjdElkcyIsInNlbGVjdEVudGl0aWVzIiwic2VsZWN0QWxsIiwiY3JlYXRlU2VsZWN0b3IiLCJpZCIsInNlbGVjdElkIiwic2VsZWN0QnlJZCIsInNlbGVjdFRvdGFsIiwic2VsZWN0R2xvYmFsaXplZEVudGl0aWVzIiwiY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yIiwibXV0YXRvciIsIm9wZXJhdG9yIiwiY3JlYXRlU3RhdGVPcGVyYXRvciIsIm9wZXJhdGlvbiIsImFyZyIsImlzUGF5bG9hZEFjdGlvbkFyZ3VtZW50IiwicnVuTXV0YXRvciIsInNlbGVjdElkVmFsdWUiLCJlbnRpdHkiLCJjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlciIsImFkZE9uZU11dGFibHkiLCJhZGRNYW55TXV0YWJseSIsInZhbHVlcyIsInNldEFsbE11dGFibHkiLCJyZW1vdmVPbmVNdXRhYmx5IiwicmVtb3ZlTWFueU11dGFibHkiLCJkaWRNdXRhdGUiLCJyZW1vdmVBbGxNdXRhYmx5IiwidGFrZU5ld0tleSIsInVwZGF0ZSIsIm9yaWdpbmFsIiwidXBkYXRlZCIsImNoYW5nZXMiLCJuZXdLZXkiLCJoYXNOZXdLZXkiLCJ1cGRhdGVPbmVNdXRhYmx5IiwidXBkYXRlTWFueU11dGFibHkiLCJ1cGRhdGVzIiwibmV3S2V5cyIsInVwZGF0ZXNQZXJFbnRpdHkiLCJkaWRNdXRhdGVFbnRpdGllcyIsImRpZE11dGF0ZUlkcyIsInVwc2VydE9uZU11dGFibHkiLCJ1cHNlcnRNYW55TXV0YWJseSIsImFkZGVkIiwicmVtb3ZlQWxsIiwiYWRkT25lIiwiYWRkTWFueSIsInNldEFsbCIsInVwZGF0ZU9uZSIsInVwZGF0ZU1hbnkiLCJ1cHNlcnRPbmUiLCJ1cHNlcnRNYW55IiwicmVtb3ZlT25lIiwicmVtb3ZlTWFueSIsImNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlciIsInNvcnQiLCJuZXdNb2RlbHMiLCJtb2RlbHMiLCJtb2RlbCIsIm1lcmdlIiwidGFrZVVwZGF0ZWRNb2RlbCIsImFyZUFycmF5c0VxdWFsIiwiYSIsImIiLCJhbGxFbnRpdGllcyIsIm5ld1NvcnRlZElkcyIsImNyZWF0ZUVudGl0eUFkYXB0ZXIiLCJzb3J0Q29tcGFyZXIiLCJpbnN0YW5jZSIsInN0YXRlRmFjdG9yeSIsInNlbGVjdG9yc0ZhY3RvcnkiLCJzdGF0ZUFkYXB0ZXIiLCJ1cmxBbHBoYWJldCIsIm5hbm9pZCIsInNpemUiLCJNYXRoIiwicmFuZG9tIiwiY29tbW9uUHJvcGVydGllcyIsIlJlamVjdFdpdGhWYWx1ZSIsIm1pbmlTZXJpYWxpemVFcnJvciIsInNpbXBsZUVycm9yIiwiU3RyaW5nIiwiY3JlYXRlQXN5bmNUaHVuayIsInR5cGVQcmVmaXgiLCJwYXlsb2FkQ3JlYXRvciIsImZ1bGZpbGxlZCIsInJlcXVlc3RJZCIsInBlbmRpbmciLCJyZWplY3RlZCIsImFib3J0ZWQiLCJkaXNwbGF5ZWRXYXJuaW5nIiwiQUMiLCJBYm9ydENvbnRyb2xsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzcGF0Y2hFdmVudCIsIm9uYWJvcnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJpbmZvIiwiZGlzcGF0Y2giLCJleHRyYSIsImFib3J0Q29udHJvbGxlciIsImFib3J0UmVhc29uIiwiYWJvcnRlZFByb21pc2UiLCJQcm9taXNlIiwicmVqZWN0Iiwic2lnbmFsIiwicmVhc29uIiwicHJvbWlzZSIsInNraXBEaXNwYXRjaCIsImRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uIiwiZmluYWxBY3Rpb24iLCJyYWNlIiwicmVzb2x2ZSIsInJlamVjdFdpdGhWYWx1ZSIsInRoZW4iLCJlcnIiLCJ1bndyYXBSZXN1bHQiLCJyZXR1cm5lZCIsImVuYWJsZUVTNSIsImRpZSIsImFyZ3MiLCJlIiwiZXJyb3JzIiwibXNnIiwiRFJBRlRfU1RBVEUiLCJwcm90b3R5cGUiLCJEUkFGVEFCTEUiLCJjb25zdHJ1Y3RvciIsImlzTWFwIiwiaXNTZXQiLCJiYXNlXyIsImVhY2giLCJpdGVyIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRBcmNodHlwZSIsIm93bktleXMiLCJlbnRyeSIsImluZGV4IiwidGhpbmciLCJ0eXBlXyIsImhhcyIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImdldCIsInNldCIsInByb3BPck9sZFZhbHVlIiwidCIsImRlbGV0ZSIsImFkZCIsImlzIiwieSIsInRhcmdldCIsImhhc01hcCIsIk1hcCIsImhhc1NldCIsIlNldCIsImxhdGVzdCIsImNvcHlfIiwic2hhbGxvd0NvcHkiLCJiYXNlIiwiZGVzY3JpcHRvcnMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVzYyIsIndyaXRhYmxlIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImNyZWF0ZSIsImZyZWV6ZSIsImRlZXAiLCJpc0Zyb3plbiIsImNsZWFyIiwiZG9udE11dGF0ZUZyb3plbkNvbGxlY3Rpb25zIiwiZ2V0UGx1Z2luIiwicGx1Z2luS2V5IiwicGx1Z2luIiwicGx1Z2lucyIsImxvYWRQbHVnaW4iLCJpbXBsZW1lbnRhdGlvbiIsImdldEN1cnJlbnRTY29wZSIsImN1cnJlbnRTY29wZSIsInVzZVBhdGNoZXNJblNjb3BlIiwic2NvcGUiLCJwYXRjaExpc3RlbmVyIiwicGF0Y2hlc18iLCJpbnZlcnNlUGF0Y2hlc18iLCJwYXRjaExpc3RlbmVyXyIsInJldm9rZVNjb3BlIiwibGVhdmVTY29wZSIsImRyYWZ0c18iLCJyZXZva2VEcmFmdCIsInBhcmVudF8iLCJlbnRlclNjb3BlIiwiaW1tZXIiLCJpbW1lcl8iLCJjYW5BdXRvRnJlZXplXyIsInVuZmluYWxpemVkRHJhZnRzXyIsInJldm9rZV8iLCJyZXZva2VkXyIsInByb2Nlc3NSZXN1bHQiLCJiYXNlRHJhZnQiLCJpc1JlcGxhY2VkIiwidXNlUHJveGllc18iLCJ3aWxsRmluYWxpemVFUzVfIiwibW9kaWZpZWRfIiwiZmluYWxpemUiLCJtYXliZUZyZWV6ZSIsImdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzXyIsIk5PVEhJTkciLCJyb290U2NvcGUiLCJjaGlsZFZhbHVlIiwiZmluYWxpemVQcm9wZXJ0eSIsInNjb3BlXyIsImZpbmFsaXplZF8iLCJkcmFmdF8iLCJnZW5lcmF0ZVBhdGNoZXNfIiwicGFyZW50U3RhdGUiLCJ0YXJnZXRPYmplY3QiLCJyb290UGF0aCIsInJlcyIsImFzc2lnbmVkXyIsImF1dG9GcmVlemVfIiwicGVlayIsImdldERlc2NyaXB0b3JGcm9tUHJvdG8iLCJzb3VyY2UiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJtYXJrQ2hhbmdlZCIsInByZXBhcmVDb3B5IiwiY3JlYXRlUHJveHkiLCJwYXJlbnQiLCJwcm94eU1hcF8iLCJwcm94eVNldF8iLCJpc01hbnVhbF8iLCJ0cmFwcyIsIm9iamVjdFRyYXBzIiwiYXJyYXlUcmFwcyIsIlByb3h5IiwicmV2b2NhYmxlIiwicmV2b2tlIiwicHJveHkiLCJjcmVhdGVQcm94eVByb3h5IiwiY3JlYXRlRVM1UHJveHlfIiwiY3VycmVudCIsImN1cnJlbnRJbXBsIiwiY29weSIsImFyY2hUeXBlIiwiaGFzQ2hhbmdlc18iLCJjb3B5SGVscGVyIiwiZnJvbSIsInByb3h5UHJvcGVydHkiLCJ0aGlzIiwiYXNzZXJ0VW5yZXZva2VkIiwibWFya0NoYW5nZXNTd2VlcCIsImRyYWZ0cyIsImhhc0FycmF5Q2hhbmdlcyIsImhhc09iamVjdENoYW5nZXMiLCJiYXNlVmFsdWUiLCJiYXNlSXNEcmFmdCIsImRlc2NyaXB0b3IiLCJkZWZpbmVQcm9wZXJ0eSIsImNyZWF0ZUVTNURyYWZ0IiwibWFya0NoYW5nZXNSZWN1cnNpdmVseSIsIm9iamVjdCIsIm1pbiIsImVuYWJsZVBhdGNoZXMiLCJkZWVwQ2xvbmVQYXRjaFZhbHVlIiwiY2xvbmVkIiwiY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQiLCJBREQiLCJhcHBseVBhdGNoZXNfIiwicGF0Y2hlcyIsInBhdGNoIiwib3AiLCJiYXNlUGF0aCIsImludmVyc2VQYXRjaGVzIiwiYXNzaWduZWRWYWx1ZSIsIm9yaWdWYWx1ZSIsImdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZCIsImdlbmVyYXRlQXJyYXlQYXRjaGVzIiwiZ2VuZXJhdGVTZXRQYXRjaGVzIiwicm9vdFN0YXRlIiwicmVwbGFjZW1lbnQiLCJlbmFibGVNYXBTZXQiLCJfX2V4dGVuZHMiLCJkIiwiX18iLCJleHRlbmRTdGF0aWNzIiwicHJlcGFyZU1hcENvcHkiLCJwcmVwYXJlU2V0Q29weSIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwicCIsIkRyYWZ0TWFwIiwiY2IiLCJ0aGlzQXJnIiwiX3ZhbHVlIiwiX3RoaXMiLCJpdGVyYXRvciIsIml0ZXJhdG9yU3ltYm9sIiwiX3RoaXMyIiwiciIsImRvbmUiLCJfdGhpczMiLCJEcmFmdFNldCIsImVuYWJsZUFsbFBsdWdpbnMiLCJjYXN0RHJhZnQiLCJjYXN0SW1tdXRhYmxlIiwiaGFzU3ltYm9sIiwiU3ltYm9sIiwiaGFzUHJveGllcyIsIlJlZmxlY3QiLCJmb3IiLCJkYXRhIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9kZXNjJGdldCIsInJlYWRQcm9wRnJvbVByb3RvIiwiY3VycmVudFN0YXRlIiwiZGVsZXRlUHJvcGVydHkiLCJvd25lciIsInBhcnNlSW50IiwiSW1tZXIiLCJjb25maWciLCJ1c2VQcm94aWVzIiwic2V0VXNlUHJveGllcyIsImF1dG9GcmVlemUiLCJzZXRBdXRvRnJlZXplIiwicHJvZHVjZSIsInByb2R1Y2VXaXRoUGF0Y2hlcyIsInJlY2lwZSIsImRlZmF1bHRCYXNlIiwic2VsZiIsImhhc0Vycm9yIiwiYXJnMSIsImFyZzIiLCJpcCIsImNyZWF0ZURyYWZ0IiwiZmluaXNoRHJhZnQiLCJhcHBseVBhdGNoZXMiLCJhcHBseVBhdGNoZXNJbXBsIl0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7UUFDQTtRQUNBLFFBQVEsb0JBQW9CO1FBQzVCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7O1FBRUE7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOzs7O1FBSUE7UUFDQTtRQUNBLHlDQUF5QyxzbUNBQXNtQztRQUMvb0M7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7QUM5a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyRkFBMkI7QUFDdEQsQ0FBQyxNQUFNLEVBSU47Ozs7Ozs7Ozs7Ozs7QUNsQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZUFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BGYTs7QUFFYixpQ0FBaUMsbUJBQU8sQ0FBQyw4REFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQyw4REFBVTs7Ozs7Ozs7Ozs7OztBQ0h2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOzs7O0FBSWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7Ozs7Ozs7Ozs7Ozs7QUNwTGE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDO0FBQ0QsbUJBQW1CLG1CQUFPLENBQUMsOEZBQStCO0FBQzFEOzs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBO0FBQUE7QUFBMEI7QUFDbkI7QUFDUDtBQUNBLDRDQUFLOztBQUVMLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFZSxnRkFBaUIsRTs7Ozs7Ozs7Ozs7O0FDVGhDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWtEO0FBQ2Y7QUFDVztBQUNHOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxREFBTztBQUM1QiwyQkFBMkIsMkRBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IscURBQU87QUFDN0I7QUFDQSxHQUFHO0FBQ0gsRUFBRSx1REFBUztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDJCQUEyQiwwREFBaUI7QUFDNUMsU0FBUyw0Q0FBSztBQUNkO0FBQ0EsR0FBRztBQUNIOztBQUVBLElBQUksSUFBcUM7QUFDekM7QUFDQSxXQUFXLGlEQUFTO0FBQ3BCLGlCQUFpQixpREFBUztBQUMxQixnQkFBZ0IsaURBQVM7QUFDekIsZ0JBQWdCLGlEQUFTO0FBQ3pCLEtBQUs7QUFDTCxhQUFhLGlEQUFTO0FBQ3RCLGNBQWMsaURBQVM7QUFDdkI7QUFDQTs7QUFFZSx1RUFBUSxFOzs7Ozs7Ozs7Ozs7QUNuRHZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTBEO0FBQzBDO0FBQ2pEO0FBQ29CO0FBQ047QUFDaEI7QUFDOEI7QUFDakM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsa0dBQXlCO0FBQzNCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7OztBQUdKO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMERBQWlCO0FBQzVELHVCQUF1Qix1R0FBNkI7O0FBRXBELE1BQU0sSUFBcUM7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxUUFBcVEsVUFBVSw4QkFBOEIsVUFBVSwwQ0FBMEMsb0JBQW9COztBQUVyWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxLQUFxQyxLQUFLLG1FQUFrQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUNBQWlDLGtGQUFRLEdBQUc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQSxpQ0FBaUMsNkNBQU87QUFDeEM7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixxREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1R0FBNkI7O0FBRXhEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIscURBQU87QUFDaEM7QUFDQTtBQUNBLHdEQUF3RCxrRUFBaUIsQ0FBQyw0Q0FBSztBQUMvRSxPQUFPLDJCQUEyQjs7QUFFbEMseUJBQXlCLHdEQUFVLGVBQWU7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFVBQVUsS0FBcUM7QUFDL0M7QUFDQSxPQUFPOzs7QUFHUDtBQUNBLCtCQUErQixxREFBTztBQUN0QztBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHNCQUFzQixxREFBTztBQUM3QixvRUFBb0U7QUFDcEU7O0FBRUEsK0JBQStCLDJEQUFZLGtFQUFrRTtBQUM3RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDBDQUEwQyxvQkFBb0Isb0JBQW9CO0FBQ2xGOzs7QUFHQSxtQ0FBbUMscURBQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0EsZUFBZSxrRkFBUSxHQUFHO0FBQzFCO0FBQ0EsU0FBUztBQUNULE9BQU8sdURBQXVEO0FBQzlEOztBQUVBLHdCQUF3Qix3REFBVTtBQUNsQztBQUNBO0FBQ0Esd0RBQXdEOzs7QUFHeEQ7QUFDQTtBQUNBLE9BQU87OztBQUdQLDJCQUEyQixvREFBTTtBQUNqQyw2QkFBNkIsb0RBQU07QUFDbkMsc0NBQXNDLG9EQUFNO0FBQzVDLDhCQUE4QixvREFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLE9BQU8sb0RBQW9EO0FBQzNEO0FBQ0E7O0FBRUEsaU1BQWlNOztBQUVqTSwwU0FBMFM7QUFDMVM7O0FBRUEscUNBQXFDLHFEQUFPO0FBQzVDLGVBQWUsNENBQUssaUNBQWlDLGtGQUFRLEdBQUc7QUFDaEU7QUFDQSxTQUFTO0FBQ1QsT0FBTyxnRUFBZ0U7QUFDdkU7O0FBRUEsMEJBQTBCLHFEQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRDQUFLO0FBQ3RCO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7O0FBR0wseUJBQXlCLDRDQUFLO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsNENBQUs7QUFDM0IsZUFBZSw0Q0FBSyx3QkFBd0Isa0ZBQVEsR0FBRztBQUN2RDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGFBQWEsOERBQVk7QUFDekI7O0FBRUEsV0FBVyw4REFBWTtBQUN2QjtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ2hYQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEwRDtBQUMwQztBQUN4QztBQUNYO0FBQ3FCO0FBQ047QUFDVjtBQUNDO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR087QUFDUCxrQ0FBa0M7QUFDbEM7QUFDQSxnREFBZ0QsbUVBQWU7QUFDL0Q7QUFDQSxvRUFBb0Usd0RBQStCO0FBQ25HO0FBQ0EsdUVBQXVFLDJEQUFrQztBQUN6RztBQUNBLCtEQUErRCxtREFBMEI7QUFDekY7QUFDQSwwREFBMEQsd0RBQXNCOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsMkRBQVk7QUFDMUU7QUFDQSxnRUFBZ0UsMkRBQVk7QUFDNUU7QUFDQSxpRUFBaUUsMkRBQVk7QUFDN0UsdUJBQXVCLHVHQUE2Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtGQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBR0EsMkZBQWUsRTs7Ozs7Ozs7Ozs7O0FDbkdmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUEyQztBQUNtQztBQUN2RTtBQUNQLG9EQUFvRCwwRUFBa0I7QUFDdEU7QUFDTztBQUNQLCtCQUErQiw4RUFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ087QUFDUCx3RUFBd0UsOEVBQXNCO0FBQzlGLFdBQVcsZ0VBQWtCO0FBQzdCLEdBQUc7QUFDSDtBQUNlLGtLQUFtRyxFOzs7Ozs7Ozs7Ozs7QUNqQmxIO0FBQUE7QUFBQTtBQUFBO0FBQThFO0FBQ3ZFO0FBQ1AsaURBQWlELDBFQUFrQjtBQUNuRTtBQUNPO0FBQ1AsNEJBQTRCLDhFQUFzQjtBQUNsRDtBQUNBLEdBQUc7QUFDSDtBQUNlLDRIQUE2RCxFOzs7Ozs7Ozs7Ozs7QUNUNUU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDQztBQUNwRDtBQUNQLFNBQVMsa0ZBQVEsR0FBRyxjQUFjLGdCQUFnQjtBQUNsRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxZQUFZLElBQXFDLEVBQUUsd0VBQWlCO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ2Usa0hBQW1ELEU7Ozs7Ozs7Ozs7OztBQ25DbEU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW9HO0FBQzlDO0FBQy9DO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUdBQTZCOztBQUU3QztBQUNBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQyxJQUFJLG1FQUFrQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDdEZBO0FBQUE7QUFBQTtBQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBTSw4REFBTztBQUNiO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ2hCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQTJEO0FBQ3BEO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsSUFBcUMsRUFBRSx3RUFBaUI7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDL0RBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBMEQ7QUFDZ0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLGFBQWEsU0FBUztBQUN0Qjs7QUFFTztBQUNQO0FBQ0EsY0FBYyxxRUFBaUI7QUFDL0I7O0FBRUEsNkJBQTZCLHFFQUFpQixHQUFHLGtEQUFlLEdBQUcsaUVBQWU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyxXQUFXLGNBQWM7QUFDekI7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBLHlEQUF5RCwyQkFBMkI7QUFDcEY7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCLDBCQUEwQixnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBLHFCOzs7Ozs7Ozs7Ozs7QUM1Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFtQztBQUN1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0MsWUFBWSxRQUFRO0FBQ3BCLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTs7QUFFTztBQUNQLHFCQUFxQix3REFBVSxDQUFDLHFFQUFpQjs7QUFFakQsTUFBTSxLQUFxQztBQUMzQyw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUMzQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQStFO0FBQ0Q7QUFDN0I7QUFDOEI7QUFDckI7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix3REFBVTtBQUM5QjtBQUNBLEdBQUc7QUFDSDs7QUFFQSxxQkFBcUIscURBQU87QUFDNUIsZUFBZSwyREFBWTtBQUMzQixHQUFHO0FBQ0gsd0NBQXdDLG9EQUFNO0FBQzlDLHVCQUF1QixvREFBTTtBQUM3Qix5QkFBeUIsb0RBQU07QUFDL0IsNEJBQTRCLG9EQUFNO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxrR0FBeUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxrR0FBeUI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7OztBQUdPO0FBQ1A7QUFDQSxjQUFjLHFFQUFpQjtBQUMvQjs7QUFFQSxvQ0FBb0MscUVBQWlCLEdBQUcsZ0VBQXNCO0FBQzlFLFdBQVcsd0RBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSwyREFBYTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBOztBQUVPO0FBQ1A7QUFDQSxxQjs7Ozs7Ozs7Ozs7O0FDeElBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQW1DO0FBQ3VCO0FBQ29CO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixhQUFhLFNBQVM7QUFDdEI7O0FBRU87QUFDUDtBQUNBLGNBQWMscUVBQWlCO0FBQy9COztBQUVBLG9DQUFvQyxxRUFBaUIsR0FBRyxnRUFBc0I7QUFDOUUsV0FBVyx3REFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBOztBQUVPO0FBQ1A7QUFDQSxrQjs7Ozs7Ozs7Ozs7O0FDM0NBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNkM7QUFDYztBQUNGO0FBQ2pCO0FBQzhCO0FBQ0E7QUFDVDtBQUNwQjtBQUNzQztBQUMvQjtBQUNoRCw2REFBUSxDQUFDLGtGQUFLOzs7Ozs7Ozs7Ozs7O0FDVmQ7QUFBQTtBQUFBO0FBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUN6SEQ7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUV0QjtBQUNQO0FBQ0EsRUFBRTs7QUFFSztBQUNQO0FBQ0EsRTs7Ozs7Ozs7Ozs7O0FDYkE7QUFBQTtBQUFBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsYUFBYSxRQUFRO0FBQ3JCO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFZTtB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Q0FBQyxvREFBQyxvREFBUSxJQUFDLEtBQUssRUFBRSxvREFBSztJQUFFLG9EQUFDLFlBQVksT0FBRyxDQUFXLEVBQUUsUUFBUSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7QUM3UHhHLG9COzs7Ozs7Ozs7OztBQ0FBLHVCOzs7Ozs7Ozs7OztBQ0FBLDBCOzs7Ozs7Ozs7OztBQ0FBLGdDIiwiZmlsZSI6IlN5c3RlbUNlbnRlci5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xuIFx0ZnVuY3Rpb24gd2VicGFja0pzb25wQ2FsbGJhY2soZGF0YSkge1xuIFx0XHR2YXIgY2h1bmtJZHMgPSBkYXRhWzBdO1xuIFx0XHR2YXIgbW9yZU1vZHVsZXMgPSBkYXRhWzFdO1xuXG5cbiBcdFx0Ly8gYWRkIFwibW9yZU1vZHVsZXNcIiB0byB0aGUgbW9kdWxlcyBvYmplY3QsXG4gXHRcdC8vIHRoZW4gZmxhZyBhbGwgXCJjaHVua0lkc1wiIGFzIGxvYWRlZCBhbmQgZmlyZSBjYWxsYmFja1xuIFx0XHR2YXIgbW9kdWxlSWQsIGNodW5rSWQsIGkgPSAwLCByZXNvbHZlcyA9IFtdO1xuIFx0XHRmb3IoO2kgPCBjaHVua0lkcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdGNodW5rSWQgPSBjaHVua0lkc1tpXTtcbiBcdFx0XHRpZihpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdHJlc29sdmVzLnB1c2goaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdWzBdKTtcbiBcdFx0XHR9XG4gXHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcbiBcdFx0fVxuIFx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGlmKHBhcmVudEpzb25wRnVuY3Rpb24pIHBhcmVudEpzb25wRnVuY3Rpb24oZGF0YSk7XG5cbiBcdFx0d2hpbGUocmVzb2x2ZXMubGVuZ3RoKSB7XG4gXHRcdFx0cmVzb2x2ZXMuc2hpZnQoKSgpO1xuIFx0XHR9XG5cbiBcdH07XG5cblxuIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3NcbiBcdC8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuIFx0Ly8gUHJvbWlzZSA9IGNodW5rIGxvYWRpbmcsIDAgPSBjaHVuayBsb2FkZWRcbiBcdHZhciBpbnN0YWxsZWRDaHVua3MgPSB7XG4gXHRcdFwiU3lzdGVtQ2VudGVyXCI6IDBcbiBcdH07XG5cblxuXG4gXHQvLyBzY3JpcHQgcGF0aCBmdW5jdGlvblxuIFx0ZnVuY3Rpb24ganNvbnBTY3JpcHRTcmMoY2h1bmtJZCkge1xuIFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArICh7XCJ2ZW5kb3JzfkFzc2V0fkFzc2V0R3JvdXB+QnlBc3NldH5CeUFzc2V0R3JvdXB+QnlDb21wYW55fkJ5Q3VzdG9tZXJ+QnlMb2NhdGlvbn5CeU1ldGVyfkJ5VXNlcn5Db21wYW55fjE1OWE3MTcxXCI6XCJ2ZW5kb3JzfkFzc2V0fkFzc2V0R3JvdXB+QnlBc3NldH5CeUFzc2V0R3JvdXB+QnlDb21wYW55fkJ5Q3VzdG9tZXJ+QnlMb2NhdGlvbn5CeU1ldGVyfkJ5VXNlcn5Db21wYW55fjE1OWE3MTcxXCIsXCJBc3NldEdyb3VwfkJ5QXNzZXRHcm91cFwiOlwiQXNzZXRHcm91cH5CeUFzc2V0R3JvdXBcIixcIkFzc2V0R3JvdXBcIjpcIkFzc2V0R3JvdXBcIixcIkJ5QXNzZXRHcm91cFwiOlwiQnlBc3NldEdyb3VwXCIsXCJBc3NldH5CeUFzc2V0fkJ5TG9jYXRpb25+Q29tcGFueX5DdXN0b21lcn5Mb2NhdGlvbn5NZXRlcn5OZXdNZXRlcldpemFyZFwiOlwiQXNzZXR+QnlBc3NldH5CeUxvY2F0aW9ufkNvbXBhbnl+Q3VzdG9tZXJ+TG9jYXRpb25+TWV0ZXJ+TmV3TWV0ZXJXaXphcmRcIixcIkFzc2V0fkJ5QXNzZXR+TG9jYXRpb25+TWV0ZXJ+TmV3TWV0ZXJXaXphcmRcIjpcIkFzc2V0fkJ5QXNzZXR+TG9jYXRpb25+TWV0ZXJ+TmV3TWV0ZXJXaXphcmRcIixcIkFzc2V0fkJ5QXNzZXRcIjpcIkFzc2V0fkJ5QXNzZXRcIixcIkJ5QXNzZXRcIjpcIkJ5QXNzZXRcIixcIkFzc2V0fkNvbXBhbnl+Q3VzdG9tZXJ+TG9jYXRpb25+TWV0ZXJcIjpcIkFzc2V0fkNvbXBhbnl+Q3VzdG9tZXJ+TG9jYXRpb25+TWV0ZXJcIixcIkFzc2V0XCI6XCJBc3NldFwiLFwiTG9jYXRpb25cIjpcIkxvY2F0aW9uXCIsXCJNZXRlclwiOlwiTWV0ZXJcIixcIk5ld01ldGVyV2l6YXJkXCI6XCJOZXdNZXRlcldpemFyZFwiLFwiQ3VzdG9tZXJcIjpcIkN1c3RvbWVyXCIsXCJCeUxvY2F0aW9uXCI6XCJCeUxvY2F0aW9uXCIsXCJCeUN1c3RvbWVyXCI6XCJCeUN1c3RvbWVyXCIsXCJCeU1ldGVyXCI6XCJCeU1ldGVyXCIsXCJCeVVzZXJ+VXNlclwiOlwiQnlVc2VyflVzZXJcIixcIkJ5VXNlclwiOlwiQnlVc2VyXCIsXCJVc2VyXCI6XCJVc2VyXCIsXCJDb25maWd1cmF0aW9uSGlzdG9yeVwiOlwiQ29uZmlndXJhdGlvbkhpc3RvcnlcIixcIlVzZXJTdGF0aXN0aWNzXCI6XCJVc2VyU3RhdGlzdGljc1wiLFwidmVuZG9yc35CeUNvbXBhbnl+Q29tcGFueVwiOlwidmVuZG9yc35CeUNvbXBhbnl+Q29tcGFueVwiLFwiQ29tcGFueVwiOlwiQ29tcGFueVwiLFwiQnlDb21wYW55XCI6XCJCeUNvbXBhbnlcIn1bY2h1bmtJZF18fGNodW5rSWQpICsgXCIuanNcIlxuIFx0fVxuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cbiBcdC8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbiBcdC8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lID0gZnVuY3Rpb24gcmVxdWlyZUVuc3VyZShjaHVua0lkKSB7XG4gXHRcdHZhciBwcm9taXNlcyA9IFtdO1xuXG5cbiBcdFx0Ly8gSlNPTlAgY2h1bmsgbG9hZGluZyBmb3IgamF2YXNjcmlwdFxuXG4gXHRcdHZhciBpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgeyAvLyAwIG1lYW5zIFwiYWxyZWFkeSBpbnN0YWxsZWRcIi5cblxuIFx0XHRcdC8vIGEgUHJvbWlzZSBtZWFucyBcImN1cnJlbnRseSBsb2FkaW5nXCIuXG4gXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG4gXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSk7XG4gXHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdC8vIHNldHVwIFByb21pc2UgaW4gY2h1bmsgY2FjaGVcbiBcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdO1xuIFx0XHRcdFx0fSk7XG4gXHRcdFx0XHRwcm9taXNlcy5wdXNoKGluc3RhbGxlZENodW5rRGF0YVsyXSA9IHByb21pc2UpO1xuXG4gXHRcdFx0XHQvLyBzdGFydCBjaHVuayBsb2FkaW5nXG4gXHRcdFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gXHRcdFx0XHR2YXIgb25TY3JpcHRDb21wbGV0ZTtcblxuIFx0XHRcdFx0c2NyaXB0LmNoYXJzZXQgPSAndXRmLTgnO1xuIFx0XHRcdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjA7XG4gXHRcdFx0XHRpZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5uYykge1xuIFx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgX193ZWJwYWNrX3JlcXVpcmVfXy5uYyk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRzY3JpcHQuc3JjID0ganNvbnBTY3JpcHRTcmMoY2h1bmtJZCk7XG5cbiBcdFx0XHRcdG9uU2NyaXB0Q29tcGxldGUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiBcdFx0XHRcdFx0Ly8gYXZvaWQgbWVtIGxlYWtzIGluIElFLlxuIFx0XHRcdFx0XHRzY3JpcHQub25lcnJvciA9IHNjcmlwdC5vbmxvYWQgPSBudWxsO1xuIFx0XHRcdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG4gXHRcdFx0XHRcdHZhciBjaHVuayA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdFx0XHRcdFx0aWYoY2h1bmsgIT09IDApIHtcbiBcdFx0XHRcdFx0XHRpZihjaHVuaykge1xuIFx0XHRcdFx0XHRcdFx0dmFyIGVycm9yVHlwZSA9IGV2ZW50ICYmIChldmVudC50eXBlID09PSAnbG9hZCcgPyAnbWlzc2luZycgOiBldmVudC50eXBlKTtcbiBcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG4gXHRcdFx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgY2h1bmsgJyArIGNodW5rSWQgKyAnIGZhaWxlZC5cXG4oJyArIGVycm9yVHlwZSArICc6ICcgKyByZWFsU3JjICsgJyknKTtcbiBcdFx0XHRcdFx0XHRcdGVycm9yLnR5cGUgPSBlcnJvclR5cGU7XG4gXHRcdFx0XHRcdFx0XHRlcnJvci5yZXF1ZXN0ID0gcmVhbFNyYztcbiBcdFx0XHRcdFx0XHRcdGNodW5rWzFdKGVycm9yKTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9O1xuIFx0XHRcdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gXHRcdFx0XHRcdG9uU2NyaXB0Q29tcGxldGUoeyB0eXBlOiAndGltZW91dCcsIHRhcmdldDogc2NyaXB0IH0pO1xuIFx0XHRcdFx0fSwgMTIwMDAwKTtcbiBcdFx0XHRcdHNjcmlwdC5vbmVycm9yID0gc2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGU7XG4gXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gXHR9O1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiU2NyaXB0cy9cIjtcblxuIFx0Ly8gb24gZXJyb3IgZnVuY3Rpb24gZm9yIGFzeW5jIGxvYWRpbmdcbiBcdF9fd2VicGFja19yZXF1aXJlX18ub2UgPSBmdW5jdGlvbihlcnIpIHsgY29uc29sZS5lcnJvcihlcnIpOyB0aHJvdyBlcnI7IH07XG5cbiBcdHZhciBqc29ucEFycmF5ID0gd2luZG93W1wid2VicGFja0pzb25wXCJdID0gd2luZG93W1wid2VicGFja0pzb25wXCJdIHx8IFtdO1xuIFx0dmFyIG9sZEpzb25wRnVuY3Rpb24gPSBqc29ucEFycmF5LnB1c2guYmluZChqc29ucEFycmF5KTtcbiBcdGpzb25wQXJyYXkucHVzaCA9IHdlYnBhY2tKc29ucENhbGxiYWNrO1xuIFx0anNvbnBBcnJheSA9IGpzb25wQXJyYXkuc2xpY2UoKTtcbiBcdGZvcih2YXIgaSA9IDA7IGkgPCBqc29ucEFycmF5Lmxlbmd0aDsgaSsrKSB3ZWJwYWNrSnNvbnBDYWxsYmFjayhqc29ucEFycmF5W2ldKTtcbiBcdHZhciBwYXJlbnRKc29ucEZ1bmN0aW9uID0gb2xkSnNvbnBGdW5jdGlvbjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9UU1gvU3lzdGVtQ2VudGVyL1N5c3RlbUNlbnRlci50c3hcIik7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufSIsImltcG9ydCB7IEFjdGlvbiwgQWN0aW9uQ3JlYXRvciwgU3RvcmVFbmhhbmNlciwgY29tcG9zZSB9IGZyb20gJ3JlZHV4J1xyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZXJPcHRpb25zIHtcclxuICAvKipcclxuICAgKiB0aGUgaW5zdGFuY2UgbmFtZSB0byBiZSBzaG93ZWQgb24gdGhlIG1vbml0b3IgcGFnZS4gRGVmYXVsdCB2YWx1ZSBpcyBgZG9jdW1lbnQudGl0bGVgLlxyXG4gICAqIElmIG5vdCBzcGVjaWZpZWQgYW5kIHRoZXJlJ3Mgbm8gZG9jdW1lbnQgdGl0bGUsIGl0IHdpbGwgY29uc2lzdCBvZiBgdGFiSWRgIGFuZCBgaW5zdGFuY2VJZGAuXHJcbiAgICovXHJcbiAgbmFtZT86IHN0cmluZ1xyXG4gIC8qKlxyXG4gICAqIGFjdGlvbiBjcmVhdG9ycyBmdW5jdGlvbnMgdG8gYmUgYXZhaWxhYmxlIGluIHRoZSBEaXNwYXRjaGVyLlxyXG4gICAqL1xyXG4gIGFjdGlvbkNyZWF0b3JzPzogQWN0aW9uQ3JlYXRvcjxhbnk+W10gfCB7IFtrZXk6IHN0cmluZ106IEFjdGlvbkNyZWF0b3I8YW55PiB9XHJcbiAgLyoqXHJcbiAgICogaWYgbW9yZSB0aGFuIG9uZSBhY3Rpb24gaXMgZGlzcGF0Y2hlZCBpbiB0aGUgaW5kaWNhdGVkIGludGVydmFsLCBhbGwgbmV3IGFjdGlvbnMgd2lsbCBiZSBjb2xsZWN0ZWQgYW5kIHNlbnQgYXQgb25jZS5cclxuICAgKiBJdCBpcyB0aGUgam9pbnQgYmV0d2VlbiBwZXJmb3JtYW5jZSBhbmQgc3BlZWQuIFdoZW4gc2V0IHRvIGAwYCwgYWxsIGFjdGlvbnMgd2lsbCBiZSBzZW50IGluc3RhbnRseS5cclxuICAgKiBTZXQgaXQgdG8gYSBoaWdoZXIgdmFsdWUgd2hlbiBleHBlcmllbmNpbmcgcGVyZiBpc3N1ZXMgKGFsc28gYG1heEFnZWAgdG8gYSBsb3dlciB2YWx1ZSkuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCA1MDAgbXMuXHJcbiAgICovXHJcbiAgbGF0ZW5jeT86IG51bWJlclxyXG4gIC8qKlxyXG4gICAqICg+IDEpIC0gbWF4aW11bSBhbGxvd2VkIGFjdGlvbnMgdG8gYmUgc3RvcmVkIGluIHRoZSBoaXN0b3J5IHRyZWUuIFRoZSBvbGRlc3QgYWN0aW9ucyBhcmUgcmVtb3ZlZCBvbmNlIG1heEFnZSBpcyByZWFjaGVkLiBJdCdzIGNyaXRpY2FsIGZvciBwZXJmb3JtYW5jZS5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IDUwXHJcbiAgICovXHJcbiAgbWF4QWdlPzogbnVtYmVyXHJcbiAgLyoqXHJcbiAgICogLSBgdW5kZWZpbmVkYCAtIHdpbGwgdXNlIHJlZ3VsYXIgYEpTT04uc3RyaW5naWZ5YCB0byBzZW5kIGRhdGEgKGl0J3MgdGhlIGZhc3QgbW9kZSkuXHJcbiAgICogLSBgZmFsc2VgIC0gd2lsbCBoYW5kbGUgYWxzbyBjaXJjdWxhciByZWZlcmVuY2VzLlxyXG4gICAqIC0gYHRydWVgIC0gd2lsbCBoYW5kbGUgYWxzbyBkYXRlLCByZWdleCwgdW5kZWZpbmVkLCBlcnJvciBvYmplY3RzLCBzeW1ib2xzLCBtYXBzLCBzZXRzIGFuZCBmdW5jdGlvbnMuXHJcbiAgICogLSBvYmplY3QsIHdoaWNoIGNvbnRhaW5zIGBkYXRlYCwgYHJlZ2V4YCwgYHVuZGVmaW5lZGAsIGBlcnJvcmAsIGBzeW1ib2xgLCBgbWFwYCwgYHNldGAgYW5kIGBmdW5jdGlvbmAga2V5cy5cclxuICAgKiAgIEZvciBlYWNoIG9mIHRoZW0geW91IGNhbiBpbmRpY2F0ZSBpZiB0byBpbmNsdWRlIChieSBzZXR0aW5nIGFzIGB0cnVlYCkuXHJcbiAgICogICBGb3IgYGZ1bmN0aW9uYCBrZXkgeW91IGNhbiBhbHNvIHNwZWNpZnkgYSBjdXN0b20gZnVuY3Rpb24gd2hpY2ggaGFuZGxlcyBzZXJpYWxpemF0aW9uLlxyXG4gICAqICAgU2VlIFtganNhbmBdKGh0dHBzOi8vZ2l0aHViLmNvbS9rb2xvZG55L2pzYW4pIGZvciBtb3JlIGRldGFpbHMuXHJcbiAgICovXHJcbiAgc2VyaWFsaXplPzpcclxuICAgIHwgYm9vbGVhblxyXG4gICAgfCB7XHJcbiAgICAgICAgZGF0ZT86IGJvb2xlYW5cclxuICAgICAgICByZWdleD86IGJvb2xlYW5cclxuICAgICAgICB1bmRlZmluZWQ/OiBib29sZWFuXHJcbiAgICAgICAgZXJyb3I/OiBib29sZWFuXHJcbiAgICAgICAgc3ltYm9sPzogYm9vbGVhblxyXG4gICAgICAgIG1hcD86IGJvb2xlYW5cclxuICAgICAgICBzZXQ/OiBib29sZWFuXHJcbiAgICAgICAgZnVuY3Rpb24/OiBib29sZWFuIHwgRnVuY3Rpb25cclxuICAgICAgfVxyXG4gIC8qKlxyXG4gICAqIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGBhY3Rpb25gIG9iamVjdCBhbmQgaWQgbnVtYmVyIGFzIGFyZ3VtZW50cywgYW5kIHNob3VsZCByZXR1cm4gYGFjdGlvbmAgb2JqZWN0IGJhY2suXHJcbiAgICovXHJcbiAgYWN0aW9uU2FuaXRpemVyPzogPEEgZXh0ZW5kcyBBY3Rpb24+KGFjdGlvbjogQSwgaWQ6IG51bWJlcikgPT4gQVxyXG4gIC8qKlxyXG4gICAqIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGBzdGF0ZWAgb2JqZWN0IGFuZCBpbmRleCBhcyBhcmd1bWVudHMsIGFuZCBzaG91bGQgcmV0dXJuIGBzdGF0ZWAgb2JqZWN0IGJhY2suXHJcbiAgICovXHJcbiAgc3RhdGVTYW5pdGl6ZXI/OiA8Uz4oc3RhdGU6IFMsIGluZGV4OiBudW1iZXIpID0+IFNcclxuICAvKipcclxuICAgKiAqc3RyaW5nIG9yIGFycmF5IG9mIHN0cmluZ3MgYXMgcmVnZXgqIC0gYWN0aW9ucyB0eXBlcyB0byBiZSBoaWRkZW4gLyBzaG93biBpbiB0aGUgbW9uaXRvcnMgKHdoaWxlIHBhc3NlZCB0byB0aGUgcmVkdWNlcnMpLlxyXG4gICAqIElmIGBhY3Rpb25zV2hpdGVsaXN0YCBzcGVjaWZpZWQsIGBhY3Rpb25zQmxhY2tsaXN0YCBpcyBpZ25vcmVkLlxyXG4gICAqL1xyXG4gIGFjdGlvbnNCbGFja2xpc3Q/OiBzdHJpbmcgfCBzdHJpbmdbXVxyXG4gIC8qKlxyXG4gICAqICpzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncyBhcyByZWdleCogLSBhY3Rpb25zIHR5cGVzIHRvIGJlIGhpZGRlbiAvIHNob3duIGluIHRoZSBtb25pdG9ycyAod2hpbGUgcGFzc2VkIHRvIHRoZSByZWR1Y2VycykuXHJcbiAgICogSWYgYGFjdGlvbnNXaGl0ZWxpc3RgIHNwZWNpZmllZCwgYGFjdGlvbnNCbGFja2xpc3RgIGlzIGlnbm9yZWQuXHJcbiAgICovXHJcbiAgYWN0aW9uc1doaXRlbGlzdD86IHN0cmluZyB8IHN0cmluZ1tdXHJcbiAgLyoqXHJcbiAgICogY2FsbGVkIGZvciBldmVyeSBhY3Rpb24gYmVmb3JlIHNlbmRpbmcsIHRha2VzIGBzdGF0ZWAgYW5kIGBhY3Rpb25gIG9iamVjdCwgYW5kIHJldHVybnMgYHRydWVgIGluIGNhc2UgaXQgYWxsb3dzIHNlbmRpbmcgdGhlIGN1cnJlbnQgZGF0YSB0byB0aGUgbW9uaXRvci5cclxuICAgKiBVc2UgaXQgYXMgYSBtb3JlIGFkdmFuY2VkIHZlcnNpb24gb2YgYGFjdGlvbnNCbGFja2xpc3RgL2BhY3Rpb25zV2hpdGVsaXN0YCBwYXJhbWV0ZXJzLlxyXG4gICAqL1xyXG4gIHByZWRpY2F0ZT86IDxTLCBBIGV4dGVuZHMgQWN0aW9uPihzdGF0ZTogUywgYWN0aW9uOiBBKSA9PiBib29sZWFuXHJcbiAgLyoqXHJcbiAgICogaWYgc3BlY2lmaWVkIGFzIGBmYWxzZWAsIGl0IHdpbGwgbm90IHJlY29yZCB0aGUgY2hhbmdlcyB0aWxsIGNsaWNraW5nIG9uIGBTdGFydCByZWNvcmRpbmdgIGJ1dHRvbi5cclxuICAgKiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIsIGZvciBvdGhlcnMgdXNlIGBhdXRvUGF1c2VgLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAqL1xyXG4gIHNob3VsZFJlY29yZENoYW5nZXM/OiBib29sZWFuXHJcbiAgLyoqXHJcbiAgICogaWYgc3BlY2lmaWVkLCB3aGVuZXZlciBjbGlja2luZyBvbiBgUGF1c2UgcmVjb3JkaW5nYCBidXR0b24gYW5kIHRoZXJlIGFyZSBhY3Rpb25zIGluIHRoZSBoaXN0b3J5IGxvZywgd2lsbCBhZGQgdGhpcyBhY3Rpb24gdHlwZS5cclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCB3aWxsIGNvbW1pdCB3aGVuIHBhdXNlZC4gQXZhaWxhYmxlIG9ubHkgZm9yIFJlZHV4IGVuaGFuY2VyLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgXCJAQFBBVVNFRFwiXCJcclxuICAgKi9cclxuICBwYXVzZUFjdGlvblR5cGU/OiBzdHJpbmdcclxuICAvKipcclxuICAgKiBhdXRvIHBhdXNlcyB3aGVuIHRoZSBleHRlbnNpb27igJlzIHdpbmRvdyBpcyBub3Qgb3BlbmVkLCBhbmQgc28gaGFzIHplcm8gaW1wYWN0IG9uIHlvdXIgYXBwIHdoZW4gbm90IGluIHVzZS5cclxuICAgKiBOb3QgYXZhaWxhYmxlIGZvciBSZWR1eCBlbmhhbmNlciAoYXMgaXQgYWxyZWFkeSBkb2VzIGl0IGJ1dCBzdG9yaW5nIHRoZSBkYXRhIHRvIGJlIHNlbnQpLlxyXG4gICAqXHJcbiAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgKi9cclxuICBhdXRvUGF1c2U/OiBib29sZWFuXHJcbiAgLyoqXHJcbiAgICogaWYgc3BlY2lmaWVkIGFzIGB0cnVlYCwgaXQgd2lsbCBub3QgYWxsb3cgYW55IG5vbi1tb25pdG9yIGFjdGlvbnMgdG8gYmUgZGlzcGF0Y2hlZCB0aWxsIGNsaWNraW5nIG9uIGBVbmxvY2sgY2hhbmdlc2AgYnV0dG9uLlxyXG4gICAqIEF2YWlsYWJsZSBvbmx5IGZvciBSZWR1eCBlbmhhbmNlci5cclxuICAgKlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXHJcbiAgc2hvdWxkU3RhcnRMb2NrZWQ/OiBib29sZWFuXHJcbiAgLyoqXHJcbiAgICogaWYgc2V0IHRvIGBmYWxzZWAsIHdpbGwgbm90IHJlY29tcHV0ZSB0aGUgc3RhdGVzIG9uIGhvdCByZWxvYWRpbmcgKG9yIG9uIHJlcGxhY2luZyB0aGUgcmVkdWNlcnMpLiBBdmFpbGFibGUgb25seSBmb3IgUmVkdXggZW5oYW5jZXIuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICovXHJcbiAgc2hvdWxkSG90UmVsb2FkPzogYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIGlmIHNwZWNpZmllZCBhcyBgdHJ1ZWAsIHdoZW5ldmVyIHRoZXJlJ3MgYW4gZXhjZXB0aW9uIGluIHJlZHVjZXJzLCB0aGUgbW9uaXRvcnMgd2lsbCBzaG93IHRoZSBlcnJvciBtZXNzYWdlLCBhbmQgbmV4dCBhY3Rpb25zIHdpbGwgbm90IGJlIGRpc3BhdGNoZWQuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAqL1xyXG4gIHNob3VsZENhdGNoRXJyb3JzPzogYm9vbGVhblxyXG4gIC8qKlxyXG4gICAqIElmIHlvdSB3YW50IHRvIHJlc3RyaWN0IHRoZSBleHRlbnNpb24sIHNwZWNpZnkgdGhlIGZlYXR1cmVzIHlvdSBhbGxvdy5cclxuICAgKiBJZiBub3Qgc3BlY2lmaWVkLCBhbGwgb2YgdGhlIGZlYXR1cmVzIGFyZSBlbmFibGVkLiBXaGVuIHNldCBhcyBhbiBvYmplY3QsIG9ubHkgdGhvc2UgaW5jbHVkZWQgYXMgYHRydWVgIHdpbGwgYmUgYWxsb3dlZC5cclxuICAgKiBOb3RlIHRoYXQgZXhjZXB0IGB0cnVlYC9gZmFsc2VgLCBgaW1wb3J0YCBhbmQgYGV4cG9ydGAgY2FuIGJlIHNldCBhcyBgY3VzdG9tYCAod2hpY2ggaXMgYnkgZGVmYXVsdCBmb3IgUmVkdXggZW5oYW5jZXIpLCBtZWFuaW5nIHRoYXQgdGhlIGltcG9ydGluZy9leHBvcnRpbmcgb2NjdXJzIG9uIHRoZSBjbGllbnQgc2lkZS5cclxuICAgKiBPdGhlcndpc2UsIHlvdSdsbCBnZXQvc2V0IHRoZSBkYXRhIHJpZ2h0IGZyb20gdGhlIG1vbml0b3IgcGFydC5cclxuICAgKi9cclxuICBmZWF0dXJlcz86IHtcclxuICAgIC8qKlxyXG4gICAgICogc3RhcnQvcGF1c2UgcmVjb3JkaW5nIG9mIGRpc3BhdGNoZWQgYWN0aW9uc1xyXG4gICAgICovXHJcbiAgICBwYXVzZT86IGJvb2xlYW5cclxuICAgIC8qKlxyXG4gICAgICogbG9jay91bmxvY2sgZGlzcGF0Y2hpbmcgYWN0aW9ucyBhbmQgc2lkZSBlZmZlY3RzXHJcbiAgICAgKi9cclxuICAgIGxvY2s/OiBib29sZWFuXHJcbiAgICAvKipcclxuICAgICAqIHBlcnNpc3Qgc3RhdGVzIG9uIHBhZ2UgcmVsb2FkaW5nXHJcbiAgICAgKi9cclxuICAgIHBlcnNpc3Q/OiBib29sZWFuXHJcbiAgICAvKipcclxuICAgICAqIGV4cG9ydCBoaXN0b3J5IG9mIGFjdGlvbnMgaW4gYSBmaWxlXHJcbiAgICAgKi9cclxuICAgIGV4cG9ydD86IGJvb2xlYW4gfCAnY3VzdG9tJ1xyXG4gICAgLyoqXHJcbiAgICAgKiBpbXBvcnQgaGlzdG9yeSBvZiBhY3Rpb25zIGZyb20gYSBmaWxlXHJcbiAgICAgKi9cclxuICAgIGltcG9ydD86IGJvb2xlYW4gfCAnY3VzdG9tJ1xyXG4gICAgLyoqXHJcbiAgICAgKiBqdW1wIGJhY2sgYW5kIGZvcnRoICh0aW1lIHRyYXZlbGxpbmcpXHJcbiAgICAgKi9cclxuICAgIGp1bXA/OiBib29sZWFuXHJcbiAgICAvKipcclxuICAgICAqIHNraXAgKGNhbmNlbCkgYWN0aW9uc1xyXG4gICAgICovXHJcbiAgICBza2lwPzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBkcmFnIGFuZCBkcm9wIGFjdGlvbnMgaW4gdGhlIGhpc3RvcnkgbGlzdFxyXG4gICAgICovXHJcbiAgICByZW9yZGVyPzogYm9vbGVhblxyXG4gICAgLyoqXHJcbiAgICAgKiBkaXNwYXRjaCBjdXN0b20gYWN0aW9ucyBvciBhY3Rpb24gY3JlYXRvcnNcclxuICAgICAqL1xyXG4gICAgZGlzcGF0Y2g/OiBib29sZWFuXHJcbiAgICAvKipcclxuICAgICAqIGdlbmVyYXRlIHRlc3RzIGZvciB0aGUgc2VsZWN0ZWQgYWN0aW9uc1xyXG4gICAgICovXHJcbiAgICB0ZXN0PzogYm9vbGVhblxyXG4gIH1cclxuICAvKipcclxuICAgKiBTZXQgdG8gdHJ1ZSBvciBhIHN0YWNrdHJhY2UtcmV0dXJuaW5nIGZ1bmN0aW9uIHRvIHJlY29yZCBjYWxsIHN0YWNrIHRyYWNlcyBmb3IgZGlzcGF0Y2hlZCBhY3Rpb25zLlxyXG4gICAqIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gICAqL1xyXG4gIHRyYWNlPzogYm9vbGVhbiB8ICg8QSBleHRlbmRzIEFjdGlvbj4oYWN0aW9uOiBBKSA9PiBzdHJpbmcpXHJcbiAgLyoqXHJcbiAgICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHN0YWNrIHRyYWNlIGVudHJpZXMgdG8gcmVjb3JkIHBlciBhY3Rpb24uIERlZmF1bHRzIHRvIDEwLlxyXG4gICAqL1xyXG4gIHRyYWNlTGltaXQ/OiBudW1iZXJcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjb25zdCBjb21wb3NlV2l0aERldlRvb2xzOiB7XHJcbiAgKG9wdGlvbnM6IEVuaGFuY2VyT3B0aW9ucyk6IHR5cGVvZiBjb21wb3NlXHJcbiAgPFN0b3JlRXh0PiguLi5mdW5jczogQXJyYXk8U3RvcmVFbmhhbmNlcjxTdG9yZUV4dD4+KTogU3RvcmVFbmhhbmNlcjxTdG9yZUV4dD5cclxufSA9XHJcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAod2luZG93IGFzIGFueSkuX19SRURVWF9ERVZUT09MU19FWFRFTlNJT05fQ09NUE9TRV9fXHJcbiAgICA/ICh3aW5kb3cgYXMgYW55KS5fX1JFRFVYX0RFVlRPT0xTX0VYVEVOU0lPTl9DT01QT1NFX19cclxuICAgIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1bmRlZmluZWRcclxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ29iamVjdCcpIHJldHVybiBjb21wb3NlXHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UuYXBwbHkobnVsbCwgKGFyZ3VtZW50cyBhcyBhbnkpIGFzIEZ1bmN0aW9uW10pXHJcbiAgICAgIH1cclxuXHJcbi8qKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGV2VG9vbHNFbmhhbmNlcjoge1xyXG4gIChvcHRpb25zOiBFbmhhbmNlck9wdGlvbnMpOiBTdG9yZUVuaGFuY2VyPGFueT5cclxufSA9XHJcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyBhcyBhbnkpLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX19cclxuICAgID8gKHdpbmRvdyBhcyBhbnkpLl9fUkVEVVhfREVWVE9PTFNfRVhURU5TSU9OX19cclxuICAgIDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vb3ApIHtcclxuICAgICAgICAgIHJldHVybiBub29wXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhc3NlZCB2YWx1ZSBpcyBcInBsYWluXCIgb2JqZWN0LCBpLmUuIGFuIG9iamVjdCB3aG9zZVxyXG4gKiBwcm90b3lwZSBpcyB0aGUgcm9vdCBgT2JqZWN0LnByb3RvdHlwZWAuIFRoaXMgaW5jbHVkZXMgb2JqZWN0cyBjcmVhdGVkXHJcbiAqIHVzaW5nIG9iamVjdCBsaXRlcmFscywgYnV0IG5vdCBmb3IgaW5zdGFuY2UgZm9yIGNsYXNzIGluc3RhbmNlcy5cclxuICpcclxuICogQHBhcmFtIHthbnl9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhIHBsYWluIG9iamVjdC5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBvYmplY3Qge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSByZXR1cm4gZmFsc2VcclxuXHJcbiAgbGV0IHByb3RvID0gdmFsdWVcclxuICB3aGlsZSAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKSAhPT0gbnVsbCkge1xyXG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pXHJcbiAgfVxyXG5cclxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKSA9PT0gcHJvdG9cclxufVxyXG4iLCJpbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZU1lYXN1cmVVdGlscyhtYXhEZWxheTogbnVtYmVyLCBmbk5hbWU6IHN0cmluZykge1xyXG4gIGxldCBlbGFwc2VkID0gMFxyXG4gIHJldHVybiB7XHJcbiAgICBtZWFzdXJlVGltZTxUPihmbjogKCkgPT4gVCk6IFQge1xyXG4gICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKVxyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBmbigpXHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgY29uc3QgZmluaXNoZWQgPSBEYXRlLm5vdygpXHJcbiAgICAgICAgZWxhcHNlZCArPSBmaW5pc2hlZCAtIHN0YXJ0ZWRcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdhcm5JZkV4Y2VlZGVkKCkge1xyXG4gICAgICBpZiAoZWxhcHNlZCA+IG1heERlbGF5KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGAke2ZuTmFtZX0gdG9vayAke2VsYXBzZWR9bXMsIHdoaWNoIGlzIG1vcmUgdGhhbiB0aGUgd2FybmluZyB0aHJlc2hvbGQgb2YgJHttYXhEZWxheX1tcy4gXHJcbklmIHlvdXIgc3RhdGUgb3IgYWN0aW9ucyBhcmUgdmVyeSBsYXJnZSwgeW91IG1heSB3YW50IHRvIGRpc2FibGUgdGhlIG1pZGRsZXdhcmUgYXMgaXQgbWlnaHQgY2F1c2UgdG9vIG11Y2ggb2YgYSBzbG93ZG93biBpbiBkZXZlbG9wbWVudCBtb2RlLiBTZWUgaHR0cHM6Ly9yZWR1eC10b29sa2l0LmpzLm9yZy9hcGkvZ2V0RGVmYXVsdE1pZGRsZXdhcmUgZm9yIGluc3RydWN0aW9ucy5cclxuSXQgaXMgZGlzYWJsZWQgaW4gcHJvZHVjdGlvbiBidWlsZHMsIHNvIHlvdSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuYClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBNaWRkbGV3YXJlQXJyYXk8XHJcbiAgTWlkZGxld2FyZXMgZXh0ZW5kcyBNaWRkbGV3YXJlPGFueSwgYW55PlxyXG4+IGV4dGVuZHMgQXJyYXk8TWlkZGxld2FyZXM+IHtcclxuICBjb25jYXQ8QWRkaXRpb25hbE1pZGRsZXdhcmVzIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxNaWRkbGV3YXJlPGFueSwgYW55Pj4+KFxyXG4gICAgaXRlbXM6IEFkZGl0aW9uYWxNaWRkbGV3YXJlc1xyXG4gICk6IE1pZGRsZXdhcmVBcnJheTxNaWRkbGV3YXJlcyB8IEFkZGl0aW9uYWxNaWRkbGV3YXJlc1tudW1iZXJdPlxyXG5cclxuICBjb25jYXQ8QWRkaXRpb25hbE1pZGRsZXdhcmVzIGV4dGVuZHMgUmVhZG9ubHlBcnJheTxNaWRkbGV3YXJlPGFueSwgYW55Pj4+KFxyXG4gICAgLi4uaXRlbXM6IEFkZGl0aW9uYWxNaWRkbGV3YXJlc1xyXG4gICk6IE1pZGRsZXdhcmVBcnJheTxNaWRkbGV3YXJlcyB8IEFkZGl0aW9uYWxNaWRkbGV3YXJlc1tudW1iZXJdPlxyXG5cclxuICBjb25jYXQoLi4uYXJyOiBhbnlbXSkge1xyXG4gICAgcmV0dXJuIG5ldyBNaWRkbGV3YXJlQXJyYXkoLi4uc3VwZXIuY29uY2F0KC4uLmFycikpXHJcbiAgfVxyXG5cclxuICBwcmVwZW5kPEFkZGl0aW9uYWxNaWRkbGV3YXJlcyBleHRlbmRzIFJlYWRvbmx5QXJyYXk8TWlkZGxld2FyZTxhbnksIGFueT4+PihcclxuICAgIGl0ZW1zOiBBZGRpdGlvbmFsTWlkZGxld2FyZXNcclxuICApOiBNaWRkbGV3YXJlQXJyYXk8QWRkaXRpb25hbE1pZGRsZXdhcmVzW251bWJlcl0gfCBNaWRkbGV3YXJlcz5cclxuXHJcbiAgcHJlcGVuZDxBZGRpdGlvbmFsTWlkZGxld2FyZXMgZXh0ZW5kcyBSZWFkb25seUFycmF5PE1pZGRsZXdhcmU8YW55LCBhbnk+Pj4oXHJcbiAgICAuLi5pdGVtczogQWRkaXRpb25hbE1pZGRsZXdhcmVzXHJcbiAgKTogTWlkZGxld2FyZUFycmF5PEFkZGl0aW9uYWxNaWRkbGV3YXJlc1tudW1iZXJdIHwgTWlkZGxld2FyZXM+XHJcblxyXG4gIHByZXBlbmQoLi4uYXJyOiBhbnlbXSkge1xyXG4gICAgaWYgKGFyci5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJbMF0pKSB7XHJcbiAgICAgIHJldHVybiBuZXcgTWlkZGxld2FyZUFycmF5KC4uLmFyclswXS5jb25jYXQodGhpcykpXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IE1pZGRsZXdhcmVBcnJheSguLi5hcnIuY29uY2F0KHRoaXMpKVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7IGdldFRpbWVNZWFzdXJlVXRpbHMgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxudHlwZSBFbnRyeVByb2Nlc3NvciA9IChrZXk6IHN0cmluZywgdmFsdWU6IGFueSkgPT4gYW55XHJcblxyXG5jb25zdCBpc1Byb2R1Y3Rpb246IGJvb2xlYW4gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nXHJcbmNvbnN0IHByZWZpeDogc3RyaW5nID0gJ0ludmFyaWFudCBmYWlsZWQnXHJcblxyXG4vLyBUaHJvdyBhbiBlcnJvciBpZiB0aGUgY29uZGl0aW9uIGZhaWxzXHJcbi8vIFN0cmlwIG91dCBlcnJvciBtZXNzYWdlcyBmb3IgcHJvZHVjdGlvblxyXG4vLyA+IE5vdCBwcm92aWRpbmcgYW4gaW5saW5lIGRlZmF1bHQgYXJndW1lbnQgZm9yIG1lc3NhZ2UgYXMgdGhlIHJlc3VsdCBpcyBzbWFsbGVyXHJcbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb246IGFueSwgbWVzc2FnZT86IHN0cmluZykge1xyXG4gIGlmIChjb25kaXRpb24pIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICAvLyBDb25kaXRpb24gbm90IHBhc3NlZFxyXG5cclxuICAvLyBJbiBwcm9kdWN0aW9uIHdlIHN0cmlwIHRoZSBtZXNzYWdlIGJ1dCBzdGlsbCB0aHJvd1xyXG4gIGlmIChpc1Byb2R1Y3Rpb24pIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihwcmVmaXgpXHJcbiAgfVxyXG5cclxuICAvLyBXaGVuIG5vdCBpbiBwcm9kdWN0aW9uIHdlIGFsbG93IHRoZSBtZXNzYWdlIHRvIHBhc3MgdGhyb3VnaFxyXG4gIC8vICpUaGlzIGJsb2NrIHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uIGJ1aWxkcypcclxuICB0aHJvdyBuZXcgRXJyb3IoYCR7cHJlZml4fTogJHttZXNzYWdlIHx8ICcnfWApXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeShcclxuICBvYmo6IGFueSxcclxuICBzZXJpYWxpemVyPzogRW50cnlQcm9jZXNzb3IsXHJcbiAgaW5kZW50Pzogc3RyaW5nIHwgbnVtYmVyLFxyXG4gIGRlY3ljbGVyPzogRW50cnlQcm9jZXNzb3JcclxuKTogc3RyaW5nIHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBnZXRTZXJpYWxpemUoc2VyaWFsaXplciwgZGVjeWNsZXIpLCBpbmRlbnQpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFNlcmlhbGl6ZShcclxuICBzZXJpYWxpemVyPzogRW50cnlQcm9jZXNzb3IsXHJcbiAgZGVjeWNsZXI/OiBFbnRyeVByb2Nlc3NvclxyXG4pOiBFbnRyeVByb2Nlc3NvciB7XHJcbiAgbGV0IHN0YWNrOiBhbnlbXSA9IFtdLFxyXG4gICAga2V5czogYW55W10gPSBbXVxyXG5cclxuICBpZiAoIWRlY3ljbGVyKVxyXG4gICAgZGVjeWNsZXIgPSBmdW5jdGlvbihfOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcclxuICAgICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuICdbQ2lyY3VsYXIgfl0nXHJcbiAgICAgIHJldHVybiAoXHJcbiAgICAgICAgJ1tDaXJjdWxhciB+LicgKyBrZXlzLnNsaWNlKDAsIHN0YWNrLmluZGV4T2YodmFsdWUpKS5qb2luKCcuJykgKyAnXSdcclxuICAgICAgKVxyXG4gICAgfVxyXG5cclxuICByZXR1cm4gZnVuY3Rpb24odGhpczogYW55LCBrZXk6IHN0cmluZywgdmFsdWU6IGFueSkge1xyXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcclxuICAgICAgdmFyIHRoaXNQb3MgPSBzdGFjay5pbmRleE9mKHRoaXMpXHJcbiAgICAgIH50aGlzUG9zID8gc3RhY2suc3BsaWNlKHRoaXNQb3MgKyAxKSA6IHN0YWNrLnB1c2godGhpcylcclxuICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpXHJcbiAgICAgIGlmICh+c3RhY2suaW5kZXhPZih2YWx1ZSkpIHZhbHVlID0gZGVjeWNsZXIhLmNhbGwodGhpcywga2V5LCB2YWx1ZSlcclxuICAgIH0gZWxzZSBzdGFjay5wdXNoKHZhbHVlKVxyXG5cclxuICAgIHJldHVybiBzZXJpYWxpemVyID09IG51bGwgPyB2YWx1ZSA6IHNlcmlhbGl6ZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKVxyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGBpc0ltbXV0YWJsZWAgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0ltbXV0YWJsZURlZmF1bHQodmFsdWU6IHVua25vd24pOiBib29sZWFuIHtcclxuICByZXR1cm4gKFxyXG4gICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXHJcbiAgKVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdHJhY2tGb3JNdXRhdGlvbnMoXHJcbiAgaXNJbW11dGFibGU6IElzSW1tdXRhYmxlRnVuYyxcclxuICBpZ25vcmVQYXRoczogc3RyaW5nW10gfCB1bmRlZmluZWQsXHJcbiAgb2JqOiBhbnlcclxuKSB7XHJcbiAgY29uc3QgdHJhY2tlZFByb3BlcnRpZXMgPSB0cmFja1Byb3BlcnRpZXMoaXNJbW11dGFibGUsIGlnbm9yZVBhdGhzLCBvYmopXHJcbiAgcmV0dXJuIHtcclxuICAgIGRldGVjdE11dGF0aW9ucygpIHtcclxuICAgICAgcmV0dXJuIGRldGVjdE11dGF0aW9ucyhpc0ltbXV0YWJsZSwgaWdub3JlUGF0aHMsIHRyYWNrZWRQcm9wZXJ0aWVzLCBvYmopXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5pbnRlcmZhY2UgVHJhY2tlZFByb3BlcnR5IHtcclxuICB2YWx1ZTogYW55XHJcbiAgY2hpbGRyZW46IFJlY29yZDxzdHJpbmcsIGFueT5cclxufVxyXG5cclxuZnVuY3Rpb24gdHJhY2tQcm9wZXJ0aWVzKFxyXG4gIGlzSW1tdXRhYmxlOiBJc0ltbXV0YWJsZUZ1bmMsXHJcbiAgaWdub3JlUGF0aHM6IElnbm9yZVBhdGhzID0gW10sXHJcbiAgb2JqOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxyXG4gIHBhdGg6IHN0cmluZ1tdID0gW11cclxuKSB7XHJcbiAgY29uc3QgdHJhY2tlZDogUGFydGlhbDxUcmFja2VkUHJvcGVydHk+ID0geyB2YWx1ZTogb2JqIH1cclxuXHJcbiAgaWYgKCFpc0ltbXV0YWJsZShvYmopKSB7XHJcbiAgICB0cmFja2VkLmNoaWxkcmVuID0ge31cclxuXHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcclxuICAgICAgY29uc3QgY2hpbGRQYXRoID0gcGF0aC5jb25jYXQoa2V5KVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgaWdub3JlUGF0aHMubGVuZ3RoICYmXHJcbiAgICAgICAgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGguam9pbignLicpKSAhPT0gLTFcclxuICAgICAgKSB7XHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG5cclxuICAgICAgdHJhY2tlZC5jaGlsZHJlbltrZXldID0gdHJhY2tQcm9wZXJ0aWVzKFxyXG4gICAgICAgIGlzSW1tdXRhYmxlLFxyXG4gICAgICAgIGlnbm9yZVBhdGhzLFxyXG4gICAgICAgIG9ialtrZXldLFxyXG4gICAgICAgIGNoaWxkUGF0aFxyXG4gICAgICApXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0cmFja2VkIGFzIFRyYWNrZWRQcm9wZXJ0eVxyXG59XHJcblxyXG50eXBlIElnbm9yZVBhdGhzID0gc3RyaW5nW11cclxuXHJcbmZ1bmN0aW9uIGRldGVjdE11dGF0aW9ucyhcclxuICBpc0ltbXV0YWJsZTogSXNJbW11dGFibGVGdW5jLFxyXG4gIGlnbm9yZVBhdGhzOiBJZ25vcmVQYXRocyA9IFtdLFxyXG4gIHRyYWNrZWRQcm9wZXJ0eTogVHJhY2tlZFByb3BlcnR5LFxyXG4gIG9iajogYW55LFxyXG4gIHNhbWVQYXJlbnRSZWY6IGJvb2xlYW4gPSBmYWxzZSxcclxuICBwYXRoOiBzdHJpbmdbXSA9IFtdXHJcbik6IHsgd2FzTXV0YXRlZDogYm9vbGVhbjsgcGF0aD86IHN0cmluZ1tdIH0ge1xyXG4gIGNvbnN0IHByZXZPYmogPSB0cmFja2VkUHJvcGVydHkgPyB0cmFja2VkUHJvcGVydHkudmFsdWUgOiB1bmRlZmluZWRcclxuXHJcbiAgY29uc3Qgc2FtZVJlZiA9IHByZXZPYmogPT09IG9ialxyXG5cclxuICBpZiAoc2FtZVBhcmVudFJlZiAmJiAhc2FtZVJlZiAmJiAhTnVtYmVyLmlzTmFOKG9iaikpIHtcclxuICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IHRydWUsIHBhdGggfVxyXG4gIH1cclxuXHJcbiAgaWYgKGlzSW1tdXRhYmxlKHByZXZPYmopIHx8IGlzSW1tdXRhYmxlKG9iaikpIHtcclxuICAgIHJldHVybiB7IHdhc011dGF0ZWQ6IGZhbHNlIH1cclxuICB9XHJcblxyXG4gIC8vIEdhdGhlciBhbGwga2V5cyBmcm9tIHByZXYgKHRyYWNrZWQpIGFuZCBhZnRlciBvYmpzXHJcbiAgY29uc3Qga2V5c1RvRGV0ZWN0OiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9XHJcbiAgT2JqZWN0LmtleXModHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBrZXlzVG9EZXRlY3Rba2V5XSA9IHRydWVcclxuICB9KVxyXG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChrZXkgPT4ge1xyXG4gICAga2V5c1RvRGV0ZWN0W2tleV0gPSB0cnVlXHJcbiAgfSlcclxuXHJcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGtleXNUb0RldGVjdClcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cclxuICAgIGNvbnN0IGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGtleSlcclxuICAgIGlmIChpZ25vcmVQYXRocy5sZW5ndGggJiYgaWdub3JlUGF0aHMuaW5kZXhPZihjaGlsZFBhdGguam9pbignLicpKSAhPT0gLTEpIHtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBkZXRlY3RNdXRhdGlvbnMoXHJcbiAgICAgIGlzSW1tdXRhYmxlLFxyXG4gICAgICBpZ25vcmVQYXRocyxcclxuICAgICAgdHJhY2tlZFByb3BlcnR5LmNoaWxkcmVuW2tleV0sXHJcbiAgICAgIG9ialtrZXldLFxyXG4gICAgICBzYW1lUmVmLFxyXG4gICAgICBjaGlsZFBhdGhcclxuICAgIClcclxuXHJcbiAgICBpZiAocmVzdWx0Lndhc011dGF0ZWQpIHtcclxuICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4geyB3YXNNdXRhdGVkOiBmYWxzZSB9XHJcbn1cclxuXHJcbnR5cGUgSXNJbW11dGFibGVGdW5jID0gKHZhbHVlOiBhbnkpID0+IGJvb2xlYW5cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKClgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gY2hlY2sgaWYgYSB2YWx1ZSBpcyBjb25zaWRlcmVkIHRvIGJlIGltbXV0YWJsZS5cclxuICAgIFRoaXMgZnVuY3Rpb24gaXMgYXBwbGllZCByZWN1cnNpdmVseSB0byBldmVyeSB2YWx1ZSBjb250YWluZWQgaW4gdGhlIHN0YXRlLlxyXG4gICAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCByZXR1cm4gdHJ1ZSBmb3IgcHJpbWl0aXZlIHR5cGVzIFxyXG4gICAgKGxpa2UgbnVtYmVycywgc3RyaW5ncywgYm9vbGVhbnMsIG51bGwgYW5kIHVuZGVmaW5lZCkuXHJcbiAgICovXHJcbiAgaXNJbW11dGFibGU/OiBJc0ltbXV0YWJsZUZ1bmNcclxuICAvKiogXHJcbiAgICBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyB0aGF0IG1hdGNoIG5hbWVkIG5vZGVzIGZyb20gXHJcbiAgICB0aGUgcm9vdCBzdGF0ZSB0byBpZ25vcmUgd2hlbiBjaGVja2luZyBmb3IgaW1tdXRhYmlsaXR5LlxyXG4gICAgRGVmYXVsdHMgdG8gdW5kZWZpbmVkXHJcbiAgICovXHJcbiAgaWdub3JlZFBhdGhzPzogc3RyaW5nW11cclxuICAvKiogUHJpbnQgYSB3YXJuaW5nIGlmIGNoZWNrcyB0YWtlIGxvbmdlciB0aGFuIE4gbXMuIERlZmF1bHQ6IDMybXMgKi9cclxuICB3YXJuQWZ0ZXI/OiBudW1iZXJcclxuICAvLyBAZGVwcmVjYXRlZC4gVXNlIGlnbm9yZWRQYXRoc1xyXG4gIGlnbm9yZT86IHN0cmluZ1tdXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWlkZGxld2FyZSB0aGF0IGNoZWNrcyB3aGV0aGVyIGFueSBzdGF0ZSB3YXMgbXV0YXRlZCBpbiBiZXR3ZWVuXHJcbiAqIGRpc3BhdGNoZXMgb3IgZHVyaW5nIGEgZGlzcGF0Y2guIElmIGFueSBtdXRhdGlvbnMgYXJlIGRldGVjdGVkLCBhbiBlcnJvciBpc1xyXG4gKiB0aHJvd24uXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIE1pZGRsZXdhcmUgb3B0aW9ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShcclxuICBvcHRpb25zOiBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge31cclxuKTogTWlkZGxld2FyZSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiBuZXh0KGFjdGlvbilcclxuICB9XHJcblxyXG4gIGxldCB7XHJcbiAgICBpc0ltbXV0YWJsZSA9IGlzSW1tdXRhYmxlRGVmYXVsdCxcclxuICAgIGlnbm9yZWRQYXRocyxcclxuICAgIHdhcm5BZnRlciA9IDMyLFxyXG4gICAgaWdub3JlXHJcbiAgfSA9IG9wdGlvbnNcclxuXHJcbiAgLy8gQWxpYXMgaWdub3JlLT5pZ25vcmVkUGF0aHMsIGJ1dCBwcmVmZXIgaWdub3JlZFBhdGhzIGlmIHByZXNlbnRcclxuICBpZ25vcmVkUGF0aHMgPSBpZ25vcmVkUGF0aHMgfHwgaWdub3JlXHJcblxyXG4gIGNvbnN0IHRyYWNrID0gdHJhY2tGb3JNdXRhdGlvbnMuYmluZChudWxsLCBpc0ltbXV0YWJsZSwgaWdub3JlZFBhdGhzKVxyXG5cclxuICByZXR1cm4gKHsgZ2V0U3RhdGUgfSkgPT4ge1xyXG4gICAgbGV0IHN0YXRlID0gZ2V0U3RhdGUoKVxyXG4gICAgbGV0IHRyYWNrZXIgPSB0cmFjayhzdGF0ZSlcclxuXHJcbiAgICBsZXQgcmVzdWx0XHJcbiAgICByZXR1cm4gbmV4dCA9PiBhY3Rpb24gPT4ge1xyXG4gICAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKFxyXG4gICAgICAgIHdhcm5BZnRlcixcclxuICAgICAgICAnSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG4gICAgICApXHJcblxyXG4gICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKVxyXG5cclxuICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpXHJcbiAgICAgICAgLy8gVHJhY2sgYmVmb3JlIHBvdGVudGlhbGx5IG5vdCBtZWV0aW5nIHRoZSBpbnZhcmlhbnRcclxuICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpXHJcblxyXG4gICAgICAgIGludmFyaWFudChcclxuICAgICAgICAgICFyZXN1bHQud2FzTXV0YXRlZCxcclxuICAgICAgICAgIGBBIHN0YXRlIG11dGF0aW9uIHdhcyBkZXRlY3RlZCBiZXR3ZWVuIGRpc3BhdGNoZXMsIGluIHRoZSBwYXRoICckeyhcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGggfHwgW11cclxuICAgICAgICAgICkuam9pbihcclxuICAgICAgICAgICAgJy4nXHJcbiAgICAgICAgICApfScuICBUaGlzIG1heSBjYXVzZSBpbmNvcnJlY3QgYmVoYXZpb3IuIChodHRwczovL3JlZHV4LmpzLm9yZy90cm91Ymxlc2hvb3RpbmcjbmV2ZXItbXV0YXRlLXJlZHVjZXItYXJndW1lbnRzKWBcclxuICAgICAgICApXHJcbiAgICAgIH0pXHJcblxyXG4gICAgICBjb25zdCBkaXNwYXRjaGVkQWN0aW9uID0gbmV4dChhY3Rpb24pXHJcblxyXG4gICAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xyXG4gICAgICAgIHN0YXRlID0gZ2V0U3RhdGUoKVxyXG5cclxuICAgICAgICByZXN1bHQgPSB0cmFja2VyLmRldGVjdE11dGF0aW9ucygpXHJcbiAgICAgICAgLy8gVHJhY2sgYmVmb3JlIHBvdGVudGlhbGx5IG5vdCBtZWV0aW5nIHRoZSBpbnZhcmlhbnRcclxuICAgICAgICB0cmFja2VyID0gdHJhY2soc3RhdGUpXHJcblxyXG4gICAgICAgIHJlc3VsdC53YXNNdXRhdGVkICYmXHJcbiAgICAgICAgICBpbnZhcmlhbnQoXHJcbiAgICAgICAgICAgICFyZXN1bHQud2FzTXV0YXRlZCxcclxuICAgICAgICAgICAgYEEgc3RhdGUgbXV0YXRpb24gd2FzIGRldGVjdGVkIGluc2lkZSBhIGRpc3BhdGNoLCBpbiB0aGUgcGF0aDogJHsoXHJcbiAgICAgICAgICAgICAgcmVzdWx0LnBhdGggfHwgW11cclxuICAgICAgICAgICAgKS5qb2luKFxyXG4gICAgICAgICAgICAgICcuJ1xyXG4gICAgICAgICAgICApfS4gVGFrZSBhIGxvb2sgYXQgdGhlIHJlZHVjZXIocykgaGFuZGxpbmcgdGhlIGFjdGlvbiAke3N0cmluZ2lmeShcclxuICAgICAgICAgICAgICBhY3Rpb25cclxuICAgICAgICAgICAgKX0uIChodHRwczovL3JlZHV4LmpzLm9yZy90cm91Ymxlc2hvb3RpbmcjbmV2ZXItbXV0YXRlLXJlZHVjZXItYXJndW1lbnRzKWBcclxuICAgICAgICAgIClcclxuICAgICAgfSlcclxuXHJcbiAgICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpXHJcblxyXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlZEFjdGlvblxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnXHJcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHsgZ2V0VGltZU1lYXN1cmVVdGlscyB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwYXNzZWQgdmFsdWUgaXMgXCJwbGFpblwiLCBpLmUuIGEgdmFsdWUgdGhhdCBpcyBlaXRoZXJcclxuICogZGlyZWN0bHkgSlNPTi1zZXJpYWxpemFibGUgKGJvb2xlYW4sIG51bWJlciwgc3RyaW5nLCBhcnJheSwgcGxhaW4gb2JqZWN0KVxyXG4gKiBvciBgdW5kZWZpbmVkYC5cclxuICpcclxuICogQHBhcmFtIHZhbCBUaGUgdmFsdWUgdG8gY2hlY2suXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluKHZhbDogYW55KSB7XHJcbiAgcmV0dXJuIChcclxuICAgIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnIHx8XHJcbiAgICB2YWwgPT09IG51bGwgfHxcclxuICAgIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8XHJcbiAgICB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicgfHxcclxuICAgIHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8XHJcbiAgICBBcnJheS5pc0FycmF5KHZhbCkgfHxcclxuICAgIGlzUGxhaW5PYmplY3QodmFsKVxyXG4gIClcclxufVxyXG5cclxuaW50ZXJmYWNlIE5vblNlcmlhbGl6YWJsZVZhbHVlIHtcclxuICBrZXlQYXRoOiBzdHJpbmdcclxuICB2YWx1ZTogdW5rbm93blxyXG59XHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcclxuICB2YWx1ZTogdW5rbm93bixcclxuICBwYXRoOiBSZWFkb25seUFycmF5PHN0cmluZz4gPSBbXSxcclxuICBpc1NlcmlhbGl6YWJsZTogKHZhbHVlOiB1bmtub3duKSA9PiBib29sZWFuID0gaXNQbGFpbixcclxuICBnZXRFbnRyaWVzPzogKHZhbHVlOiB1bmtub3duKSA9PiBbc3RyaW5nLCBhbnldW10sXHJcbiAgaWdub3JlZFBhdGhzOiBzdHJpbmdbXSA9IFtdXHJcbik6IE5vblNlcmlhbGl6YWJsZVZhbHVlIHwgZmFsc2Uge1xyXG4gIGxldCBmb3VuZE5lc3RlZFNlcmlhbGl6YWJsZTogTm9uU2VyaWFsaXphYmxlVmFsdWUgfCBmYWxzZVxyXG5cclxuICBpZiAoIWlzU2VyaWFsaXphYmxlKHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAga2V5UGF0aDogcGF0aC5qb2luKCcuJykgfHwgJzxyb290PicsXHJcbiAgICAgIHZhbHVlOiB2YWx1ZVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgdmFsdWUgPT09IG51bGwpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxuXHJcbiAgY29uc3QgZW50cmllcyA9IGdldEVudHJpZXMgIT0gbnVsbCA/IGdldEVudHJpZXModmFsdWUpIDogT2JqZWN0LmVudHJpZXModmFsdWUpXHJcblxyXG4gIGNvbnN0IGhhc0lnbm9yZWRQYXRocyA9IGlnbm9yZWRQYXRocy5sZW5ndGggPiAwXHJcblxyXG4gIGZvciAoY29uc3QgW3Byb3BlcnR5LCBuZXN0ZWRWYWx1ZV0gb2YgZW50cmllcykge1xyXG4gICAgY29uc3QgbmVzdGVkUGF0aCA9IHBhdGguY29uY2F0KHByb3BlcnR5KVxyXG5cclxuICAgIGlmIChoYXNJZ25vcmVkUGF0aHMgJiYgaWdub3JlZFBhdGhzLmluZGV4T2YobmVzdGVkUGF0aC5qb2luKCcuJykpID49IDApIHtcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzU2VyaWFsaXphYmxlKG5lc3RlZFZhbHVlKSkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGtleVBhdGg6IG5lc3RlZFBhdGguam9pbignLicpLFxyXG4gICAgICAgIHZhbHVlOiBuZXN0ZWRWYWx1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiBuZXN0ZWRWYWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm91bmROZXN0ZWRTZXJpYWxpemFibGUgPSBmaW5kTm9uU2VyaWFsaXphYmxlVmFsdWUoXHJcbiAgICAgICAgbmVzdGVkVmFsdWUsXHJcbiAgICAgICAgbmVzdGVkUGF0aCxcclxuICAgICAgICBpc1NlcmlhbGl6YWJsZSxcclxuICAgICAgICBnZXRFbnRyaWVzLFxyXG4gICAgICAgIGlnbm9yZWRQYXRoc1xyXG4gICAgICApXHJcblxyXG4gICAgICBpZiAoZm91bmROZXN0ZWRTZXJpYWxpemFibGUpIHtcclxuICAgICAgICByZXR1cm4gZm91bmROZXN0ZWRTZXJpYWxpemFibGVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZhbHNlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKClgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnMge1xyXG4gIC8qKlxyXG4gICAqIFRoZSBmdW5jdGlvbiB0byBjaGVjayBpZiBhIHZhbHVlIGlzIGNvbnNpZGVyZWQgc2VyaWFsaXphYmxlLiBUaGlzXHJcbiAgICogZnVuY3Rpb24gaXMgYXBwbGllZCByZWN1cnNpdmVseSB0byBldmVyeSB2YWx1ZSBjb250YWluZWQgaW4gdGhlXHJcbiAgICogc3RhdGUuIERlZmF1bHRzIHRvIGBpc1BsYWluKClgLlxyXG4gICAqL1xyXG4gIGlzU2VyaWFsaXphYmxlPzogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW5cclxuICAvKipcclxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmV0cmlldmUgZW50cmllcyBmcm9tIGVhY2hcclxuICAgKiB2YWx1ZS4gIElmIHVuc3BlY2lmaWVkLCBgT2JqZWN0LmVudHJpZXNgIHdpbGwgYmUgdXNlZC4gRGVmYXVsdHNcclxuICAgKiB0byBgdW5kZWZpbmVkYC5cclxuICAgKi9cclxuICBnZXRFbnRyaWVzPzogKHZhbHVlOiBhbnkpID0+IFtzdHJpbmcsIGFueV1bXVxyXG5cclxuICAvKipcclxuICAgKiBBbiBhcnJheSBvZiBhY3Rpb24gdHlwZXMgdG8gaWdub3JlIHdoZW4gY2hlY2tpbmcgZm9yIHNlcmlhbGl6YWJpbGl0eS5cclxuICAgKiBEZWZhdWx0cyB0byBbXVxyXG4gICAqL1xyXG4gIGlnbm9yZWRBY3Rpb25zPzogc3RyaW5nW11cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgZG90LXNlcGFyYXRlZCBwYXRoIHN0cmluZ3MgdG8gaWdub3JlIHdoZW4gY2hlY2tpbmdcclxuICAgKiBmb3Igc2VyaWFsaXphYmlsaXR5LCBEZWZhdWx0cyB0byBbJ21ldGEuYXJnJ11cclxuICAgKi9cclxuICBpZ25vcmVkQWN0aW9uUGF0aHM/OiBzdHJpbmdbXVxyXG5cclxuICAvKipcclxuICAgKiBBbiBhcnJheSBvZiBkb3Qtc2VwYXJhdGVkIHBhdGggc3RyaW5ncyB0byBpZ25vcmUgd2hlbiBjaGVja2luZ1xyXG4gICAqIGZvciBzZXJpYWxpemFiaWxpdHksIERlZmF1bHRzIHRvIFtdXHJcbiAgICovXHJcbiAgaWdub3JlZFBhdGhzPzogc3RyaW5nW11cclxuICAvKipcclxuICAgKiBFeGVjdXRpb24gdGltZSB3YXJuaW5nIHRocmVzaG9sZC4gSWYgdGhlIG1pZGRsZXdhcmUgdGFrZXMgbG9uZ2VyXHJcbiAgICogdGhhbiBgd2FybkFmdGVyYCBtcywgYSB3YXJuaW5nIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBjb25zb2xlLlxyXG4gICAqIERlZmF1bHRzIHRvIDMybXMuXHJcbiAgICovXHJcbiAgd2FybkFmdGVyPzogbnVtYmVyXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWlkZGxld2FyZSB0aGF0LCBhZnRlciBldmVyeSBzdGF0ZSBjaGFuZ2UsIGNoZWNrcyBpZiB0aGUgbmV3XHJcbiAqIHN0YXRlIGlzIHNlcmlhbGl6YWJsZS4gSWYgYSBub24tc2VyaWFsaXphYmxlIHZhbHVlIGlzIGZvdW5kIHdpdGhpbiB0aGVcclxuICogc3RhdGUsIGFuIGVycm9yIGlzIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zIE1pZGRsZXdhcmUgb3B0aW9ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZShcclxuICBvcHRpb25zOiBTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge31cclxuKTogTWlkZGxld2FyZSB7XHJcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcclxuICAgIHJldHVybiAoKSA9PiBuZXh0ID0+IGFjdGlvbiA9PiBuZXh0KGFjdGlvbilcclxuICB9XHJcbiAgY29uc3Qge1xyXG4gICAgaXNTZXJpYWxpemFibGUgPSBpc1BsYWluLFxyXG4gICAgZ2V0RW50cmllcyxcclxuICAgIGlnbm9yZWRBY3Rpb25zID0gW10sXHJcbiAgICBpZ25vcmVkQWN0aW9uUGF0aHMgPSBbJ21ldGEuYXJnJ10sXHJcbiAgICBpZ25vcmVkUGF0aHMgPSBbXSxcclxuICAgIHdhcm5BZnRlciA9IDMyXHJcbiAgfSA9IG9wdGlvbnNcclxuXHJcbiAgcmV0dXJuIHN0b3JlQVBJID0+IG5leHQgPT4gYWN0aW9uID0+IHtcclxuICAgIGlmIChpZ25vcmVkQWN0aW9ucy5sZW5ndGggJiYgaWdub3JlZEFjdGlvbnMuaW5kZXhPZihhY3Rpb24udHlwZSkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBuZXh0KGFjdGlvbilcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBtZWFzdXJlVXRpbHMgPSBnZXRUaW1lTWVhc3VyZVV0aWxzKFxyXG4gICAgICB3YXJuQWZ0ZXIsXHJcbiAgICAgICdTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnXHJcbiAgICApXHJcbiAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBmb3VuZEFjdGlvbk5vblNlcmlhbGl6YWJsZVZhbHVlID0gZmluZE5vblNlcmlhbGl6YWJsZVZhbHVlKFxyXG4gICAgICAgIGFjdGlvbixcclxuICAgICAgICBbXSxcclxuICAgICAgICBpc1NlcmlhbGl6YWJsZSxcclxuICAgICAgICBnZXRFbnRyaWVzLFxyXG4gICAgICAgIGlnbm9yZWRBY3Rpb25QYXRoc1xyXG4gICAgICApXHJcblxyXG4gICAgICBpZiAoZm91bmRBY3Rpb25Ob25TZXJpYWxpemFibGVWYWx1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsga2V5UGF0aCwgdmFsdWUgfSA9IGZvdW5kQWN0aW9uTm9uU2VyaWFsaXphYmxlVmFsdWVcclxuXHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgIGBBIG5vbi1zZXJpYWxpemFibGUgdmFsdWUgd2FzIGRldGVjdGVkIGluIGFuIGFjdGlvbiwgaW4gdGhlIHBhdGg6IFxcYCR7a2V5UGF0aH1cXGAuIFZhbHVlOmAsXHJcbiAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICdcXG5UYWtlIGEgbG9vayBhdCB0aGUgbG9naWMgdGhhdCBkaXNwYXRjaGVkIHRoaXMgYWN0aW9uOiAnLFxyXG4gICAgICAgICAgYWN0aW9uLFxyXG4gICAgICAgICAgJ1xcbihTZWUgaHR0cHM6Ly9yZWR1eC5qcy5vcmcvZmFxL2FjdGlvbnMjd2h5LXNob3VsZC10eXBlLWJlLWEtc3RyaW5nLW9yLWF0LWxlYXN0LXNlcmlhbGl6YWJsZS13aHktc2hvdWxkLW15LWFjdGlvbi10eXBlcy1iZS1jb25zdGFudHMpJyxcclxuICAgICAgICAgICdcXG4oVG8gYWxsb3cgbm9uLXNlcmlhbGl6YWJsZSB2YWx1ZXMgc2VlOiBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3VzYWdlL3VzYWdlLWd1aWRlI3dvcmtpbmctd2l0aC1ub24tc2VyaWFsaXphYmxlLWRhdGEpJ1xyXG4gICAgICAgIClcclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICBjb25zdCByZXN1bHQgPSBuZXh0KGFjdGlvbilcclxuXHJcbiAgICBtZWFzdXJlVXRpbHMubWVhc3VyZVRpbWUoKCkgPT4ge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHN0b3JlQVBJLmdldFN0YXRlKClcclxuXHJcbiAgICAgIGNvbnN0IGZvdW5kU3RhdGVOb25TZXJpYWxpemFibGVWYWx1ZSA9IGZpbmROb25TZXJpYWxpemFibGVWYWx1ZShcclxuICAgICAgICBzdGF0ZSxcclxuICAgICAgICBbXSxcclxuICAgICAgICBpc1NlcmlhbGl6YWJsZSxcclxuICAgICAgICBnZXRFbnRyaWVzLFxyXG4gICAgICAgIGlnbm9yZWRQYXRoc1xyXG4gICAgICApXHJcblxyXG4gICAgICBpZiAoZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgeyBrZXlQYXRoLCB2YWx1ZSB9ID0gZm91bmRTdGF0ZU5vblNlcmlhbGl6YWJsZVZhbHVlXHJcblxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgICBgQSBub24tc2VyaWFsaXphYmxlIHZhbHVlIHdhcyBkZXRlY3RlZCBpbiB0aGUgc3RhdGUsIGluIHRoZSBwYXRoOiBcXGAke2tleVBhdGh9XFxgLiBWYWx1ZTpgLFxyXG4gICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICBgXHJcblRha2UgYSBsb29rIGF0IHRoZSByZWR1Y2VyKHMpIGhhbmRsaW5nIHRoaXMgYWN0aW9uIHR5cGU6ICR7YWN0aW9uLnR5cGV9LlxyXG4oU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2ZhcS9vcmdhbml6aW5nLXN0YXRlI2Nhbi1pLXB1dC1mdW5jdGlvbnMtcHJvbWlzZXMtb3Itb3RoZXItbm9uLXNlcmlhbGl6YWJsZS1pdGVtcy1pbi1teS1zdG9yZS1zdGF0ZSlgXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIG1lYXN1cmVVdGlscy53YXJuSWZFeGNlZWRlZCgpXHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBNaWRkbGV3YXJlLCBBbnlBY3Rpb24gfSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHRodW5rTWlkZGxld2FyZSwgeyBUaHVua01pZGRsZXdhcmUgfSBmcm9tICdyZWR1eC10aHVuaydcclxuaW1wb3J0IHtcclxuICAvKiBQUk9EX1NUQVJUX1JFTU9WRV9VTUQgKi9cclxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXHJcbiAgLyogUFJPRF9TVE9QX1JFTU9WRV9VTUQgKi9cclxuICBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zXHJcbn0gZnJvbSAnLi9pbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnXHJcblxyXG5pbXBvcnQge1xyXG4gIGNyZWF0ZVNlcmlhbGl6YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZSxcclxuICBTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zXHJcbn0gZnJvbSAnLi9zZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUnXHJcbmltcG9ydCB7IE1pZGRsZXdhcmVBcnJheSB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG5mdW5jdGlvbiBpc0Jvb2xlYW4oeDogYW55KTogeCBpcyBib29sZWFuIHtcclxuICByZXR1cm4gdHlwZW9mIHggPT09ICdib29sZWFuJ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVGh1bmtPcHRpb25zPEUgPSBhbnk+IHtcclxuICBleHRyYUFyZ3VtZW50OiBFXHJcbn1cclxuXHJcbmludGVyZmFjZSBHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnMge1xyXG4gIHRodW5rPzogYm9vbGVhbiB8IFRodW5rT3B0aW9uc1xyXG4gIGltbXV0YWJsZUNoZWNrPzogYm9vbGVhbiB8IEltbXV0YWJsZVN0YXRlSW52YXJpYW50TWlkZGxld2FyZU9wdGlvbnNcclxuICBzZXJpYWxpemFibGVDaGVjaz86IGJvb2xlYW4gfCBTZXJpYWxpemFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRodW5rTWlkZGxld2FyZUZvcjxcclxuICBTLFxyXG4gIE8gZXh0ZW5kcyBHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnMgPSB7fVxyXG4+ID0gTyBleHRlbmRzIHtcclxuICB0aHVuazogZmFsc2VcclxufVxyXG4gID8gbmV2ZXJcclxuICA6IE8gZXh0ZW5kcyB7IHRodW5rOiB7IGV4dHJhQXJndW1lbnQ6IGluZmVyIEUgfSB9XHJcbiAgPyBUaHVua01pZGRsZXdhcmU8UywgQW55QWN0aW9uLCBFPlxyXG4gIDpcclxuICAgICAgfCBUaHVua01pZGRsZXdhcmU8UywgQW55QWN0aW9uLCBudWxsPiAvL1RoZSBUaHVua01pZGRsZXdhcmUgd2l0aCBhIGBudWxsYCBFeHRyYUFyZ3VtZW50IGlzIGhlcmUgdG8gcHJvdmlkZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eS5cclxuICAgICAgfCBUaHVua01pZGRsZXdhcmU8UywgQW55QWN0aW9uPlxyXG5cclxuZXhwb3J0IHR5cGUgQ3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlPFMgPSBhbnk+ID0gPFxyXG4gIE8gZXh0ZW5kcyBQYXJ0aWFsPEdldERlZmF1bHRNaWRkbGV3YXJlT3B0aW9ucz4gPSB7XHJcbiAgICB0aHVuazogdHJ1ZVxyXG4gICAgaW1tdXRhYmxlQ2hlY2s6IHRydWVcclxuICAgIHNlcmlhbGl6YWJsZUNoZWNrOiB0cnVlXHJcbiAgfVxyXG4+KFxyXG4gIG9wdGlvbnM/OiBPXHJcbikgPT4gTWlkZGxld2FyZUFycmF5PE1pZGRsZXdhcmU8e30sIFM+IHwgVGh1bmtNaWRkbGV3YXJlRm9yPFMsIE8+PlxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmU8XHJcbiAgUyA9IGFueVxyXG4+KCk6IEN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZTxTPiB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uIGN1cnJpZWRHZXREZWZhdWx0TWlkZGxld2FyZShvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gZ2V0RGVmYXVsdE1pZGRsZXdhcmUob3B0aW9ucylcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFueSBhcnJheSBjb250YWluaW5nIHRoZSBkZWZhdWx0IG1pZGRsZXdhcmUgaW5zdGFsbGVkIGJ5XHJcbiAqIGBjb25maWd1cmVTdG9yZSgpYC4gVXNlZnVsIGlmIHlvdSB3YW50IHRvIGNvbmZpZ3VyZSB5b3VyIHN0b3JlIHdpdGggYSBjdXN0b21cclxuICogYG1pZGRsZXdhcmVgIGFycmF5IGJ1dCBzdGlsbCBrZWVwIHRoZSBkZWZhdWx0IHNldC5cclxuICpcclxuICogQHJldHVybiBUaGUgZGVmYXVsdCBtaWRkbGV3YXJlIHVzZWQgYnkgYGNvbmZpZ3VyZVN0b3JlKClgLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdE1pZGRsZXdhcmU8XHJcbiAgUyA9IGFueSxcclxuICBPIGV4dGVuZHMgUGFydGlhbDxHZXREZWZhdWx0TWlkZGxld2FyZU9wdGlvbnM+ID0ge1xyXG4gICAgdGh1bms6IHRydWVcclxuICAgIGltbXV0YWJsZUNoZWNrOiB0cnVlXHJcbiAgICBzZXJpYWxpemFibGVDaGVjazogdHJ1ZVxyXG4gIH1cclxuPihcclxuICBvcHRpb25zOiBPID0ge30gYXMgT1xyXG4pOiBNaWRkbGV3YXJlQXJyYXk8TWlkZGxld2FyZTx7fSwgUz4gfCBUaHVua01pZGRsZXdhcmVGb3I8UywgTz4+IHtcclxuICBjb25zdCB7XHJcbiAgICB0aHVuayA9IHRydWUsXHJcbiAgICBpbW11dGFibGVDaGVjayA9IHRydWUsXHJcbiAgICBzZXJpYWxpemFibGVDaGVjayA9IHRydWVcclxuICB9ID0gb3B0aW9uc1xyXG5cclxuICBsZXQgbWlkZGxld2FyZUFycmF5OiBNaWRkbGV3YXJlPHt9LCBTPltdID0gbmV3IE1pZGRsZXdhcmVBcnJheSgpXHJcblxyXG4gIGlmICh0aHVuaykge1xyXG4gICAgaWYgKGlzQm9vbGVhbih0aHVuaykpIHtcclxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2godGh1bmtNaWRkbGV3YXJlKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goXHJcbiAgICAgICAgdGh1bmtNaWRkbGV3YXJlLndpdGhFeHRyYUFyZ3VtZW50KHRodW5rLmV4dHJhQXJndW1lbnQpXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICBpZiAoaW1tdXRhYmxlQ2hlY2spIHtcclxuICAgICAgLyogUFJPRF9TVEFSVF9SRU1PVkVfVU1EICovXHJcbiAgICAgIGxldCBpbW11dGFibGVPcHRpb25zOiBJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmVPcHRpb25zID0ge31cclxuXHJcbiAgICAgIGlmICghaXNCb29sZWFuKGltbXV0YWJsZUNoZWNrKSkge1xyXG4gICAgICAgIGltbXV0YWJsZU9wdGlvbnMgPSBpbW11dGFibGVDaGVja1xyXG4gICAgICB9XHJcblxyXG4gICAgICBtaWRkbGV3YXJlQXJyYXkudW5zaGlmdChcclxuICAgICAgICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUoaW1tdXRhYmxlT3B0aW9ucylcclxuICAgICAgKVxyXG4gICAgICAvKiBQUk9EX1NUT1BfUkVNT1ZFX1VNRCAqL1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXJpYWxpemFibGVDaGVjaykge1xyXG4gICAgICBsZXQgc2VyaWFsaXphYmxlT3B0aW9uczogU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9ucyA9IHt9XHJcblxyXG4gICAgICBpZiAoIWlzQm9vbGVhbihzZXJpYWxpemFibGVDaGVjaykpIHtcclxuICAgICAgICBzZXJpYWxpemFibGVPcHRpb25zID0gc2VyaWFsaXphYmxlQ2hlY2tcclxuICAgICAgfVxyXG5cclxuICAgICAgbWlkZGxld2FyZUFycmF5LnB1c2goXHJcbiAgICAgICAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlKHNlcmlhbGl6YWJsZU9wdGlvbnMpXHJcbiAgICAgIClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBtaWRkbGV3YXJlQXJyYXkgYXMgYW55XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBjcmVhdGVTdG9yZSxcclxuICBjb21wb3NlLFxyXG4gIGFwcGx5TWlkZGxld2FyZSxcclxuICBjb21iaW5lUmVkdWNlcnMsXHJcbiAgUmVkdWNlcixcclxuICBSZWR1Y2Vyc01hcE9iamVjdCxcclxuICBNaWRkbGV3YXJlLFxyXG4gIEFjdGlvbixcclxuICBBbnlBY3Rpb24sXHJcbiAgU3RvcmVFbmhhbmNlcixcclxuICBTdG9yZSxcclxuICBEZWVwUGFydGlhbCxcclxuICBEaXNwYXRjaFxyXG59IGZyb20gJ3JlZHV4J1xyXG5pbXBvcnQge1xyXG4gIGNvbXBvc2VXaXRoRGV2VG9vbHMsXHJcbiAgRW5oYW5jZXJPcHRpb25zIGFzIERldlRvb2xzT3B0aW9uc1xyXG59IGZyb20gJy4vZGV2dG9vbHNFeHRlbnNpb24nXHJcblxyXG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzUGxhaW5PYmplY3QnXHJcbmltcG9ydCB7XHJcbiAgVGh1bmtNaWRkbGV3YXJlRm9yLFxyXG4gIGN1cnJ5R2V0RGVmYXVsdE1pZGRsZXdhcmUsXHJcbiAgQ3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlXHJcbn0gZnJvbSAnLi9nZXREZWZhdWx0TWlkZGxld2FyZSdcclxuaW1wb3J0IHsgRGlzcGF0Y2hGb3JNaWRkbGV3YXJlcyB9IGZyb20gJy4vdHNIZWxwZXJzJ1xyXG5cclxuY29uc3QgSVNfUFJPRFVDVElPTiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcclxuXHJcbi8qKlxyXG4gKiBDYWxsYmFjayBmdW5jdGlvbiB0eXBlLCB0byBiZSB1c2VkIGluIGBDb25maWd1cmVTdG9yZU9wdGlvbnMuZW5oYW5jZXJzYFxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDb25maWd1cmVFbmhhbmNlcnNDYWxsYmFjayA9IChcclxuICBkZWZhdWx0RW5oYW5jZXJzOiBTdG9yZUVuaGFuY2VyW11cclxuKSA9PiBTdG9yZUVuaGFuY2VyW11cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBgY29uZmlndXJlU3RvcmUoKWAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29uZmlndXJlU3RvcmVPcHRpb25zPFxyXG4gIFMgPSBhbnksXHJcbiAgQSBleHRlbmRzIEFjdGlvbiA9IEFueUFjdGlvbixcclxuICBNIGV4dGVuZHMgTWlkZGxld2FyZXM8Uz4gPSBNaWRkbGV3YXJlczxTPlxyXG4+IHtcclxuICAvKipcclxuICAgKiBBIHNpbmdsZSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHRoZSByb290IHJlZHVjZXIsIG9yIGFuXHJcbiAgICogb2JqZWN0IG9mIHNsaWNlIHJlZHVjZXJzIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gYGNvbWJpbmVSZWR1Y2VycygpYC5cclxuICAgKi9cclxuICByZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+IHwgUmVkdWNlcnNNYXBPYmplY3Q8UywgQT5cclxuXHJcbiAgLyoqXHJcbiAgICogQW4gYXJyYXkgb2YgUmVkdXggbWlkZGxld2FyZSB0byBpbnN0YWxsLiBJZiBub3Qgc3VwcGxpZWQsIGRlZmF1bHRzIHRvXHJcbiAgICogdGhlIHNldCBvZiBtaWRkbGV3YXJlIHJldHVybmVkIGJ5IGBnZXREZWZhdWx0TWlkZGxld2FyZSgpYC5cclxuICAgKi9cclxuICBtaWRkbGV3YXJlPzogKChnZXREZWZhdWx0TWlkZGxld2FyZTogQ3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlPFM+KSA9PiBNKSB8IE1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hldGhlciB0byBlbmFibGUgUmVkdXggRGV2VG9vbHMgaW50ZWdyYXRpb24uIERlZmF1bHRzIHRvIGB0cnVlYC5cclxuICAgKlxyXG4gICAqIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBjYW4gYmUgZG9uZSBieSBwYXNzaW5nIFJlZHV4IERldlRvb2xzIG9wdGlvbnNcclxuICAgKi9cclxuICBkZXZUb29scz86IGJvb2xlYW4gfCBEZXZUb29sc09wdGlvbnNcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGluaXRpYWwgc3RhdGUsIHNhbWUgYXMgUmVkdXgncyBjcmVhdGVTdG9yZS5cclxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgc3BlY2lmeSBpdCB0byBoeWRyYXRlIHRoZSBzdGF0ZVxyXG4gICAqIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhIHByZXZpb3VzbHkgc2VyaWFsaXplZFxyXG4gICAqIHVzZXIgc2Vzc2lvbi4gSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzKClgIHRvIHByb2R1Y2UgdGhlIHJvb3QgcmVkdWNlclxyXG4gICAqIGZ1bmN0aW9uIChlaXRoZXIgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSBieSBwYXNzaW5nIGFuIG9iamVjdCBhcyBgcmVkdWNlcmApLFxyXG4gICAqIHRoaXMgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgcmVkdWNlciBtYXAga2V5cy5cclxuICAgKi9cclxuICAvLyBOT1RFOiBUaGUgbmVlZGxlc3NseSBjb21wbGljYXRlZCBgUyBleHRlbmRzIGFueSA/IFMgOiBTYCBpbnN0ZWFkIG9mIGp1c3RcclxuICAvLyBgU2AgZW5zdXJlcyB0aGF0IHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIGRvZXNuJ3QgYXR0ZW1wdCB0byBpbmZlciBgU2BcclxuICAvLyBiYXNlZCBvbiB0aGUgdmFsdWUgcGFzc2VkIGFzIGBwcmVsb2FkZWRTdGF0ZWAsIHdoaWNoIG1pZ2h0IGJlIGEgcGFydGlhbFxyXG4gIC8vIHN0YXRlIHJhdGhlciB0aGFuIHRoZSBmdWxsIHRoaW5nLlxyXG4gIHByZWxvYWRlZFN0YXRlPzogRGVlcFBhcnRpYWw8UyBleHRlbmRzIGFueSA/IFMgOiBTPlxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc3RvcmUgZW5oYW5jZXJzIHRvIGFwcGx5LiBTZWUgUmVkdXgncyBgY3JlYXRlU3RvcmUoKWAuXHJcbiAgICogQWxsIGVuaGFuY2VycyB3aWxsIGJlIGluY2x1ZGVkIGJlZm9yZSB0aGUgRGV2VG9vbHMgRXh0ZW5zaW9uIGVuaGFuY2VyLlxyXG4gICAqIElmIHlvdSBuZWVkIHRvIGN1c3RvbWl6ZSB0aGUgb3JkZXIgb2YgZW5oYW5jZXJzLCBzdXBwbHkgYSBjYWxsYmFja1xyXG4gICAqIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWNlaXZlIHRoZSBvcmlnaW5hbCBhcnJheSAoaWUsIGBbYXBwbHlNaWRkbGV3YXJlXWApLFxyXG4gICAqIGFuZCBzaG91bGQgcmV0dXJuIGEgbmV3IGFycmF5IChzdWNoIGFzIGBbYXBwbHlNaWRkbGV3YXJlLCBvZmZsaW5lXWApLlxyXG4gICAqIElmIHlvdSBvbmx5IG5lZWQgdG8gYWRkIG1pZGRsZXdhcmUsIHlvdSBjYW4gdXNlIHRoZSBgbWlkZGxld2FyZWAgcGFyYW1ldGVyIGluc3RlYWQuXHJcbiAgICovXHJcbiAgZW5oYW5jZXJzPzogU3RvcmVFbmhhbmNlcltdIHwgQ29uZmlndXJlRW5oYW5jZXJzQ2FsbGJhY2tcclxufVxyXG5cclxudHlwZSBNaWRkbGV3YXJlczxTPiA9IFJlYWRvbmx5QXJyYXk8TWlkZGxld2FyZTx7fSwgUz4+XHJcblxyXG4vKipcclxuICogQSBSZWR1eCBzdG9yZSByZXR1cm5lZCBieSBgY29uZmlndXJlU3RvcmUoKWAuIFN1cHBvcnRzIGRpc3BhdGNoaW5nXHJcbiAqIHNpZGUtZWZmZWN0ZnVsIF90aHVua3NfIGluIGFkZGl0aW9uIHRvIHBsYWluIGFjdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgRW5oYW5jZWRTdG9yZTxcclxuICBTID0gYW55LFxyXG4gIEEgZXh0ZW5kcyBBY3Rpb24gPSBBbnlBY3Rpb24sXHJcbiAgTSBleHRlbmRzIE1pZGRsZXdhcmVzPFM+ID0gTWlkZGxld2FyZXM8Uz5cclxuPiBleHRlbmRzIFN0b3JlPFMsIEE+IHtcclxuICAvKipcclxuICAgKiBUaGUgYGRpc3BhdGNoYCBtZXRob2Qgb2YgeW91ciBzdG9yZSwgZW5oYW5jZWQgYnkgYWxsIGl0J3MgbWlkZGxld2FyZXMuXHJcbiAgICpcclxuICAgKiBAaW5oZXJpdGRvY1xyXG4gICAqL1xyXG4gIGRpc3BhdGNoOiBEaXNwYXRjaEZvck1pZGRsZXdhcmVzPE0+ICYgRGlzcGF0Y2g8QT5cclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZnJpZW5kbHkgYWJzdHJhY3Rpb24gb3ZlciB0aGUgc3RhbmRhcmQgUmVkdXggYGNyZWF0ZVN0b3JlKClgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0gY29uZmlnIFRoZSBzdG9yZSBjb25maWd1cmF0aW9uLlxyXG4gKiBAcmV0dXJucyBBIGNvbmZpZ3VyZWQgUmVkdXggc3RvcmUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmVTdG9yZTxcclxuICBTID0gYW55LFxyXG4gIEEgZXh0ZW5kcyBBY3Rpb24gPSBBbnlBY3Rpb24sXHJcbiAgTSBleHRlbmRzIE1pZGRsZXdhcmVzPFM+ID0gW1RodW5rTWlkZGxld2FyZUZvcjxTPl1cclxuPihvcHRpb25zOiBDb25maWd1cmVTdG9yZU9wdGlvbnM8UywgQSwgTT4pOiBFbmhhbmNlZFN0b3JlPFMsIEEsIE0+IHtcclxuICBjb25zdCBjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUgPSBjdXJyeUdldERlZmF1bHRNaWRkbGV3YXJlPFM+KClcclxuXHJcbiAgY29uc3Qge1xyXG4gICAgcmVkdWNlciA9IHVuZGVmaW5lZCxcclxuICAgIG1pZGRsZXdhcmUgPSBjdXJyaWVkR2V0RGVmYXVsdE1pZGRsZXdhcmUoKSxcclxuICAgIGRldlRvb2xzID0gdHJ1ZSxcclxuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkLFxyXG4gICAgZW5oYW5jZXJzID0gdW5kZWZpbmVkXHJcbiAgfSA9IG9wdGlvbnMgfHwge31cclxuXHJcbiAgbGV0IHJvb3RSZWR1Y2VyOiBSZWR1Y2VyPFMsIEE+XHJcblxyXG4gIGlmICh0eXBlb2YgcmVkdWNlciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcm9vdFJlZHVjZXIgPSByZWR1Y2VyXHJcbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHJlZHVjZXIpKSB7XHJcbiAgICByb290UmVkdWNlciA9IGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2VyKVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICdcInJlZHVjZXJcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LCBhbmQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIGNvbWJpbmVSZWR1Y2VycydcclxuICAgIClcclxuICB9XHJcblxyXG4gIGNvbnN0IG1pZGRsZXdhcmVFbmhhbmNlciA9IGFwcGx5TWlkZGxld2FyZShcclxuICAgIC4uLih0eXBlb2YgbWlkZGxld2FyZSA9PT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICA/IG1pZGRsZXdhcmUoY3VycmllZEdldERlZmF1bHRNaWRkbGV3YXJlKVxyXG4gICAgICA6IG1pZGRsZXdhcmUpXHJcbiAgKVxyXG5cclxuICBsZXQgZmluYWxDb21wb3NlID0gY29tcG9zZVxyXG5cclxuICBpZiAoZGV2VG9vbHMpIHtcclxuICAgIGZpbmFsQ29tcG9zZSA9IGNvbXBvc2VXaXRoRGV2VG9vbHMoe1xyXG4gICAgICAvLyBFbmFibGUgY2FwdHVyZSBvZiBzdGFjayB0cmFjZXMgZm9yIGRpc3BhdGNoZWQgUmVkdXggYWN0aW9uc1xyXG4gICAgICB0cmFjZTogIUlTX1BST0RVQ1RJT04sXHJcbiAgICAgIC4uLih0eXBlb2YgZGV2VG9vbHMgPT09ICdvYmplY3QnICYmIGRldlRvb2xzKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGxldCBzdG9yZUVuaGFuY2VyczogU3RvcmVFbmhhbmNlcltdID0gW21pZGRsZXdhcmVFbmhhbmNlcl1cclxuXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZW5oYW5jZXJzKSkge1xyXG4gICAgc3RvcmVFbmhhbmNlcnMgPSBbbWlkZGxld2FyZUVuaGFuY2VyLCAuLi5lbmhhbmNlcnNdXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5oYW5jZXJzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBzdG9yZUVuaGFuY2VycyA9IGVuaGFuY2VycyhzdG9yZUVuaGFuY2VycylcclxuICB9XHJcblxyXG4gIGNvbnN0IGNvbXBvc2VkRW5oYW5jZXIgPSBmaW5hbENvbXBvc2UoLi4uc3RvcmVFbmhhbmNlcnMpIGFzIGFueVxyXG5cclxuICByZXR1cm4gY3JlYXRlU3RvcmUoXHJcbiAgICByb290UmVkdWNlcixcclxuICAgIHByZWxvYWRlZFN0YXRlIGFzIERlZXBQYXJ0aWFsPFM+LFxyXG4gICAgY29tcG9zZWRFbmhhbmNlclxyXG4gIClcclxufVxyXG4iLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHtcclxuICBJc1Vua25vd25Pck5vbkluZmVycmFibGUsXHJcbiAgSWZNYXliZVVuZGVmaW5lZCxcclxuICBJZlZvaWQsXHJcbiAgSXNBbnlcclxufSBmcm9tICcuL3RzSGVscGVycydcclxuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0J1xyXG5cclxuLyoqXHJcbiAqIEFuIGFjdGlvbiB3aXRoIGEgc3RyaW5nIHR5cGUgYW5kIGFuIGFzc29jaWF0ZWQgcGF5bG9hZC4gVGhpcyBpcyB0aGVcclxuICogdHlwZSBvZiBhY3Rpb24gcmV0dXJuZWQgYnkgYGNyZWF0ZUFjdGlvbigpYCBhY3Rpb24gY3JlYXRvcnMuXHJcbiAqXHJcbiAqIEB0ZW1wbGF0ZSBQIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb24ncyBwYXlsb2FkLlxyXG4gKiBAdGVtcGxhdGUgVCB0aGUgdHlwZSB1c2VkIGZvciB0aGUgYWN0aW9uIHR5cGUuXHJcbiAqIEB0ZW1wbGF0ZSBNIFRoZSB0eXBlIG9mIHRoZSBhY3Rpb24ncyBtZXRhIChvcHRpb25hbClcclxuICogQHRlbXBsYXRlIEUgVGhlIHR5cGUgb2YgdGhlIGFjdGlvbidzIGVycm9yIChvcHRpb25hbClcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgUGF5bG9hZEFjdGlvbjxcclxuICBQID0gdm9pZCxcclxuICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxyXG4gIE0gPSBuZXZlcixcclxuICBFID0gbmV2ZXJcclxuPiA9IHtcclxuICBwYXlsb2FkOiBQXHJcbiAgdHlwZTogVFxyXG59ICYgKFtNXSBleHRlbmRzIFtuZXZlcl1cclxuICA/IHt9XHJcbiAgOiB7XHJcbiAgICAgIG1ldGE6IE1cclxuICAgIH0pICZcclxuICAoW0VdIGV4dGVuZHMgW25ldmVyXVxyXG4gICAgPyB7fVxyXG4gICAgOiB7XHJcbiAgICAgICAgZXJyb3I6IEVcclxuICAgICAgfSlcclxuXHJcbi8qKlxyXG4gKiBBIFwicHJlcGFyZVwiIG1ldGhvZCB0byBiZSB1c2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyIG9mIGBjcmVhdGVBY3Rpb25gLlxyXG4gKiBUYWtlcyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhIEZsdXggU3RhbmRhcmQgQWN0aW9uIHdpdGhvdXRcclxuICogdHlwZSAod2lsbCBiZSBhZGRlZCBsYXRlcikgdGhhdCAqbXVzdCogY29udGFpbiBhIHBheWxvYWQgKG1pZ2h0IGJlIHVuZGVmaW5lZCkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFByZXBhcmVBY3Rpb248UD4gPVxyXG4gIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4geyBwYXlsb2FkOiBQIH0pXHJcbiAgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7IHBheWxvYWQ6IFA7IG1ldGE6IGFueSB9KVxyXG4gIHwgKCguLi5hcmdzOiBhbnlbXSkgPT4geyBwYXlsb2FkOiBQOyBlcnJvcjogYW55IH0pXHJcbiAgfCAoKC4uLmFyZ3M6IGFueVtdKSA9PiB7IHBheWxvYWQ6IFA7IG1ldGE6IGFueTsgZXJyb3I6IGFueSB9KVxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIHZlcnNpb24gb2YgYEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkYC4gTm90IHRvIGJlIHVzZWQgZXh0ZXJuYWxseS5cclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8XHJcbiAgUEEgZXh0ZW5kcyBQcmVwYXJlQWN0aW9uPGFueT4gfCB2b2lkLFxyXG4gIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmdcclxuPiA9IFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxpbmZlciBQPlxyXG4gID8gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8XHJcbiAgICAgIFBhcmFtZXRlcnM8UEE+LFxyXG4gICAgICBQLFxyXG4gICAgICBULFxyXG4gICAgICBSZXR1cm5UeXBlPFBBPiBleHRlbmRzIHtcclxuICAgICAgICBlcnJvcjogaW5mZXIgRVxyXG4gICAgICB9XHJcbiAgICAgICAgPyBFXHJcbiAgICAgICAgOiBuZXZlcixcclxuICAgICAgUmV0dXJuVHlwZTxQQT4gZXh0ZW5kcyB7XHJcbiAgICAgICAgbWV0YTogaW5mZXIgTVxyXG4gICAgICB9XHJcbiAgICAgICAgPyBNXHJcbiAgICAgICAgOiBuZXZlclxyXG4gICAgPlxyXG4gIDogdm9pZFxyXG5cclxuLyoqXHJcbiAqIEJhc2ljIHR5cGUgZm9yIGFsbCBhY3Rpb24gY3JlYXRvcnMuXHJcbiAqXHJcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxyXG4gKi9cclxuaW50ZXJmYWNlIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQgZXh0ZW5kcyBzdHJpbmcsIE0gPSBuZXZlciwgRSA9IG5ldmVyPiB7XHJcbiAgdHlwZTogVFxyXG4gIG1hdGNoKGFjdGlvbjogQWN0aW9uPHVua25vd24+KTogYWN0aW9uIGlzIFBheWxvYWRBY3Rpb248UCwgVCwgTSwgRT5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIHRoYXQgdGFrZXMgbXVsdGlwbGUgYXJndW1lbnRzIHRoYXQgYXJlIHBhc3NlZFxyXG4gKiB0byBhIGBQcmVwYXJlQWN0aW9uYCBtZXRob2QgdG8gY3JlYXRlIHRoZSBmaW5hbCBBY3Rpb24uXHJcbiAqIEB0eXBlUGFyYW0gQXJncyBhcmd1bWVudHMgZm9yIHRoZSBhY3Rpb24gY3JlYXRvciBmdW5jdGlvblxyXG4gKiBAdHlwZVBhcmFtIFAgYHBheWxvYWRgIHR5cGVcclxuICogQHR5cGVQYXJhbSBUIGB0eXBlYCBuYW1lXHJcbiAqIEB0eXBlUGFyYW0gRSBvcHRpb25hbCBgZXJyb3JgIHR5cGVcclxuICogQHR5cGVQYXJhbSBNIG9wdGlvbmFsIGBtZXRhYCB0eXBlXHJcbiAqXHJcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPFxyXG4gIEFyZ3MgZXh0ZW5kcyB1bmtub3duW10sXHJcbiAgUCxcclxuICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxyXG4gIEUgPSBuZXZlcixcclxuICBNID0gbmV2ZXJcclxuPiBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQsIE0sIEU+IHtcclxuICAvKipcclxuICAgKiBDYWxsaW5nIHRoaXMge0BsaW5rIHJlZHV4I0FjdGlvbkNyZWF0b3J9IHdpdGggYEFyZ3NgIHdpbGwgcmV0dXJuXHJcbiAgICogYW4gQWN0aW9uIHdpdGggYSBwYXlsb2FkIG9mIHR5cGUgYFBgIGFuZCAoZGVwZW5kaW5nIG9uIHRoZSBgUHJlcGFyZUFjdGlvbmBcclxuICAgKiBtZXRob2QgdXNlZCkgYSBgbWV0YWAtIGFuZCBgZXJyb3JgIHByb3BlcnR5IG9mIHR5cGVzIGBNYCBhbmQgYEVgIHJlc3BlY3RpdmVseS5cclxuICAgKi9cclxuICAoLi4uYXJnczogQXJncyk6IFBheWxvYWRBY3Rpb248UCwgVCwgTSwgRT5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIG9mIHR5cGUgYFRgIHRoYXQgdGFrZXMgYW4gb3B0aW9uYWwgcGF5bG9hZCBvZiB0eXBlIGBQYC5cclxuICpcclxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhPcHRpb25hbFBheWxvYWQ8UCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz5cclxuICBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQ+IHtcclxuICAvKipcclxuICAgKiBDYWxsaW5nIHRoaXMge0BsaW5rIHJlZHV4I0FjdGlvbkNyZWF0b3J9IHdpdGggYW4gYXJndW1lbnQgd2lsbFxyXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZCBvZiBgUGAuXHJcbiAgICogQ2FsbGluZyBpdCB3aXRob3V0IGFuIGFyZ3VtZW50IHdpbGwgcmV0dXJuIGEgUGF5bG9hZEFjdGlvbiB3aXRoIGEgcGF5bG9hZCBvZiBgdW5kZWZpbmVkYC5cclxuICAgKi9cclxuICAocGF5bG9hZD86IFApOiBQYXlsb2FkQWN0aW9uPFAsIFQ+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBvZiB0eXBlIGBUYCB0aGF0IHRha2VzIG5vIHBheWxvYWQuXHJcbiAqXHJcbiAqIEBpbmhlcml0ZG9jIHtyZWR1eCNBY3Rpb25DcmVhdG9yfVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPlxyXG4gIGV4dGVuZHMgQmFzZUFjdGlvbkNyZWF0b3I8dW5kZWZpbmVkLCBUPiB7XHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aWxsXHJcbiAgICogcmV0dXJuIGEge0BsaW5rIFBheWxvYWRBY3Rpb259IG9mIHR5cGUgYFRgIHdpdGggYSBwYXlsb2FkIG9mIGB1bmRlZmluZWRgXHJcbiAgICovXHJcbiAgKCk6IFBheWxvYWRBY3Rpb248dW5kZWZpbmVkLCBUPlxyXG59XHJcblxyXG4vKipcclxuICogQW4gYWN0aW9uIGNyZWF0b3Igb2YgdHlwZSBgVGAgdGhhdCByZXF1aXJlcyBhIHBheWxvYWQgb2YgdHlwZSBQLlxyXG4gKlxyXG4gKiBAaW5oZXJpdGRvYyB7cmVkdXgjQWN0aW9uQ3JlYXRvcn1cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBBY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQ8UCwgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz5cclxuICBleHRlbmRzIEJhc2VBY3Rpb25DcmVhdG9yPFAsIFQ+IHtcclxuICAvKipcclxuICAgKiBDYWxsaW5nIHRoaXMge0BsaW5rIHJlZHV4I0FjdGlvbkNyZWF0b3J9IHdpdGggYW4gYXJndW1lbnQgd2lsbFxyXG4gICAqIHJldHVybiBhIHtAbGluayBQYXlsb2FkQWN0aW9ufSBvZiB0eXBlIGBUYCB3aXRoIGEgcGF5bG9hZCBvZiBgUGBcclxuICAgKi9cclxuICAocGF5bG9hZDogUCk6IFBheWxvYWRBY3Rpb248UCwgVD5cclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFjdGlvbiBjcmVhdG9yIG9mIHR5cGUgYFRgIHdob3NlIGBwYXlsb2FkYCB0eXBlIGNvdWxkIG5vdCBiZSBpbmZlcnJlZC4gQWNjZXB0cyBldmVyeXRoaW5nIGFzIGBwYXlsb2FkYC5cclxuICpcclxuICogQGluaGVyaXRkb2Mge3JlZHV4I0FjdGlvbkNyZWF0b3J9XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uQ3JlYXRvcldpdGhOb25JbmZlcnJhYmxlUGF5bG9hZDxcclxuICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXHJcbj4gZXh0ZW5kcyBCYXNlQWN0aW9uQ3JlYXRvcjx1bmtub3duLCBUPiB7XHJcbiAgLyoqXHJcbiAgICogQ2FsbGluZyB0aGlzIHtAbGluayByZWR1eCNBY3Rpb25DcmVhdG9yfSB3aXRoIGFuIGFyZ3VtZW50IHdpbGxcclxuICAgKiByZXR1cm4gYSB7QGxpbmsgUGF5bG9hZEFjdGlvbn0gb2YgdHlwZSBgVGAgd2l0aCBhIHBheWxvYWRcclxuICAgKiBvZiBleGFjdGx5IHRoZSB0eXBlIG9mIHRoZSBhcmd1bWVudC5cclxuICAgKi9cclxuICA8UFQgZXh0ZW5kcyB1bmtub3duPihwYXlsb2FkOiBQVCk6IFBheWxvYWRBY3Rpb248UFQsIFQ+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciB0aGF0IHByb2R1Y2VzIGFjdGlvbnMgd2l0aCBhIGBwYXlsb2FkYCBhdHRyaWJ1dGUuXHJcbiAqXHJcbiAqIEB0eXBlUGFyYW0gUCB0aGUgYHBheWxvYWRgIHR5cGVcclxuICogQHR5cGVQYXJhbSBUIHRoZSBgdHlwZWAgb2YgdGhlIHJlc3VsdGluZyBhY3Rpb25cclxuICogQHR5cGVQYXJhbSBQQSBpZiB0aGUgcmVzdWx0aW5nIGFjdGlvbiBpcyBwcmVwcm9jZXNzZWQgYnkgYSBgcHJlcGFyZWAgbWV0aG9kLCB0aGUgc2lnbmF0dXJlIG9mIHNhaWQgbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxcclxuICBQID0gdm9pZCxcclxuICBUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nLFxyXG4gIFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxQPiB8IHZvaWQgPSB2b2lkXHJcbj4gPSBJZlByZXBhcmVBY3Rpb25NZXRob2RQcm92aWRlZDxcclxuICBQQSxcclxuICBfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8UEEsIFQ+LFxyXG4gIC8vIGVsc2VcclxuICBJc0FueTxcclxuICAgIFAsXHJcbiAgICBBY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQ8YW55LCBUPixcclxuICAgIElzVW5rbm93bk9yTm9uSW5mZXJyYWJsZTxcclxuICAgICAgUCxcclxuICAgICAgQWN0aW9uQ3JlYXRvcldpdGhOb25JbmZlcnJhYmxlUGF5bG9hZDxUPixcclxuICAgICAgLy8gZWxzZVxyXG4gICAgICBJZlZvaWQ8XHJcbiAgICAgICAgUCxcclxuICAgICAgICBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQ8VD4sXHJcbiAgICAgICAgLy8gZWxzZVxyXG4gICAgICAgIElmTWF5YmVVbmRlZmluZWQ8XHJcbiAgICAgICAgICBQLFxyXG4gICAgICAgICAgQWN0aW9uQ3JlYXRvcldpdGhPcHRpb25hbFBheWxvYWQ8UCwgVD4sXHJcbiAgICAgICAgICAvLyBlbHNlXHJcbiAgICAgICAgICBBY3Rpb25DcmVhdG9yV2l0aFBheWxvYWQ8UCwgVD5cclxuICAgICAgICA+XHJcbiAgICAgID5cclxuICAgID5cclxuICA+XHJcbj5cclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGFjdGlvbiBjcmVhdG9yIGZvciB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGVcclxuICogc3RyaW5nLiBUaGUgYWN0aW9uIGNyZWF0b3IgYWNjZXB0cyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZFxyXG4gKiBpbiB0aGUgYWN0aW9uIG9iamVjdCBhcyBhIGZpZWxkIGNhbGxlZCBwYXlsb2FkLiBUaGUgYWN0aW9uIGNyZWF0b3IgZnVuY3Rpb25cclxuICogd2lsbCBhbHNvIGhhdmUgaXRzIHRvU3RyaW5nKCkgb3ZlcnJpZGVuIHNvIHRoYXQgaXQgcmV0dXJucyB0aGUgYWN0aW9uIHR5cGUsXHJcbiAqIGFsbG93aW5nIGl0IHRvIGJlIHVzZWQgaW4gcmVkdWNlciBsb2dpYyB0aGF0IGlzIGxvb2tpbmcgZm9yIHRoYXQgYWN0aW9uIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSBhY3Rpb24gdHlwZSB0byB1c2UgZm9yIGNyZWF0ZWQgYWN0aW9ucy5cclxuICogQHBhcmFtIHByZXBhcmUgKG9wdGlvbmFsKSBhIG1ldGhvZCB0aGF0IHRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCByZXR1cm5zIHsgcGF5bG9hZCB9IG9yIHsgcGF5bG9hZCwgbWV0YSB9LlxyXG4gKiAgICAgICAgICAgICAgICBJZiB0aGlzIGlzIGdpdmVuLCB0aGUgcmVzdWx0aW5nIGFjdGlvbiBjcmVhdG9yIHdpbGwgcGFzcyBpdCdzIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCB0byBjYWxjdWxhdGUgcGF5bG9hZCAmIG1ldGEuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb248UCA9IHZvaWQsIFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KFxyXG4gIHR5cGU6IFRcclxuKTogUGF5bG9hZEFjdGlvbkNyZWF0b3I8UCwgVD5cclxuXHJcbi8qKlxyXG4gKiBBIHV0aWxpdHkgZnVuY3Rpb24gdG8gY3JlYXRlIGFuIGFjdGlvbiBjcmVhdG9yIGZvciB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGVcclxuICogc3RyaW5nLiBUaGUgYWN0aW9uIGNyZWF0b3IgYWNjZXB0cyBhIHNpbmdsZSBhcmd1bWVudCwgd2hpY2ggd2lsbCBiZSBpbmNsdWRlZFxyXG4gKiBpbiB0aGUgYWN0aW9uIG9iamVjdCBhcyBhIGZpZWxkIGNhbGxlZCBwYXlsb2FkLiBUaGUgYWN0aW9uIGNyZWF0b3IgZnVuY3Rpb25cclxuICogd2lsbCBhbHNvIGhhdmUgaXRzIHRvU3RyaW5nKCkgb3ZlcnJpZGVuIHNvIHRoYXQgaXQgcmV0dXJucyB0aGUgYWN0aW9uIHR5cGUsXHJcbiAqIGFsbG93aW5nIGl0IHRvIGJlIHVzZWQgaW4gcmVkdWNlciBsb2dpYyB0aGF0IGlzIGxvb2tpbmcgZm9yIHRoYXQgYWN0aW9uIHR5cGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB0eXBlIFRoZSBhY3Rpb24gdHlwZSB0byB1c2UgZm9yIGNyZWF0ZWQgYWN0aW9ucy5cclxuICogQHBhcmFtIHByZXBhcmUgKG9wdGlvbmFsKSBhIG1ldGhvZCB0aGF0IHRha2VzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCByZXR1cm5zIHsgcGF5bG9hZCB9IG9yIHsgcGF5bG9hZCwgbWV0YSB9LlxyXG4gKiAgICAgICAgICAgICAgICBJZiB0aGlzIGlzIGdpdmVuLCB0aGUgcmVzdWx0aW5nIGFjdGlvbiBjcmVhdG9yIHdpbGwgcGFzcyBpdCdzIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCB0byBjYWxjdWxhdGUgcGF5bG9hZCAmIG1ldGEuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBY3Rpb248XHJcbiAgUEEgZXh0ZW5kcyBQcmVwYXJlQWN0aW9uPGFueT4sXHJcbiAgVCBleHRlbmRzIHN0cmluZyA9IHN0cmluZ1xyXG4+KFxyXG4gIHR5cGU6IFQsXHJcbiAgcHJlcGFyZUFjdGlvbjogUEFcclxuKTogUGF5bG9hZEFjdGlvbkNyZWF0b3I8UmV0dXJuVHlwZTxQQT5bJ3BheWxvYWQnXSwgVCwgUEE+XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQWN0aW9uKHR5cGU6IHN0cmluZywgcHJlcGFyZUFjdGlvbj86IEZ1bmN0aW9uKTogYW55IHtcclxuICBmdW5jdGlvbiBhY3Rpb25DcmVhdG9yKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAocHJlcGFyZUFjdGlvbikge1xyXG4gICAgICBsZXQgcHJlcGFyZWQgPSBwcmVwYXJlQWN0aW9uKC4uLmFyZ3MpXHJcbiAgICAgIGlmICghcHJlcGFyZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZXBhcmVBY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0JylcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlLFxyXG4gICAgICAgIHBheWxvYWQ6IHByZXBhcmVkLnBheWxvYWQsXHJcbiAgICAgICAgLi4uKCdtZXRhJyBpbiBwcmVwYXJlZCAmJiB7IG1ldGE6IHByZXBhcmVkLm1ldGEgfSksXHJcbiAgICAgICAgLi4uKCdlcnJvcicgaW4gcHJlcGFyZWQgJiYgeyBlcnJvcjogcHJlcGFyZWQuZXJyb3IgfSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgdHlwZSwgcGF5bG9hZDogYXJnc1swXSB9XHJcbiAgfVxyXG5cclxuICBhY3Rpb25DcmVhdG9yLnRvU3RyaW5nID0gKCkgPT4gYCR7dHlwZX1gXHJcblxyXG4gIGFjdGlvbkNyZWF0b3IudHlwZSA9IHR5cGVcclxuXHJcbiAgYWN0aW9uQ3JlYXRvci5tYXRjaCA9IChhY3Rpb246IEFjdGlvbjx1bmtub3duPik6IGFjdGlvbiBpcyBQYXlsb2FkQWN0aW9uID0+XHJcbiAgICBhY3Rpb24udHlwZSA9PT0gdHlwZVxyXG5cclxuICByZXR1cm4gYWN0aW9uQ3JlYXRvclxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNGU0EoXHJcbiAgYWN0aW9uOiB1bmtub3duXHJcbik6IGFjdGlvbiBpcyB7XHJcbiAgdHlwZTogc3RyaW5nXHJcbiAgcGF5bG9hZD86IHVua25vd25cclxuICBlcnJvcj86IHVua25vd25cclxuICBtZXRhPzogdW5rbm93blxyXG59IHtcclxuICByZXR1cm4gKFxyXG4gICAgaXNQbGFpbk9iamVjdChhY3Rpb24pICYmXHJcbiAgICB0eXBlb2YgKGFjdGlvbiBhcyBhbnkpLnR5cGUgPT09ICdzdHJpbmcnICYmXHJcbiAgICBPYmplY3Qua2V5cyhhY3Rpb24pLmV2ZXJ5KGlzVmFsaWRLZXkpXHJcbiAgKVxyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleTogc3RyaW5nKSB7XHJcbiAgcmV0dXJuIFsndHlwZScsICdwYXlsb2FkJywgJ2Vycm9yJywgJ21ldGEnXS5pbmRleE9mKGtleSkgPiAtMVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYWN0aW9uIHR5cGUgb2YgdGhlIGFjdGlvbnMgY3JlYXRlZCBieSB0aGUgcGFzc2VkXHJcbiAqIGBjcmVhdGVBY3Rpb24oKWAtZ2VuZXJhdGVkIGFjdGlvbiBjcmVhdG9yIChhcmJpdHJhcnkgYWN0aW9uIGNyZWF0b3JzXHJcbiAqIGFyZSBub3Qgc3VwcG9ydGVkKS5cclxuICpcclxuICogQHBhcmFtIGFjdGlvbiBUaGUgYWN0aW9uIGNyZWF0b3Igd2hvc2UgYWN0aW9uIHR5cGUgdG8gZ2V0LlxyXG4gKiBAcmV0dXJucyBUaGUgYWN0aW9uIHR5cGUgdXNlZCBieSB0aGUgYWN0aW9uIGNyZWF0b3IuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlPFQgZXh0ZW5kcyBzdHJpbmc+KFxyXG4gIGFjdGlvbkNyZWF0b3I6IFBheWxvYWRBY3Rpb25DcmVhdG9yPGFueSwgVD5cclxuKTogVCB7XHJcbiAgcmV0dXJuIGAke2FjdGlvbkNyZWF0b3J9YCBhcyBUXHJcbn1cclxuXHJcbi8vIGhlbHBlciB0eXBlcyBmb3IgbW9yZSByZWFkYWJsZSB0eXBpbmdzXHJcblxyXG50eXBlIElmUHJlcGFyZUFjdGlvbk1ldGhvZFByb3ZpZGVkPFxyXG4gIFBBIGV4dGVuZHMgUHJlcGFyZUFjdGlvbjxhbnk+IHwgdm9pZCxcclxuICBUcnVlLFxyXG4gIEZhbHNlXHJcbj4gPSBQQSBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55ID8gVHJ1ZSA6IEZhbHNlXHJcbiIsImltcG9ydCB7IEFjdGlvbiwgQW55QWN0aW9uIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7XHJcbiAgQ2FzZVJlZHVjZXIsXHJcbiAgQ2FzZVJlZHVjZXJzLFxyXG4gIEFjdGlvbk1hdGNoZXIsXHJcbiAgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvblxyXG59IGZyb20gJy4vY3JlYXRlUmVkdWNlcidcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHlwZWRBY3Rpb25DcmVhdG9yPFR5cGUgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAoLi4uYXJnczogYW55W10pOiBBY3Rpb248VHlwZT5cclxuICB0eXBlOiBUeXBlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIGJ1aWxkZXIgZm9yIGFuIGFjdGlvbiA8LT4gcmVkdWNlciBtYXAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+IHtcclxuICAvKipcclxuICAgKiBBZGQgYSBjYXNlIHJlZHVjZXIgZm9yIGFjdGlvbnMgY3JlYXRlZCBieSB0aGlzIGFjdGlvbiBjcmVhdG9yLlxyXG4gICAqIEBwYXJhbSBhY3Rpb25DcmVhdG9yXHJcbiAgICogQHBhcmFtIHJlZHVjZXJcclxuICAgKi9cclxuICBhZGRDYXNlPEFjdGlvbkNyZWF0b3IgZXh0ZW5kcyBUeXBlZEFjdGlvbkNyZWF0b3I8c3RyaW5nPj4oXHJcbiAgICBhY3Rpb25DcmVhdG9yOiBBY3Rpb25DcmVhdG9yLFxyXG4gICAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIFJldHVyblR5cGU8QWN0aW9uQ3JlYXRvcj4+XHJcbiAgKTogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8U3RhdGU+XHJcbiAgLyoqXHJcbiAgICogQWRkIGEgY2FzZSByZWR1Y2VyIGZvciBhY3Rpb25zIHdpdGggdGhlIHNwZWNpZmllZCB0eXBlLlxyXG4gICAqIEBwYXJhbSB0eXBlXHJcbiAgICogQHBhcmFtIHJlZHVjZXJcclxuICAgKi9cclxuICBhZGRDYXNlPFR5cGUgZXh0ZW5kcyBzdHJpbmcsIEEgZXh0ZW5kcyBBY3Rpb248VHlwZT4+KFxyXG4gICAgdHlwZTogVHlwZSxcclxuICAgIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFN0YXRlLCBBPlxyXG4gICk6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPlxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgcmVkdWNlciBmb3IgYWxsIGFjdGlvbnMsIHVzaW5nIGBtYXRjaGVyYCBhcyBhIGZpbHRlciBmdW5jdGlvbi5cclxuICAgKiBJZiBtdWx0aXBsZSBtYXRjaGVyIHJlZHVjZXJzIG1hdGNoLCBhbGwgb2YgdGhlbSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlclxyXG4gICAqIHRoZXkgd2VyZSBkZWZpbmVkIGlmIC0gZXZlbiBpZiBhIGNhc2UgcmVkdWNlciBhbHJlYWR5IG1hdGNoZWQuXHJcbiAgICogQHBhcmFtIG1hdGNoZXIgQSBtYXRjaGVyIGZ1bmN0aW9uLiBJbiBUeXBlU2NyaXB0LCB0aGlzIHNob3VsZCBiZSBhIFt0eXBlIHByZWRpY2F0ZV0oaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svYWR2YW5jZWQtdHlwZXMuaHRtbCN1c2luZy10eXBlLXByZWRpY2F0ZXMpXHJcbiAgICogICBmdW5jdGlvblxyXG4gICAqIEBwYXJhbSByZWR1Y2VyXHJcbiAgICovXHJcbiAgYWRkTWF0Y2hlcjxBIGV4dGVuZHMgQW55QWN0aW9uPihcclxuICAgIG1hdGNoZXI6IEFjdGlvbk1hdGNoZXI8QT4sXHJcbiAgICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQT5cclxuICApOiBPbWl0PEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFN0YXRlPiwgJ2FkZENhc2UnPlxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgXCJkZWZhdWx0IGNhc2VcIiByZWR1Y2VyIHRoYXQgaXMgZXhlY3V0ZWQgaWYgbm8gY2FzZSByZWR1Y2VyIGFuZCBubyBtYXRjaGVyXHJcbiAgICogcmVkdWNlciB3YXMgZXhlY3V0ZWQgZm9yIHRoaXMgYWN0aW9uLlxyXG4gICAqIEBwYXJhbSByZWR1Y2VyXHJcbiAgICovXHJcbiAgYWRkRGVmYXVsdENhc2UocmVkdWNlcjogQ2FzZVJlZHVjZXI8U3RhdGUsIEFueUFjdGlvbj4pOiB7fVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZXhlY3V0ZVJlZHVjZXJCdWlsZGVyQ2FsbGJhY2s8Uz4oXHJcbiAgYnVpbGRlckNhbGxiYWNrOiAoYnVpbGRlcjogQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXI8Uz4pID0+IHZvaWRcclxuKTogW1xyXG4gIENhc2VSZWR1Y2VyczxTLCBhbnk+LFxyXG4gIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb248Uz4sXHJcbiAgQ2FzZVJlZHVjZXI8UywgQW55QWN0aW9uPiB8IHVuZGVmaW5lZFxyXG5dIHtcclxuICBjb25zdCBhY3Rpb25zTWFwOiBDYXNlUmVkdWNlcnM8UywgYW55PiA9IHt9XHJcbiAgY29uc3QgYWN0aW9uTWF0Y2hlcnM6IEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb248Uz4gPSBbXVxyXG4gIGxldCBkZWZhdWx0Q2FzZVJlZHVjZXI6IENhc2VSZWR1Y2VyPFMsIEFueUFjdGlvbj4gfCB1bmRlZmluZWRcclxuICBjb25zdCBidWlsZGVyID0ge1xyXG4gICAgYWRkQ2FzZShcclxuICAgICAgdHlwZU9yQWN0aW9uQ3JlYXRvcjogc3RyaW5nIHwgVHlwZWRBY3Rpb25DcmVhdG9yPGFueT4sXHJcbiAgICAgIHJlZHVjZXI6IENhc2VSZWR1Y2VyPFM+XHJcbiAgICApIHtcclxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAvKlxyXG4gICAgICAgICB0byBrZWVwIHRoZSBkZWZpbml0aW9uIGJ5IHRoZSB1c2VyIGluIGxpbmUgd2l0aCBhY3R1YWwgYmVoYXZpb3IsIFxyXG4gICAgICAgICB3ZSBlbmZvcmNlIGBhZGRDYXNlYCB0byBhbHdheXMgYmUgY2FsbGVkIGJlZm9yZSBjYWxsaW5nIGBhZGRNYXRjaGVyYFxyXG4gICAgICAgICBhcyBtYXRjaGluZyBjYXNlcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBtYXRjaGVyc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmIChhY3Rpb25NYXRjaGVycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgICdgYnVpbGRlci5hZGRDYXNlYCBzaG91bGQgb25seSBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGJ1aWxkZXIuYWRkTWF0Y2hlcmAnXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgJ2BidWlsZGVyLmFkZENhc2VgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAnXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHR5cGUgPVxyXG4gICAgICAgIHR5cGVvZiB0eXBlT3JBY3Rpb25DcmVhdG9yID09PSAnc3RyaW5nJ1xyXG4gICAgICAgICAgPyB0eXBlT3JBY3Rpb25DcmVhdG9yXHJcbiAgICAgICAgICA6IHR5cGVPckFjdGlvbkNyZWF0b3IudHlwZVxyXG4gICAgICBpZiAodHlwZSBpbiBhY3Rpb25zTWFwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgJ2FkZENhc2UgY2Fubm90IGJlIGNhbGxlZCB3aXRoIHR3byByZWR1Y2VycyBmb3IgdGhlIHNhbWUgYWN0aW9uIHR5cGUnXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICAgIGFjdGlvbnNNYXBbdHlwZV0gPSByZWR1Y2VyXHJcbiAgICAgIHJldHVybiBidWlsZGVyXHJcbiAgICB9LFxyXG4gICAgYWRkTWF0Y2hlcjxBIGV4dGVuZHMgQW55QWN0aW9uPihcclxuICAgICAgbWF0Y2hlcjogQWN0aW9uTWF0Y2hlcjxBPixcclxuICAgICAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgQT5cclxuICAgICkge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgJ2BidWlsZGVyLmFkZE1hdGNoZXJgIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBiZWZvcmUgY2FsbGluZyBgYnVpbGRlci5hZGREZWZhdWx0Q2FzZWAnXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGFjdGlvbk1hdGNoZXJzLnB1c2goeyBtYXRjaGVyLCByZWR1Y2VyIH0pXHJcbiAgICAgIHJldHVybiBidWlsZGVyXHJcbiAgICB9LFxyXG4gICAgYWRkRGVmYXVsdENhc2UocmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgQW55QWN0aW9uPikge1xyXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xyXG4gICAgICAgIGlmIChkZWZhdWx0Q2FzZVJlZHVjZXIpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYGJ1aWxkZXIuYWRkRGVmYXVsdENhc2VgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlJylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZGVmYXVsdENhc2VSZWR1Y2VyID0gcmVkdWNlclxyXG4gICAgICByZXR1cm4gYnVpbGRlclxyXG4gICAgfVxyXG4gIH1cclxuICBidWlsZGVyQ2FsbGJhY2soYnVpbGRlcilcclxuICByZXR1cm4gW2FjdGlvbnNNYXAsIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdXHJcbn1cclxuIiwiaW1wb3J0IGNyZWF0ZU5leHRTdGF0ZSwgeyBEcmFmdCwgaXNEcmFmdCwgaXNEcmFmdGFibGUgfSBmcm9tICdpbW1lcidcclxuaW1wb3J0IHsgQW55QWN0aW9uLCBBY3Rpb24sIFJlZHVjZXIgfSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHtcclxuICBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayxcclxuICBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlclxyXG59IGZyb20gJy4vbWFwQnVpbGRlcnMnXHJcbmltcG9ydCB7IE5vSW5mZXIgfSBmcm9tICcuL3RzSGVscGVycydcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIGEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBjb3JyZXNwb25kaW5nIGFjdGlvbiBvYmplY3Qgc2hhcGVzLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBUaGlzIHNob3VsZCBub3QgYmUgdXNlZCBtYW51YWxseSAtIGl0IGlzIG9ubHkgdXNlZCBmb3IgaW50ZXJuYWxcclxuICogICAgICAgICAgICAgaW5mZXJlbmNlIHB1cnBvc2VzIGFuZCBzaG91bGQgbm90IGhhdmUgYW55IGZ1cnRoZXIgdmFsdWUuXHJcbiAqICAgICAgICAgICAgIEl0IG1pZ2h0IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQWN0aW9uczxUIGV4dGVuZHMga2V5b2YgYW55ID0gc3RyaW5nPiA9IFJlY29yZDxULCBBY3Rpb24+XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbk1hdGNoZXI8QSBleHRlbmRzIEFueUFjdGlvbj4ge1xyXG4gIChhY3Rpb246IEFueUFjdGlvbik6IGFjdGlvbiBpcyBBXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbjxTLCBBIGV4dGVuZHMgQW55QWN0aW9uPiA9IHtcclxuICBtYXRjaGVyOiBBY3Rpb25NYXRjaGVyPEE+XHJcbiAgcmVkdWNlcjogQ2FzZVJlZHVjZXI8UywgTm9JbmZlcjxBPj5cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgQWN0aW9uTWF0Y2hlckRlc2NyaXB0aW9uQ29sbGVjdGlvbjxTPiA9IEFycmF5PFxyXG4gIEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbjxTLCBhbnk+XHJcbj5cclxuXHJcbi8qKlxyXG4gKiBBbiAqY2FzZSByZWR1Y2VyKiBpcyBhIHJlZHVjZXIgZnVuY3Rpb24gZm9yIGEgc3BlY2lmaWMgYWN0aW9uIHR5cGUuIENhc2VcclxuICogcmVkdWNlcnMgY2FuIGJlIGNvbXBvc2VkIHRvIGZ1bGwgcmVkdWNlcnMgdXNpbmcgYGNyZWF0ZVJlZHVjZXIoKWAuXHJcbiAqXHJcbiAqIFVubGlrZSBhIG5vcm1hbCBSZWR1eCByZWR1Y2VyLCBhIGNhc2UgcmVkdWNlciBpcyBuZXZlciBjYWxsZWQgd2l0aCBhblxyXG4gKiBgdW5kZWZpbmVkYCBzdGF0ZSB0byBkZXRlcm1pbmUgdGhlIGluaXRpYWwgc3RhdGUuIEluc3RlYWQsIHRoZSBpbml0aWFsXHJcbiAqIHN0YXRlIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGBjcmVhdGVSZWR1Y2VyKClgLlxyXG4gKlxyXG4gKiBJbiBhZGRpdGlvbiwgYSBjYXNlIHJlZHVjZXIgY2FuIGNob29zZSB0byBtdXRhdGUgdGhlIHBhc3NlZC1pbiBgc3RhdGVgXHJcbiAqIHZhbHVlIGRpcmVjdGx5IGluc3RlYWQgb2YgcmV0dXJuaW5nIGEgbmV3IHN0YXRlLiBUaGlzIGRvZXMgbm90IGFjdHVhbGx5XHJcbiAqIGNhdXNlIHRoZSBzdG9yZSBzdGF0ZSB0byBiZSBtdXRhdGVkIGRpcmVjdGx5OyBpbnN0ZWFkLCB0aGFua3MgdG9cclxuICogW2ltbWVyXShodHRwczovL2dpdGh1Yi5jb20vbXdlc3RzdHJhdGUvaW1tZXIpLCB0aGUgbXV0YXRpb25zIGFyZVxyXG4gKiB0cmFuc2xhdGVkIHRvIGNvcHkgb3BlcmF0aW9ucyB0aGF0IHJlc3VsdCBpbiBhIG5ldyBzdGF0ZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXI8UyA9IGFueSwgQSBleHRlbmRzIEFjdGlvbiA9IEFueUFjdGlvbj4gPSAoXHJcbiAgc3RhdGU6IERyYWZ0PFM+LFxyXG4gIGFjdGlvbjogQVxyXG4pID0+IFMgfCB2b2lkXHJcblxyXG4vKipcclxuICogQSBtYXBwaW5nIGZyb20gYWN0aW9uIHR5cGVzIHRvIGNhc2UgcmVkdWNlcnMgZm9yIGBjcmVhdGVSZWR1Y2VyKClgLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBUaGlzIHNob3VsZCBub3QgYmUgdXNlZCBtYW51YWxseSAtIGl0IGlzIG9ubHkgdXNlZFxyXG4gKiAgICAgICAgICAgICBmb3IgaW50ZXJuYWwgaW5mZXJlbmNlIHB1cnBvc2VzIGFuZCB1c2luZyBpdCBtYW51YWxseVxyXG4gKiAgICAgICAgICAgICB3b3VsZCBsZWFkIHRvIHR5cGUgZXJhc3VyZS5cclxuICogICAgICAgICAgICAgSXQgbWlnaHQgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDYXNlUmVkdWNlcnM8UywgQVMgZXh0ZW5kcyBBY3Rpb25zPiA9IHtcclxuICBbVCBpbiBrZXlvZiBBU106IEFTW1RdIGV4dGVuZHMgQWN0aW9uID8gQ2FzZVJlZHVjZXI8UywgQVNbVF0+IDogdm9pZFxyXG59XHJcblxyXG4vKipcclxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGRlZmluaW5nIGEgcmVkdWNlciBhcyBhIG1hcHBpbmcgZnJvbSBhY3Rpb25cclxuICogdHlwZSB0byAqY2FzZSByZWR1Y2VyKiBmdW5jdGlvbnMgdGhhdCBoYW5kbGUgdGhlc2UgYWN0aW9uIHR5cGVzLiBUaGVcclxuICogcmVkdWNlcidzIGluaXRpYWwgc3RhdGUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhlIGJvZHkgb2YgZXZlcnkgY2FzZSByZWR1Y2VyIGlzIGltcGxpY2l0bHkgd3JhcHBlZCB3aXRoIGEgY2FsbCB0b1xyXG4gKiBgcHJvZHVjZSgpYCBmcm9tIHRoZSBbaW1tZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9td2VzdHN0cmF0ZS9pbW1lcikgbGlicmFyeS5cclxuICogVGhpcyBtZWFucyB0aGF0IHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBzdGF0ZSBvYmplY3QsIHlvdSBjYW4gYWxzb1xyXG4gKiBtdXRhdGUgdGhlIHBhc3NlZC1pbiBzdGF0ZSBvYmplY3QgZGlyZWN0bHk7IHRoZXNlIG11dGF0aW9ucyB3aWxsIHRoZW4gYmVcclxuICogYXV0b21hdGljYWxseSBhbmQgZWZmaWNpZW50bHkgdHJhbnNsYXRlZCBpbnRvIGNvcGllcywgZ2l2aW5nIHlvdSBib3RoXHJcbiAqIGNvbnZlbmllbmNlIGFuZCBpbW11dGFiaWxpdHkuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIHJlZHVjZXIuXHJcbiAqIEBwYXJhbSBhY3Rpb25zTWFwIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBhY3Rpb24tdHlwZS1zcGVjaWZpY1xyXG4gKiAgIGNhc2UgcmVkdWNlcnMuXHJcbiAqIEBwYXJhbSBhY3Rpb25NYXRjaGVycyBBbiBhcnJheSBvZiBtYXRjaGVyIGRlZmluaXRpb25zIGluIHRoZSBmb3JtIGB7bWF0Y2hlciwgcmVkdWNlcn1gLlxyXG4gKiAgIEFsbCBtYXRjaGluZyByZWR1Y2VycyB3aWxsIGJlIGV4ZWN1dGVkIGluIG9yZGVyLCBpbmRlcGVuZGVudGx5IGlmIGEgY2FzZSByZWR1Y2VyIG1hdGNoZWQgb3Igbm90LlxyXG4gKiBAcGFyYW0gZGVmYXVsdENhc2VSZWR1Y2VyIEEgXCJkZWZhdWx0IGNhc2VcIiByZWR1Y2VyIHRoYXQgaXMgZXhlY3V0ZWQgaWYgbm8gY2FzZSByZWR1Y2VyIGFuZCBubyBtYXRjaGVyXHJcbiAqICAgcmVkdWNlciB3YXMgZXhlY3V0ZWQgZm9yIHRoaXMgYWN0aW9uLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVkdWNlcjxcclxuICBTLFxyXG4gIENSIGV4dGVuZHMgQ2FzZVJlZHVjZXJzPFMsIGFueT4gPSBDYXNlUmVkdWNlcnM8UywgYW55PlxyXG4+KFxyXG4gIGluaXRpYWxTdGF0ZTogUyxcclxuICBhY3Rpb25zTWFwOiBDUixcclxuICBhY3Rpb25NYXRjaGVycz86IEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb248Uz4sXHJcbiAgZGVmYXVsdENhc2VSZWR1Y2VyPzogQ2FzZVJlZHVjZXI8Uz5cclxuKTogUmVkdWNlcjxTPlxyXG4vKipcclxuICogQSB1dGlsaXR5IGZ1bmN0aW9uIHRoYXQgYWxsb3dzIGRlZmluaW5nIGEgcmVkdWNlciBhcyBhIG1hcHBpbmcgZnJvbSBhY3Rpb25cclxuICogdHlwZSB0byAqY2FzZSByZWR1Y2VyKiBmdW5jdGlvbnMgdGhhdCBoYW5kbGUgdGhlc2UgYWN0aW9uIHR5cGVzLiBUaGVcclxuICogcmVkdWNlcidzIGluaXRpYWwgc3RhdGUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICpcclxuICogVGhlIGJvZHkgb2YgZXZlcnkgY2FzZSByZWR1Y2VyIGlzIGltcGxpY2l0bHkgd3JhcHBlZCB3aXRoIGEgY2FsbCB0b1xyXG4gKiBgcHJvZHVjZSgpYCBmcm9tIHRoZSBbaW1tZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9td2VzdHN0cmF0ZS9pbW1lcikgbGlicmFyeS5cclxuICogVGhpcyBtZWFucyB0aGF0IHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBzdGF0ZSBvYmplY3QsIHlvdSBjYW4gYWxzb1xyXG4gKiBtdXRhdGUgdGhlIHBhc3NlZC1pbiBzdGF0ZSBvYmplY3QgZGlyZWN0bHk7IHRoZXNlIG11dGF0aW9ucyB3aWxsIHRoZW4gYmVcclxuICogYXV0b21hdGljYWxseSBhbmQgZWZmaWNpZW50bHkgdHJhbnNsYXRlZCBpbnRvIGNvcGllcywgZ2l2aW5nIHlvdSBib3RoXHJcbiAqIGNvbnZlbmllbmNlIGFuZCBpbW11dGFiaWxpdHkuXHJcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgVGhlIGluaXRpYWwgc3RhdGUgdG8gYmUgcmV0dXJuZWQgYnkgdGhlIHJlZHVjZXIuXHJcbiAqIEBwYXJhbSBidWlsZGVyQ2FsbGJhY2sgQSBjYWxsYmFjayB0aGF0IHJlY2VpdmVzIGEgKmJ1aWxkZXIqIG9iamVjdCB0byBkZWZpbmVcclxuICogICBjYXNlIHJlZHVjZXJzIHZpYSBjYWxscyB0byBgYnVpbGRlci5hZGRDYXNlKGFjdGlvbkNyZWF0b3JPclR5cGUsIHJlZHVjZXIpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZXI8Uz4oXHJcbiAgaW5pdGlhbFN0YXRlOiBTLFxyXG4gIGJ1aWxkZXJDYWxsYmFjazogKGJ1aWxkZXI6IEFjdGlvblJlZHVjZXJNYXBCdWlsZGVyPFM+KSA9PiB2b2lkXHJcbik6IFJlZHVjZXI8Uz5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWR1Y2VyPFM+KFxyXG4gIGluaXRpYWxTdGF0ZTogUyxcclxuICBtYXBPckJ1aWxkZXJDYWxsYmFjazpcclxuICAgIHwgQ2FzZVJlZHVjZXJzPFMsIGFueT5cclxuICAgIHwgKChidWlsZGVyOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxTPikgPT4gdm9pZCksXHJcbiAgYWN0aW9uTWF0Y2hlcnM6IEFjdGlvbk1hdGNoZXJEZXNjcmlwdGlvbkNvbGxlY3Rpb248Uz4gPSBbXSxcclxuICBkZWZhdWx0Q2FzZVJlZHVjZXI/OiBDYXNlUmVkdWNlcjxTPlxyXG4pOiBSZWR1Y2VyPFM+IHtcclxuICBsZXQgW2FjdGlvbnNNYXAsIGZpbmFsQWN0aW9uTWF0Y2hlcnMsIGZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXSA9XHJcbiAgICB0eXBlb2YgbWFwT3JCdWlsZGVyQ2FsbGJhY2sgPT09ICdmdW5jdGlvbidcclxuICAgICAgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhtYXBPckJ1aWxkZXJDYWxsYmFjaylcclxuICAgICAgOiBbbWFwT3JCdWlsZGVyQ2FsbGJhY2ssIGFjdGlvbk1hdGNoZXJzLCBkZWZhdWx0Q2FzZVJlZHVjZXJdXHJcblxyXG4gIHJldHVybiBmdW5jdGlvbihzdGF0ZSA9IGluaXRpYWxTdGF0ZSwgYWN0aW9uKTogUyB7XHJcbiAgICBsZXQgY2FzZVJlZHVjZXJzID0gW1xyXG4gICAgICBhY3Rpb25zTWFwW2FjdGlvbi50eXBlXSxcclxuICAgICAgLi4uZmluYWxBY3Rpb25NYXRjaGVyc1xyXG4gICAgICAgIC5maWx0ZXIoKHsgbWF0Y2hlciB9KSA9PiBtYXRjaGVyKGFjdGlvbikpXHJcbiAgICAgICAgLm1hcCgoeyByZWR1Y2VyIH0pID0+IHJlZHVjZXIpXHJcbiAgICBdXHJcbiAgICBpZiAoY2FzZVJlZHVjZXJzLmZpbHRlcihjciA9PiAhIWNyKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgY2FzZVJlZHVjZXJzID0gW2ZpbmFsRGVmYXVsdENhc2VSZWR1Y2VyXVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjYXNlUmVkdWNlcnMucmVkdWNlKChwcmV2aW91c1N0YXRlLCBjYXNlUmVkdWNlcik6IFMgPT4ge1xyXG4gICAgICBpZiAoY2FzZVJlZHVjZXIpIHtcclxuICAgICAgICBpZiAoaXNEcmFmdChwcmV2aW91c1N0YXRlKSkge1xyXG4gICAgICAgICAgLy8gSWYgaXQncyBhbHJlYWR5IGEgZHJhZnQsIHdlIG11c3QgYWxyZWFkeSBiZSBpbnNpZGUgYSBgY3JlYXRlTmV4dFN0YXRlYCBjYWxsLFxyXG4gICAgICAgICAgLy8gbGlrZWx5IGJlY2F1c2UgdGhpcyBpcyBiZWluZyB3cmFwcGVkIGluIGBjcmVhdGVSZWR1Y2VyYCwgYGNyZWF0ZVNsaWNlYCwgb3IgbmVzdGVkXHJcbiAgICAgICAgICAvLyBpbnNpZGUgYW4gZXhpc3RpbmcgZHJhZnQuIEl0J3Mgc2FmZSB0byBqdXN0IHBhc3MgdGhlIGRyYWZ0IHRvIHRoZSBtdXRhdG9yLlxyXG4gICAgICAgICAgY29uc3QgZHJhZnQgPSBwcmV2aW91c1N0YXRlIGFzIERyYWZ0PFM+IC8vIFdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhbHJlYWR5IGEgZHJhZnRcclxuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNhc2VSZWR1Y2VyKGRyYWZ0LCBhY3Rpb24pXHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1N0YXRlXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRHJhZnRhYmxlKHByZXZpb3VzU3RhdGUpKSB7XHJcbiAgICAgICAgICAvLyBJZiBzdGF0ZSBpcyBub3QgZHJhZnRhYmxlIChleDogYSBwcmltaXRpdmUsIHN1Y2ggYXMgMCksIHdlIHdhbnQgdG8gZGlyZWN0bHlcclxuICAgICAgICAgIC8vIHJldHVybiB0aGUgY2FzZVJlZHVjZXIgZnVuYyBhbmQgbm90IHdyYXAgaXQgd2l0aCBwcm9kdWNlLlxyXG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2FzZVJlZHVjZXIocHJldmlvdXNTdGF0ZSBhcyBhbnksIGFjdGlvbilcclxuXHJcbiAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXHJcbiAgICAgICAgICAgICAgJ0EgY2FzZSByZWR1Y2VyIG9uIGEgbm9uLWRyYWZ0YWJsZSB2YWx1ZSBtdXN0IG5vdCByZXR1cm4gdW5kZWZpbmVkJ1xyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIGNyZWF0ZU5leHRTdGF0ZSgpIHByb2R1Y2VzIGFuIEltbXV0YWJsZTxEcmFmdDxTPj4gcmF0aGVyXHJcbiAgICAgICAgICAvLyB0aGFuIGFuIEltbXV0YWJsZTxTPiwgYW5kIFR5cGVTY3JpcHQgY2Fubm90IGZpbmQgb3V0IGhvdyB0byByZWNvbmNpbGVcclxuICAgICAgICAgIC8vIHRoZXNlIHR3byB0eXBlcy5cclxuICAgICAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUocHJldmlvdXNTdGF0ZSwgKGRyYWZ0OiBEcmFmdDxTPikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gY2FzZVJlZHVjZXIoZHJhZnQsIGFjdGlvbilcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcHJldmlvdXNTdGF0ZVxyXG4gICAgfSwgc3RhdGUpXHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IFJlZHVjZXIgfSBmcm9tICdyZWR1eCdcclxuaW1wb3J0IHtcclxuICBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWQsXHJcbiAgY3JlYXRlQWN0aW9uLFxyXG4gIFBheWxvYWRBY3Rpb24sXHJcbiAgUGF5bG9hZEFjdGlvbkNyZWF0b3IsXHJcbiAgUHJlcGFyZUFjdGlvbixcclxuICBfQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWRcclxufSBmcm9tICcuL2NyZWF0ZUFjdGlvbidcclxuaW1wb3J0IHsgQ2FzZVJlZHVjZXIsIENhc2VSZWR1Y2VycywgY3JlYXRlUmVkdWNlciB9IGZyb20gJy4vY3JlYXRlUmVkdWNlcidcclxuaW1wb3J0IHtcclxuICBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcixcclxuICBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFja1xyXG59IGZyb20gJy4vbWFwQnVpbGRlcnMnXHJcbmltcG9ydCB7IE9taXQsIE5vSW5mZXIgfSBmcm9tICcuL3RzSGVscGVycydcclxuXHJcbi8qKlxyXG4gKiBBbiBhY3Rpb24gY3JlYXRvciBhdHRhY2hlZCB0byBhIHNsaWNlLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBwbGVhc2UgdXNlIFBheWxvYWRBY3Rpb25DcmVhdG9yIGRpcmVjdGx5XHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIFNsaWNlQWN0aW9uQ3JlYXRvcjxQPiA9IFBheWxvYWRBY3Rpb25DcmVhdG9yPFA+XHJcblxyXG4vKipcclxuICogVGhlIHJldHVybiB2YWx1ZSBvZiBgY3JlYXRlU2xpY2VgXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2xpY2U8XHJcbiAgU3RhdGUgPSBhbnksXHJcbiAgQ2FzZVJlZHVjZXJzIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+ID0gU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+LFxyXG4gIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmdcclxuPiB7XHJcbiAgLyoqXHJcbiAgICogVGhlIHNsaWNlIG5hbWUuXHJcbiAgICovXHJcbiAgbmFtZTogTmFtZVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgc2xpY2UncyByZWR1Y2VyLlxyXG4gICAqL1xyXG4gIHJlZHVjZXI6IFJlZHVjZXI8U3RhdGU+XHJcblxyXG4gIC8qKlxyXG4gICAqIEFjdGlvbiBjcmVhdG9ycyBmb3IgdGhlIHR5cGVzIG9mIGFjdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSB0aGUgc2xpY2VcclxuICAgKiByZWR1Y2VyLlxyXG4gICAqL1xyXG4gIGFjdGlvbnM6IENhc2VSZWR1Y2VyQWN0aW9uczxDYXNlUmVkdWNlcnM+XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBpbmRpdmlkdWFsIGNhc2UgcmVkdWNlciBmdW5jdGlvbnMgdGhhdCB3ZXJlIHBhc3NlZCBpbiB0aGUgYHJlZHVjZXJzYCBwYXJhbWV0ZXIuXHJcbiAgICogVGhpcyBlbmFibGVzIHJldXNlIGFuZCB0ZXN0aW5nIGlmIHRoZXkgd2VyZSBkZWZpbmVkIGlubGluZSB3aGVuIGNhbGxpbmcgYGNyZWF0ZVNsaWNlYC5cclxuICAgKi9cclxuICBjYXNlUmVkdWNlcnM6IFNsaWNlRGVmaW5lZENhc2VSZWR1Y2VyczxDYXNlUmVkdWNlcnM+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBPcHRpb25zIGZvciBgY3JlYXRlU2xpY2UoKWAuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlU2xpY2VPcHRpb25zPFxyXG4gIFN0YXRlID0gYW55LFxyXG4gIENSIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+ID0gU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+LFxyXG4gIE5hbWUgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmdcclxuPiB7XHJcbiAgLyoqXHJcbiAgICogVGhlIHNsaWNlJ3MgbmFtZS4gVXNlZCB0byBuYW1lc3BhY2UgdGhlIGdlbmVyYXRlZCBhY3Rpb24gdHlwZXMuXHJcbiAgICovXHJcbiAgbmFtZTogTmFtZVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgaW5pdGlhbCBzdGF0ZSB0byBiZSByZXR1cm5lZCBieSB0aGUgc2xpY2UgcmVkdWNlci5cclxuICAgKi9cclxuICBpbml0aWFsU3RhdGU6IFN0YXRlXHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBhY3Rpb24tdHlwZS1zcGVjaWZpYyAqY2FzZSByZWR1Y2VyKlxyXG4gICAqIGZ1bmN0aW9ucy4gRm9yIGV2ZXJ5IGFjdGlvbiB0eXBlLCBhIG1hdGNoaW5nIGFjdGlvbiBjcmVhdG9yIHdpbGwgYmVcclxuICAgKiBnZW5lcmF0ZWQgdXNpbmcgYGNyZWF0ZUFjdGlvbigpYC5cclxuICAgKi9cclxuICByZWR1Y2VyczogVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VyczxTdGF0ZSwgQ1I+XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWFwcGluZyBmcm9tIGFjdGlvbiB0eXBlcyB0byBhY3Rpb24tdHlwZS1zcGVjaWZpYyAqY2FzZSByZWR1Y2VyKlxyXG4gICAqIGZ1bmN0aW9ucy4gVGhlc2UgcmVkdWNlcnMgc2hvdWxkIGhhdmUgZXhpc3RpbmcgYWN0aW9uIHR5cGVzIHVzZWRcclxuICAgKiBhcyB0aGUga2V5cywgYW5kIGFjdGlvbiBjcmVhdG9ycyB3aWxsIF9ub3RfIGJlIGdlbmVyYXRlZC5cclxuICAgKiBBbHRlcm5hdGl2ZWx5LCBhIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgYSAqYnVpbGRlciogb2JqZWN0IHRvIGRlZmluZVxyXG4gICAqIGNhc2UgcmVkdWNlcnMgdmlhIGNhbGxzIHRvIGBidWlsZGVyLmFkZENhc2UoYWN0aW9uQ3JlYXRvck9yVHlwZSwgcmVkdWNlcilgLlxyXG4gICAqL1xyXG4gIGV4dHJhUmVkdWNlcnM/OlxyXG4gICAgfCBDYXNlUmVkdWNlcnM8Tm9JbmZlcjxTdGF0ZT4sIGFueT5cclxuICAgIHwgKChidWlsZGVyOiBBY3Rpb25SZWR1Y2VyTWFwQnVpbGRlcjxOb0luZmVyPFN0YXRlPj4pID0+IHZvaWQpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBIENhc2VSZWR1Y2VyIHdpdGggYSBgcHJlcGFyZWAgbWV0aG9kLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBDYXNlUmVkdWNlcldpdGhQcmVwYXJlPFN0YXRlLCBBY3Rpb24gZXh0ZW5kcyBQYXlsb2FkQWN0aW9uPiA9IHtcclxuICByZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgQWN0aW9uPlxyXG4gIHByZXBhcmU6IFByZXBhcmVBY3Rpb248QWN0aW9uWydwYXlsb2FkJ10+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgdHlwZSBkZXNjcmliaW5nIGEgc2xpY2UncyBgcmVkdWNlcnNgIG9wdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgU2xpY2VDYXNlUmVkdWNlcnM8U3RhdGU+ID0ge1xyXG4gIFtLOiBzdHJpbmddOlxyXG4gICAgfCBDYXNlUmVkdWNlcjxTdGF0ZSwgUGF5bG9hZEFjdGlvbjxhbnk+PlxyXG4gICAgfCBDYXNlUmVkdWNlcldpdGhQcmVwYXJlPFN0YXRlLCBQYXlsb2FkQWN0aW9uPGFueSwgc3RyaW5nLCBhbnksIGFueT4+XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXJpdmVzIHRoZSBzbGljZSdzIGBhY3Rpb25zYCBwcm9wZXJ0eSBmcm9tIHRoZSBgcmVkdWNlcnNgIG9wdGlvbnNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQ2FzZVJlZHVjZXJBY3Rpb25zPENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPGFueT4+ID0ge1xyXG4gIFtUeXBlIGluIGtleW9mIENhc2VSZWR1Y2Vyc106IENhc2VSZWR1Y2Vyc1tUeXBlXSBleHRlbmRzIHsgcHJlcGFyZTogYW55IH1cclxuICAgID8gQWN0aW9uQ3JlYXRvckZvckNhc2VSZWR1Y2VyV2l0aFByZXBhcmU8Q2FzZVJlZHVjZXJzW1R5cGVdPlxyXG4gICAgOiBBY3Rpb25DcmVhdG9yRm9yQ2FzZVJlZHVjZXI8Q2FzZVJlZHVjZXJzW1R5cGVdPlxyXG59XHJcblxyXG4vKipcclxuICogR2V0IGEgYFBheWxvYWRBY3Rpb25DcmVhdG9yYCB0eXBlIGZvciBhIHBhc3NlZCBgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZWBcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG50eXBlIEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcldpdGhQcmVwYXJlPFxyXG4gIENSIGV4dGVuZHMgeyBwcmVwYXJlOiBhbnkgfVxyXG4+ID0gX0FjdGlvbkNyZWF0b3JXaXRoUHJlcGFyZWRQYXlsb2FkPENSWydwcmVwYXJlJ10sIHN0cmluZz5cclxuXHJcbi8qKlxyXG4gKiBHZXQgYSBgUGF5bG9hZEFjdGlvbkNyZWF0b3JgIHR5cGUgZm9yIGEgcGFzc2VkIGBDYXNlUmVkdWNlcmBcclxuICpcclxuICogQGludGVybmFsXHJcbiAqL1xyXG50eXBlIEFjdGlvbkNyZWF0b3JGb3JDYXNlUmVkdWNlcjxDUj4gPSBDUiBleHRlbmRzIChcclxuICBzdGF0ZTogYW55LFxyXG4gIGFjdGlvbjogaW5mZXIgQWN0aW9uXHJcbikgPT4gYW55XHJcbiAgPyBBY3Rpb24gZXh0ZW5kcyB7IHBheWxvYWQ6IGluZmVyIFAgfVxyXG4gICAgPyBQYXlsb2FkQWN0aW9uQ3JlYXRvcjxQPlxyXG4gICAgOiBBY3Rpb25DcmVhdG9yV2l0aG91dFBheWxvYWRcclxuICA6IEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZFxyXG5cclxuLyoqXHJcbiAqIEV4dHJhY3RzIHRoZSBDYXNlUmVkdWNlcnMgb3V0IG9mIGEgYHJlZHVjZXJzYCBvYmplY3QsIGV2ZW4gaWYgdGhleSBhcmVcclxuICogdGVzdGVkIGludG8gYSBgQ2FzZVJlZHVjZXJXaXRoUHJlcGFyZWAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudHlwZSBTbGljZURlZmluZWRDYXNlUmVkdWNlcnM8Q2FzZVJlZHVjZXJzIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8YW55Pj4gPSB7XHJcbiAgW1R5cGUgaW4ga2V5b2YgQ2FzZVJlZHVjZXJzXTogQ2FzZVJlZHVjZXJzW1R5cGVdIGV4dGVuZHMge1xyXG4gICAgcmVkdWNlcjogaW5mZXIgUmVkdWNlclxyXG4gIH1cclxuICAgID8gUmVkdWNlclxyXG4gICAgOiBDYXNlUmVkdWNlcnNbVHlwZV1cclxufVxyXG5cclxuLyoqXHJcbiAqIFVzZWQgb24gYSBTbGljZUNhc2VSZWR1Y2VycyBvYmplY3QuXHJcbiAqIEVuc3VyZXMgdGhhdCBpZiBhIENhc2VSZWR1Y2VyIGlzIGEgYENhc2VSZWR1Y2VyV2l0aFByZXBhcmVgLCB0aGF0XHJcbiAqIHRoZSBgcmVkdWNlcmAgYW5kIHRoZSBgcHJlcGFyZWAgZnVuY3Rpb24gdXNlIHRoZSBzYW1lIHR5cGUgb2YgYHBheWxvYWRgLlxyXG4gKlxyXG4gKiBNaWdodCBkbyBhZGRpdGlvbmFsIHN1Y2ggY2hlY2tzIGluIHRoZSBmdXR1cmUuXHJcbiAqXHJcbiAqIFRoaXMgdHlwZSBpcyBvbmx5IGV2ZXIgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdyaXRlIHlvdXIgb3duIHdyYXBwZXIgYXJvdW5kXHJcbiAqIGBjcmVhdGVTbGljZWAuIFBsZWFzZSBkb24ndCB1c2UgaXQgb3RoZXJ3aXNlIVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBWYWxpZGF0ZVNsaWNlQ2FzZVJlZHVjZXJzPFxyXG4gIFMsXHJcbiAgQUNSIGV4dGVuZHMgU2xpY2VDYXNlUmVkdWNlcnM8Uz5cclxuPiA9IEFDUiAmXHJcbiAge1xyXG4gICAgW1QgaW4ga2V5b2YgQUNSXTogQUNSW1RdIGV4dGVuZHMge1xyXG4gICAgICByZWR1Y2VyKHM6IFMsIGFjdGlvbj86IGluZmVyIEEpOiBhbnlcclxuICAgIH1cclxuICAgICAgPyB7XHJcbiAgICAgICAgICBwcmVwYXJlKC4uLmE6IG5ldmVyW10pOiBPbWl0PEEsICd0eXBlJz5cclxuICAgICAgICB9XHJcbiAgICAgIDoge31cclxuICB9XHJcblxyXG5mdW5jdGlvbiBnZXRUeXBlKHNsaWNlOiBzdHJpbmcsIGFjdGlvbktleTogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gYCR7c2xpY2V9LyR7YWN0aW9uS2V5fWBcclxufVxyXG5cclxuLyoqXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIGluaXRpYWwgc3RhdGUsIGFuIG9iamVjdCBmdWxsIG9mIHJlZHVjZXJcclxuICogZnVuY3Rpb25zLCBhbmQgYSBcInNsaWNlIG5hbWVcIiwgYW5kIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzXHJcbiAqIGFjdGlvbiBjcmVhdG9ycyBhbmQgYWN0aW9uIHR5cGVzIHRoYXQgY29ycmVzcG9uZCB0byB0aGVcclxuICogcmVkdWNlcnMgYW5kIHN0YXRlLlxyXG4gKlxyXG4gKiBUaGUgYHJlZHVjZXJgIGFyZ3VtZW50IGlzIHBhc3NlZCB0byBgY3JlYXRlUmVkdWNlcigpYC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNsaWNlPFxyXG4gIFN0YXRlLFxyXG4gIENhc2VSZWR1Y2VycyBleHRlbmRzIFNsaWNlQ2FzZVJlZHVjZXJzPFN0YXRlPixcclxuICBOYW1lIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nXHJcbj4oXHJcbiAgb3B0aW9uczogQ3JlYXRlU2xpY2VPcHRpb25zPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWU+XHJcbik6IFNsaWNlPFN0YXRlLCBDYXNlUmVkdWNlcnMsIE5hbWU+IHtcclxuICBjb25zdCB7IG5hbWUsIGluaXRpYWxTdGF0ZSB9ID0gb3B0aW9uc1xyXG4gIGlmICghbmFtZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdgbmFtZWAgaXMgYSByZXF1aXJlZCBvcHRpb24gZm9yIGNyZWF0ZVNsaWNlJylcclxuICB9XHJcbiAgY29uc3QgcmVkdWNlcnMgPSBvcHRpb25zLnJlZHVjZXJzIHx8IHt9XHJcbiAgY29uc3QgW1xyXG4gICAgZXh0cmFSZWR1Y2VycyA9IHt9LFxyXG4gICAgYWN0aW9uTWF0Y2hlcnMgPSBbXSxcclxuICAgIGRlZmF1bHRDYXNlUmVkdWNlciA9IHVuZGVmaW5lZFxyXG4gIF0gPVxyXG4gICAgdHlwZW9mIG9wdGlvbnMuZXh0cmFSZWR1Y2VycyA9PT0gJ3VuZGVmaW5lZCdcclxuICAgICAgPyBbXVxyXG4gICAgICA6IHR5cGVvZiBvcHRpb25zLmV4dHJhUmVkdWNlcnMgPT09ICdmdW5jdGlvbidcclxuICAgICAgPyBleGVjdXRlUmVkdWNlckJ1aWxkZXJDYWxsYmFjayhvcHRpb25zLmV4dHJhUmVkdWNlcnMpXHJcbiAgICAgIDogW29wdGlvbnMuZXh0cmFSZWR1Y2Vyc11cclxuXHJcbiAgY29uc3QgcmVkdWNlck5hbWVzID0gT2JqZWN0LmtleXMocmVkdWNlcnMpXHJcblxyXG4gIGNvbnN0IHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lOiBSZWNvcmQ8c3RyaW5nLCBDYXNlUmVkdWNlcj4gPSB7fVxyXG4gIGNvbnN0IHNsaWNlQ2FzZVJlZHVjZXJzQnlUeXBlOiBSZWNvcmQ8c3RyaW5nLCBDYXNlUmVkdWNlcj4gPSB7fVxyXG4gIGNvbnN0IGFjdGlvbkNyZWF0b3JzOiBSZWNvcmQ8c3RyaW5nLCBGdW5jdGlvbj4gPSB7fVxyXG5cclxuICByZWR1Y2VyTmFtZXMuZm9yRWFjaChyZWR1Y2VyTmFtZSA9PiB7XHJcbiAgICBjb25zdCBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSA9IHJlZHVjZXJzW3JlZHVjZXJOYW1lXVxyXG4gICAgY29uc3QgdHlwZSA9IGdldFR5cGUobmFtZSwgcmVkdWNlck5hbWUpXHJcblxyXG4gICAgbGV0IGNhc2VSZWR1Y2VyOiBDYXNlUmVkdWNlcjxTdGF0ZSwgYW55PlxyXG4gICAgbGV0IHByZXBhcmVDYWxsYmFjazogUHJlcGFyZUFjdGlvbjxhbnk+IHwgdW5kZWZpbmVkXHJcblxyXG4gICAgaWYgKCdyZWR1Y2VyJyBpbiBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZSkge1xyXG4gICAgICBjYXNlUmVkdWNlciA9IG1heWJlUmVkdWNlcldpdGhQcmVwYXJlLnJlZHVjZXJcclxuICAgICAgcHJlcGFyZUNhbGxiYWNrID0gbWF5YmVSZWR1Y2VyV2l0aFByZXBhcmUucHJlcGFyZVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2FzZVJlZHVjZXIgPSBtYXliZVJlZHVjZXJXaXRoUHJlcGFyZVxyXG4gICAgfVxyXG5cclxuICAgIHNsaWNlQ2FzZVJlZHVjZXJzQnlOYW1lW3JlZHVjZXJOYW1lXSA9IGNhc2VSZWR1Y2VyXHJcbiAgICBzbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZVt0eXBlXSA9IGNhc2VSZWR1Y2VyXHJcbiAgICBhY3Rpb25DcmVhdG9yc1tyZWR1Y2VyTmFtZV0gPSBwcmVwYXJlQ2FsbGJhY2tcclxuICAgICAgPyBjcmVhdGVBY3Rpb24odHlwZSwgcHJlcGFyZUNhbGxiYWNrKVxyXG4gICAgICA6IGNyZWF0ZUFjdGlvbih0eXBlKVxyXG4gIH0pXHJcblxyXG4gIGNvbnN0IGZpbmFsQ2FzZVJlZHVjZXJzID0geyAuLi5leHRyYVJlZHVjZXJzLCAuLi5zbGljZUNhc2VSZWR1Y2Vyc0J5VHlwZSB9XHJcbiAgY29uc3QgcmVkdWNlciA9IGNyZWF0ZVJlZHVjZXIoXHJcbiAgICBpbml0aWFsU3RhdGUsXHJcbiAgICBmaW5hbENhc2VSZWR1Y2VycyBhcyBhbnksXHJcbiAgICBhY3Rpb25NYXRjaGVycyxcclxuICAgIGRlZmF1bHRDYXNlUmVkdWNlclxyXG4gIClcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG5hbWUsXHJcbiAgICByZWR1Y2VyLFxyXG4gICAgYWN0aW9uczogYWN0aW9uQ3JlYXRvcnMgYXMgYW55LFxyXG4gICAgY2FzZVJlZHVjZXJzOiBzbGljZUNhc2VSZWR1Y2Vyc0J5TmFtZSBhcyBhbnlcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgRW50aXR5U3RhdGUgfSBmcm9tICcuL21vZGVscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsRW50aXR5U3RhdGU8Vj4oKTogRW50aXR5U3RhdGU8Vj4ge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZHM6IFtdLFxyXG4gICAgZW50aXRpZXM6IHt9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSW5pdGlhbFN0YXRlRmFjdG9yeTxWPigpIHtcclxuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoKTogRW50aXR5U3RhdGU8Vj5cclxuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGU8UyBleHRlbmRzIG9iamVjdD4oXHJcbiAgICBhZGRpdGlvbmFsU3RhdGU6IFNcclxuICApOiBFbnRpdHlTdGF0ZTxWPiAmIFNcclxuICBmdW5jdGlvbiBnZXRJbml0aWFsU3RhdGUoYWRkaXRpb25hbFN0YXRlOiBhbnkgPSB7fSk6IGFueSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihnZXRJbml0aWFsRW50aXR5U3RhdGUoKSwgYWRkaXRpb25hbFN0YXRlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgZ2V0SW5pdGlhbFN0YXRlIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjcmVhdGVTZWxlY3RvciB9IGZyb20gJ3Jlc2VsZWN0J1xyXG5pbXBvcnQgeyBFbnRpdHlTdGF0ZSwgRW50aXR5U2VsZWN0b3JzLCBEaWN0aW9uYXJ5LCBFbnRpdHlJZCB9IGZyb20gJy4vbW9kZWxzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yc0ZhY3Rvcnk8VD4oKSB7XHJcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0b3JzKCk6IEVudGl0eVNlbGVjdG9yczxULCBFbnRpdHlTdGF0ZTxUPj5cclxuICBmdW5jdGlvbiBnZXRTZWxlY3RvcnM8Vj4oXHJcbiAgICBzZWxlY3RTdGF0ZTogKHN0YXRlOiBWKSA9PiBFbnRpdHlTdGF0ZTxUPlxyXG4gICk6IEVudGl0eVNlbGVjdG9yczxULCBWPlxyXG4gIGZ1bmN0aW9uIGdldFNlbGVjdG9ycyhcclxuICAgIHNlbGVjdFN0YXRlPzogKHN0YXRlOiBhbnkpID0+IEVudGl0eVN0YXRlPFQ+XHJcbiAgKTogRW50aXR5U2VsZWN0b3JzPFQsIGFueT4ge1xyXG4gICAgY29uc3Qgc2VsZWN0SWRzID0gKHN0YXRlOiBhbnkpID0+IHN0YXRlLmlkc1xyXG5cclxuICAgIGNvbnN0IHNlbGVjdEVudGl0aWVzID0gKHN0YXRlOiBFbnRpdHlTdGF0ZTxUPikgPT4gc3RhdGUuZW50aXRpZXNcclxuXHJcbiAgICBjb25zdCBzZWxlY3RBbGwgPSBjcmVhdGVTZWxlY3RvcihcclxuICAgICAgc2VsZWN0SWRzLFxyXG4gICAgICBzZWxlY3RFbnRpdGllcyxcclxuICAgICAgKGlkczogVFtdLCBlbnRpdGllczogRGljdGlvbmFyeTxUPik6IGFueSA9PlxyXG4gICAgICAgIGlkcy5tYXAoKGlkOiBhbnkpID0+IChlbnRpdGllcyBhcyBhbnkpW2lkXSlcclxuICAgIClcclxuXHJcbiAgICBjb25zdCBzZWxlY3RJZCA9IChfOiBhbnksIGlkOiBFbnRpdHlJZCkgPT4gaWRcclxuXHJcbiAgICBjb25zdCBzZWxlY3RCeUlkID0gKGVudGl0aWVzOiBEaWN0aW9uYXJ5PFQ+LCBpZDogRW50aXR5SWQpID0+IGVudGl0aWVzW2lkXVxyXG5cclxuICAgIGNvbnN0IHNlbGVjdFRvdGFsID0gY3JlYXRlU2VsZWN0b3Ioc2VsZWN0SWRzLCBpZHMgPT4gaWRzLmxlbmd0aClcclxuXHJcbiAgICBpZiAoIXNlbGVjdFN0YXRlKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0SWRzLFxyXG4gICAgICAgIHNlbGVjdEVudGl0aWVzLFxyXG4gICAgICAgIHNlbGVjdEFsbCxcclxuICAgICAgICBzZWxlY3RUb3RhbCxcclxuICAgICAgICBzZWxlY3RCeUlkOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzZWxlY3RHbG9iYWxpemVkRW50aXRpZXMgPSBjcmVhdGVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0RW50aXRpZXMpXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2VsZWN0SWRzOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0SWRzKSxcclxuICAgICAgc2VsZWN0RW50aXRpZXM6IHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcyxcclxuICAgICAgc2VsZWN0QWxsOiBjcmVhdGVTZWxlY3RvcihzZWxlY3RTdGF0ZSwgc2VsZWN0QWxsKSxcclxuICAgICAgc2VsZWN0VG90YWw6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdFN0YXRlLCBzZWxlY3RUb3RhbCksXHJcbiAgICAgIHNlbGVjdEJ5SWQ6IGNyZWF0ZVNlbGVjdG9yKHNlbGVjdEdsb2JhbGl6ZWRFbnRpdGllcywgc2VsZWN0SWQsIHNlbGVjdEJ5SWQpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geyBnZXRTZWxlY3RvcnMgfVxyXG59XHJcbiIsImltcG9ydCBjcmVhdGVOZXh0U3RhdGUsIHsgaXNEcmFmdCB9IGZyb20gJ2ltbWVyJ1xyXG5pbXBvcnQgeyBFbnRpdHlTdGF0ZSwgUHJldmVudEFueSB9IGZyb20gJy4vbW9kZWxzJ1xyXG5pbXBvcnQgeyBQYXlsb2FkQWN0aW9uLCBpc0ZTQSB9IGZyb20gJy4uL2NyZWF0ZUFjdGlvbidcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaW5nbGVBcmd1bWVudFN0YXRlT3BlcmF0b3I8Vj4oXHJcbiAgbXV0YXRvcjogKHN0YXRlOiBFbnRpdHlTdGF0ZTxWPikgPT4gdm9pZFxyXG4pIHtcclxuICBjb25zdCBvcGVyYXRvciA9IGNyZWF0ZVN0YXRlT3BlcmF0b3IoKF86IHVuZGVmaW5lZCwgc3RhdGU6IEVudGl0eVN0YXRlPFY+KSA9PlxyXG4gICAgbXV0YXRvcihzdGF0ZSlcclxuICApXHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb248UyBleHRlbmRzIEVudGl0eVN0YXRlPFY+PihcclxuICAgIHN0YXRlOiBQcmV2ZW50QW55PFMsIFY+XHJcbiAgKTogUyB7XHJcbiAgICByZXR1cm4gb3BlcmF0b3Ioc3RhdGUgYXMgUywgdW5kZWZpbmVkKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVN0YXRlT3BlcmF0b3I8ViwgUj4oXHJcbiAgbXV0YXRvcjogKGFyZzogUiwgc3RhdGU6IEVudGl0eVN0YXRlPFY+KSA9PiB2b2lkXHJcbikge1xyXG4gIHJldHVybiBmdW5jdGlvbiBvcGVyYXRpb248UyBleHRlbmRzIEVudGl0eVN0YXRlPFY+PihcclxuICAgIHN0YXRlOiBTLFxyXG4gICAgYXJnOiBSIHwgUGF5bG9hZEFjdGlvbjxSPlxyXG4gICk6IFMge1xyXG4gICAgZnVuY3Rpb24gaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoXHJcbiAgICAgIGFyZzogUiB8IFBheWxvYWRBY3Rpb248Uj5cclxuICAgICk6IGFyZyBpcyBQYXlsb2FkQWN0aW9uPFI+IHtcclxuICAgICAgcmV0dXJuIGlzRlNBKGFyZylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBydW5NdXRhdG9yID0gKGRyYWZ0OiBFbnRpdHlTdGF0ZTxWPikgPT4ge1xyXG4gICAgICBpZiAoaXNQYXlsb2FkQWN0aW9uQXJndW1lbnQoYXJnKSkge1xyXG4gICAgICAgIG11dGF0b3IoYXJnLnBheWxvYWQsIGRyYWZ0KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG11dGF0b3IoYXJnLCBkcmFmdClcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0RyYWZ0KHN0YXRlKSkge1xyXG4gICAgICAvLyB3ZSBtdXN0IGFscmVhZHkgYmUgaW5zaWRlIGEgYGNyZWF0ZU5leHRTdGF0ZWAgY2FsbCwgbGlrZWx5IGJlY2F1c2VcclxuICAgICAgLy8gdGhpcyBpcyBiZWluZyB3cmFwcGVkIGluIGBjcmVhdGVSZWR1Y2VyYCBvciBgY3JlYXRlU2xpY2VgLlxyXG4gICAgICAvLyBJdCdzIHNhZmUgdG8ganVzdCBwYXNzIHRoZSBkcmFmdCB0byB0aGUgbXV0YXRvci5cclxuICAgICAgcnVuTXV0YXRvcihzdGF0ZSlcclxuXHJcbiAgICAgIC8vIHNpbmNlIGl0J3MgYSBkcmFmdCwgd2UnbGwganVzdCByZXR1cm4gaXRcclxuICAgICAgcmV0dXJuIHN0YXRlXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBAdHMtaWdub3JlIGNyZWF0ZU5leHRTdGF0ZSgpIHByb2R1Y2VzIGFuIEltbXV0YWJsZTxEcmFmdDxTPj4gcmF0aGVyXHJcbiAgICAgIC8vIHRoYW4gYW4gSW1tdXRhYmxlPFM+LCBhbmQgVHlwZVNjcmlwdCBjYW5ub3QgZmluZCBvdXQgaG93IHRvIHJlY29uY2lsZVxyXG4gICAgICAvLyB0aGVzZSB0d28gdHlwZXMuXHJcbiAgICAgIHJldHVybiBjcmVhdGVOZXh0U3RhdGUoc3RhdGUsIHJ1bk11dGF0b3IpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IElkU2VsZWN0b3IgfSBmcm9tICcuL21vZGVscydcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZWxlY3RJZFZhbHVlPFQ+KGVudGl0eTogVCwgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VD4pIHtcclxuICBjb25zdCBrZXkgPSBzZWxlY3RJZChlbnRpdHkpXHJcblxyXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGtleSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICdUaGUgZW50aXR5IHBhc3NlZCB0byB0aGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCB1bmRlZmluZWQuJyxcclxuICAgICAgJ1lvdSBzaG91bGQgcHJvYmFibHkgcHJvdmlkZSB5b3VyIG93biBgc2VsZWN0SWRgIGltcGxlbWVudGF0aW9uLicsXHJcbiAgICAgICdUaGUgZW50aXR5IHRoYXQgd2FzIHBhc3NlZDonLFxyXG4gICAgICBlbnRpdHksXHJcbiAgICAgICdUaGUgYHNlbGVjdElkYCBpbXBsZW1lbnRhdGlvbjonLFxyXG4gICAgICBzZWxlY3RJZC50b1N0cmluZygpXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICByZXR1cm4ga2V5XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBFbnRpdHlTdGF0ZSxcclxuICBFbnRpdHlTdGF0ZUFkYXB0ZXIsXHJcbiAgSWRTZWxlY3RvcixcclxuICBVcGRhdGUsXHJcbiAgRW50aXR5SWRcclxufSBmcm9tICcuL21vZGVscydcclxuaW1wb3J0IHtcclxuICBjcmVhdGVTdGF0ZU9wZXJhdG9yLFxyXG4gIGNyZWF0ZVNpbmdsZUFyZ3VtZW50U3RhdGVPcGVyYXRvclxyXG59IGZyb20gJy4vc3RhdGVfYWRhcHRlcidcclxuaW1wb3J0IHsgc2VsZWN0SWRWYWx1ZSB9IGZyb20gJy4vdXRpbHMnXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXI8VD4oXHJcbiAgc2VsZWN0SWQ6IElkU2VsZWN0b3I8VD5cclxuKTogRW50aXR5U3RhdGVBZGFwdGVyPFQ+IHtcclxuICB0eXBlIFIgPSBFbnRpdHlTdGF0ZTxUPlxyXG5cclxuICBmdW5jdGlvbiBhZGRPbmVNdXRhYmx5KGVudGl0eTogVCwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIGNvbnN0IGtleSA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZClcclxuXHJcbiAgICBpZiAoa2V5IGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmlkcy5wdXNoKGtleSlcclxuICAgIHN0YXRlLmVudGl0aWVzW2tleV0gPSBlbnRpdHlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KGVudGl0aWVzOiBUW10gfCBSZWNvcmQ8RW50aXR5SWQsIFQ+LCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xyXG4gICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpXHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgYWRkT25lTXV0YWJseShlbnRpdHksIHN0YXRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QWxsTXV0YWJseShlbnRpdGllczogVFtdIHwgUmVjb3JkPEVudGl0eUlkLCBUPiwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShlbnRpdGllcykpIHtcclxuICAgICAgZW50aXRpZXMgPSBPYmplY3QudmFsdWVzKGVudGl0aWVzKVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmlkcyA9IFtdXHJcbiAgICBzdGF0ZS5lbnRpdGllcyA9IHt9XHJcblxyXG4gICAgYWRkTWFueU11dGFibHkoZW50aXRpZXMsIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gcmVtb3ZlT25lTXV0YWJseShrZXk6IEVudGl0eUlkLCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgcmV0dXJuIHJlbW92ZU1hbnlNdXRhYmx5KFtrZXldLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZU1hbnlNdXRhYmx5KGtleXM6IEVudGl0eUlkW10sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBsZXQgZGlkTXV0YXRlID0gZmFsc2VcclxuXHJcbiAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgaWYgKGtleSBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgIGRlbGV0ZSBzdGF0ZS5lbnRpdGllc1trZXldXHJcbiAgICAgICAgZGlkTXV0YXRlID0gdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChkaWRNdXRhdGUpIHtcclxuICAgICAgc3RhdGUuaWRzID0gc3RhdGUuaWRzLmZpbHRlcihpZCA9PiBpZCBpbiBzdGF0ZS5lbnRpdGllcylcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlbW92ZUFsbE11dGFibHkoc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUsIHtcclxuICAgICAgaWRzOiBbXSxcclxuICAgICAgZW50aXRpZXM6IHt9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdGFrZU5ld0tleShcclxuICAgIGtleXM6IHsgW2lkOiBzdHJpbmddOiBFbnRpdHlJZCB9LFxyXG4gICAgdXBkYXRlOiBVcGRhdGU8VD4sXHJcbiAgICBzdGF0ZTogUlxyXG4gICk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdXHJcbiAgICBjb25zdCB1cGRhdGVkOiBUID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwsIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgY29uc3QgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZClcclxuICAgIGNvbnN0IGhhc05ld0tleSA9IG5ld0tleSAhPT0gdXBkYXRlLmlkXHJcblxyXG4gICAgaWYgKGhhc05ld0tleSkge1xyXG4gICAgICBrZXlzW3VwZGF0ZS5pZF0gPSBuZXdLZXlcclxuICAgICAgZGVsZXRlIHN0YXRlLmVudGl0aWVzW3VwZGF0ZS5pZF1cclxuICAgIH1cclxuXHJcbiAgICBzdGF0ZS5lbnRpdGllc1tuZXdLZXldID0gdXBkYXRlZFxyXG5cclxuICAgIHJldHVybiBoYXNOZXdLZXlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwZGF0ZU9uZU11dGFibHkodXBkYXRlOiBVcGRhdGU8VD4sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICByZXR1cm4gdXBkYXRlTWFueU11dGFibHkoW3VwZGF0ZV0sIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlTWFueU11dGFibHkodXBkYXRlczogVXBkYXRlPFQ+W10sIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICBjb25zdCBuZXdLZXlzOiB7IFtpZDogc3RyaW5nXTogRW50aXR5SWQgfSA9IHt9XHJcblxyXG4gICAgY29uc3QgdXBkYXRlc1BlckVudGl0eTogeyBbaWQ6IHN0cmluZ106IFVwZGF0ZTxUPiB9ID0ge31cclxuXHJcbiAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHtcclxuICAgICAgLy8gT25seSBhcHBseSB1cGRhdGVzIHRvIGVudGl0aWVzIHRoYXQgY3VycmVudGx5IGV4aXN0XHJcbiAgICAgIGlmICh1cGRhdGUuaWQgaW4gc3RhdGUuZW50aXRpZXMpIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdXBkYXRlcyB0byBvbmUgZW50aXR5LCBtZXJnZSB0aGVtIHRvZ2V0aGVyXHJcbiAgICAgICAgdXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdID0ge1xyXG4gICAgICAgICAgaWQ6IHVwZGF0ZS5pZCxcclxuICAgICAgICAgIC8vIFNwcmVhZHMgaWdub3JlIGZhbHN5IHZhbHVlcywgc28gdGhpcyB3b3JrcyBldmVuIGlmIHRoZXJlIGlzbid0XHJcbiAgICAgICAgICAvLyBhbiBleGlzdGluZyB1cGRhdGUgYWxyZWFkeSBhdCB0aGlzIGtleVxyXG4gICAgICAgICAgY2hhbmdlczoge1xyXG4gICAgICAgICAgICAuLi4odXBkYXRlc1BlckVudGl0eVt1cGRhdGUuaWRdXHJcbiAgICAgICAgICAgICAgPyB1cGRhdGVzUGVyRW50aXR5W3VwZGF0ZS5pZF0uY2hhbmdlc1xyXG4gICAgICAgICAgICAgIDogbnVsbCksXHJcbiAgICAgICAgICAgIC4uLnVwZGF0ZS5jaGFuZ2VzXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG5cclxuICAgIHVwZGF0ZXMgPSBPYmplY3QudmFsdWVzKHVwZGF0ZXNQZXJFbnRpdHkpXHJcblxyXG4gICAgY29uc3QgZGlkTXV0YXRlRW50aXRpZXMgPSB1cGRhdGVzLmxlbmd0aCA+IDBcclxuXHJcbiAgICBpZiAoZGlkTXV0YXRlRW50aXRpZXMpIHtcclxuICAgICAgY29uc3QgZGlkTXV0YXRlSWRzID1cclxuICAgICAgICB1cGRhdGVzLmZpbHRlcih1cGRhdGUgPT4gdGFrZU5ld0tleShuZXdLZXlzLCB1cGRhdGUsIHN0YXRlKSkubGVuZ3RoID4gMFxyXG5cclxuICAgICAgaWYgKGRpZE11dGF0ZUlkcykge1xyXG4gICAgICAgIHN0YXRlLmlkcyA9IHN0YXRlLmlkcy5tYXAoaWQgPT4gbmV3S2V5c1tpZF0gfHwgaWQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwc2VydE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgcmV0dXJuIHVwc2VydE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHVwc2VydE1hbnlNdXRhYmx5KFxyXG4gICAgZW50aXRpZXM6IFRbXSB8IFJlY29yZDxFbnRpdHlJZCwgVD4sXHJcbiAgICBzdGF0ZTogUlxyXG4gICk6IHZvaWQge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGVudGl0aWVzKSkge1xyXG4gICAgICBlbnRpdGllcyA9IE9iamVjdC52YWx1ZXMoZW50aXRpZXMpXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYWRkZWQ6IFRbXSA9IFtdXHJcbiAgICBjb25zdCB1cGRhdGVkOiBVcGRhdGU8VD5bXSA9IFtdXHJcblxyXG4gICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgY29uc3QgaWQgPSBzZWxlY3RJZFZhbHVlKGVudGl0eSwgc2VsZWN0SWQpXHJcbiAgICAgIGlmIChpZCBpbiBzdGF0ZS5lbnRpdGllcykge1xyXG4gICAgICAgIHVwZGF0ZWQucHVzaCh7IGlkLCBjaGFuZ2VzOiBlbnRpdHkgfSlcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBhZGRlZC5wdXNoKGVudGl0eSlcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHVwZGF0ZU1hbnlNdXRhYmx5KHVwZGF0ZWQsIHN0YXRlKVxyXG4gICAgYWRkTWFueU11dGFibHkoYWRkZWQsIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlbW92ZUFsbDogY3JlYXRlU2luZ2xlQXJndW1lbnRTdGF0ZU9wZXJhdG9yKHJlbW92ZUFsbE11dGFibHkpLFxyXG4gICAgYWRkT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKGFkZE9uZU11dGFibHkpLFxyXG4gICAgYWRkTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRNYW55TXV0YWJseSksXHJcbiAgICBzZXRBbGw6IGNyZWF0ZVN0YXRlT3BlcmF0b3Ioc2V0QWxsTXV0YWJseSksXHJcbiAgICB1cGRhdGVPbmU6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBkYXRlT25lTXV0YWJseSksXHJcbiAgICB1cGRhdGVNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwZGF0ZU1hbnlNdXRhYmx5KSxcclxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcclxuICAgIHVwc2VydE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IodXBzZXJ0TWFueU11dGFibHkpLFxyXG4gICAgcmVtb3ZlT25lOiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHJlbW92ZU9uZU11dGFibHkpLFxyXG4gICAgcmVtb3ZlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcihyZW1vdmVNYW55TXV0YWJseSlcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBFbnRpdHlTdGF0ZSxcclxuICBJZFNlbGVjdG9yLFxyXG4gIENvbXBhcmVyLFxyXG4gIEVudGl0eVN0YXRlQWRhcHRlcixcclxuICBVcGRhdGUsXHJcbiAgRW50aXR5SWRcclxufSBmcm9tICcuL21vZGVscydcclxuaW1wb3J0IHsgY3JlYXRlU3RhdGVPcGVyYXRvciB9IGZyb20gJy4vc3RhdGVfYWRhcHRlcidcclxuaW1wb3J0IHsgY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIgfSBmcm9tICcuL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXInXHJcbmltcG9ydCB7IHNlbGVjdElkVmFsdWUgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcjxUPihcclxuICBzZWxlY3RJZDogSWRTZWxlY3RvcjxUPixcclxuICBzb3J0OiBDb21wYXJlcjxUPlxyXG4pOiBFbnRpdHlTdGF0ZUFkYXB0ZXI8VD4ge1xyXG4gIHR5cGUgUiA9IEVudGl0eVN0YXRlPFQ+XHJcblxyXG4gIGNvbnN0IHsgcmVtb3ZlT25lLCByZW1vdmVNYW55LCByZW1vdmVBbGwgfSA9IGNyZWF0ZVVuc29ydGVkU3RhdGVBZGFwdGVyKFxyXG4gICAgc2VsZWN0SWRcclxuICApXHJcblxyXG4gIGZ1bmN0aW9uIGFkZE9uZU11dGFibHkoZW50aXR5OiBULCBzdGF0ZTogUik6IHZvaWQge1xyXG4gICAgcmV0dXJuIGFkZE1hbnlNdXRhYmx5KFtlbnRpdHldLCBzdGF0ZSlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZE1hbnlNdXRhYmx5KFxyXG4gICAgbmV3TW9kZWxzOiBUW10gfCBSZWNvcmQ8RW50aXR5SWQsIFQ+LFxyXG4gICAgc3RhdGU6IFJcclxuICApOiB2b2lkIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShuZXdNb2RlbHMpKSB7XHJcbiAgICAgIG5ld01vZGVscyA9IE9iamVjdC52YWx1ZXMobmV3TW9kZWxzKVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1vZGVscyA9IG5ld01vZGVscy5maWx0ZXIoXHJcbiAgICAgIG1vZGVsID0+ICEoc2VsZWN0SWRWYWx1ZShtb2RlbCwgc2VsZWN0SWQpIGluIHN0YXRlLmVudGl0aWVzKVxyXG4gICAgKVxyXG5cclxuICAgIGlmIChtb2RlbHMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIG1lcmdlKG1vZGVscywgc3RhdGUpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBzZXRBbGxNdXRhYmx5KG1vZGVsczogVFtdIHwgUmVjb3JkPEVudGl0eUlkLCBUPiwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShtb2RlbHMpKSB7XHJcbiAgICAgIG1vZGVscyA9IE9iamVjdC52YWx1ZXMobW9kZWxzKVxyXG4gICAgfVxyXG4gICAgc3RhdGUuZW50aXRpZXMgPSB7fVxyXG4gICAgc3RhdGUuaWRzID0gW11cclxuXHJcbiAgICBhZGRNYW55TXV0YWJseShtb2RlbHMsIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBkYXRlT25lTXV0YWJseSh1cGRhdGU6IFVwZGF0ZTxUPiwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIHJldHVybiB1cGRhdGVNYW55TXV0YWJseShbdXBkYXRlXSwgc3RhdGUpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB0YWtlVXBkYXRlZE1vZGVsKG1vZGVsczogVFtdLCB1cGRhdGU6IFVwZGF0ZTxUPiwgc3RhdGU6IFIpOiBib29sZWFuIHtcclxuICAgIGlmICghKHVwZGF0ZS5pZCBpbiBzdGF0ZS5lbnRpdGllcykpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb3JpZ2luYWwgPSBzdGF0ZS5lbnRpdGllc1t1cGRhdGUuaWRdXHJcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWwsIHVwZGF0ZS5jaGFuZ2VzKVxyXG4gICAgY29uc3QgbmV3S2V5ID0gc2VsZWN0SWRWYWx1ZSh1cGRhdGVkLCBzZWxlY3RJZClcclxuXHJcbiAgICBkZWxldGUgc3RhdGUuZW50aXRpZXNbdXBkYXRlLmlkXVxyXG5cclxuICAgIG1vZGVscy5wdXNoKHVwZGF0ZWQpXHJcblxyXG4gICAgcmV0dXJuIG5ld0tleSAhPT0gdXBkYXRlLmlkXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiB1cGRhdGVNYW55TXV0YWJseSh1cGRhdGVzOiBVcGRhdGU8VD5bXSwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIGNvbnN0IG1vZGVsczogVFtdID0gW11cclxuXHJcbiAgICB1cGRhdGVzLmZvckVhY2godXBkYXRlID0+IHRha2VVcGRhdGVkTW9kZWwobW9kZWxzLCB1cGRhdGUsIHN0YXRlKSlcclxuXHJcbiAgICBpZiAobW9kZWxzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICBtZXJnZShtb2RlbHMsIHN0YXRlKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBzZXJ0T25lTXV0YWJseShlbnRpdHk6IFQsIHN0YXRlOiBSKTogdm9pZCB7XHJcbiAgICByZXR1cm4gdXBzZXJ0TWFueU11dGFibHkoW2VudGl0eV0sIHN0YXRlKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gdXBzZXJ0TWFueU11dGFibHkoXHJcbiAgICBlbnRpdGllczogVFtdIHwgUmVjb3JkPEVudGl0eUlkLCBUPixcclxuICAgIHN0YXRlOiBSXHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZW50aXRpZXMpKSB7XHJcbiAgICAgIGVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhlbnRpdGllcylcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhZGRlZDogVFtdID0gW11cclxuICAgIGNvbnN0IHVwZGF0ZWQ6IFVwZGF0ZTxUPltdID0gW11cclxuXHJcbiAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xyXG4gICAgICBjb25zdCBpZCA9IHNlbGVjdElkVmFsdWUoZW50aXR5LCBzZWxlY3RJZClcclxuICAgICAgaWYgKGlkIGluIHN0YXRlLmVudGl0aWVzKSB7XHJcbiAgICAgICAgdXBkYXRlZC5wdXNoKHsgaWQsIGNoYW5nZXM6IGVudGl0eSB9KVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkZGVkLnB1c2goZW50aXR5KVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdXBkYXRlTWFueU11dGFibHkodXBkYXRlZCwgc3RhdGUpXHJcbiAgICBhZGRNYW55TXV0YWJseShhZGRlZCwgc3RhdGUpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhOiB1bmtub3duW10sIGI6IHVua25vd25bXSkge1xyXG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoICYmIGkgPCBiLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGlmIChhW2ldID09PSBiW2ldKSB7XHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtZXJnZShtb2RlbHM6IFRbXSwgc3RhdGU6IFIpOiB2b2lkIHtcclxuICAgIG1vZGVscy5zb3J0KHNvcnQpXHJcblxyXG4gICAgLy8gSW5zZXJ0L292ZXJ3cml0ZSBhbGwgbmV3L3VwZGF0ZWRcclxuICAgIG1vZGVscy5mb3JFYWNoKG1vZGVsID0+IHtcclxuICAgICAgc3RhdGUuZW50aXRpZXNbc2VsZWN0SWQobW9kZWwpXSA9IG1vZGVsXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IGFsbEVudGl0aWVzID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5lbnRpdGllcykgYXMgVFtdXHJcbiAgICBhbGxFbnRpdGllcy5zb3J0KHNvcnQpXHJcblxyXG4gICAgY29uc3QgbmV3U29ydGVkSWRzID0gYWxsRW50aXRpZXMubWFwKHNlbGVjdElkKVxyXG4gICAgY29uc3QgeyBpZHMgfSA9IHN0YXRlXHJcblxyXG4gICAgaWYgKCFhcmVBcnJheXNFcXVhbChpZHMsIG5ld1NvcnRlZElkcykpIHtcclxuICAgICAgc3RhdGUuaWRzID0gbmV3U29ydGVkSWRzXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4ge1xyXG4gICAgcmVtb3ZlT25lLFxyXG4gICAgcmVtb3ZlTWFueSxcclxuICAgIHJlbW92ZUFsbCxcclxuICAgIGFkZE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcihhZGRPbmVNdXRhYmx5KSxcclxuICAgIHVwZGF0ZU9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVPbmVNdXRhYmx5KSxcclxuICAgIHVwc2VydE9uZTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cHNlcnRPbmVNdXRhYmx5KSxcclxuICAgIHNldEFsbDogY3JlYXRlU3RhdGVPcGVyYXRvcihzZXRBbGxNdXRhYmx5KSxcclxuICAgIGFkZE1hbnk6IGNyZWF0ZVN0YXRlT3BlcmF0b3IoYWRkTWFueU11dGFibHkpLFxyXG4gICAgdXBkYXRlTWFueTogY3JlYXRlU3RhdGVPcGVyYXRvcih1cGRhdGVNYW55TXV0YWJseSksXHJcbiAgICB1cHNlcnRNYW55OiBjcmVhdGVTdGF0ZU9wZXJhdG9yKHVwc2VydE1hbnlNdXRhYmx5KVxyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBFbnRpdHlEZWZpbml0aW9uLCBDb21wYXJlciwgSWRTZWxlY3RvciwgRW50aXR5QWRhcHRlciB9IGZyb20gJy4vbW9kZWxzJ1xyXG5pbXBvcnQgeyBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5IH0gZnJvbSAnLi9lbnRpdHlfc3RhdGUnXHJcbmltcG9ydCB7IGNyZWF0ZVNlbGVjdG9yc0ZhY3RvcnkgfSBmcm9tICcuL3N0YXRlX3NlbGVjdG9ycydcclxuaW1wb3J0IHsgY3JlYXRlU29ydGVkU3RhdGVBZGFwdGVyIH0gZnJvbSAnLi9zb3J0ZWRfc3RhdGVfYWRhcHRlcidcclxuaW1wb3J0IHsgY3JlYXRlVW5zb3J0ZWRTdGF0ZUFkYXB0ZXIgfSBmcm9tICcuL3Vuc29ydGVkX3N0YXRlX2FkYXB0ZXInXHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIG9wdGlvbnNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVudGl0eUFkYXB0ZXI8VD4oXHJcbiAgb3B0aW9uczoge1xyXG4gICAgc2VsZWN0SWQ/OiBJZFNlbGVjdG9yPFQ+XHJcbiAgICBzb3J0Q29tcGFyZXI/OiBmYWxzZSB8IENvbXBhcmVyPFQ+XHJcbiAgfSA9IHt9XHJcbik6IEVudGl0eUFkYXB0ZXI8VD4ge1xyXG4gIGNvbnN0IHsgc2VsZWN0SWQsIHNvcnRDb21wYXJlciB9OiBFbnRpdHlEZWZpbml0aW9uPFQ+ID0ge1xyXG4gICAgc29ydENvbXBhcmVyOiBmYWxzZSxcclxuICAgIHNlbGVjdElkOiAoaW5zdGFuY2U6IGFueSkgPT4gaW5zdGFuY2UuaWQsXHJcbiAgICAuLi5vcHRpb25zXHJcbiAgfVxyXG5cclxuICBjb25zdCBzdGF0ZUZhY3RvcnkgPSBjcmVhdGVJbml0aWFsU3RhdGVGYWN0b3J5PFQ+KClcclxuICBjb25zdCBzZWxlY3RvcnNGYWN0b3J5ID0gY3JlYXRlU2VsZWN0b3JzRmFjdG9yeTxUPigpXHJcbiAgY29uc3Qgc3RhdGVBZGFwdGVyID0gc29ydENvbXBhcmVyXHJcbiAgICA/IGNyZWF0ZVNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZCwgc29ydENvbXBhcmVyKVxyXG4gICAgOiBjcmVhdGVVbnNvcnRlZFN0YXRlQWRhcHRlcihzZWxlY3RJZClcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHNlbGVjdElkLFxyXG4gICAgc29ydENvbXBhcmVyLFxyXG4gICAgLi4uc3RhdGVGYWN0b3J5LFxyXG4gICAgLi4uc2VsZWN0b3JzRmFjdG9yeSxcclxuICAgIC4uLnN0YXRlQWRhcHRlclxyXG4gIH1cclxufVxyXG4iLCIvLyBBIHR5cGUgb2YgcHJvbWlzZS1saWtlIHRoYXQgcmVzb2x2ZXMgc3luY2hyb25vdXNseSBhbmQgc3VwcG9ydHMgb25seSBvbmUgb2JzZXJ2ZXJcbmV4cG9ydCBjb25zdCBfUGFjdCA9IC8qI19fUFVSRV9fKi8oZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIF9QYWN0KCkge31cblx0X1BhY3QucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IG5ldyBfUGFjdCgpO1xuXHRcdGNvbnN0IHN0YXRlID0gdGhpcy5zO1xuXHRcdGlmIChzdGF0ZSkge1xuXHRcdFx0Y29uc3QgY2FsbGJhY2sgPSBzdGF0ZSAmIDEgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG5cdFx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMSwgY2FsbGJhY2sodGhpcy52KSk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMiwgZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLm8gPSBmdW5jdGlvbihfdGhpcykge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBfdGhpcy52O1xuXHRcdFx0XHRpZiAoX3RoaXMucyAmIDEpIHtcblx0XHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMSwgb25GdWxmaWxsZWQgPyBvbkZ1bGZpbGxlZCh2YWx1ZSkgOiB2YWx1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAob25SZWplY3RlZCkge1xuXHRcdFx0XHRcdF9zZXR0bGUocmVzdWx0LCAxLCBvblJlamVjdGVkKHZhbHVlKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3NldHRsZShyZXN1bHQsIDIsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRfc2V0dGxlKHJlc3VsdCwgMiwgZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdHJldHVybiBfUGFjdDtcbn0pKCk7XG5cbi8vIFNldHRsZXMgYSBwYWN0IHN5bmNocm9ub3VzbHlcbmV4cG9ydCBmdW5jdGlvbiBfc2V0dGxlKHBhY3QsIHN0YXRlLCB2YWx1ZSkge1xuXHRpZiAoIXBhY3Qucykge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIF9QYWN0KSB7XG5cdFx0XHRpZiAodmFsdWUucykge1xuXHRcdFx0XHRpZiAoc3RhdGUgJiAxKSB7XG5cdFx0XHRcdFx0c3RhdGUgPSB2YWx1ZS5zO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUudjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbHVlLm8gPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgc3RhdGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG5cdFx0XHR2YWx1ZS50aGVuKF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCBzdGF0ZSksIF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCAyKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHBhY3QucyA9IHN0YXRlO1xuXHRcdHBhY3QudiA9IHZhbHVlO1xuXHRcdGNvbnN0IG9ic2VydmVyID0gcGFjdC5vO1xuXHRcdGlmIChvYnNlcnZlcikge1xuXHRcdFx0b2JzZXJ2ZXIocGFjdCk7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaXNTZXR0bGVkUGFjdCh0aGVuYWJsZSkge1xuXHRyZXR1cm4gdGhlbmFibGUgaW5zdGFuY2VvZiBfUGFjdCAmJiB0aGVuYWJsZS5zICYgMTtcbn1cblxuLy8gQ29udmVydHMgYXJndW1lbnQgdG8gYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIGEgUHJvbWlzZVxuZXhwb3J0IGZ1bmN0aW9uIF9hc3luYyhmKSB7XG5cdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBhcmdzID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmLmFwcGx5KHRoaXMsIGFyZ3MpKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcblx0XHR9XG5cdH1cbn1cblxuLy8gQXdhaXRzIG9uIGEgdmFsdWUgdGhhdCBtYXkgb3IgbWF5IG5vdCBiZSBhIFByb21pc2UgKGVxdWl2YWxlbnQgdG8gdGhlIGF3YWl0IGtleXdvcmQgaW4gRVMyMDE1LCB3aXRoIGNvbnRpbnVhdGlvbnMgcGFzc2VkIGV4cGxpY2l0bHkpXG5leHBvcnQgZnVuY3Rpb24gX2F3YWl0KHZhbHVlLCB0aGVuLCBkaXJlY3QpIHtcblx0aWYgKGRpcmVjdCkge1xuXHRcdHJldHVybiB0aGVuID8gdGhlbih2YWx1ZSkgOiB2YWx1ZTtcblx0fVxuXHRpZiAoIXZhbHVlIHx8ICF2YWx1ZS50aGVuKSB7XG5cdFx0dmFsdWUgPSBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuXHR9XG5cdHJldHVybiB0aGVuID8gdmFsdWUudGhlbih0aGVuKSA6IHZhbHVlO1xufVxuXG4vLyBBd2FpdHMgb24gYSB2YWx1ZSB0aGF0IG1heSBvciBtYXkgbm90IGJlIGEgUHJvbWlzZSwgdGhlbiBpZ25vcmVzIGl0XG5leHBvcnQgZnVuY3Rpb24gX2F3YWl0SWdub3JlZCh2YWx1ZSwgZGlyZWN0KSB7XG5cdGlmICghZGlyZWN0KSB7XG5cdFx0cmV0dXJuIHZhbHVlICYmIHZhbHVlLnRoZW4gPyB2YWx1ZS50aGVuKF9lbXB0eSkgOiBQcm9taXNlLnJlc29sdmUoKTtcblx0fVxufVxuXG4vLyBQcm9jZWVkcyBhZnRlciBhIHZhbHVlIGhhcyByZXNvbHZlZCwgb3IgcHJvY2VlZHMgaW1tZWRpYXRlbHkgaWYgdGhlIHZhbHVlIGlzIG5vdCB0aGVuYWJsZVxuZXhwb3J0IGZ1bmN0aW9uIF9jb250aW51ZSh2YWx1ZSwgdGhlbikge1xuXHRyZXR1cm4gdmFsdWUgJiYgdmFsdWUudGhlbiA/IHZhbHVlLnRoZW4odGhlbikgOiB0aGVuKHZhbHVlKTtcbn1cblxuLy8gUHJvY2VlZHMgYWZ0ZXIgYSB2YWx1ZSBoYXMgcmVzb2x2ZWQsIG9yIHByb2NlZWRzIGltbWVkaWF0ZWx5IGlmIHRoZSB2YWx1ZSBpcyBub3QgdGhlbmFibGVcbmV4cG9ydCBmdW5jdGlvbiBfY29udGludWVJZ25vcmVkKHZhbHVlKSB7XG5cdGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG5cdFx0cmV0dXJuIHZhbHVlLnRoZW4oX2VtcHR5KTtcblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIHRocm91Z2ggYW4gb2JqZWN0IHRoYXQgaGFzIGEgbGVuZ3RoIHByb3BlcnR5LCBwYXNzaW5nIHRoZSBpbmRleCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIChldmVuIGFzIHRoZSBsZW5ndGggcHJvcGVydHkgY2hhbmdlcylcbmV4cG9ydCBmdW5jdGlvbiBfZm9yVG8oYXJyYXksIGJvZHksIGNoZWNrKSB7XG5cdHZhciBpID0gLTEsIHBhY3QsIHJlamVjdDtcblx0ZnVuY3Rpb24gX2N5Y2xlKHJlc3VsdCkge1xuXHRcdHRyeSB7XG5cdFx0XHR3aGlsZSAoKytpIDwgYXJyYXkubGVuZ3RoICYmICghY2hlY2sgfHwgIWNoZWNrKCkpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGJvZHkoaSk7XG5cdFx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnY7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdC50aGVuKF9jeWNsZSwgcmVqZWN0IHx8IChyZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCA9IG5ldyBfUGFjdCgpLCAyKSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhY3QpIHtcblx0XHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFjdCA9IHJlc3VsdDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRfc2V0dGxlKHBhY3QgfHwgKHBhY3QgPSBuZXcgX1BhY3QoKSksIDIsIGUpO1xuXHRcdH1cblx0fVxuXHRfY3ljbGUoKTtcblx0cmV0dXJuIHBhY3Q7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGl0ZXJhdGUgdGhyb3VnaCBhbiBvYmplY3QncyBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSB0aGUgcHJvdG90eXBlKVxuLy8gVXNlcyBhIHNuYXBzaG90IG9mIHRoZSBvYmplY3QncyBwcm9wZXJ0aWVzXG5leHBvcnQgZnVuY3Rpb24gX2ZvckluKHRhcmdldCwgYm9keSwgY2hlY2spIHtcblx0dmFyIGtleXMgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuXHRcdGtleXMucHVzaChrZXkpO1xuXHR9XG5cdHJldHVybiBfZm9yVG8oa2V5cywgZnVuY3Rpb24oaSkgeyByZXR1cm4gYm9keShrZXlzW2ldKTsgfSwgY2hlY2spO1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIHRocm91Z2ggYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMgKGV4Y2x1ZGluZyBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIHRoZSBwcm90b3R5cGUpXG4vLyBVc2VzIGEgc25hcHNob3Qgb2YgdGhlIG9iamVjdCdzIHByb3BlcnRpZXNcbmV4cG9ydCBmdW5jdGlvbiBfZm9yT3duKHRhcmdldCwgYm9keSwgY2hlY2spIHtcblx0dmFyIGtleXMgPSBbXTtcblx0Zm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuXHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG5cdFx0XHRrZXlzLnB1c2goa2V5KTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIF9mb3JUbyhrZXlzLCBmdW5jdGlvbihpKSB7IHJldHVybiBib2R5KGtleXNbaV0pOyB9LCBjaGVjayk7XG59XG5cbmV4cG9ydCBjb25zdCBfaXRlcmF0b3JTeW1ib2wgPSAvKiNfX1BVUkVfXyovIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyAoU3ltYm9sLml0ZXJhdG9yIHx8IChTeW1ib2wuaXRlcmF0b3IgPSBTeW1ib2woXCJTeW1ib2wuaXRlcmF0b3JcIikpKSA6IFwiQEBpdGVyYXRvclwiO1xuXG4vLyBBc3luY2hyb25vdXNseSBpdGVyYXRlIHRocm91Z2ggYW4gb2JqZWN0J3MgdmFsdWVzXG4vLyBVc2VzIGZvci4uLm9mIGlmIHRoZSBydW50aW1lIHN1cHBvcnRzIGl0LCBvdGhlcndpc2UgaXRlcmF0ZXMgdW50aWwgbGVuZ3RoIG9uIGEgY29weVxuZXhwb3J0IGZ1bmN0aW9uIF9mb3JPZih0YXJnZXQsIGJvZHksIGNoZWNrKSB7XG5cdGlmICh0eXBlb2YgdGFyZ2V0W19pdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHZhciBpdGVyYXRvciA9IHRhcmdldFtfaXRlcmF0b3JTeW1ib2xdKCksIHN0ZXAsIHBhY3QsIHJlamVjdDtcblx0XHRmdW5jdGlvbiBfY3ljbGUocmVzdWx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lICYmICghY2hlY2sgfHwgIWNoZWNrKCkpKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gYm9keShzdGVwLnZhbHVlKTtcblx0XHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0XHRpZiAoX2lzU2V0dGxlZFBhY3QocmVzdWx0KSkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdC50aGVuKF9jeWNsZSwgcmVqZWN0IHx8IChyZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCA9IG5ldyBfUGFjdCgpLCAyKSkpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYWN0KSB7XG5cdFx0XHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhY3QgPSByZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3NldHRsZShwYWN0IHx8IChwYWN0ID0gbmV3IF9QYWN0KCkpLCAyLCBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0X2N5Y2xlKCk7XG5cdFx0aWYgKGl0ZXJhdG9yLnJldHVybikge1xuXHRcdFx0dmFyIF9maXh1cCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0aWYgKCFzdGVwLmRvbmUpIHtcblx0XHRcdFx0XHRcdGl0ZXJhdG9yLnJldHVybigpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhY3QgJiYgcGFjdC50aGVuKSB7XG5cdFx0XHRcdHJldHVybiBwYWN0LnRoZW4oX2ZpeHVwLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0dGhyb3cgX2ZpeHVwKGUpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdF9maXh1cCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFjdDtcblx0fVxuXHQvLyBObyBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3Jcblx0aWYgKCEoXCJsZW5ndGhcIiBpbiB0YXJnZXQpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgaXRlcmFibGVcIik7XG5cdH1cblx0Ly8gSGFuZGxlIGxpdmUgY29sbGVjdGlvbnMgcHJvcGVybHlcblx0dmFyIHZhbHVlcyA9IFtdO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldC5sZW5ndGg7IGkrKykge1xuXHRcdHZhbHVlcy5wdXNoKHRhcmdldFtpXSk7XG5cdH1cblx0cmV0dXJuIF9mb3JUbyh2YWx1ZXMsIGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGJvZHkodmFsdWVzW2ldKTsgfSwgY2hlY2spO1xufVxuXG5leHBvcnQgY29uc3QgX2FzeW5jSXRlcmF0b3JTeW1ib2wgPSAvKiNfX1BVUkVfXyovIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgPyAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgKFN5bWJvbC5hc3luY0l0ZXJhdG9yID0gU3ltYm9sKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3JcIikpKSA6IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG5cbi8vIEFzeW5jaHJvbm91c2x5IGl0ZXJhdGUgb24gYSB2YWx1ZSB1c2luZyBpdCdzIGFzeW5jIGl0ZXJhdG9yIGlmIHByZXNlbnQsIG9yIGl0cyBzeW5jaHJvbm91cyBpdGVyYXRvciBpZiBtaXNzaW5nXG5leHBvcnQgZnVuY3Rpb24gX2ZvckF3YWl0T2YodGFyZ2V0LCBib2R5LCBjaGVjaykge1xuXHRpZiAodHlwZW9mIHRhcmdldFtfYXN5bmNJdGVyYXRvclN5bWJvbF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdHZhciBwYWN0ID0gbmV3IF9QYWN0KCk7XG5cdFx0dmFyIGl0ZXJhdG9yID0gdGFyZ2V0W19hc3luY0l0ZXJhdG9yU3ltYm9sXSgpO1xuXHRcdGl0ZXJhdG9yLm5leHQoKS50aGVuKF9yZXN1bWVBZnRlck5leHQpLnRoZW4odm9pZCAwLCBfcmVqZWN0KTtcblx0XHRyZXR1cm4gcGFjdDtcblx0XHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJCb2R5KHJlc3VsdCkge1xuXHRcdFx0aWYgKGNoZWNrICYmIGNoZWNrKCkpIHtcblx0XHRcdFx0cmV0dXJuIF9zZXR0bGUocGFjdCwgMSwgaXRlcmF0b3IucmV0dXJuID8gaXRlcmF0b3IucmV0dXJuKCkudGhlbihmdW5jdGlvbigpIHsgcmV0dXJuIHJlc3VsdDsgfSkgOiByZXN1bHQpO1xuXHRcdFx0fVxuXHRcdFx0aXRlcmF0b3IubmV4dCgpLnRoZW4oX3Jlc3VtZUFmdGVyTmV4dCkudGhlbih2b2lkIDAsIF9yZWplY3QpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJOZXh0KHN0ZXApIHtcblx0XHRcdGlmIChzdGVwLmRvbmUpIHtcblx0XHRcdFx0X3NldHRsZShwYWN0LCAxKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZShib2R5KHN0ZXAudmFsdWUpKS50aGVuKF9yZXN1bWVBZnRlckJvZHkpLnRoZW4odm9pZCAwLCBfcmVqZWN0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gX3JlamVjdChlcnJvcikge1xuXHRcdFx0X3NldHRsZShwYWN0LCAyLCBpdGVyYXRvci5yZXR1cm4gPyBpdGVyYXRvci5yZXR1cm4oKS50aGVuKGZ1bmN0aW9uKCkgeyByZXR1cm4gZXJyb3I7IH0pIDogZXJyb3IpO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKF9mb3JPZih0YXJnZXQsIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oYm9keSk7IH0sIGNoZWNrKSk7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGltcGxlbWVudCBhIGdlbmVyaWMgZm9yIGxvb3BcbmV4cG9ydCBmdW5jdGlvbiBfZm9yKHRlc3QsIHVwZGF0ZSwgYm9keSkge1xuXHR2YXIgc3RhZ2U7XG5cdGZvciAoOzspIHtcblx0XHR2YXIgc2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0aWYgKF9pc1NldHRsZWRQYWN0KHNob3VsZENvbnRpbnVlKSkge1xuXHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdH1cblx0XHRpZiAoIXNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0XHRpZiAoc2hvdWxkQ29udGludWUudGhlbikge1xuXHRcdFx0c3RhZ2UgPSAwO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdFx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LnM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzdGFnZSA9IDE7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodXBkYXRlKSB7XG5cdFx0XHR2YXIgdXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblx0XHRcdGlmICh1cGRhdGVWYWx1ZSAmJiB1cGRhdGVWYWx1ZS50aGVuICYmICFfaXNTZXR0bGVkUGFjdCh1cGRhdGVWYWx1ZSkpIHtcblx0XHRcdFx0c3RhZ2UgPSAyO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0dmFyIHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0dmFyIHJlamVjdCA9IF9zZXR0bGUuYmluZChudWxsLCBwYWN0LCAyKTtcblx0KHN0YWdlID09PSAwID8gc2hvdWxkQ29udGludWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KSA6IHN0YWdlID09PSAxID8gcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkgOiB1cGRhdGVWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclVwZGF0ZSkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRyZXR1cm4gcGFjdDtcblx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyQm9keSh2YWx1ZSkge1xuXHRcdHJlc3VsdCA9IHZhbHVlO1xuXHRcdGRvIHtcblx0XHRcdGlmICh1cGRhdGUpIHtcblx0XHRcdFx0dXBkYXRlVmFsdWUgPSB1cGRhdGUoKTtcblx0XHRcdFx0aWYgKHVwZGF0ZVZhbHVlICYmIHVwZGF0ZVZhbHVlLnRoZW4gJiYgIV9pc1NldHRsZWRQYWN0KHVwZGF0ZVZhbHVlKSkge1xuXHRcdFx0XHRcdHVwZGF0ZVZhbHVlLnRoZW4oX3Jlc3VtZUFmdGVyVXBkYXRlKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHNob3VsZENvbnRpbnVlID0gdGVzdCgpO1xuXHRcdFx0aWYgKCFzaG91bGRDb250aW51ZSB8fCAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpICYmICFzaG91bGRDb250aW51ZS52KSkge1xuXHRcdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC52O1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCFyZXN1bHQgfHwgIXJlc3VsdC50aGVuKTtcblx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0fVxuXHRmdW5jdGlvbiBfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKSB7XG5cdFx0aWYgKHNob3VsZENvbnRpbnVlKSB7XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3Jlc3VtZUFmdGVyQm9keShyZXN1bHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlclVwZGF0ZSgpIHtcblx0XHRpZiAoc2hvdWxkQ29udGludWUgPSB0ZXN0KCkpIHtcblx0XHRcdGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfcmVzdW1lQWZ0ZXJUZXN0KHNob3VsZENvbnRpbnVlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdH1cblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBpbXBsZW1lbnQgYSBkbyAuLi4gd2hpbGUgbG9vcFxuZXhwb3J0IGZ1bmN0aW9uIF9kbyhib2R5LCB0ZXN0KSB7XG5cdHZhciBhd2FpdEJvZHk7XG5cdGRvIHtcblx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChyZXN1bHQpKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC52O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXdhaXRCb2R5ID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblx0XHRpZiAoX2lzU2V0dGxlZFBhY3Qoc2hvdWxkQ29udGludWUpKSB7XG5cdFx0XHRzaG91bGRDb250aW51ZSA9IHNob3VsZENvbnRpbnVlLnY7XG5cdFx0fVxuXHRcdGlmICghc2hvdWxkQ29udGludWUpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9IHdoaWxlICghc2hvdWxkQ29udGludWUudGhlbik7XG5cdGNvbnN0IHBhY3QgPSBuZXcgX1BhY3QoKTtcblx0Y29uc3QgcmVqZWN0ID0gX3NldHRsZS5iaW5kKG51bGwsIHBhY3QsIDIpO1xuXHQoYXdhaXRCb2R5ID8gcmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkgOiBzaG91bGRDb250aW51ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0cmV0dXJuIHBhY3Q7XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlckJvZHkodmFsdWUpIHtcblx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRzaG91bGRDb250aW51ZSA9IHRlc3QoKTtcblx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChzaG91bGRDb250aW51ZSkpIHtcblx0XHRcdFx0c2hvdWxkQ29udGludWUgPSBzaG91bGRDb250aW51ZS52O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCFzaG91bGRDb250aW51ZSkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChzaG91bGRDb250aW51ZS50aGVuKSB7XG5cdFx0XHRcdHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRyZXN1bHQgPSByZXN1bHQudjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHR9XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlclRlc3Qoc2hvdWxkQ29udGludWUpIHtcblx0XHRpZiAoc2hvdWxkQ29udGludWUpIHtcblx0XHRcdGRvIHtcblx0XHRcdFx0cmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0aWYgKF9pc1NldHRsZWRQYWN0KHJlc3VsdCkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC52O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0c2hvdWxkQ29udGludWUgPSB0ZXN0KCk7XG5cdFx0XHRcdGlmIChfaXNTZXR0bGVkUGFjdChzaG91bGRDb250aW51ZSkpIHtcblx0XHRcdFx0XHRzaG91bGRDb250aW51ZSA9IHNob3VsZENvbnRpbnVlLnY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzaG91bGRDb250aW51ZSkge1xuXHRcdFx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCFzaG91bGRDb250aW51ZS50aGVuKTtcblx0XHRcdHNob3VsZENvbnRpbnVlLnRoZW4oX3Jlc3VtZUFmdGVyVGVzdCkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0XHR9XG5cdH1cbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgaW1wbGVtZW50IGEgc3dpdGNoIHN0YXRlbWVudFxuZXhwb3J0IGZ1bmN0aW9uIF9zd2l0Y2goZGlzY3JpbWluYW50LCBjYXNlcykge1xuXHR2YXIgZGlzcGF0Y2hJbmRleCA9IC0xO1xuXHR2YXIgYXdhaXRCb2R5O1xuXHRvdXRlcjoge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY2FzZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0ZXN0ID0gY2FzZXNbaV1bMF07XG5cdFx0XHRpZiAodGVzdCkge1xuXHRcdFx0XHR2YXIgdGVzdFZhbHVlID0gdGVzdCgpO1xuXHRcdFx0XHRpZiAodGVzdFZhbHVlICYmIHRlc3RWYWx1ZS50aGVuKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRlc3RWYWx1ZSA9PT0gZGlzY3JpbWluYW50KSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hJbmRleCA9IGk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEZvdW5kIHRoZSBkZWZhdWx0IGNhc2UsIHNldCBpdCBhcyB0aGUgcGVuZGluZyBkaXNwYXRjaCBjYXNlXG5cdFx0XHRcdGRpc3BhdGNoSW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoZGlzcGF0Y2hJbmRleCAhPT0gLTEpIHtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdFx0d2hpbGUgKCFib2R5KSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdFx0XHRcdGJvZHkgPSBjYXNlc1tkaXNwYXRjaEluZGV4XVsxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmVzdWx0ID0gYm9keSgpO1xuXHRcdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdFx0YXdhaXRCb2R5ID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmFsbHRocm91Z2hDaGVjayA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzJdO1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0XHR9IHdoaWxlIChmYWxsdGhyb3VnaENoZWNrICYmICFmYWxsdGhyb3VnaENoZWNrKCkpO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblx0Y29uc3QgcGFjdCA9IG5ldyBfUGFjdCgpO1xuXHRjb25zdCByZWplY3QgPSBfc2V0dGxlLmJpbmQobnVsbCwgcGFjdCwgMik7XG5cdChhd2FpdEJvZHkgPyByZXN1bHQudGhlbihfcmVzdW1lQWZ0ZXJCb2R5KSA6IHRlc3RWYWx1ZS50aGVuKF9yZXN1bWVBZnRlclRlc3QpKS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0cmV0dXJuIHBhY3Q7XG5cdGZ1bmN0aW9uIF9yZXN1bWVBZnRlclRlc3QodmFsdWUpIHtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpZiAodmFsdWUgPT09IGRpc2NyaW1pbmFudCkge1xuXHRcdFx0XHRkaXNwYXRjaEluZGV4ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoKytpID09PSBjYXNlcy5sZW5ndGgpIHtcblx0XHRcdFx0aWYgKGRpc3BhdGNoSW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0X3NldHRsZShwYWN0LCAxLCByZXN1bHQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGVzdCA9IGNhc2VzW2ldWzBdO1xuXHRcdFx0aWYgKHRlc3QpIHtcblx0XHRcdFx0dmFsdWUgPSB0ZXN0KCk7XG5cdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS50aGVuKSB7XG5cdFx0XHRcdFx0dmFsdWUudGhlbihfcmVzdW1lQWZ0ZXJUZXN0KS50aGVuKHZvaWQgMCwgcmVqZWN0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc3BhdGNoSW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRkbyB7XG5cdFx0XHR2YXIgYm9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0d2hpbGUgKCFib2R5KSB7XG5cdFx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdFx0Ym9keSA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzFdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdFx0cmVzdWx0LnRoZW4oX3Jlc3VtZUFmdGVyQm9keSkudGhlbih2b2lkIDAsIHJlamVjdCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBmYWxsdGhyb3VnaENoZWNrID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMl07XG5cdFx0XHRkaXNwYXRjaEluZGV4Kys7XG5cdFx0fSB3aGlsZSAoZmFsbHRocm91Z2hDaGVjayAmJiAhZmFsbHRocm91Z2hDaGVjaygpKTtcblx0XHRfc2V0dGxlKHBhY3QsIDEsIHJlc3VsdCk7XG5cdH1cblx0ZnVuY3Rpb24gX3Jlc3VtZUFmdGVyQm9keShyZXN1bHQpIHtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHR2YXIgZmFsbHRocm91Z2hDaGVjayA9IGNhc2VzW2Rpc3BhdGNoSW5kZXhdWzJdO1xuXHRcdFx0aWYgKCFmYWxsdGhyb3VnaENoZWNrIHx8IGZhbGx0aHJvdWdoQ2hlY2soKSkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGRpc3BhdGNoSW5kZXgrKztcblx0XHRcdHZhciBib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHR3aGlsZSAoIWJvZHkpIHtcblx0XHRcdFx0ZGlzcGF0Y2hJbmRleCsrO1xuXHRcdFx0XHRib2R5ID0gY2FzZXNbZGlzcGF0Y2hJbmRleF1bMV07XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSBib2R5KCk7XG5cdFx0XHRpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuKSB7XG5cdFx0XHRcdHJlc3VsdC50aGVuKF9yZXN1bWVBZnRlckJvZHkpLnRoZW4odm9pZCAwLCByZWplY3QpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9zZXR0bGUocGFjdCwgMSwgcmVzdWx0KTtcblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBjYWxsIGEgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBleHBsaWNpdGx5IHBhc3NlZCBjb250aW51YXRpb25zXG5leHBvcnQgZnVuY3Rpb24gX2NhbGwoYm9keSwgdGhlbiwgZGlyZWN0KSB7XG5cdGlmIChkaXJlY3QpIHtcblx0XHRyZXR1cm4gdGhlbiA/IHRoZW4oYm9keSgpKSA6IGJvZHkoKTtcblx0fVxuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSBQcm9taXNlLnJlc29sdmUoYm9keSgpKTtcblx0XHRyZXR1cm4gdGhlbiA/IHJlc3VsdC50aGVuKHRoZW4pIDogcmVzdWx0O1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuXHR9XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGNhbGwgYSBmdW5jdGlvbiBhbmQgc3dhbGxvdyB0aGUgcmVzdWx0XG5leHBvcnQgZnVuY3Rpb24gX2NhbGxJZ25vcmVkKGJvZHksIGRpcmVjdCkge1xuXHRyZXR1cm4gX2NhbGwoYm9keSwgX2VtcHR5LCBkaXJlY3QpO1xufVxuXG4vLyBBc3luY2hyb25vdXNseSBjYWxsIGEgZnVuY3Rpb24gYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBleHBsaWNpdGx5IHBhc3NlZCBjb250aW51YXRpb25zXG5leHBvcnQgZnVuY3Rpb24gX2ludm9rZShib2R5LCB0aGVuKSB7XG5cdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4odGhlbik7XG5cdH1cblx0cmV0dXJuIHRoZW4ocmVzdWx0KTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBzd2FsbG93IHRoZSByZXN1bHRcbmV4cG9ydCBmdW5jdGlvbiBfaW52b2tlSWdub3JlZChib2R5KSB7XG5cdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4oX2VtcHR5KTtcblx0fVxufVxuXG4vLyBBc3luY2hyb25vdXNseSBjYWxsIGEgZnVuY3Rpb24gYW5kIHNlbmQgZXJyb3JzIHRvIHJlY292ZXJ5IGNvbnRpbnVhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaChib2R5LCByZWNvdmVyKSB7XG5cdHRyeSB7XG5cdFx0dmFyIHJlc3VsdCA9IGJvZHkoKTtcblx0fSBjYXRjaChlKSB7XG5cdFx0cmV0dXJuIHJlY292ZXIoZSk7XG5cdH1cblx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdHJldHVybiByZXN1bHQudGhlbih2b2lkIDAsIHJlY292ZXIpO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vIEFzeW5jaHJvbm91c2x5IGF3YWl0IGEgcHJvbWlzZSBhbmQgcGFzcyB0aGUgcmVzdWx0IHRvIGEgZmluYWxseSBjb250aW51YXRpb25cbmV4cG9ydCBmdW5jdGlvbiBfZmluYWxseVJldGhyb3dzKGJvZHksIGZpbmFsaXplcikge1xuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmluYWxpemVyKHRydWUsIGUpO1xuXHR9XG5cdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRyZXR1cm4gcmVzdWx0LnRoZW4oZmluYWxpemVyLmJpbmQobnVsbCwgZmFsc2UpLCBmaW5hbGl6ZXIuYmluZChudWxsLCB0cnVlKSk7XG5cdH1cblx0cmV0dXJuIGZpbmFsaXplcihmYWxzZSwgcmVzdWx0KTtcbn1cblxuLy8gQXN5bmNocm9ub3VzbHkgYXdhaXQgYSBwcm9taXNlIGFuZCBpbnZva2UgYSBmaW5hbGx5IGNvbnRpbnVhdGlvbiB0aGF0IGFsd2F5cyBvdmVycmlkZXMgdGhlIHJlc3VsdFxuZXhwb3J0IGZ1bmN0aW9uIF9maW5hbGx5KGJvZHksIGZpbmFsaXplcikge1xuXHR0cnkge1xuXHRcdHZhciByZXN1bHQgPSBib2R5KCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmluYWxpemVyKCk7XG5cdH1cblx0aWYgKHJlc3VsdCAmJiByZXN1bHQudGhlbikge1xuXHRcdHJldHVybiByZXN1bHQudGhlbihmaW5hbGl6ZXIsIGZpbmFsaXplcik7XG5cdH1cblx0cmV0dXJuIGZpbmFsaXplcigpO1xufVxuXG4vLyBSZXRocm93IG9yIHJldHVybiBhIHZhbHVlIGZyb20gYSBmaW5hbGx5IGNvbnRpbnVhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIF9yZXRocm93KHRocm93biwgdmFsdWUpIHtcblx0aWYgKHRocm93bilcblx0XHR0aHJvdyB2YWx1ZTtcblx0cmV0dXJuIHZhbHVlO1xufVxuXG4vLyBFbXB0eSBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYnJlYWsgYW5kIG90aGVyIGNvbnRyb2wgZmxvdyB0aGF0IGlnbm9yZXMgYXN5bmNocm9ub3VzIHJlc3VsdHNcbmV4cG9ydCBmdW5jdGlvbiBfZW1wdHkoKSB7XG59XG5cbi8vIFNlbnRpbmVsIHZhbHVlIGZvciBlYXJseSByZXR1cm5zIGluIGdlbmVyYXRvcnMgXG5leHBvcnQgY29uc3QgX2Vhcmx5UmV0dXJuID0gLyojX19QVVJFX18qLyB7fTtcblxuLy8gQXN5bmNocm9ub3VzbHkgY2FsbCBhIGZ1bmN0aW9uIGFuZCBzZW5kIGVycm9ycyB0byByZWNvdmVyeSBjb250aW51YXRpb24sIHNraXBwaW5nIGVhcmx5IHJldHVybnNcbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hJbkdlbmVyYXRvcihib2R5LCByZWNvdmVyKSB7XG5cdHJldHVybiBfY2F0Y2goYm9keSwgZnVuY3Rpb24oZSkge1xuXHRcdGlmIChlID09PSBfZWFybHlSZXR1cm4pIHtcblx0XHRcdHRocm93IGU7XG5cdFx0fVxuXHRcdHJldHVybiByZWNvdmVyKGUpO1xuXHR9KTtcbn1cblxuLy8gQXN5bmNocm9ub3VzIGdlbmVyYXRvciBjbGFzczsgYWNjZXB0cyB0aGUgZW50cnlwb2ludCBvZiB0aGUgZ2VuZXJhdG9yLCB0byB3aGljaCBpdCBwYXNzZXMgaXRzZWxmIHdoZW4gdGhlIGdlbmVyYXRvciBzaG91bGQgc3RhcnRcbmV4cG9ydCBjb25zdCBfQXN5bmNHZW5lcmF0b3IgPSAvKiNfX1BVUkVfXyovKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBfQXN5bmNHZW5lcmF0b3IoZW50cnkpIHtcblx0XHR0aGlzLl9lbnRyeSA9IGVudHJ5O1xuXHRcdHRoaXMuX3BhY3QgPSBudWxsO1xuXHRcdHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuXHRcdHRoaXMuX3JldHVybiA9IG51bGw7XG5cdFx0dGhpcy5fcHJvbWlzZSA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBfd3JhcFJldHVybmVkVmFsdWUodmFsdWUpIHtcblx0XHRyZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6IHRydWUgfTtcblx0fVxuXHRmdW5jdGlvbiBfd3JhcFlpZWxkZWRWYWx1ZSh2YWx1ZSkge1xuXHRcdHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcblx0fVxuXG5cdF9Bc3luY0dlbmVyYXRvci5wcm90b3R5cGUuX3lpZWxkID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBZaWVsZCB0aGUgdmFsdWUgdG8gdGhlIHBlbmRpbmcgbmV4dCBjYWxsXG5cdFx0dGhpcy5fcmVzb2x2ZSh2YWx1ZSAmJiB2YWx1ZS50aGVuID8gdmFsdWUudGhlbihfd3JhcFlpZWxkZWRWYWx1ZSkgOiBfd3JhcFlpZWxkZWRWYWx1ZSh2YWx1ZSkpO1xuXHRcdC8vIFJldHVybiBhIHBhY3QgZm9yIGFuIHVwY29taW5nIG5leHQvcmV0dXJuL3Rocm93IGNhbGxcblx0XHRyZXR1cm4gdGhpcy5fcGFjdCA9IG5ldyBfUGFjdCgpO1xuXHR9O1xuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdC8vIEFkdmFuY2UgdGhlIGdlbmVyYXRvciwgc3RhcnRpbmcgaXQgaWYgaXQgaGFzIHlldCB0byBiZSBzdGFydGVkXG5cdFx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRcdHJldHVybiBfdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdFx0XHRjb25zdCBfcGFjdCA9IF90aGlzLl9wYWN0O1xuXHRcdFx0aWYgKF9wYWN0ID09PSBudWxsKSB7XG5cdFx0XHRcdGNvbnN0IF9lbnRyeSA9IF90aGlzLl9lbnRyeTtcblx0XHRcdFx0aWYgKF9lbnRyeSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdC8vIEdlbmVyYXRvciBpcyBzdGFydGVkLCBidXQgbm90IGF3YWl0aW5nIGEgeWllbGQgZXhwcmVzc2lvblxuXHRcdFx0XHRcdC8vIEFiYW5kb24gdGhlIG5leHQgY2FsbCFcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZShfdGhpcy5fcHJvbWlzZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gU3RhcnQgdGhlIGdlbmVyYXRvclxuXHRcdFx0XHRfdGhpcy5fZW50cnkgPSBudWxsO1xuXHRcdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRcdGZ1bmN0aW9uIHJldHVyblZhbHVlKHZhbHVlKSB7XG5cdFx0XHRcdFx0X3RoaXMuX3Jlc29sdmUodmFsdWUgJiYgdmFsdWUudGhlbiA/IHZhbHVlLnRoZW4oX3dyYXBSZXR1cm5lZFZhbHVlKSA6IF93cmFwUmV0dXJuZWRWYWx1ZSh2YWx1ZSkpO1xuXHRcdFx0XHRcdF90aGlzLl9wYWN0ID0gbnVsbDtcblx0XHRcdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHJlc3VsdCA9IF9lbnRyeShfdGhpcyk7XG5cdFx0XHRcdGlmIChyZXN1bHQgJiYgcmVzdWx0LnRoZW4pIHtcblx0XHRcdFx0XHRyZXN1bHQudGhlbihyZXR1cm5WYWx1ZSwgZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdFx0XHRcdGlmIChlcnJvciA9PT0gX2Vhcmx5UmV0dXJuKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVyblZhbHVlKF90aGlzLl9yZXR1cm4pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgcGFjdCA9IG5ldyBfUGFjdCgpO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5fcmVzb2x2ZShwYWN0KTtcblx0XHRcdFx0XHRcdFx0X3RoaXMuX3BhY3QgPSBudWxsO1xuXHRcdFx0XHRcdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdF9yZXNvbHZlKHBhY3QsIDIsIGVycm9yKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm5WYWx1ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgc3RhcnRlZCBhbmQgYSB5aWVsZCBleHByZXNzaW9uIGlzIHBlbmRpbmcsIHNldHRsZSBpdFxuXHRcdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRcdF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRcdFx0X3NldHRsZShfcGFjdCwgMSwgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnJldHVybiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0Ly8gRWFybHkgcmV0dXJuIGZyb20gdGhlIGdlbmVyYXRvciBpZiBzdGFydGVkLCBvdGhlcndpc2UgYWJhbmRvbnMgdGhlIGdlbmVyYXRvclxuXHRcdGNvbnN0IF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRcdFx0Y29uc3QgX3BhY3QgPSBfdGhpcy5fcGFjdDtcblx0XHRcdGlmIChfcGFjdCA9PT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoX3RoaXMuX2VudHJ5ID09PSBudWxsKSB7XG5cdFx0XHRcdFx0Ly8gR2VuZXJhdG9yIGlzIHN0YXJ0ZWQsIGJ1dCBub3QgYXdhaXRpbmcgYSB5aWVsZCBleHByZXNzaW9uXG5cdFx0XHRcdFx0Ly8gQWJhbmRvbiB0aGUgcmV0dXJuIGNhbGwhXG5cdFx0XHRcdFx0cmV0dXJuIHJlc29sdmUoX3RoaXMuX3Byb21pc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEdlbmVyYXRvciBpcyBub3Qgc3RhcnRlZCwgYWJhbmRvbiBpdCBhbmQgcmV0dXJuIHRoZSBzcGVjaWZpZWQgdmFsdWVcblx0XHRcdFx0X3RoaXMuX2VudHJ5ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIHJlc29sdmUodmFsdWUgJiYgdmFsdWUudGhlbiA/IHZhbHVlLnRoZW4oX3dyYXBSZXR1cm5lZFZhbHVlKSA6IF93cmFwUmV0dXJuZWRWYWx1ZSh2YWx1ZSkpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU2V0dGxlIHRoZSB5aWVsZCBleHByZXNzaW9uIHdpdGggYSByZWplY3RlZCBcImVhcmx5IHJldHVyblwiIHZhbHVlXG5cdFx0XHRfdGhpcy5fcmV0dXJuID0gdmFsdWU7XG5cdFx0XHRfdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cdFx0XHRfdGhpcy5fcGFjdCA9IG51bGw7XG5cdFx0XHRfc2V0dGxlKF9wYWN0LCAyLCBfZWFybHlSZXR1cm4pO1xuXHRcdH0pO1xuXHR9O1xuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlLnRocm93ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0XHQvLyBJbmplY3QgYW4gZXhjZXB0aW9uIGludG8gdGhlIHBlbmRpbmcgeWllbGQgZXhwcmVzc2lvblxuXHRcdGNvbnN0IF90aGlzID0gdGhpcztcblx0XHRyZXR1cm4gX3RoaXMuX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRjb25zdCBfcGFjdCA9IF90aGlzLl9wYWN0O1xuXHRcdFx0aWYgKF9wYWN0ID09PSBudWxsKSB7XG5cdFx0XHRcdGlmIChfdGhpcy5fZW50cnkgPT09IG51bGwpIHtcblx0XHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgc3RhcnRlZCwgYnV0IG5vdCBhd2FpdGluZyBhIHlpZWxkIGV4cHJlc3Npb25cblx0XHRcdFx0XHQvLyBBYmFuZG9uIHRoZSB0aHJvdyBjYWxsIVxuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlKF90aGlzLl9wcm9taXNlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBHZW5lcmF0b3IgaXMgbm90IHN0YXJ0ZWQsIGFiYW5kb24gaXQgYW5kIHJldHVybiBhIHJlamVjdGVkIFByb21pc2UgY29udGFpbmluZyB0aGUgZXJyb3Jcblx0XHRcdFx0X3RoaXMuX2VudHJ5ID0gbnVsbDtcblx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHQvLyBTZXR0bGUgdGhlIHlpZWxkIGV4cHJlc3Npb24gd2l0aCB0aGUgdmFsdWUgYXMgYSByZWplY3Rpb25cblx0XHRcdF90aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcblx0XHRcdF90aGlzLl9wYWN0ID0gbnVsbDtcblx0XHRcdF9zZXR0bGUoX3BhY3QsIDIsIGVycm9yKTtcblx0XHR9KTtcblx0fTtcblxuXHRfQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW19hc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXHRcblx0cmV0dXJuIF9Bc3luY0dlbmVyYXRvcjtcbn0pKCk7XG4iLCIvLyBCb3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9haS9uYW5vaWQvYmxvYi8zLjAuMi9ub24tc2VjdXJlL2luZGV4LmpzXHJcbi8vIFRoaXMgYWxwaGFiZXQgdXNlcyBgQS1aYS16MC05Xy1gIHN5bWJvbHMuIEEgZ2VuZXRpYyBhbGdvcml0aG0gaGVscGVkXHJcbi8vIG9wdGltaXplIHRoZSBnemlwIGNvbXByZXNzaW9uIGZvciB0aGlzIGFscGhhYmV0LlxyXG5sZXQgdXJsQWxwaGFiZXQgPVxyXG4gICdNb2R1bGVTeW1iaGFzT3duUHItMDEyMzQ1Njc4OUFCQ0RFRkdITlJWZmdjdGlVdnpfS3FZVEprTHhwWlhJalFXJ1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBsZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xyXG4gIGxldCBpZCA9ICcnXHJcbiAgLy8gQSBjb21wYWN0IGFsdGVybmF0aXZlIGZvciBgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspYC5cclxuICBsZXQgaSA9IHNpemVcclxuICB3aGlsZSAoaS0tKSB7XHJcbiAgICAvLyBgfCAwYCBpcyBtb3JlIGNvbXBhY3QgYW5kIGZhc3RlciB0aGFuIGBNYXRoLmZsb29yKClgLlxyXG4gICAgaWQgKz0gdXJsQWxwaGFiZXRbKE1hdGgucmFuZG9tKCkgKiA2NCkgfCAwXVxyXG4gIH1cclxuICByZXR1cm4gaWRcclxufVxyXG4iLCJpbXBvcnQgeyBEaXNwYXRjaCwgQW55QWN0aW9uIH0gZnJvbSAncmVkdXgnXHJcbmltcG9ydCB7XHJcbiAgY3JlYXRlQWN0aW9uLFxyXG4gIFBheWxvYWRBY3Rpb24sXHJcbiAgQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWRcclxufSBmcm9tICcuL2NyZWF0ZUFjdGlvbidcclxuaW1wb3J0IHsgVGh1bmtEaXNwYXRjaCB9IGZyb20gJ3JlZHV4LXRodW5rJ1xyXG5pbXBvcnQgeyBGYWxsYmFja0lmVW5rbm93biwgSXNBbnkgfSBmcm9tICcuL3RzSGVscGVycydcclxuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnLi9uYW5vaWQnXHJcblxyXG4vLyBAdHMtaWdub3JlIHdlIG5lZWQgdGhlIGltcG9ydCBvZiB0aGVzZSB0eXBlcyBkdWUgdG8gYSBidW5kbGluZyBpc3N1ZS5cclxudHlwZSBfS2VlcCA9IFBheWxvYWRBY3Rpb24gfCBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxhbnksIHVua25vd24+XHJcblxyXG5leHBvcnQgdHlwZSBCYXNlVGh1bmtBUEk8XHJcbiAgUyxcclxuICBFLFxyXG4gIEQgZXh0ZW5kcyBEaXNwYXRjaCA9IERpc3BhdGNoLFxyXG4gIFJlamVjdGVkVmFsdWUgPSB1bmRlZmluZWRcclxuPiA9IHtcclxuICBkaXNwYXRjaDogRFxyXG4gIGdldFN0YXRlOiAoKSA9PiBTXHJcbiAgZXh0cmE6IEVcclxuICByZXF1ZXN0SWQ6IHN0cmluZ1xyXG4gIHNpZ25hbDogQWJvcnRTaWduYWxcclxuICByZWplY3RXaXRoVmFsdWUodmFsdWU6IFJlamVjdGVkVmFsdWUpOiBSZWplY3RXaXRoVmFsdWU8UmVqZWN0ZWRWYWx1ZT5cclxufVxyXG5cclxuLyoqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgU2VyaWFsaXplZEVycm9yIHtcclxuICBuYW1lPzogc3RyaW5nXHJcbiAgbWVzc2FnZT86IHN0cmluZ1xyXG4gIHN0YWNrPzogc3RyaW5nXHJcbiAgY29kZT86IHN0cmluZ1xyXG59XHJcblxyXG5jb25zdCBjb21tb25Qcm9wZXJ0aWVzOiBBcnJheTxrZXlvZiBTZXJpYWxpemVkRXJyb3I+ID0gW1xyXG4gICduYW1lJyxcclxuICAnbWVzc2FnZScsXHJcbiAgJ3N0YWNrJyxcclxuICAnY29kZSdcclxuXVxyXG5cclxuY2xhc3MgUmVqZWN0V2l0aFZhbHVlPFJlamVjdFZhbHVlPiB7XHJcbiAgY29uc3RydWN0b3IocHVibGljIHJlYWRvbmx5IHZhbHVlOiBSZWplY3RWYWx1ZSkge31cclxufVxyXG5cclxuLy8gUmV3b3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3NlcmlhbGl6ZS1lcnJvclxyXG5leHBvcnQgY29uc3QgbWluaVNlcmlhbGl6ZUVycm9yID0gKHZhbHVlOiBhbnkpOiBTZXJpYWxpemVkRXJyb3IgPT4ge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XHJcbiAgICBjb25zdCBzaW1wbGVFcnJvcjogU2VyaWFsaXplZEVycm9yID0ge31cclxuICAgIGZvciAoY29uc3QgcHJvcGVydHkgb2YgY29tbW9uUHJvcGVydGllcykge1xyXG4gICAgICBpZiAodHlwZW9mIHZhbHVlW3Byb3BlcnR5XSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICBzaW1wbGVFcnJvcltwcm9wZXJ0eV0gPSB2YWx1ZVtwcm9wZXJ0eV1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzaW1wbGVFcnJvclxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgbWVzc2FnZTogU3RyaW5nKHZhbHVlKSB9XHJcbn1cclxuXHJcbnR5cGUgQXN5bmNUaHVua0NvbmZpZyA9IHtcclxuICBzdGF0ZT86IHVua25vd25cclxuICBkaXNwYXRjaD86IERpc3BhdGNoXHJcbiAgZXh0cmE/OiB1bmtub3duXHJcbiAgcmVqZWN0VmFsdWU/OiB1bmtub3duXHJcbn1cclxuXHJcbnR5cGUgR2V0U3RhdGU8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XHJcbiAgc3RhdGU6IGluZmVyIFN0YXRlXHJcbn1cclxuICA/IFN0YXRlXHJcbiAgOiB1bmtub3duXHJcbnR5cGUgR2V0RXh0cmE8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7IGV4dHJhOiBpbmZlciBFeHRyYSB9XHJcbiAgPyBFeHRyYVxyXG4gIDogdW5rbm93blxyXG50eXBlIEdldERpc3BhdGNoPFRodW5rQXBpQ29uZmlnPiA9IFRodW5rQXBpQ29uZmlnIGV4dGVuZHMge1xyXG4gIGRpc3BhdGNoOiBpbmZlciBEaXNwYXRjaFxyXG59XHJcbiAgPyBGYWxsYmFja0lmVW5rbm93bjxcclxuICAgICAgRGlzcGF0Y2gsXHJcbiAgICAgIFRodW5rRGlzcGF0Y2g8XHJcbiAgICAgICAgR2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LFxyXG4gICAgICAgIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPixcclxuICAgICAgICBBbnlBY3Rpb25cclxuICAgICAgPlxyXG4gICAgPlxyXG4gIDogVGh1bmtEaXNwYXRjaDxHZXRTdGF0ZTxUaHVua0FwaUNvbmZpZz4sIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPiwgQW55QWN0aW9uPlxyXG5cclxudHlwZSBHZXRUaHVua0FQSTxUaHVua0FwaUNvbmZpZz4gPSBCYXNlVGh1bmtBUEk8XHJcbiAgR2V0U3RhdGU8VGh1bmtBcGlDb25maWc+LFxyXG4gIEdldEV4dHJhPFRodW5rQXBpQ29uZmlnPixcclxuICBHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4sXHJcbiAgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+XHJcbj5cclxuXHJcbnR5cGUgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+ID0gVGh1bmtBcGlDb25maWcgZXh0ZW5kcyB7XHJcbiAgcmVqZWN0VmFsdWU6IGluZmVyIFJlamVjdFZhbHVlXHJcbn1cclxuICA/IFJlamVjdFZhbHVlXHJcbiAgOiB1bmtub3duXHJcbi8qKlxyXG4gKiBBIHR5cGUgZGVzY3JpYmluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgcGF5bG9hZENyZWF0b3JgIGFyZ3VtZW50IHRvIGBjcmVhdGVBc3luY1RodW5rYC5cclxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXN5bmNUaHVua1BheWxvYWRDcmVhdG9yUmV0dXJuVmFsdWU8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnXHJcbj4gPVxyXG4gIHwgUHJvbWlzZTxSZXR1cm5lZCB8IFJlamVjdFdpdGhWYWx1ZTxHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4+PlxyXG4gIHwgUmV0dXJuZWRcclxuICB8IFJlamVjdFdpdGhWYWx1ZTxHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4+XHJcbi8qKlxyXG4gKiBBIHR5cGUgZGVzY3JpYmluZyB0aGUgYHBheWxvYWRDcmVhdG9yYCBhcmd1bWVudCB0byBgY3JlYXRlQXN5bmNUaHVua2AuXHJcbiAqIE1pZ2h0IGJlIHVzZWZ1bCBmb3Igd3JhcHBpbmcgYGNyZWF0ZUFzeW5jVGh1bmtgIGluIGN1c3RvbSBhYnN0cmFjdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydCB0eXBlIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcjxcclxuICBSZXR1cm5lZCxcclxuICBUaHVua0FyZyA9IHZvaWQsXHJcbiAgVGh1bmtBcGlDb25maWcgZXh0ZW5kcyBBc3luY1RodW5rQ29uZmlnID0ge31cclxuPiA9IChcclxuICBhcmc6IFRodW5rQXJnLFxyXG4gIHRodW5rQVBJOiBHZXRUaHVua0FQSTxUaHVua0FwaUNvbmZpZz5cclxuKSA9PiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3JSZXR1cm5WYWx1ZTxSZXR1cm5lZCwgVGh1bmtBcGlDb25maWc+XHJcblxyXG4vKipcclxuICogQSBUaHVua0FjdGlvbiBjcmVhdGVkIGJ5IGBjcmVhdGVBc3luY1RodW5rYC5cclxuICogRGlzcGF0Y2hpbmcgaXQgcmV0dXJucyBhIFByb21pc2UgZm9yIGVpdGhlciBhXHJcbiAqIGZ1bGZpbGxlZCBvciByZWplY3RlZCBhY3Rpb24uXHJcbiAqIEFsc28sIHRoZSByZXR1cm5lZCB2YWx1ZSBjb250YWlucyBhIGBhYm9ydCgpYCBtZXRob2RcclxuICogdGhhdCBhbGxvd3MgdGhlIGFzeW5jQWN0aW9uIHRvIGJlIGNhbmNlbGxlZCBmcm9tIHRoZSBvdXRzaWRlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBBc3luY1RodW5rQWN0aW9uPFxyXG4gIFJldHVybmVkLFxyXG4gIFRodW5rQXJnLFxyXG4gIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZ1xyXG4+ID0gKFxyXG4gIGRpc3BhdGNoOiBHZXREaXNwYXRjaDxUaHVua0FwaUNvbmZpZz4sXHJcbiAgZ2V0U3RhdGU6ICgpID0+IEdldFN0YXRlPFRodW5rQXBpQ29uZmlnPixcclxuICBleHRyYTogR2V0RXh0cmE8VGh1bmtBcGlDb25maWc+XHJcbikgPT4gUHJvbWlzZTxcclxuICB8IFBheWxvYWRBY3Rpb248UmV0dXJuZWQsIHN0cmluZywgeyBhcmc6IFRodW5rQXJnOyByZXF1ZXN0SWQ6IHN0cmluZyB9PlxyXG4gIHwgUGF5bG9hZEFjdGlvbjxcclxuICAgICAgdW5kZWZpbmVkIHwgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+LFxyXG4gICAgICBzdHJpbmcsXHJcbiAgICAgIHtcclxuICAgICAgICBhcmc6IFRodW5rQXJnXHJcbiAgICAgICAgcmVxdWVzdElkOiBzdHJpbmdcclxuICAgICAgICBhYm9ydGVkOiBib29sZWFuXHJcbiAgICAgICAgY29uZGl0aW9uOiBib29sZWFuXHJcbiAgICAgIH0sXHJcbiAgICAgIFNlcmlhbGl6ZWRFcnJvclxyXG4gICAgPlxyXG4+ICYge1xyXG4gIGFib3J0KHJlYXNvbj86IHN0cmluZyk6IHZvaWRcclxufVxyXG5cclxudHlwZSBBc3luY1RodW5rQWN0aW9uQ3JlYXRvcjxcclxuICBSZXR1cm5lZCxcclxuICBUaHVua0FyZyxcclxuICBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWdcclxuPiA9IElzQW55PFxyXG4gIFRodW5rQXJnLFxyXG4gIC8vIGFueSBoYW5kbGluZ1xyXG4gIChhcmc6IFRodW5rQXJnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+LFxyXG4gIC8vIHVua25vd24gaGFuZGxpbmdcclxuICB1bmtub3duIGV4dGVuZHMgVGh1bmtBcmdcclxuICAgID8gKGFyZzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gLy8gYXJndW1lbnQgbm90IHNwZWNpZmllZCBvciBzcGVjaWZpZWQgYXMgdm9pZCBvciB1bmRlZmluZWRcclxuICAgIDogW1RodW5rQXJnXSBleHRlbmRzIFt2b2lkXSB8IFt1bmRlZmluZWRdXHJcbiAgICA/ICgpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4gLy8gYXJndW1lbnQgY29udGFpbnMgdm9pZFxyXG4gICAgOiBbdm9pZF0gZXh0ZW5kcyBbVGh1bmtBcmddIC8vIG1ha2Ugb3B0aW9uYWxcclxuICAgID8gKGFyZz86IFRodW5rQXJnKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IC8vIGFyZ3VtZW50IGNvbnRhaW5zIHVuZGVmaW5lZFxyXG4gICAgOiBbdW5kZWZpbmVkXSBleHRlbmRzIFtUaHVua0FyZ11cclxuICAgID8gV2l0aFN0cmljdE51bGxDaGVja3M8XHJcbiAgICAgICAgLy8gd2l0aCBzdHJpY3QgbnVsbENoZWNrczogbWFrZSBvcHRpb25hbFxyXG4gICAgICAgIChcclxuICAgICAgICAgIGFyZz86IFRodW5rQXJnXHJcbiAgICAgICAgKSA9PiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+LFxyXG4gICAgICAgIC8vIHdpdGhvdXQgc3RyaWN0IG51bGwgY2hlY2tzIHRoaXMgd2lsbCBtYXRjaCBldmVyeXRoaW5nLCBzbyBkb24ndCBtYWtlIGl0IG9wdGlvbmFsXHJcbiAgICAgICAgKGFyZzogVGh1bmtBcmcpID0+IEFzeW5jVGh1bmtBY3Rpb248UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5cclxuICAgICAgPiAvLyBkZWZhdWx0IGNhc2U6IG5vcm1hbCBhcmd1bWVudFxyXG4gICAgOiAoYXJnOiBUaHVua0FyZykgPT4gQXN5bmNUaHVua0FjdGlvbjxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPlxyXG4+XHJcblxyXG5pbnRlcmZhY2UgQXN5bmNUaHVua09wdGlvbnM8XHJcbiAgVGh1bmtBcmcgPSB2b2lkLFxyXG4gIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9XHJcbj4ge1xyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIHRvIGNvbnRyb2wgd2hldGhlciB0aGUgYXN5bmNUaHVuayBzaG91bGQgYmUgZXhlY3V0ZWQuIEhhcyBhY2Nlc3MgdG8gdGhlXHJcbiAgICogYGFyZ2AsIGBhcGkuZ2V0U3RhdGUoKWAgYW5kIGBhcGkuZXh0cmFgIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIGBmYWxzZWAgaWYgaXQgc2hvdWxkIGJlIHNraXBwZWRcclxuICAgKi9cclxuICBjb25kaXRpb24/KFxyXG4gICAgYXJnOiBUaHVua0FyZyxcclxuICAgIGFwaTogUGljazxHZXRUaHVua0FQSTxUaHVua0FwaUNvbmZpZz4sICdnZXRTdGF0ZScgfCAnZXh0cmEnPlxyXG4gICk6IGJvb2xlYW4gfCB1bmRlZmluZWRcclxuICAvKipcclxuICAgKiBJZiBgY29uZGl0aW9uYCByZXR1cm5zIGBmYWxzZWAsIHRoZSBhc3luY1RodW5rIHdpbGwgYmUgc2tpcHBlZC5cclxuICAgKiBUaGlzIG9wdGlvbiBhbGxvd3MgeW91IHRvIGNvbnRyb2wgd2hldGhlciBhIGByZWplY3RlZGAgYWN0aW9uIHdpdGggYG1ldGEuY29uZGl0aW9uID09IGZhbHNlYFxyXG4gICAqIHdpbGwgYmUgZGlzcGF0Y2hlZCBvciBub3QuXHJcbiAgICpcclxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXHJcbiAgICovXHJcbiAgZGlzcGF0Y2hDb25kaXRpb25SZWplY3Rpb24/OiBib29sZWFuXHJcbn1cclxuXHJcbnR5cGUgQXN5bmNUaHVua1BlbmRpbmdBY3Rpb25DcmVhdG9yPFxyXG4gIFRodW5rQXJnXHJcbj4gPSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxcclxuICBbc3RyaW5nLCBUaHVua0FyZ10sXHJcbiAgdW5kZWZpbmVkLFxyXG4gIHN0cmluZyxcclxuICBuZXZlcixcclxuICB7XHJcbiAgICBhcmc6IFRodW5rQXJnXHJcbiAgICByZXF1ZXN0SWQ6IHN0cmluZ1xyXG4gIH1cclxuPlxyXG5cclxudHlwZSBBc3luY1RodW5rUmVqZWN0ZWRBY3Rpb25DcmVhdG9yPFxyXG4gIFRodW5rQXJnLFxyXG4gIFRodW5rQXBpQ29uZmlnXHJcbj4gPSBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZDxcclxuICBbXHJcbiAgICBFcnJvciB8IG51bGwsXHJcbiAgICBzdHJpbmcsXHJcbiAgICBUaHVua0FyZyxcclxuICAgIChHZXRSZWplY3RWYWx1ZTxUaHVua0FwaUNvbmZpZz4gfCB1bmRlZmluZWQpP1xyXG4gIF0sXHJcbiAgR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+IHwgdW5kZWZpbmVkLFxyXG4gIHN0cmluZyxcclxuICBTZXJpYWxpemVkRXJyb3IsXHJcbiAge1xyXG4gICAgYXJnOiBUaHVua0FyZ1xyXG4gICAgcmVxdWVzdElkOiBzdHJpbmdcclxuICAgIGFib3J0ZWQ6IGJvb2xlYW5cclxuICAgIGNvbmRpdGlvbjogYm9vbGVhblxyXG4gIH1cclxuPlxyXG5cclxudHlwZSBBc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uQ3JlYXRvcjxcclxuICBSZXR1cm5lZCxcclxuICBUaHVua0FyZ1xyXG4+ID0gQWN0aW9uQ3JlYXRvcldpdGhQcmVwYXJlZFBheWxvYWQ8XHJcbiAgW1JldHVybmVkLCBzdHJpbmcsIFRodW5rQXJnXSxcclxuICBSZXR1cm5lZCxcclxuICBzdHJpbmcsXHJcbiAgbmV2ZXIsXHJcbiAge1xyXG4gICAgYXJnOiBUaHVua0FyZ1xyXG4gICAgcmVxdWVzdElkOiBzdHJpbmdcclxuICB9XHJcbj5cclxuXHJcbi8qKlxyXG4gKiBBIHR5cGUgZGVzY3JpYmluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBjcmVhdGVBc3luY1RodW5rYC5cclxuICogTWlnaHQgYmUgdXNlZnVsIGZvciB3cmFwcGluZyBgY3JlYXRlQXN5bmNUaHVua2AgaW4gY3VzdG9tIGFic3RyYWN0aW9ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IHR5cGUgQXN5bmNUaHVuazxcclxuICBSZXR1cm5lZCxcclxuICBUaHVua0FyZyxcclxuICBUaHVua0FwaUNvbmZpZyBleHRlbmRzIEFzeW5jVGh1bmtDb25maWdcclxuPiA9IEFzeW5jVGh1bmtBY3Rpb25DcmVhdG9yPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+ICYge1xyXG4gIHBlbmRpbmc6IEFzeW5jVGh1bmtQZW5kaW5nQWN0aW9uQ3JlYXRvcjxUaHVua0FyZz5cclxuICByZWplY3RlZDogQXN5bmNUaHVua1JlamVjdGVkQWN0aW9uQ3JlYXRvcjxUaHVua0FyZywgVGh1bmtBcGlDb25maWc+XHJcbiAgZnVsZmlsbGVkOiBBc3luY1RodW5rRnVsZmlsbGVkQWN0aW9uQ3JlYXRvcjxSZXR1cm5lZCwgVGh1bmtBcmc+XHJcbiAgdHlwZVByZWZpeDogc3RyaW5nXHJcbn1cclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAcGFyYW0gdHlwZVByZWZpeFxyXG4gKiBAcGFyYW0gcGF5bG9hZENyZWF0b3JcclxuICogQHBhcmFtIG9wdGlvbnNcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFzeW5jVGh1bms8XHJcbiAgUmV0dXJuZWQsXHJcbiAgVGh1bmtBcmcgPSB2b2lkLFxyXG4gIFRodW5rQXBpQ29uZmlnIGV4dGVuZHMgQXN5bmNUaHVua0NvbmZpZyA9IHt9XHJcbj4oXHJcbiAgdHlwZVByZWZpeDogc3RyaW5nLFxyXG4gIHBheWxvYWRDcmVhdG9yOiBBc3luY1RodW5rUGF5bG9hZENyZWF0b3I8UmV0dXJuZWQsIFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz4sXHJcbiAgb3B0aW9ucz86IEFzeW5jVGh1bmtPcHRpb25zPFRodW5rQXJnLCBUaHVua0FwaUNvbmZpZz5cclxuKTogQXN5bmNUaHVuazxSZXR1cm5lZCwgVGh1bmtBcmcsIFRodW5rQXBpQ29uZmlnPiB7XHJcbiAgdHlwZSBSZWplY3RlZFZhbHVlID0gR2V0UmVqZWN0VmFsdWU8VGh1bmtBcGlDb25maWc+XHJcblxyXG4gIGNvbnN0IGZ1bGZpbGxlZCA9IGNyZWF0ZUFjdGlvbihcclxuICAgIHR5cGVQcmVmaXggKyAnL2Z1bGZpbGxlZCcsXHJcbiAgICAocmVzdWx0OiBSZXR1cm5lZCwgcmVxdWVzdElkOiBzdHJpbmcsIGFyZzogVGh1bmtBcmcpID0+IHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXlsb2FkOiByZXN1bHQsXHJcbiAgICAgICAgbWV0YTogeyBhcmcsIHJlcXVlc3RJZCB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICApXHJcblxyXG4gIGNvbnN0IHBlbmRpbmcgPSBjcmVhdGVBY3Rpb24oXHJcbiAgICB0eXBlUHJlZml4ICsgJy9wZW5kaW5nJyxcclxuICAgIChyZXF1ZXN0SWQ6IHN0cmluZywgYXJnOiBUaHVua0FyZykgPT4ge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHBheWxvYWQ6IHVuZGVmaW5lZCxcclxuICAgICAgICBtZXRhOiB7IGFyZywgcmVxdWVzdElkIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIClcclxuXHJcbiAgY29uc3QgcmVqZWN0ZWQgPSBjcmVhdGVBY3Rpb24oXHJcbiAgICB0eXBlUHJlZml4ICsgJy9yZWplY3RlZCcsXHJcbiAgICAoXHJcbiAgICAgIGVycm9yOiBFcnJvciB8IG51bGwsXHJcbiAgICAgIHJlcXVlc3RJZDogc3RyaW5nLFxyXG4gICAgICBhcmc6IFRodW5rQXJnLFxyXG4gICAgICBwYXlsb2FkPzogUmVqZWN0ZWRWYWx1ZVxyXG4gICAgKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFib3J0ZWQgPSAhIWVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJ1xyXG4gICAgICBjb25zdCBjb25kaXRpb24gPSAhIWVycm9yICYmIGVycm9yLm5hbWUgPT09ICdDb25kaXRpb25FcnJvcidcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgIGVycm9yOiBtaW5pU2VyaWFsaXplRXJyb3IoZXJyb3IgfHwgJ1JlamVjdGVkJyksXHJcbiAgICAgICAgbWV0YToge1xyXG4gICAgICAgICAgYXJnLFxyXG4gICAgICAgICAgcmVxdWVzdElkLFxyXG4gICAgICAgICAgYWJvcnRlZCxcclxuICAgICAgICAgIGNvbmRpdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIClcclxuXHJcbiAgbGV0IGRpc3BsYXllZFdhcm5pbmcgPSBmYWxzZVxyXG5cclxuICBjb25zdCBBQyA9XHJcbiAgICB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJ1xyXG4gICAgICA/IEFib3J0Q29udHJvbGxlclxyXG4gICAgICA6IGNsYXNzIGltcGxlbWVudHMgQWJvcnRDb250cm9sbGVyIHtcclxuICAgICAgICAgIHNpZ25hbDogQWJvcnRTaWduYWwgPSB7XHJcbiAgICAgICAgICAgIGFib3J0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCkge30sXHJcbiAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoKSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIG9uYWJvcnQoKSB7fSxcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcigpIHt9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBhYm9ydCgpIHtcclxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgICBpZiAoIWRpc3BsYXllZFdhcm5pbmcpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXllZFdhcm5pbmcgPSB0cnVlXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oXHJcbiAgICAgICAgICAgICAgICAgIGBUaGlzIHBsYXRmb3JtIGRvZXMgbm90IGltcGxlbWVudCBBYm9ydENvbnRyb2xsZXIuIFxyXG5JZiB5b3Ugd2FudCB0byB1c2UgdGhlIEFib3J0Q29udHJvbGxlciB0byByZWFjdCB0byBcXGBhYm9ydFxcYCBldmVudHMsIHBsZWFzZSBjb25zaWRlciBpbXBvcnRpbmcgYSBwb2x5ZmlsbCBsaWtlICdhYm9ydGNvbnRyb2xsZXItcG9seWZpbGwvZGlzdC9hYm9ydGNvbnRyb2xsZXItcG9seWZpbGwtb25seScuYFxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgZnVuY3Rpb24gYWN0aW9uQ3JlYXRvcihcclxuICAgIGFyZzogVGh1bmtBcmdcclxuICApOiBBc3luY1RodW5rQWN0aW9uPFJldHVybmVkLCBUaHVua0FyZywgVGh1bmtBcGlDb25maWc+IHtcclxuICAgIHJldHVybiAoZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYSkgPT4ge1xyXG4gICAgICBjb25zdCByZXF1ZXN0SWQgPSBuYW5vaWQoKVxyXG5cclxuICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFDKClcclxuICAgICAgbGV0IGFib3J0UmVhc29uOiBzdHJpbmcgfCB1bmRlZmluZWRcclxuXHJcbiAgICAgIGNvbnN0IGFib3J0ZWRQcm9taXNlID0gbmV3IFByb21pc2U8bmV2ZXI+KChfLCByZWplY3QpID0+XHJcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+XHJcbiAgICAgICAgICByZWplY3QoeyBuYW1lOiAnQWJvcnRFcnJvcicsIG1lc3NhZ2U6IGFib3J0UmVhc29uIHx8ICdBYm9ydGVkJyB9KVxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG5cclxuICAgICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZVxyXG4gICAgICBmdW5jdGlvbiBhYm9ydChyZWFzb24/OiBzdHJpbmcpIHtcclxuICAgICAgICBpZiAoc3RhcnRlZCkge1xyXG4gICAgICAgICAgYWJvcnRSZWFzb24gPSByZWFzb25cclxuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwcm9taXNlID0gKGFzeW5jIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGxldCBmaW5hbEFjdGlvbjogUmV0dXJuVHlwZTx0eXBlb2YgZnVsZmlsbGVkIHwgdHlwZW9mIHJlamVjdGVkPlxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIG9wdGlvbnMgJiZcclxuICAgICAgICAgICAgb3B0aW9ucy5jb25kaXRpb24gJiZcclxuICAgICAgICAgICAgb3B0aW9ucy5jb25kaXRpb24oYXJnLCB7IGdldFN0YXRlLCBleHRyYSB9KSA9PT0gZmFsc2VcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxyXG4gICAgICAgICAgICB0aHJvdyB7XHJcbiAgICAgICAgICAgICAgbmFtZTogJ0NvbmRpdGlvbkVycm9yJyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQWJvcnRlZCBkdWUgdG8gY29uZGl0aW9uIGNhbGxiYWNrIHJldHVybmluZyBmYWxzZS4nXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlXHJcbiAgICAgICAgICBkaXNwYXRjaChwZW5kaW5nKHJlcXVlc3RJZCwgYXJnKSlcclxuICAgICAgICAgIGZpbmFsQWN0aW9uID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcclxuICAgICAgICAgICAgYWJvcnRlZFByb21pc2UsXHJcbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZShcclxuICAgICAgICAgICAgICBwYXlsb2FkQ3JlYXRvcihhcmcsIHtcclxuICAgICAgICAgICAgICAgIGRpc3BhdGNoLFxyXG4gICAgICAgICAgICAgICAgZ2V0U3RhdGUsXHJcbiAgICAgICAgICAgICAgICBleHRyYSxcclxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcclxuICAgICAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgICAgICAgIHJlamVjdFdpdGhWYWx1ZSh2YWx1ZTogUmVqZWN0ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlamVjdFdpdGhWYWx1ZSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApLnRoZW4ocmVzdWx0ID0+IHtcclxuICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVqZWN0V2l0aFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0ZWQobnVsbCwgcmVxdWVzdElkLCBhcmcsIHJlc3VsdC52YWx1ZSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZChyZXN1bHQsIHJlcXVlc3RJZCwgYXJnKVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgXSlcclxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgIGZpbmFsQWN0aW9uID0gcmVqZWN0ZWQoZXJyLCByZXF1ZXN0SWQsIGFyZylcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UgZGlzcGF0Y2ggdGhlIHJlc3VsdCBhY3Rpb24gX2FmdGVyXyB0aGUgY2F0Y2gsIHRvIGF2b2lkIGhhdmluZyBhbnkgZXJyb3JzXHJcbiAgICAgICAgLy8gaGVyZSBnZXQgc3dhbGxvd2VkIGJ5IHRoZSB0cnkvY2F0Y2ggYmxvY2ssXHJcbiAgICAgICAgLy8gcGVyIGh0dHBzOi8vdHdpdHRlci5jb20vZGFuX2FicmFtb3Yvc3RhdHVzLzc3MDkxNDIyMTYzODk0MjcyMFxyXG4gICAgICAgIC8vIGFuZCBodHRwczovL3JlZHV4LXRvb2xraXQuanMub3JnL3R1dG9yaWFscy9hZHZhbmNlZC10dXRvcmlhbCNhc3luYy1lcnJvci1oYW5kbGluZy1sb2dpYy1pbi10aHVua3NcclxuXHJcbiAgICAgICAgY29uc3Qgc2tpcERpc3BhdGNoID1cclxuICAgICAgICAgIG9wdGlvbnMgJiZcclxuICAgICAgICAgICFvcHRpb25zLmRpc3BhdGNoQ29uZGl0aW9uUmVqZWN0aW9uICYmXHJcbiAgICAgICAgICByZWplY3RlZC5tYXRjaChmaW5hbEFjdGlvbikgJiZcclxuICAgICAgICAgIGZpbmFsQWN0aW9uLm1ldGEuY29uZGl0aW9uXHJcblxyXG4gICAgICAgIGlmICghc2tpcERpc3BhdGNoKSB7XHJcbiAgICAgICAgICBkaXNwYXRjaChmaW5hbEFjdGlvbilcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbmFsQWN0aW9uXHJcbiAgICAgIH0pKClcclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvbWlzZSwgeyBhYm9ydCB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXHJcbiAgICBhY3Rpb25DcmVhdG9yIGFzIEFzeW5jVGh1bmtBY3Rpb25DcmVhdG9yPFxyXG4gICAgICBSZXR1cm5lZCxcclxuICAgICAgVGh1bmtBcmcsXHJcbiAgICAgIFRodW5rQXBpQ29uZmlnXHJcbiAgICA+LFxyXG4gICAge1xyXG4gICAgICBwZW5kaW5nLFxyXG4gICAgICByZWplY3RlZCxcclxuICAgICAgZnVsZmlsbGVkLFxyXG4gICAgICB0eXBlUHJlZml4XHJcbiAgICB9XHJcbiAgKVxyXG59XHJcblxyXG50eXBlIEFjdGlvblR5cGVzV2l0aE9wdGlvbmFsRXJyb3JBY3Rpb24gPVxyXG4gIHwgeyBlcnJvcjogYW55IH1cclxuICB8IHsgZXJyb3I/OiBuZXZlcjsgcGF5bG9hZDogYW55IH1cclxudHlwZSBQYXlsb2FkRm9yQWN0aW9uVHlwZXNFeGNsdWRpbmdFcnJvckFjdGlvbnM8VD4gPSBUIGV4dGVuZHMgeyBlcnJvcjogYW55IH1cclxuICA/IG5ldmVyXHJcbiAgOiBUIGV4dGVuZHMgeyBwYXlsb2FkOiBpbmZlciBQIH1cclxuICA/IFBcclxuICA6IG5ldmVyXHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFJlc3VsdDxSIGV4dGVuZHMgQWN0aW9uVHlwZXNXaXRoT3B0aW9uYWxFcnJvckFjdGlvbj4oXHJcbiAgcmV0dXJuZWQ6IFJcclxuKTogUGF5bG9hZEZvckFjdGlvblR5cGVzRXhjbHVkaW5nRXJyb3JBY3Rpb25zPFI+IHtcclxuICBpZiAoJ2Vycm9yJyBpbiByZXR1cm5lZCkge1xyXG4gICAgdGhyb3cgcmV0dXJuZWQuZXJyb3JcclxuICB9XHJcbiAgcmV0dXJuIChyZXR1cm5lZCBhcyBhbnkpLnBheWxvYWRcclxufVxyXG5cclxudHlwZSBXaXRoU3RyaWN0TnVsbENoZWNrczxUcnVlLCBGYWxzZT4gPSB1bmRlZmluZWQgZXh0ZW5kcyBib29sZWFuXHJcbiAgPyBGYWxzZVxyXG4gIDogVHJ1ZVxyXG4iLCJpbXBvcnQgeyBlbmFibGVFUzUgfSBmcm9tICdpbW1lcidcclxuZXhwb3J0ICogZnJvbSAncmVkdXgnXHJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY3JlYXRlTmV4dFN0YXRlLCBEcmFmdCwgY3VycmVudCB9IGZyb20gJ2ltbWVyJ1xyXG5leHBvcnQge1xyXG4gIGNyZWF0ZVNlbGVjdG9yLFxyXG4gIFNlbGVjdG9yLFxyXG4gIE91dHB1dFBhcmFtZXRyaWNTZWxlY3RvcixcclxuICBPdXRwdXRTZWxlY3RvcixcclxuICBQYXJhbWV0cmljU2VsZWN0b3JcclxufSBmcm9tICdyZXNlbGVjdCdcclxuZXhwb3J0IHsgVGh1bmtBY3Rpb24sIFRodW5rRGlzcGF0Y2ggfSBmcm9tICdyZWR1eC10aHVuaydcclxuXHJcbi8vIFdlIGRlbGliZXJhdGVseSBlbmFibGUgSW1tZXIncyBFUzUgc3VwcG9ydCwgb24gdGhlIGdyb3VuZHMgdGhhdFxyXG4vLyB3ZSBhc3N1bWUgUlRLIHdpbGwgYmUgdXNlZCB3aXRoIFJlYWN0IE5hdGl2ZSBhbmQgb3RoZXIgUHJveHktbGVzc1xyXG4vLyBlbnZpcm9ubWVudHMuICBJbiBhZGRpdGlvbiwgdGhhdCdzIGhvdyBJbW1lciA0IGJlaGF2ZWQsIGFuZCBzaW5jZVxyXG4vLyB3ZSB3YW50IHRvIHNoaXAgdGhpcyBpbiBhbiBSVEsgbWlub3IsIHdlIHNob3VsZCBrZWVwIHRoZSBzYW1lIGJlaGF2aW9yLlxyXG5lbmFibGVFUzUoKVxyXG5cclxuZXhwb3J0IHtcclxuICAvLyBqc1xyXG4gIGNvbmZpZ3VyZVN0b3JlLFxyXG4gIC8vIHR5cGVzXHJcbiAgQ29uZmlndXJlRW5oYW5jZXJzQ2FsbGJhY2ssXHJcbiAgQ29uZmlndXJlU3RvcmVPcHRpb25zLFxyXG4gIEVuaGFuY2VkU3RvcmVcclxufSBmcm9tICcuL2NvbmZpZ3VyZVN0b3JlJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgY3JlYXRlQWN0aW9uLFxyXG4gIGdldFR5cGUsXHJcbiAgLy8gdHlwZXNcclxuICBQYXlsb2FkQWN0aW9uLFxyXG4gIFBheWxvYWRBY3Rpb25DcmVhdG9yLFxyXG4gIEFjdGlvbkNyZWF0b3JXaXRoTm9uSW5mZXJyYWJsZVBheWxvYWQsXHJcbiAgQWN0aW9uQ3JlYXRvcldpdGhPcHRpb25hbFBheWxvYWQsXHJcbiAgQWN0aW9uQ3JlYXRvcldpdGhQYXlsb2FkLFxyXG4gIEFjdGlvbkNyZWF0b3JXaXRob3V0UGF5bG9hZCxcclxuICBBY3Rpb25DcmVhdG9yV2l0aFByZXBhcmVkUGF5bG9hZCxcclxuICBQcmVwYXJlQWN0aW9uXHJcbn0gZnJvbSAnLi9jcmVhdGVBY3Rpb24nXHJcbmV4cG9ydCB7XHJcbiAgLy8ganNcclxuICBjcmVhdGVSZWR1Y2VyLFxyXG4gIC8vIHR5cGVzXHJcbiAgQWN0aW9ucyxcclxuICBDYXNlUmVkdWNlcixcclxuICBDYXNlUmVkdWNlcnNcclxufSBmcm9tICcuL2NyZWF0ZVJlZHVjZXInXHJcbmV4cG9ydCB7XHJcbiAgLy8ganNcclxuICBjcmVhdGVTbGljZSxcclxuICAvLyB0eXBlc1xyXG4gIENyZWF0ZVNsaWNlT3B0aW9ucyxcclxuICBTbGljZSxcclxuICBDYXNlUmVkdWNlckFjdGlvbnMsXHJcbiAgU2xpY2VDYXNlUmVkdWNlcnMsXHJcbiAgVmFsaWRhdGVTbGljZUNhc2VSZWR1Y2VycyxcclxuICBDYXNlUmVkdWNlcldpdGhQcmVwYXJlLFxyXG4gIFNsaWNlQWN0aW9uQ3JlYXRvclxyXG59IGZyb20gJy4vY3JlYXRlU2xpY2UnXHJcbmV4cG9ydCB7XHJcbiAgLy8ganNcclxuICBjcmVhdGVJbW11dGFibGVTdGF0ZUludmFyaWFudE1pZGRsZXdhcmUsXHJcbiAgaXNJbW11dGFibGVEZWZhdWx0LFxyXG4gIC8vIHR5cGVzXHJcbiAgSW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9uc1xyXG59IGZyb20gJy4vaW1tdXRhYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgY3JlYXRlU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlLFxyXG4gIGZpbmROb25TZXJpYWxpemFibGVWYWx1ZSxcclxuICBpc1BsYWluLFxyXG4gIC8vIHR5cGVzXHJcbiAgU2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlT3B0aW9uc1xyXG59IGZyb20gJy4vc2VyaWFsaXphYmxlU3RhdGVJbnZhcmlhbnRNaWRkbGV3YXJlJ1xyXG5leHBvcnQge1xyXG4gIC8vIGpzXHJcbiAgZ2V0RGVmYXVsdE1pZGRsZXdhcmVcclxufSBmcm9tICcuL2dldERlZmF1bHRNaWRkbGV3YXJlJ1xyXG5leHBvcnQge1xyXG4gIC8vIHR5cGVzXHJcbiAgQWN0aW9uUmVkdWNlck1hcEJ1aWxkZXJcclxufSBmcm9tICcuL21hcEJ1aWxkZXJzJ1xyXG5leHBvcnQgeyBNaWRkbGV3YXJlQXJyYXkgfSBmcm9tICcuL3V0aWxzJ1xyXG5cclxuZXhwb3J0IHsgY3JlYXRlRW50aXR5QWRhcHRlciB9IGZyb20gJy4vZW50aXRpZXMvY3JlYXRlX2FkYXB0ZXInXHJcbmV4cG9ydCB7XHJcbiAgRGljdGlvbmFyeSxcclxuICBFbnRpdHlTdGF0ZSxcclxuICBFbnRpdHlBZGFwdGVyLFxyXG4gIEVudGl0eVNlbGVjdG9ycyxcclxuICBFbnRpdHlTdGF0ZUFkYXB0ZXIsXHJcbiAgRW50aXR5SWQsXHJcbiAgVXBkYXRlLFxyXG4gIElkU2VsZWN0b3IsXHJcbiAgQ29tcGFyZXJcclxufSBmcm9tICcuL2VudGl0aWVzL21vZGVscydcclxuXHJcbmV4cG9ydCB7XHJcbiAgQXN5bmNUaHVuayxcclxuICBBc3luY1RodW5rQWN0aW9uLFxyXG4gIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvclJldHVyblZhbHVlLFxyXG4gIEFzeW5jVGh1bmtQYXlsb2FkQ3JlYXRvcixcclxuICBjcmVhdGVBc3luY1RodW5rLFxyXG4gIHVud3JhcFJlc3VsdCxcclxuICBTZXJpYWxpemVkRXJyb3JcclxufSBmcm9tICcuL2NyZWF0ZUFzeW5jVGh1bmsnXHJcblxyXG5leHBvcnQgeyBuYW5vaWQgfSBmcm9tICcuL25hbm9pZCdcclxuIiwiZXhwb3J0IHZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5leHBvcnQgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIGV2ZW50LCBsaXN0ZW5lcikge1xuICByZXR1cm4gbm9kZS5hZGRFdmVudExpc3RlbmVyID8gbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpIDogbm9kZS5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbmV4cG9ydCB2YXIgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPyBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSkgOiBub2RlLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xufTtcblxuZXhwb3J0IHZhciBnZXRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBnZXRDb25maXJtYXRpb24obWVzc2FnZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGNhbGxiYWNrKHdpbmRvdy5jb25maXJtKG1lc3NhZ2UpKTtcbn07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYWxlcnRcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGlzIHN1cHBvcnRlZC4gVGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2hpc3RvcnkuanNcbiAqIGNoYW5nZWQgdG8gYXZvaWQgZmFsc2UgbmVnYXRpdmVzIGZvciBXaW5kb3dzIFBob25lczogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmVhY3Qtcm91dGVyL2lzc3Vlcy81ODZcbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0hpc3RvcnkgPSBmdW5jdGlvbiBzdXBwb3J0c0hpc3RvcnkoKSB7XG4gIHZhciB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuXG4gIGlmICgodWEuaW5kZXhPZignQW5kcm9pZCAyLicpICE9PSAtMSB8fCB1YS5pbmRleE9mKCdBbmRyb2lkIDQuMCcpICE9PSAtMSkgJiYgdWEuaW5kZXhPZignTW9iaWxlIFNhZmFyaScpICE9PSAtMSAmJiB1YS5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiYgdWEuaW5kZXhPZignV2luZG93cyBQaG9uZScpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJyb3dzZXIgZmlyZXMgcG9wc3RhdGUgb24gaGFzaCBjaGFuZ2UuXG4gKiBJRTEwIGFuZCBJRTExIGRvIG5vdC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlID0gZnVuY3Rpb24gc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSA9PT0gLTE7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZmFsc2UgaWYgdXNpbmcgZ28obikgd2l0aCBoYXNoIGhpc3RvcnkgY2F1c2VzIGEgZnVsbCBwYWdlIHJlbG9hZC5cbiAqL1xuZXhwb3J0IHZhciBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCA9IGZ1bmN0aW9uIHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCkge1xuICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID09PSAtMTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gcG9wc3RhdGUgZXZlbnQgaXMgYW4gZXh0cmFuZW91cyBXZWJLaXQgZXZlbnQuXG4gKiBBY2NvdW50cyBmb3IgdGhlIGZhY3QgdGhhdCBDaHJvbWUgb24gaU9TIGZpcmVzIHJlYWwgcG9wc3RhdGUgZXZlbnRzXG4gKiBjb250YWluaW5nIHVuZGVmaW5lZCBzdGF0ZSB3aGVuIHByZXNzaW5nIHRoZSBiYWNrIGJ1dHRvbi5cbiAqL1xuZXhwb3J0IHZhciBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50ID0gZnVuY3Rpb24gaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkge1xuICByZXR1cm4gZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0NyaU9TJykgPT09IC0xO1xufTsiLCJ2YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgcmVzb2x2ZVBhdGhuYW1lIGZyb20gJ3Jlc29sdmUtcGF0aG5hbWUnO1xuaW1wb3J0IHZhbHVlRXF1YWwgZnJvbSAndmFsdWUtZXF1YWwnO1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi9QYXRoVXRpbHMnO1xuXG5leHBvcnQgdmFyIGNyZWF0ZUxvY2F0aW9uID0gZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGtleSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciBsb2NhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgIC8vIFR3by1hcmcgZm9ybTogcHVzaChwYXRoLCBzdGF0ZSlcbiAgICBsb2NhdGlvbiA9IHBhcnNlUGF0aChwYXRoKTtcbiAgICBsb2NhdGlvbi5zdGF0ZSA9IHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIE9uZS1hcmcgZm9ybTogcHVzaChsb2NhdGlvbilcbiAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBwYXRoKTtcblxuICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gdW5kZWZpbmVkKSBsb2NhdGlvbi5wYXRobmFtZSA9ICcnO1xuXG4gICAgaWYgKGxvY2F0aW9uLnNlYXJjaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLnNlYXJjaC5jaGFyQXQoMCkgIT09ICc/JykgbG9jYXRpb24uc2VhcmNoID0gJz8nICsgbG9jYXRpb24uc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5zZWFyY2ggPSAnJztcbiAgICB9XG5cbiAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgaWYgKGxvY2F0aW9uLmhhc2guY2hhckF0KDApICE9PSAnIycpIGxvY2F0aW9uLmhhc2ggPSAnIycgKyBsb2NhdGlvbi5oYXNoO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQgJiYgbG9jYXRpb24uc3RhdGUgPT09IHVuZGVmaW5lZCkgbG9jYXRpb24uc3RhdGUgPSBzdGF0ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9jYXRpb24ucGF0aG5hbWUgPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgaWYgKGUgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFVSSUVycm9yKCdQYXRobmFtZSBcIicgKyBsb2NhdGlvbi5wYXRobmFtZSArICdcIiBjb3VsZCBub3QgYmUgZGVjb2RlZC4gJyArICdUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgYW4gaW52YWxpZCBwZXJjZW50LWVuY29kaW5nLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChrZXkpIGxvY2F0aW9uLmtleSA9IGtleTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uKSB7XG4gICAgLy8gUmVzb2x2ZSBpbmNvbXBsZXRlL3JlbGF0aXZlIHBhdGhuYW1lIHJlbGF0aXZlIHRvIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgaWYgKCFsb2NhdGlvbi5wYXRobmFtZSkge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWU7XG4gICAgfSBlbHNlIGlmIChsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgICAgbG9jYXRpb24ucGF0aG5hbWUgPSByZXNvbHZlUGF0aG5hbWUobG9jYXRpb24ucGF0aG5hbWUsIGN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gcHJpb3IgbG9jYXRpb24gYW5kIHBhdGhuYW1lIGlzIGVtcHR5LCBzZXQgaXQgdG8gL1xuICAgIGlmICghbG9jYXRpb24ucGF0aG5hbWUpIHtcbiAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsb2NhdGlvbjtcbn07XG5cbmV4cG9ydCB2YXIgbG9jYXRpb25zQXJlRXF1YWwgPSBmdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJiBhLmhhc2ggPT09IGIuaGFzaCAmJiBhLmtleSA9PT0gYi5rZXkgJiYgdmFsdWVFcXVhbChhLnN0YXRlLCBiLnN0YXRlKTtcbn07IiwiZXhwb3J0IHZhciBhZGRMZWFkaW5nU2xhc2ggPSBmdW5jdGlvbiBhZGRMZWFkaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJyA/IHBhdGggOiAnLycgKyBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcExlYWRpbmdTbGFzaCA9IGZ1bmN0aW9uIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnLycgPyBwYXRoLnN1YnN0cigxKSA6IHBhdGg7XG59O1xuXG5leHBvcnQgdmFyIGhhc0Jhc2VuYW1lID0gZnVuY3Rpb24gaGFzQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoXFxcXC98XFxcXD98I3wkKScsICdpJykudGVzdChwYXRoKTtcbn07XG5cbmV4cG9ydCB2YXIgc3RyaXBCYXNlbmFtZSA9IGZ1bmN0aW9uIHN0cmlwQmFzZW5hbWUocGF0aCwgcHJlZml4KSB7XG4gIHJldHVybiBoYXNCYXNlbmFtZShwYXRoLCBwcmVmaXgpID8gcGF0aC5zdWJzdHIocHJlZml4Lmxlbmd0aCkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBzdHJpcFRyYWlsaW5nU2xhc2ggPSBmdW5jdGlvbiBzdHJpcFRyYWlsaW5nU2xhc2gocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gJy8nID8gcGF0aC5zbGljZSgwLCAtMSkgOiBwYXRoO1xufTtcblxuZXhwb3J0IHZhciBwYXJzZVBhdGggPSBmdW5jdGlvbiBwYXJzZVBhdGgocGF0aCkge1xuICB2YXIgcGF0aG5hbWUgPSBwYXRoIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9ICcnO1xuICB2YXIgaGFzaCA9ICcnO1xuXG4gIHZhciBoYXNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoSW5kZXggIT09IC0xKSB7XG4gICAgaGFzaCA9IHBhdGhuYW1lLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gIH1cblxuICB2YXIgc2VhcmNoSW5kZXggPSBwYXRobmFtZS5pbmRleE9mKCc/Jyk7XG4gIGlmIChzZWFyY2hJbmRleCAhPT0gLTEpIHtcbiAgICBzZWFyY2ggPSBwYXRobmFtZS5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgIHBhdGhuYW1lID0gcGF0aG5hbWUuc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoID09PSAnPycgPyAnJyA6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoID09PSAnIycgPyAnJyA6IGhhc2hcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2gsXG4gICAgICBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuXG4gIHZhciBwYXRoID0gcGF0aG5hbWUgfHwgJy8nO1xuXG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSAnPycpIHBhdGggKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuXG4gIGlmIChoYXNoICYmIGhhc2ggIT09ICcjJykgcGF0aCArPSBoYXNoLmNoYXJBdCgwKSA9PT0gJyMnID8gaGFzaCA6ICcjJyArIGhhc2g7XG5cbiAgcmV0dXJuIHBhdGg7XG59OyIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuaW1wb3J0IHdhcm5pbmcgZnJvbSAnd2FybmluZyc7XG5pbXBvcnQgaW52YXJpYW50IGZyb20gJ2ludmFyaWFudCc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgeyBhZGRMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNIaXN0b3J5LCBzdXBwb3J0c1BvcFN0YXRlT25IYXNoQ2hhbmdlLCBpc0V4dHJhbmVvdXNQb3BzdGF0ZUV2ZW50IH0gZnJvbSAnLi9ET01VdGlscyc7XG5cbnZhciBQb3BTdGF0ZUV2ZW50ID0gJ3BvcHN0YXRlJztcbnZhciBIYXNoQ2hhbmdlRXZlbnQgPSAnaGFzaGNoYW5nZSc7XG5cbnZhciBnZXRIaXN0b3J5U3RhdGUgPSBmdW5jdGlvbiBnZXRIaXN0b3J5U3RhdGUoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8IHt9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gSUUgMTEgc29tZXRpbWVzIHRocm93cyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cuaGlzdG9yeS5zdGF0ZVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUmVhY3RUcmFpbmluZy9oaXN0b3J5L3B1bGwvMjg5XG4gICAgcmV0dXJuIHt9O1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoaXN0b3J5IG9iamVjdCB0aGF0IHVzZXMgdGhlIEhUTUw1IGhpc3RvcnkgQVBJIGluY2x1ZGluZ1xuICogcHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQuXG4gKi9cbnZhciBjcmVhdGVCcm93c2VySGlzdG9yeSA9IGZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KCkge1xuICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gIGludmFyaWFudChjYW5Vc2VET00sICdCcm93c2VyIGhpc3RvcnkgbmVlZHMgYSBET00nKTtcblxuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuICB2YXIgY2FuVXNlSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgbmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIgPSAhc3VwcG9ydHNQb3BTdGF0ZU9uSGFzaENoYW5nZSgpO1xuXG4gIHZhciBfcHJvcHMkZm9yY2VSZWZyZXNoID0gcHJvcHMuZm9yY2VSZWZyZXNoLFxuICAgICAgZm9yY2VSZWZyZXNoID0gX3Byb3BzJGZvcmNlUmVmcmVzaCA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBfcHJvcHMkZm9yY2VSZWZyZXNoLFxuICAgICAgX3Byb3BzJGdldFVzZXJDb25maXJtID0gcHJvcHMuZ2V0VXNlckNvbmZpcm1hdGlvbixcbiAgICAgIGdldFVzZXJDb25maXJtYXRpb24gPSBfcHJvcHMkZ2V0VXNlckNvbmZpcm0gPT09IHVuZGVmaW5lZCA/IGdldENvbmZpcm1hdGlvbiA6IF9wcm9wcyRnZXRVc2VyQ29uZmlybSxcbiAgICAgIF9wcm9wcyRrZXlMZW5ndGggPSBwcm9wcy5rZXlMZW5ndGgsXG4gICAgICBrZXlMZW5ndGggPSBfcHJvcHMka2V5TGVuZ3RoID09PSB1bmRlZmluZWQgPyA2IDogX3Byb3BzJGtleUxlbmd0aDtcblxuICB2YXIgYmFzZW5hbWUgPSBwcm9wcy5iYXNlbmFtZSA/IHN0cmlwVHJhaWxpbmdTbGFzaChhZGRMZWFkaW5nU2xhc2gocHJvcHMuYmFzZW5hbWUpKSA6ICcnO1xuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHZhciBfcmVmID0gaGlzdG9yeVN0YXRlIHx8IHt9LFxuICAgICAgICBrZXkgPSBfcmVmLmtleSxcbiAgICAgICAgc3RhdGUgPSBfcmVmLnN0YXRlO1xuXG4gICAgdmFyIF93aW5kb3ckbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICAgIHBhdGhuYW1lID0gX3dpbmRvdyRsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoID0gX3dpbmRvdyRsb2NhdGlvbi5zZWFyY2gsXG4gICAgICAgIGhhc2ggPSBfd2luZG93JGxvY2F0aW9uLmhhc2g7XG5cblxuICAgIHZhciBwYXRoID0gcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xuXG4gICAgd2FybmluZyghYmFzZW5hbWUgfHwgaGFzQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpLCAnWW91IGFyZSBhdHRlbXB0aW5nIHRvIHVzZSBhIGJhc2VuYW1lIG9uIGEgcGFnZSB3aG9zZSBVUkwgcGF0aCBkb2VzIG5vdCBiZWdpbiAnICsgJ3dpdGggdGhlIGJhc2VuYW1lLiBFeHBlY3RlZCBwYXRoIFwiJyArIHBhdGggKyAnXCIgdG8gYmVnaW4gd2l0aCBcIicgKyBiYXNlbmFtZSArICdcIi4nKTtcblxuICAgIGlmIChiYXNlbmFtZSkgcGF0aCA9IHN0cmlwQmFzZW5hbWUocGF0aCwgYmFzZW5hbWUpO1xuXG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBrZXkpO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKCk7XG5cbiAgdmFyIHNldFN0YXRlID0gZnVuY3Rpb24gc2V0U3RhdGUobmV4dFN0YXRlKSB7XG4gICAgX2V4dGVuZHMoaGlzdG9yeSwgbmV4dFN0YXRlKTtcblxuICAgIGhpc3RvcnkubGVuZ3RoID0gZ2xvYmFsSGlzdG9yeS5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb3BTdGF0ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvcFN0YXRlKGV2ZW50KSB7XG4gICAgLy8gSWdub3JlIGV4dHJhbmVvdXMgcG9wc3RhdGUgZXZlbnRzIGluIFdlYktpdC5cbiAgICBpZiAoaXNFeHRyYW5lb3VzUG9wc3RhdGVFdmVudChldmVudCkpIHJldHVybjtcblxuICAgIGhhbmRsZVBvcChnZXRET01Mb2NhdGlvbihldmVudC5zdGF0ZSkpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVIYXNoQ2hhbmdlID0gZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZSgpIHtcbiAgICBoYW5kbGVQb3AoZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG5cbiAgdmFyIGhhbmRsZVBvcCA9IGZ1bmN0aW9uIGhhbmRsZVBvcChsb2NhdGlvbikge1xuICAgIGlmIChmb3JjZU5leHRQb3ApIHtcbiAgICAgIGZvcmNlTmV4dFBvcCA9IGZhbHNlO1xuICAgICAgc2V0U3RhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuXG4gICAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV2ZXJ0UG9wKGxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZXZlcnRQb3AgPSBmdW5jdGlvbiByZXZlcnRQb3AoZnJvbUxvY2F0aW9uKSB7XG4gICAgdmFyIHRvTG9jYXRpb24gPSBoaXN0b3J5LmxvY2F0aW9uO1xuXG4gICAgLy8gVE9ETzogV2UgY291bGQgcHJvYmFibHkgbWFrZSB0aGlzIG1vcmUgcmVsaWFibGUgYnlcbiAgICAvLyBrZWVwaW5nIGEgbGlzdCBvZiBrZXlzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIGtleXMgd2UgZG9uJ3Qga25vdy5cblxuICAgIHZhciB0b0luZGV4ID0gYWxsS2V5cy5pbmRleE9mKHRvTG9jYXRpb24ua2V5KTtcblxuICAgIGlmICh0b0luZGV4ID09PSAtMSkgdG9JbmRleCA9IDA7XG5cbiAgICB2YXIgZnJvbUluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGZyb21Mb2NhdGlvbi5rZXkpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oZ2V0SGlzdG9yeVN0YXRlKCkpO1xuICB2YXIgYWxsS2V5cyA9IFtpbml0aWFsTG9jYXRpb24ua2V5XTtcblxuICAvLyBQdWJsaWMgaW50ZXJmYWNlXG5cbiAgdmFyIGNyZWF0ZUhyZWYgPSBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gIH07XG5cbiAgdmFyIHB1c2ggPSBmdW5jdGlvbiBwdXNoKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyghKCh0eXBlb2YgcGF0aCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocGF0aCkpID09PSAnb2JqZWN0JyAmJiBwYXRoLnN0YXRlICE9PSB1bmRlZmluZWQgJiYgc3RhdGUgIT09IHVuZGVmaW5lZCksICdZb3Ugc2hvdWxkIGF2b2lkIHByb3ZpZGluZyBhIDJuZCBzdGF0ZSBhcmd1bWVudCB0byBwdXNoIHdoZW4gdGhlIDFzdCAnICsgJ2FyZ3VtZW50IGlzIGEgbG9jYXRpb24tbGlrZSBvYmplY3QgdGhhdCBhbHJlYWR5IGhhcyBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCBzdGF0ZSwgY3JlYXRlS2V5KCksIGhpc3RvcnkubG9jYXRpb24pO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmICghb2spIHJldHVybjtcblxuICAgICAgdmFyIGhyZWYgPSBjcmVhdGVIcmVmKGxvY2F0aW9uKTtcbiAgICAgIHZhciBrZXkgPSBsb2NhdGlvbi5rZXksXG4gICAgICAgICAgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZTtcblxuXG4gICAgICBpZiAoY2FuVXNlSGlzdG9yeSkge1xuICAgICAgICBnbG9iYWxIaXN0b3J5LnB1c2hTdGF0ZSh7IGtleToga2V5LCBzdGF0ZTogc3RhdGUgfSwgbnVsbCwgaHJlZik7XG5cbiAgICAgICAgaWYgKGZvcmNlUmVmcmVzaCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gaHJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcbiAgICAgICAgICB2YXIgbmV4dEtleXMgPSBhbGxLZXlzLnNsaWNlKDAsIHByZXZJbmRleCA9PT0gLTEgPyAwIDogcHJldkluZGV4ICsgMSk7XG5cbiAgICAgICAgICBuZXh0S2V5cy5wdXNoKGxvY2F0aW9uLmtleSk7XG4gICAgICAgICAgYWxsS2V5cyA9IG5leHRLZXlzO1xuXG4gICAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHN0YXRlID09PSB1bmRlZmluZWQsICdCcm93c2VyIGhpc3RvcnkgY2Fubm90IHB1c2ggc3RhdGUgaW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCBIVE1MNSBoaXN0b3J5Jyk7XG5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBocmVmO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBocmVmID0gY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5LFxuICAgICAgICAgIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG5cblxuICAgICAgaWYgKGNhblVzZUhpc3RvcnkpIHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoeyBrZXk6IGtleSwgc3RhdGU6IHN0YXRlIH0sIG51bGwsIGhyZWYpO1xuXG4gICAgICAgIGlmIChmb3JjZVJlZnJlc2gpIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGhpc3RvcnkubG9jYXRpb24ua2V5KTtcblxuICAgICAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxLZXlzW3ByZXZJbmRleF0gPSBsb2NhdGlvbi5rZXk7XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0Jyb3dzZXIgaGlzdG9yeSBjYW5ub3QgcmVwbGFjZSBzdGF0ZSBpbiBicm93c2VycyB0aGF0IGRvIG5vdCBzdXBwb3J0IEhUTUw1IGhpc3RvcnknKTtcblxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShocmVmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbiBnbyhuKSB7XG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgUG9wU3RhdGVFdmVudCwgaGFuZGxlUG9wU3RhdGUpO1xuXG4gICAgICBpZiAobmVlZHNIYXNoQ2hhbmdlTGlzdGVuZXIpIGFkZEV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH0gZWxzZSBpZiAobGlzdGVuZXJDb3VudCA9PT0gMCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csIFBvcFN0YXRlRXZlbnQsIGhhbmRsZVBvcFN0YXRlKTtcblxuICAgICAgaWYgKG5lZWRzSGFzaENoYW5nZUxpc3RlbmVyKSByZW1vdmVFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGlzQmxvY2tlZCA9IGZhbHNlO1xuXG4gIHZhciBibG9jayA9IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgIHZhciBwcm9tcHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgdmFyIHVuYmxvY2sgPSB0cmFuc2l0aW9uTWFuYWdlci5zZXRQcm9tcHQocHJvbXB0KTtcblxuICAgIGlmICghaXNCbG9ja2VkKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcbiAgICAgIGlzQmxvY2tlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0Jsb2NrZWQpIHtcbiAgICAgICAgaXNCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKC0xKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuYmxvY2soKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBsaXN0ZW4gPSBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICB2YXIgdW5saXN0ZW4gPSB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgY2hlY2tET01MaXN0ZW5lcnMoMSk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgdW5saXN0ZW4oKTtcbiAgICB9O1xuICB9O1xuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGxlbmd0aDogZ2xvYmFsSGlzdG9yeS5sZW5ndGgsXG4gICAgYWN0aW9uOiAnUE9QJyxcbiAgICBsb2NhdGlvbjogaW5pdGlhbExvY2F0aW9uLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBnb0JhY2s6IGdvQmFjayxcbiAgICBnb0ZvcndhcmQ6IGdvRm9yd2FyZCxcbiAgICBibG9jazogYmxvY2ssXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcblxuICByZXR1cm4gaGlzdG9yeTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUJyb3dzZXJIaXN0b3J5OyIsInZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmltcG9ydCB3YXJuaW5nIGZyb20gJ3dhcm5pbmcnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICdpbnZhcmlhbnQnO1xuaW1wb3J0IHsgY3JlYXRlTG9jYXRpb24sIGxvY2F0aW9uc0FyZUVxdWFsIH0gZnJvbSAnLi9Mb2NhdGlvblV0aWxzJztcbmltcG9ydCB7IGFkZExlYWRpbmdTbGFzaCwgc3RyaXBMZWFkaW5nU2xhc2gsIHN0cmlwVHJhaWxpbmdTbGFzaCwgaGFzQmFzZW5hbWUsIHN0cmlwQmFzZW5hbWUsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjYW5Vc2VET00sIGFkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXIsIGdldENvbmZpcm1hdGlvbiwgc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggfSBmcm9tICcuL0RPTVV0aWxzJztcblxudmFyIEhhc2hDaGFuZ2VFdmVudCA9ICdoYXNoY2hhbmdlJztcblxudmFyIEhhc2hQYXRoQ29kZXJzID0ge1xuICBoYXNoYmFuZzoge1xuICAgIGVuY29kZVBhdGg6IGZ1bmN0aW9uIGVuY29kZVBhdGgocGF0aCkge1xuICAgICAgcmV0dXJuIHBhdGguY2hhckF0KDApID09PSAnIScgPyBwYXRoIDogJyEvJyArIHN0cmlwTGVhZGluZ1NsYXNoKHBhdGgpO1xuICAgIH0sXG4gICAgZGVjb2RlUGF0aDogZnVuY3Rpb24gZGVjb2RlUGF0aChwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICchJyA/IHBhdGguc3Vic3RyKDEpIDogcGF0aDtcbiAgICB9XG4gIH0sXG4gIG5vc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBzdHJpcExlYWRpbmdTbGFzaCxcbiAgICBkZWNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2hcbiAgfSxcbiAgc2xhc2g6IHtcbiAgICBlbmNvZGVQYXRoOiBhZGRMZWFkaW5nU2xhc2gsXG4gICAgZGVjb2RlUGF0aDogYWRkTGVhZGluZ1NsYXNoXG4gIH1cbn07XG5cbnZhciBnZXRIYXNoUGF0aCA9IGZ1bmN0aW9uIGdldEhhc2hQYXRoKCkge1xuICAvLyBXZSBjYW4ndCB1c2Ugd2luZG93LmxvY2F0aW9uLmhhc2ggaGVyZSBiZWNhdXNlIGl0J3Mgbm90XG4gIC8vIGNvbnNpc3RlbnQgYWNyb3NzIGJyb3dzZXJzIC0gRmlyZWZveCB3aWxsIHByZS1kZWNvZGUgaXQhXG4gIHZhciBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIHZhciBoYXNoSW5kZXggPSBocmVmLmluZGV4T2YoJyMnKTtcbiAgcmV0dXJuIGhhc2hJbmRleCA9PT0gLTEgPyAnJyA6IGhyZWYuc3Vic3RyaW5nKGhhc2hJbmRleCArIDEpO1xufTtcblxudmFyIHB1c2hIYXNoUGF0aCA9IGZ1bmN0aW9uIHB1c2hIYXNoUGF0aChwYXRoKSB7XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG59O1xuXG52YXIgcmVwbGFjZUhhc2hQYXRoID0gZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgdmFyIGhhc2hJbmRleCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YoJyMnKTtcblxuICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh3aW5kb3cubG9jYXRpb24uaHJlZi5zbGljZSgwLCBoYXNoSW5kZXggPj0gMCA/IGhhc2hJbmRleCA6IDApICsgJyMnICsgcGF0aCk7XG59O1xuXG52YXIgY3JlYXRlSGFzaEhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICBpbnZhcmlhbnQoY2FuVXNlRE9NLCAnSGFzaCBoaXN0b3J5IG5lZWRzIGEgRE9NJyk7XG5cbiAgdmFyIGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgdmFyIGNhbkdvV2l0aG91dFJlbG9hZCA9IHN1cHBvcnRzR29XaXRob3V0UmVsb2FkVXNpbmdIYXNoKCk7XG5cbiAgdmFyIF9wcm9wcyRnZXRVc2VyQ29uZmlybSA9IHByb3BzLmdldFVzZXJDb25maXJtYXRpb24sXG4gICAgICBnZXRVc2VyQ29uZmlybWF0aW9uID0gX3Byb3BzJGdldFVzZXJDb25maXJtID09PSB1bmRlZmluZWQgPyBnZXRDb25maXJtYXRpb24gOiBfcHJvcHMkZ2V0VXNlckNvbmZpcm0sXG4gICAgICBfcHJvcHMkaGFzaFR5cGUgPSBwcm9wcy5oYXNoVHlwZSxcbiAgICAgIGhhc2hUeXBlID0gX3Byb3BzJGhhc2hUeXBlID09PSB1bmRlZmluZWQgPyAnc2xhc2gnIDogX3Byb3BzJGhhc2hUeXBlO1xuXG4gIHZhciBiYXNlbmFtZSA9IHByb3BzLmJhc2VuYW1lID8gc3RyaXBUcmFpbGluZ1NsYXNoKGFkZExlYWRpbmdTbGFzaChwcm9wcy5iYXNlbmFtZSkpIDogJyc7XG5cbiAgdmFyIF9IYXNoUGF0aENvZGVycyRoYXNoVCA9IEhhc2hQYXRoQ29kZXJzW2hhc2hUeXBlXSxcbiAgICAgIGVuY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZW5jb2RlUGF0aCxcbiAgICAgIGRlY29kZVBhdGggPSBfSGFzaFBhdGhDb2RlcnMkaGFzaFQuZGVjb2RlUGF0aDtcblxuXG4gIHZhciBnZXRET01Mb2NhdGlvbiA9IGZ1bmN0aW9uIGdldERPTUxvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gZGVjb2RlUGF0aChnZXRIYXNoUGF0aCgpKTtcblxuICAgIHdhcm5pbmcoIWJhc2VuYW1lIHx8IGhhc0Jhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKSwgJ1lvdSBhcmUgYXR0ZW1wdGluZyB0byB1c2UgYSBiYXNlbmFtZSBvbiBhIHBhZ2Ugd2hvc2UgVVJMIHBhdGggZG9lcyBub3QgYmVnaW4gJyArICd3aXRoIHRoZSBiYXNlbmFtZS4gRXhwZWN0ZWQgcGF0aCBcIicgKyBwYXRoICsgJ1wiIHRvIGJlZ2luIHdpdGggXCInICsgYmFzZW5hbWUgKyAnXCIuJyk7XG5cbiAgICBpZiAoYmFzZW5hbWUpIHBhdGggPSBzdHJpcEJhc2VuYW1lKHBhdGgsIGJhc2VuYW1lKTtcblxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihwYXRoKTtcbiAgfTtcblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGdsb2JhbEhpc3RvcnkubGVuZ3RoO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIubm90aWZ5TGlzdGVuZXJzKGhpc3RvcnkubG9jYXRpb24sIGhpc3RvcnkuYWN0aW9uKTtcbiAgfTtcblxuICB2YXIgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gIHZhciBpZ25vcmVQYXRoID0gbnVsbDtcblxuICB2YXIgaGFuZGxlSGFzaENoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUhhc2hDaGFuZ2UoKSB7XG4gICAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICAgIHZhciBlbmNvZGVkUGF0aCA9IGVuY29kZVBhdGgocGF0aCk7XG5cbiAgICBpZiAocGF0aCAhPT0gZW5jb2RlZFBhdGgpIHtcbiAgICAgIC8vIEVuc3VyZSB3ZSBhbHdheXMgaGF2ZSBhIHByb3Blcmx5LWVuY29kZWQgaGFzaC5cbiAgICAgIHJlcGxhY2VIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdldERPTUxvY2F0aW9uKCk7XG4gICAgICB2YXIgcHJldkxvY2F0aW9uID0gaGlzdG9yeS5sb2NhdGlvbjtcblxuICAgICAgaWYgKCFmb3JjZU5leHRQb3AgJiYgbG9jYXRpb25zQXJlRXF1YWwocHJldkxvY2F0aW9uLCBsb2NhdGlvbikpIHJldHVybjsgLy8gQSBoYXNoY2hhbmdlIGRvZXNuJ3QgYWx3YXlzID09IGxvY2F0aW9uIGNoYW5nZS5cblxuICAgICAgaWYgKGlnbm9yZVBhdGggPT09IGNyZWF0ZVBhdGgobG9jYXRpb24pKSByZXR1cm47IC8vIElnbm9yZSB0aGlzIGNoYW5nZTsgd2UgYWxyZWFkeSBzZXRTdGF0ZSBpbiBwdXNoL3JlcGxhY2UuXG5cbiAgICAgIGlnbm9yZVBhdGggPSBudWxsO1xuXG4gICAgICBoYW5kbGVQb3AobG9jYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlUG9wID0gZnVuY3Rpb24gaGFuZGxlUG9wKGxvY2F0aW9uKSB7XG4gICAgaWYgKGZvcmNlTmV4dFBvcCkge1xuICAgICAgZm9yY2VOZXh0UG9wID0gZmFsc2U7XG4gICAgICBzZXRTdGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYWN0aW9uID0gJ1BPUCc7XG5cbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgIGlmIChvaykge1xuICAgICAgICAgIHNldFN0YXRlKHsgYWN0aW9uOiBhY3Rpb24sIGxvY2F0aW9uOiBsb2NhdGlvbiB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXZlcnRQb3AobG9jYXRpb24pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHJldmVydFBvcCA9IGZ1bmN0aW9uIHJldmVydFBvcChmcm9tTG9jYXRpb24pIHtcbiAgICB2YXIgdG9Mb2NhdGlvbiA9IGhpc3RvcnkubG9jYXRpb247XG5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZSBieVxuICAgIC8vIGtlZXBpbmcgYSBsaXN0IG9mIHBhdGhzIHdlJ3ZlIHNlZW4gaW4gc2Vzc2lvblN0b3JhZ2UuXG4gICAgLy8gSW5zdGVhZCwgd2UganVzdCBkZWZhdWx0IHRvIDAgZm9yIHBhdGhzIHdlIGRvbid0IGtub3cuXG5cbiAgICB2YXIgdG9JbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgodG9Mb2NhdGlvbikpO1xuXG4gICAgaWYgKHRvSW5kZXggPT09IC0xKSB0b0luZGV4ID0gMDtcblxuICAgIHZhciBmcm9tSW5kZXggPSBhbGxQYXRocy5sYXN0SW5kZXhPZihjcmVhdGVQYXRoKGZyb21Mb2NhdGlvbikpO1xuXG4gICAgaWYgKGZyb21JbmRleCA9PT0gLTEpIGZyb21JbmRleCA9IDA7XG5cbiAgICB2YXIgZGVsdGEgPSB0b0luZGV4IC0gZnJvbUluZGV4O1xuXG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBmb3JjZU5leHRQb3AgPSB0cnVlO1xuICAgICAgZ28oZGVsdGEpO1xuICAgIH1cbiAgfTtcblxuICAvLyBFbnN1cmUgdGhlIGhhc2ggaXMgZW5jb2RlZCBwcm9wZXJseSBiZWZvcmUgZG9pbmcgYW55dGhpbmcgZWxzZS5cbiAgdmFyIHBhdGggPSBnZXRIYXNoUGF0aCgpO1xuICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKHBhdGgpO1xuXG4gIGlmIChwYXRoICE9PSBlbmNvZGVkUGF0aCkgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcblxuICB2YXIgaW5pdGlhbExvY2F0aW9uID0gZ2V0RE9NTG9jYXRpb24oKTtcbiAgdmFyIGFsbFBhdGhzID0gW2NyZWF0ZVBhdGgoaW5pdGlhbExvY2F0aW9uKV07XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiAnIycgKyBlbmNvZGVQYXRoKGJhc2VuYW1lICsgY3JlYXRlUGF0aChsb2NhdGlvbikpO1xuICB9O1xuXG4gIHZhciBwdXNoID0gZnVuY3Rpb24gcHVzaChwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoc3RhdGUgPT09IHVuZGVmaW5lZCwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgcHVzaCBzdGF0ZTsgaXQgaXMgaWdub3JlZCcpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQVVNIJztcbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihwYXRoLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcGF0aCA9IGNyZWF0ZVBhdGgobG9jYXRpb24pO1xuICAgICAgdmFyIGVuY29kZWRQYXRoID0gZW5jb2RlUGF0aChiYXNlbmFtZSArIHBhdGgpO1xuICAgICAgdmFyIGhhc2hDaGFuZ2VkID0gZ2V0SGFzaFBhdGgoKSAhPT0gZW5jb2RlZFBhdGg7XG5cbiAgICAgIGlmIChoYXNoQ2hhbmdlZCkge1xuICAgICAgICAvLyBXZSBjYW5ub3QgdGVsbCBpZiBhIGhhc2hjaGFuZ2Ugd2FzIGNhdXNlZCBieSBhIFBVU0gsIHNvIHdlJ2RcbiAgICAgICAgLy8gcmF0aGVyIHNldFN0YXRlIGhlcmUgYW5kIGlnbm9yZSB0aGUgaGFzaGNoYW5nZS4gVGhlIGNhdmVhdCBoZXJlXG4gICAgICAgIC8vIGlzIHRoYXQgb3RoZXIgaGFzaCBoaXN0b3JpZXMgaW4gdGhlIHBhZ2Ugd2lsbCBjb25zaWRlciBpdCBhIFBPUC5cbiAgICAgICAgaWdub3JlUGF0aCA9IHBhdGg7XG4gICAgICAgIHB1c2hIYXNoUGF0aChlbmNvZGVkUGF0aCk7XG5cbiAgICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmxhc3RJbmRleE9mKGNyZWF0ZVBhdGgoaGlzdG9yeS5sb2NhdGlvbikpO1xuICAgICAgICB2YXIgbmV4dFBhdGhzID0gYWxsUGF0aHMuc2xpY2UoMCwgcHJldkluZGV4ID09PSAtMSA/IDAgOiBwcmV2SW5kZXggKyAxKTtcblxuICAgICAgICBuZXh0UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgYWxsUGF0aHMgPSBuZXh0UGF0aHM7XG5cbiAgICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0hhc2ggaGlzdG9yeSBjYW5ub3QgUFVTSCB0aGUgc2FtZSBwYXRoOyBhIG5ldyBlbnRyeSB3aWxsIG5vdCBiZSBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaycpO1xuXG4gICAgICAgIHNldFN0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHBhdGgsIHN0YXRlKSB7XG4gICAgd2FybmluZyhzdGF0ZSA9PT0gdW5kZWZpbmVkLCAnSGFzaCBoaXN0b3J5IGNhbm5vdCByZXBsYWNlIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1JFUExBQ0UnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIHZhciBwYXRoID0gY3JlYXRlUGF0aChsb2NhdGlvbik7XG4gICAgICB2YXIgZW5jb2RlZFBhdGggPSBlbmNvZGVQYXRoKGJhc2VuYW1lICsgcGF0aCk7XG4gICAgICB2YXIgaGFzaENoYW5nZWQgPSBnZXRIYXNoUGF0aCgpICE9PSBlbmNvZGVkUGF0aDtcblxuICAgICAgaWYgKGhhc2hDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB0ZWxsIGlmIGEgaGFzaGNoYW5nZSB3YXMgY2F1c2VkIGJ5IGEgUkVQTEFDRSwgc28gd2UnZFxuICAgICAgICAvLyByYXRoZXIgc2V0U3RhdGUgaGVyZSBhbmQgaWdub3JlIHRoZSBoYXNoY2hhbmdlLiBUaGUgY2F2ZWF0IGhlcmVcbiAgICAgICAgLy8gaXMgdGhhdCBvdGhlciBoYXNoIGhpc3RvcmllcyBpbiB0aGUgcGFnZSB3aWxsIGNvbnNpZGVyIGl0IGEgUE9QLlxuICAgICAgICBpZ25vcmVQYXRoID0gcGF0aDtcbiAgICAgICAgcmVwbGFjZUhhc2hQYXRoKGVuY29kZWRQYXRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZJbmRleCA9IGFsbFBhdGhzLmluZGV4T2YoY3JlYXRlUGF0aChoaXN0b3J5LmxvY2F0aW9uKSk7XG5cbiAgICAgIGlmIChwcmV2SW5kZXggIT09IC0xKSBhbGxQYXRoc1twcmV2SW5kZXhdID0gcGF0aDtcblxuICAgICAgc2V0U3RhdGUoeyBhY3Rpb246IGFjdGlvbiwgbG9jYXRpb246IGxvY2F0aW9uIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uIGdvKG4pIHtcbiAgICB3YXJuaW5nKGNhbkdvV2l0aG91dFJlbG9hZCwgJ0hhc2ggaGlzdG9yeSBnbyhuKSBjYXVzZXMgYSBmdWxsIHBhZ2UgcmVsb2FkIGluIHRoaXMgYnJvd3NlcicpO1xuXG4gICAgZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIHZhciBjaGVja0RPTUxpc3RlbmVycyA9IGZ1bmN0aW9uIGNoZWNrRE9NTGlzdGVuZXJzKGRlbHRhKSB7XG4gICAgbGlzdGVuZXJDb3VudCArPSBkZWx0YTtcblxuICAgIGlmIChsaXN0ZW5lckNvdW50ID09PSAxKSB7XG4gICAgICBhZGRFdmVudExpc3RlbmVyKHdpbmRvdywgSGFzaENoYW5nZUV2ZW50LCBoYW5kbGVIYXNoQ2hhbmdlKTtcbiAgICB9IGVsc2UgaWYgKGxpc3RlbmVyQ291bnQgPT09IDApIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCBIYXNoQ2hhbmdlRXZlbnQsIGhhbmRsZUhhc2hDaGFuZ2UpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaXNCbG9ja2VkID0gZmFsc2U7XG5cbiAgdmFyIGJsb2NrID0gZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgdmFyIHByb21wdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICB2YXIgdW5ibG9jayA9IHRyYW5zaXRpb25NYW5hZ2VyLnNldFByb21wdChwcm9tcHQpO1xuXG4gICAgaWYgKCFpc0Jsb2NrZWQpIHtcbiAgICAgIGNoZWNrRE9NTGlzdGVuZXJzKDEpO1xuICAgICAgaXNCbG9ja2VkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlzQmxvY2tlZCkge1xuICAgICAgICBpc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgY2hlY2tET01MaXN0ZW5lcnMoLTEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5ibG9jaygpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHZhciB1bmxpc3RlbiA9IHRyYW5zaXRpb25NYW5hZ2VyLmFwcGVuZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICBjaGVja0RPTUxpc3RlbmVycygxKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGVja0RPTUxpc3RlbmVycygtMSk7XG4gICAgICB1bmxpc3RlbigpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBnbG9iYWxIaXN0b3J5Lmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBpbml0aWFsTG9jYXRpb24sXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGdvQmFjazogZ29CYWNrLFxuICAgIGdvRm9yd2FyZDogZ29Gb3J3YXJkLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlSGFzaEhpc3Rvcnk7IiwidmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5pbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcbmltcG9ydCB7IGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7XG5pbXBvcnQgeyBjcmVhdGVMb2NhdGlvbiB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5pbXBvcnQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgZnJvbSAnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcic7XG5cbnZhciBjbGFtcCA9IGZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgc3RvcmVzIGxvY2F0aW9ucyBpbiBtZW1vcnkuXG4gKi9cbnZhciBjcmVhdGVNZW1vcnlIaXN0b3J5ID0gZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeSgpIHtcbiAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBwcm9wcy5nZXRVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgX3Byb3BzJGluaXRpYWxFbnRyaWVzID0gcHJvcHMuaW5pdGlhbEVudHJpZXMsXG4gICAgICBpbml0aWFsRW50cmllcyA9IF9wcm9wcyRpbml0aWFsRW50cmllcyA9PT0gdW5kZWZpbmVkID8gWycvJ10gOiBfcHJvcHMkaW5pdGlhbEVudHJpZXMsXG4gICAgICBfcHJvcHMkaW5pdGlhbEluZGV4ID0gcHJvcHMuaW5pdGlhbEluZGV4LFxuICAgICAgaW5pdGlhbEluZGV4ID0gX3Byb3BzJGluaXRpYWxJbmRleCA9PT0gdW5kZWZpbmVkID8gMCA6IF9wcm9wcyRpbml0aWFsSW5kZXgsXG4gICAgICBfcHJvcHMka2V5TGVuZ3RoID0gcHJvcHMua2V5TGVuZ3RoLFxuICAgICAga2V5TGVuZ3RoID0gX3Byb3BzJGtleUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gNiA6IF9wcm9wcyRrZXlMZW5ndGg7XG5cblxuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcigpO1xuXG4gIHZhciBzZXRTdGF0ZSA9IGZ1bmN0aW9uIHNldFN0YXRlKG5leHRTdGF0ZSkge1xuICAgIF9leHRlbmRzKGhpc3RvcnksIG5leHRTdGF0ZSk7XG5cbiAgICBoaXN0b3J5Lmxlbmd0aCA9IGhpc3RvcnkuZW50cmllcy5sZW5ndGg7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5ub3RpZnlMaXN0ZW5lcnMoaGlzdG9yeS5sb2NhdGlvbiwgaGlzdG9yeS5hY3Rpb24pO1xuICB9O1xuXG4gIHZhciBjcmVhdGVLZXkgPSBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBrZXlMZW5ndGgpO1xuICB9O1xuXG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCwgMCwgaW5pdGlhbEVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIHZhciBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHJldHVybiB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnID8gY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgY3JlYXRlS2V5KCkpIDogY3JlYXRlTG9jYXRpb24oZW50cnksIHVuZGVmaW5lZCwgZW50cnkua2V5IHx8IGNyZWF0ZUtleSgpKTtcbiAgfSk7XG5cbiAgLy8gUHVibGljIGludGVyZmFjZVxuXG4gIHZhciBjcmVhdGVIcmVmID0gY3JlYXRlUGF0aDtcblxuICB2YXIgcHVzaCA9IGZ1bmN0aW9uIHB1c2gocGF0aCwgc3RhdGUpIHtcbiAgICB3YXJuaW5nKCEoKHR5cGVvZiBwYXRoID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihwYXRoKSkgPT09ICdvYmplY3QnICYmIHBhdGguc3RhdGUgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSAhPT0gdW5kZWZpbmVkKSwgJ1lvdSBzaG91bGQgYXZvaWQgcHJvdmlkaW5nIGEgMm5kIHN0YXRlIGFyZ3VtZW50IHRvIHB1c2ggd2hlbiB0aGUgMXN0ICcgKyAnYXJndW1lbnQgaXMgYSBsb2NhdGlvbi1saWtlIG9iamVjdCB0aGF0IGFscmVhZHkgaGFzIHN0YXRlOyBpdCBpcyBpZ25vcmVkJyk7XG5cbiAgICB2YXIgYWN0aW9uID0gJ1BVU0gnO1xuICAgIHZhciBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKHBhdGgsIHN0YXRlLCBjcmVhdGVLZXkoKSwgaGlzdG9yeS5sb2NhdGlvbik7XG5cbiAgICB0cmFuc2l0aW9uTWFuYWdlci5jb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGZ1bmN0aW9uIChvaykge1xuICAgICAgaWYgKCFvaykgcmV0dXJuO1xuXG4gICAgICB2YXIgcHJldkluZGV4ID0gaGlzdG9yeS5pbmRleDtcbiAgICAgIHZhciBuZXh0SW5kZXggPSBwcmV2SW5kZXggKyAxO1xuXG4gICAgICB2YXIgbmV4dEVudHJpZXMgPSBoaXN0b3J5LmVudHJpZXMuc2xpY2UoMCk7XG4gICAgICBpZiAobmV4dEVudHJpZXMubGVuZ3RoID4gbmV4dEluZGV4KSB7XG4gICAgICAgIG5leHRFbnRyaWVzLnNwbGljZShuZXh0SW5kZXgsIG5leHRFbnRyaWVzLmxlbmd0aCAtIG5leHRJbmRleCwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEVudHJpZXMucHVzaChsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgaW5kZXg6IG5leHRJbmRleCxcbiAgICAgICAgZW50cmllczogbmV4dEVudHJpZXNcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciByZXBsYWNlID0gZnVuY3Rpb24gcmVwbGFjZShwYXRoLCBzdGF0ZSkge1xuICAgIHdhcm5pbmcoISgodHlwZW9mIHBhdGggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdGgpKSA9PT0gJ29iamVjdCcgJiYgcGF0aC5zdGF0ZSAhPT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSB1bmRlZmluZWQpLCAnWW91IHNob3VsZCBhdm9pZCBwcm92aWRpbmcgYSAybmQgc3RhdGUgYXJndW1lbnQgdG8gcmVwbGFjZSB3aGVuIHRoZSAxc3QgJyArICdhcmd1bWVudCBpcyBhIGxvY2F0aW9uLWxpa2Ugb2JqZWN0IHRoYXQgYWxyZWFkeSBoYXMgc3RhdGU7IGl0IGlzIGlnbm9yZWQnKTtcblxuICAgIHZhciBhY3Rpb24gPSAnUkVQTEFDRSc7XG4gICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24ocGF0aCwgc3RhdGUsIGNyZWF0ZUtleSgpLCBoaXN0b3J5LmxvY2F0aW9uKTtcblxuICAgIHRyYW5zaXRpb25NYW5hZ2VyLmNvbmZpcm1UcmFuc2l0aW9uVG8obG9jYXRpb24sIGFjdGlvbiwgZ2V0VXNlckNvbmZpcm1hdGlvbiwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICBpZiAoIW9rKSByZXR1cm47XG5cbiAgICAgIGhpc3RvcnkuZW50cmllc1toaXN0b3J5LmluZGV4XSA9IGxvY2F0aW9uO1xuXG4gICAgICBzZXRTdGF0ZSh7IGFjdGlvbjogYWN0aW9uLCBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24gZ28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChoaXN0b3J5LmluZGV4ICsgbiwgMCwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aCAtIDEpO1xuXG4gICAgdmFyIGFjdGlvbiA9ICdQT1AnO1xuICAgIHZhciBsb2NhdGlvbiA9IGhpc3RvcnkuZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuY29uZmlybVRyYW5zaXRpb25Ubyhsb2NhdGlvbiwgYWN0aW9uLCBnZXRVc2VyQ29uZmlybWF0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChvaykge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgIGluZGV4OiBuZXh0SW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNaW1pYyB0aGUgYmVoYXZpb3Igb2YgRE9NIGhpc3RvcmllcyBieVxuICAgICAgICAvLyBjYXVzaW5nIGEgcmVuZGVyIGFmdGVyIGEgY2FuY2VsbGVkIFBPUC5cbiAgICAgICAgc2V0U3RhdGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZ29CYWNrID0gZnVuY3Rpb24gZ29CYWNrKCkge1xuICAgIHJldHVybiBnbygtMSk7XG4gIH07XG5cbiAgdmFyIGdvRm9yd2FyZCA9IGZ1bmN0aW9uIGdvRm9yd2FyZCgpIHtcbiAgICByZXR1cm4gZ28oMSk7XG4gIH07XG5cbiAgdmFyIGNhbkdvID0gZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBuZXh0SW5kZXggPSBoaXN0b3J5LmluZGV4ICsgbjtcbiAgICByZXR1cm4gbmV4dEluZGV4ID49IDAgJiYgbmV4dEluZGV4IDwgaGlzdG9yeS5lbnRyaWVzLmxlbmd0aDtcbiAgfTtcblxuICB2YXIgYmxvY2sgPSBmdW5jdGlvbiBibG9jaygpIHtcbiAgICB2YXIgcHJvbXB0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuc2V0UHJvbXB0KHByb21wdCk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgIHJldHVybiB0cmFuc2l0aW9uTWFuYWdlci5hcHBlbmRMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIH07XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgbGVuZ3RoOiBlbnRyaWVzLmxlbmd0aCxcbiAgICBhY3Rpb246ICdQT1AnLFxuICAgIGxvY2F0aW9uOiBlbnRyaWVzW2luZGV4XSxcbiAgICBpbmRleDogaW5kZXgsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY2FuR286IGNhbkdvLFxuICAgIGJsb2NrOiBibG9jayxcbiAgICBsaXN0ZW46IGxpc3RlblxuICB9O1xuXG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTWVtb3J5SGlzdG9yeTsiLCJpbXBvcnQgd2FybmluZyBmcm9tICd3YXJuaW5nJztcblxudmFyIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIoKSB7XG4gIHZhciBwcm9tcHQgPSBudWxsO1xuXG4gIHZhciBzZXRQcm9tcHQgPSBmdW5jdGlvbiBzZXRQcm9tcHQobmV4dFByb21wdCkge1xuICAgIHdhcm5pbmcocHJvbXB0ID09IG51bGwsICdBIGhpc3Rvcnkgc3VwcG9ydHMgb25seSBvbmUgcHJvbXB0IGF0IGEgdGltZScpO1xuXG4gICAgcHJvbXB0ID0gbmV4dFByb21wdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocHJvbXB0ID09PSBuZXh0UHJvbXB0KSBwcm9tcHQgPSBudWxsO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNvbmZpcm1UcmFuc2l0aW9uVG8gPSBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBhY3Rpb24sIGdldFVzZXJDb25maXJtYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogSWYgYW5vdGhlciB0cmFuc2l0aW9uIHN0YXJ0cyB3aGlsZSB3ZSdyZSBzdGlsbCBjb25maXJtaW5nXG4gICAgLy8gdGhlIHByZXZpb3VzIG9uZSwgd2UgbWF5IGVuZCB1cCBpbiBhIHdlaXJkIHN0YXRlLiBGaWd1cmUgb3V0IHRoZVxuICAgIC8vIGJlc3Qgd2F5IHRvIGhhbmRsZSB0aGlzLlxuICAgIGlmIChwcm9tcHQgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHR5cGVvZiBwcm9tcHQgPT09ICdmdW5jdGlvbicgPyBwcm9tcHQobG9jYXRpb24sIGFjdGlvbikgOiBwcm9tcHQ7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGdldFVzZXJDb25maXJtYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBnZXRVc2VyQ29uZmlybWF0aW9uKHJlc3VsdCwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGhpc3RvcnkgbmVlZHMgYSBnZXRVc2VyQ29uZmlybWF0aW9uIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHVzZSBhIHByb21wdCBtZXNzYWdlJyk7XG5cbiAgICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGZhbHNlIGZyb20gYSB0cmFuc2l0aW9uIGhvb2sgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLlxuICAgICAgICBjYWxsYmFjayhyZXN1bHQgIT09IGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICB2YXIgYXBwZW5kTGlzdGVuZXIgPSBmdW5jdGlvbiBhcHBlbmRMaXN0ZW5lcihmbikge1xuICAgIHZhciBpc0FjdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmIChpc0FjdGl2ZSkgZm4uYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gIT09IGxpc3RlbmVyO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgbm90aWZ5TGlzdGVuZXJzID0gZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBzZXRQcm9tcHQ6IHNldFByb21wdCxcbiAgICBjb25maXJtVHJhbnNpdGlvblRvOiBjb25maXJtVHJhbnNpdGlvblRvLFxuICAgIGFwcGVuZExpc3RlbmVyOiBhcHBlbmRMaXN0ZW5lcixcbiAgICBub3RpZnlMaXN0ZW5lcnM6IG5vdGlmeUxpc3RlbmVyc1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXI7IiwiaW1wb3J0IF9jcmVhdGVCcm93c2VySGlzdG9yeSBmcm9tICcuL2NyZWF0ZUJyb3dzZXJIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVCcm93c2VySGlzdG9yeSBhcyBjcmVhdGVCcm93c2VySGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVIYXNoSGlzdG9yeSBmcm9tICcuL2NyZWF0ZUhhc2hIaXN0b3J5JztcbmV4cG9ydCB7IF9jcmVhdGVIYXNoSGlzdG9yeSBhcyBjcmVhdGVIYXNoSGlzdG9yeSB9O1xuaW1wb3J0IF9jcmVhdGVNZW1vcnlIaXN0b3J5IGZyb20gJy4vY3JlYXRlTWVtb3J5SGlzdG9yeSc7XG5leHBvcnQgeyBfY3JlYXRlTWVtb3J5SGlzdG9yeSBhcyBjcmVhdGVNZW1vcnlIaXN0b3J5IH07XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2F0aW9uLCBsb2NhdGlvbnNBcmVFcXVhbCB9IGZyb20gJy4vTG9jYXRpb25VdGlscyc7XG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGggfSBmcm9tICcuL1BhdGhVdGlscyc7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgY29udGV4dFR5cGU6IHRydWUsXG4gIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgbWl4aW5zOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgS05PV05fU1RBVElDUyA9IHtcbiAgbmFtZTogdHJ1ZSxcbiAgbGVuZ3RoOiB0cnVlLFxuICBwcm90b3R5cGU6IHRydWUsXG4gIGNhbGxlcjogdHJ1ZSxcbiAgY2FsbGVlOiB0cnVlLFxuICBhcmd1bWVudHM6IHRydWUsXG4gIGFyaXR5OiB0cnVlXG59O1xudmFyIEZPUldBUkRfUkVGX1NUQVRJQ1MgPSB7XG4gICckJHR5cGVvZic6IHRydWUsXG4gIHJlbmRlcjogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlXG59O1xudmFyIE1FTU9fU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgY29tcGFyZTogdHJ1ZSxcbiAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICBkaXNwbGF5TmFtZTogdHJ1ZSxcbiAgcHJvcFR5cGVzOiB0cnVlLFxuICB0eXBlOiB0cnVlXG59O1xudmFyIFRZUEVfU1RBVElDUyA9IHt9O1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuRm9yd2FyZFJlZl0gPSBGT1JXQVJEX1JFRl9TVEFUSUNTO1xuVFlQRV9TVEFUSUNTW3JlYWN0SXMuTWVtb10gPSBNRU1PX1NUQVRJQ1M7XG5cbmZ1bmN0aW9uIGdldFN0YXRpY3MoY29tcG9uZW50KSB7XG4gIC8vIFJlYWN0IHYxNi4xMSBhbmQgYmVsb3dcbiAgaWYgKHJlYWN0SXMuaXNNZW1vKGNvbXBvbmVudCkpIHtcbiAgICByZXR1cm4gTUVNT19TVEFUSUNTO1xuICB9IC8vIFJlYWN0IHYxNi4xMiBhbmQgYWJvdmVcblxuXG4gIHJldHVybiBUWVBFX1NUQVRJQ1NbY29tcG9uZW50WyckJHR5cGVvZiddXSB8fCBSRUFDVF9TVEFUSUNTO1xufVxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBvYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICBpZiAodHlwZW9mIHNvdXJjZUNvbXBvbmVudCAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgICBpZiAoaW5oZXJpdGVkQ29tcG9uZW50ICYmIGluaGVyaXRlZENvbXBvbmVudCAhPT0gb2JqZWN0UHJvdG90eXBlKSB7XG4gICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICB9XG5cbiAgICB2YXIgdGFyZ2V0U3RhdGljcyA9IGdldFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50KTtcbiAgICB2YXIgc291cmNlU3RhdGljcyA9IGdldFN0YXRpY3Moc291cmNlQ29tcG9uZW50KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghS05PV05fU1RBVElDU1trZXldICYmICEoYmxhY2tsaXN0ICYmIGJsYWNrbGlzdFtrZXldKSAmJiAhKHNvdXJjZVN0YXRpY3MgJiYgc291cmNlU3RhdGljc1trZXldKSAmJiAhKHRhcmdldFN0YXRpY3MgJiYgdGFyZ2V0U3RhdGljc1trZXldKSkge1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBdm9pZCBmYWlsdXJlcyBmcm9tIHJlYWQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0Q29tcG9uZW50LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaG9pc3ROb25SZWFjdFN0YXRpY3M7XG4iLCJjb25zdCBlcnJvcnMgPSB7XG5cdDA6IFwiSWxsZWdhbCBzdGF0ZVwiLFxuXHQxOiBcIkltbWVyIGRyYWZ0cyBjYW5ub3QgaGF2ZSBjb21wdXRlZCBwcm9wZXJ0aWVzXCIsXG5cdDI6IFwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIixcblx0MyhkYXRhOiBhbnkpIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0XCJDYW5ub3QgdXNlIGEgcHJveHkgdGhhdCBoYXMgYmVlbiByZXZva2VkLiBEaWQgeW91IHBhc3MgYW4gb2JqZWN0IGZyb20gaW5zaWRlIGFuIGltbWVyIGZ1bmN0aW9uIHRvIGFuIGFzeW5jIHByb2Nlc3M/IFwiICtcblx0XHRcdGRhdGFcblx0XHQpXG5cdH0sXG5cdDQ6IFwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIixcblx0NTogXCJJbW1lciBmb3JiaWRzIGNpcmN1bGFyIHJlZmVyZW5jZXNcIixcblx0NjogXCJUaGUgZmlyc3Qgb3Igc2Vjb25kIGFyZ3VtZW50IHRvIGBwcm9kdWNlYCBtdXN0IGJlIGEgZnVuY3Rpb25cIixcblx0NzogXCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIixcblx0ODogXCJGaXJzdCBhcmd1bWVudCB0byBgY3JlYXRlRHJhZnRgIG11c3QgYmUgYSBwbGFpbiBvYmplY3QsIGFuIGFycmF5LCBvciBhbiBpbW1lcmFibGUgb2JqZWN0XCIsXG5cdDk6IFwiRmlyc3QgYXJndW1lbnQgdG8gYGZpbmlzaERyYWZ0YCBtdXN0IGJlIGEgZHJhZnQgcmV0dXJuZWQgYnkgYGNyZWF0ZURyYWZ0YFwiLFxuXHQxMDogXCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIixcblx0MTE6IFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTI6IFwiT2JqZWN0LnNldFByb3RvdHlwZU9mKCkgY2Fubm90IGJlIHVzZWQgb24gYW4gSW1tZXIgZHJhZnRcIixcblx0MTM6IFwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsXG5cdDE0OiBcIkltbWVyIG9ubHkgc3VwcG9ydHMgc2V0dGluZyBhcnJheSBpbmRpY2VzIGFuZCB0aGUgJ2xlbmd0aCcgcHJvcGVydHlcIixcblx0MTUocGF0aDogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIFwiQ2Fubm90IGFwcGx5IHBhdGNoLCBwYXRoIGRvZXNuJ3QgcmVzb2x2ZTogXCIgKyBwYXRoXG5cdH0sXG5cdDE2OiAnU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsXG5cdDE3KG9wOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiICsgb3Bcblx0fSxcblx0MTgocGx1Z2luOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYFRoZSBwbHVnaW4gZm9yICcke3BsdWdpbn0nIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBcXGBlbmFibGUke3BsdWdpbn0oKVxcYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLmBcblx0fSxcblx0MTk6IFwicGx1Z2luIG5vdCBsb2FkZWRcIixcblx0MjA6IFwiQ2Fubm90IHVzZSBwcm94aWVzIGlmIFByb3h5LCBQcm94eS5yZXZvY2FibGUgb3IgUmVmbGVjdCBhcmUgbm90IGF2YWlsYWJsZVwiLFxuXHQyMSh0aGluZzogc3RyaW5nKSB7XG5cdFx0cmV0dXJuIGBwcm9kdWNlIGNhbiBvbmx5IGJlIGNhbGxlZCBvbiB0aGluZ3MgdGhhdCBhcmUgZHJhZnRhYmxlOiBwbGFpbiBvYmplY3RzLCBhcnJheXMsIE1hcCwgU2V0IG9yIGNsYXNzZXMgdGhhdCBhcmUgbWFya2VkIHdpdGggJ1tpbW1lcmFibGVdOiB0cnVlJy4gR290ICcke3RoaW5nfSdgXG5cdH0sXG5cdDIyKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdjdXJyZW50JyBleHBlY3RzIGEgZHJhZnQsIGdvdDogJHt0aGluZ31gXG5cdH0sXG5cdDIzKHRoaW5nOiBzdHJpbmcpIHtcblx0XHRyZXR1cm4gYCdvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6ICR7dGhpbmd9YFxuXHR9XG59IGFzIGNvbnN0XG5cbmV4cG9ydCBmdW5jdGlvbiBkaWUoZXJyb3I6IGtleW9mIHR5cGVvZiBlcnJvcnMsIC4uLmFyZ3M6IGFueVtdKTogbmV2ZXIge1xuXHRpZiAoX19ERVZfXykge1xuXHRcdGNvbnN0IGUgPSBlcnJvcnNbZXJyb3JdXG5cdFx0Y29uc3QgbXNnID0gIWVcblx0XHRcdD8gXCJ1bmtub3duIGVycm9yIG5yOiBcIiArIGVycm9yXG5cdFx0XHQ6IHR5cGVvZiBlID09PSBcImZ1bmN0aW9uXCJcblx0XHRcdD8gZS5hcHBseShudWxsLCBhcmdzIGFzIGFueSlcblx0XHRcdDogZVxuXHRcdHRocm93IG5ldyBFcnJvcihgW0ltbWVyXSAke21zZ31gKVxuXHR9XG5cdHRocm93IG5ldyBFcnJvcihcblx0XHRgW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogJHtlcnJvcn0ke1xuXHRcdFx0YXJncy5sZW5ndGggPyBcIiBcIiArIGFyZ3Muam9pbihcIixcIikgOiBcIlwiXG5cdFx0fS4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZmBcblx0KVxufVxuIiwiaW1wb3J0IHtcblx0RFJBRlRfU1RBVEUsXG5cdERSQUZUQUJMRSxcblx0aGFzU2V0LFxuXHRPYmplY3Rpc2gsXG5cdERyYWZ0ZWQsXG5cdEFueU9iamVjdCxcblx0QW55TWFwLFxuXHRBbnlTZXQsXG5cdEltbWVyU3RhdGUsXG5cdGhhc01hcCxcblx0QXJjaHR5cGVPYmplY3QsXG5cdEFyY2h0eXBlQXJyYXksXG5cdEFyY2h0eXBlTWFwLFxuXHRBcmNodHlwZVNldCxcblx0ZGllXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIEltbWVyIGRyYWZ0ICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNEcmFmdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cdHJldHVybiAhIXZhbHVlICYmICEhdmFsdWVbRFJBRlRfU1RBVEVdXG59XG5cbi8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHZhbHVlIGNhbiBiZSBkcmFmdGVkIGJ5IEltbWVyICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNEcmFmdGFibGUodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlKSByZXR1cm4gZmFsc2Vcblx0cmV0dXJuIChcblx0XHRpc1BsYWluT2JqZWN0KHZhbHVlKSB8fFxuXHRcdEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG5cdFx0ISF2YWx1ZVtEUkFGVEFCTEVdIHx8XG5cdFx0ISF2YWx1ZS5jb25zdHJ1Y3RvcltEUkFGVEFCTEVdIHx8XG5cdFx0aXNNYXAodmFsdWUpIHx8XG5cdFx0aXNTZXQodmFsdWUpXG5cdClcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlXG5cdGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKVxuXHRyZXR1cm4gIXByb3RvIHx8IHByb3RvID09PSBPYmplY3QucHJvdG90eXBlXG59XG5cbi8qKiBHZXQgdGhlIHVuZGVybHlpbmcgb2JqZWN0IHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIGRyYWZ0ICovXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gb3JpZ2luYWw8VD4odmFsdWU6IFQpOiBUIHwgdW5kZWZpbmVkXG5leHBvcnQgZnVuY3Rpb24gb3JpZ2luYWwodmFsdWU6IERyYWZ0ZWQ8YW55Pik6IGFueSB7XG5cdGlmICghaXNEcmFmdCh2YWx1ZSkpIGRpZSgyMywgdmFsdWUpXG5cdHJldHVybiB2YWx1ZVtEUkFGVF9TVEFURV0uYmFzZV9cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGNvbnN0IG93bktleXM6ICh0YXJnZXQ6IEFueU9iamVjdCkgPT4gUHJvcGVydHlLZXlbXSA9XG5cdHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3Qub3duS2V5c1xuXHRcdD8gUmVmbGVjdC5vd25LZXlzXG5cdFx0OiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAhPT0gXCJ1bmRlZmluZWRcIlxuXHRcdD8gb2JqID0+XG5cdFx0XHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuY29uY2F0KFxuXHRcdFx0XHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSBhcyBhbnlcblx0XHRcdFx0KVxuXHRcdDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcblxuZXhwb3J0IGNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPVxuXHRPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuXHRmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRhcmdldDogYW55KSB7XG5cdFx0Ly8gUG9seWZpbGwgbmVlZGVkIGZvciBIZXJtZXMgYW5kIElFLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2hlcm1lcy9pc3N1ZXMvMjc0XG5cdFx0Y29uc3QgcmVzOiBhbnkgPSB7fVxuXHRcdG93bktleXModGFyZ2V0KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0XHRyZXNba2V5XSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpXG5cdFx0fSlcblx0XHRyZXR1cm4gcmVzXG5cdH1cblxuZXhwb3J0IGZ1bmN0aW9uIGVhY2g8VCBleHRlbmRzIE9iamVjdGlzaD4oXG5cdG9iajogVCxcblx0aXRlcjogKGtleTogc3RyaW5nIHwgbnVtYmVyLCB2YWx1ZTogYW55LCBzb3VyY2U6IFQpID0+IHZvaWQsXG5cdGVudW1lcmFibGVPbmx5PzogYm9vbGVhblxuKTogdm9pZFxuZXhwb3J0IGZ1bmN0aW9uIGVhY2gob2JqOiBhbnksIGl0ZXI6IGFueSwgZW51bWVyYWJsZU9ubHkgPSBmYWxzZSkge1xuXHRpZiAoZ2V0QXJjaHR5cGUob2JqKSA9PT0gQXJjaHR5cGVPYmplY3QpIHtcblx0XHQ7KGVudW1lcmFibGVPbmx5ID8gT2JqZWN0LmtleXMgOiBvd25LZXlzKShvYmopLmZvckVhY2goa2V5ID0+IHtcblx0XHRcdGlmICghZW51bWVyYWJsZU9ubHkgfHwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIikgaXRlcihrZXksIG9ialtrZXldLCBvYmopXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHRvYmouZm9yRWFjaCgoZW50cnk6IGFueSwgaW5kZXg6IGFueSkgPT4gaXRlcihpbmRleCwgZW50cnksIG9iaikpXG5cdH1cbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFyY2h0eXBlKHRoaW5nOiBhbnkpOiAwIHwgMSB8IDIgfCAzIHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0Y29uc3Qgc3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUgPSB0aGluZ1tEUkFGVF9TVEFURV1cblx0cmV0dXJuIHN0YXRlXG5cdFx0PyBzdGF0ZS50eXBlXyA+IDNcblx0XHRcdD8gc3RhdGUudHlwZV8gLSA0IC8vIGNhdXNlIE9iamVjdCBhbmQgQXJyYXkgbWFwIGJhY2sgZnJvbSA0IGFuZCA1XG5cdFx0XHQ6IChzdGF0ZS50eXBlXyBhcyBhbnkpIC8vIG90aGVycyBhcmUgdGhlIHNhbWVcblx0XHQ6IEFycmF5LmlzQXJyYXkodGhpbmcpXG5cdFx0PyBBcmNodHlwZUFycmF5XG5cdFx0OiBpc01hcCh0aGluZylcblx0XHQ/IEFyY2h0eXBlTWFwXG5cdFx0OiBpc1NldCh0aGluZylcblx0XHQ/IEFyY2h0eXBlU2V0XG5cdFx0OiBBcmNodHlwZU9iamVjdFxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaGFzKHRoaW5nOiBhbnksIHByb3A6IFByb3BlcnR5S2V5KTogYm9vbGVhbiB7XG5cdHJldHVybiBnZXRBcmNodHlwZSh0aGluZykgPT09IEFyY2h0eXBlTWFwXG5cdFx0PyB0aGluZy5oYXMocHJvcClcblx0XHQ6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGluZywgcHJvcClcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGdldCh0aGluZzogQW55TWFwIHwgQW55T2JqZWN0LCBwcm9wOiBQcm9wZXJ0eUtleSk6IGFueSB7XG5cdC8vIEB0cy1pZ25vcmVcblx0cmV0dXJuIGdldEFyY2h0eXBlKHRoaW5nKSA9PT0gQXJjaHR5cGVNYXAgPyB0aGluZy5nZXQocHJvcCkgOiB0aGluZ1twcm9wXVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gc2V0KHRoaW5nOiBhbnksIHByb3BPck9sZFZhbHVlOiBQcm9wZXJ0eUtleSwgdmFsdWU6IGFueSkge1xuXHRjb25zdCB0ID0gZ2V0QXJjaHR5cGUodGhpbmcpXG5cdGlmICh0ID09PSBBcmNodHlwZU1hcCkgdGhpbmcuc2V0KHByb3BPck9sZFZhbHVlLCB2YWx1ZSlcblx0ZWxzZSBpZiAodCA9PT0gQXJjaHR5cGVTZXQpIHtcblx0XHR0aGluZy5kZWxldGUocHJvcE9yT2xkVmFsdWUpXG5cdFx0dGhpbmcuYWRkKHZhbHVlKVxuXHR9IGVsc2UgdGhpbmdbcHJvcE9yT2xkVmFsdWVdID0gdmFsdWVcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzKHg6IGFueSwgeTogYW55KTogYm9vbGVhbiB7XG5cdC8vIEZyb206IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvYzY5OTA0YTUxMWI5MDAyNjY5MzUxNjgyMjMwNjNkZDg3NzJkZmM0MC9wYWNrYWdlcy9mYmpzL3NyYy9jb3JlL3NoYWxsb3dFcXVhbC5qc1xuXHRpZiAoeCA9PT0geSkge1xuXHRcdHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geVxuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHlcblx0fVxufVxuXG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gaXNNYXAodGFyZ2V0OiBhbnkpOiB0YXJnZXQgaXMgQW55TWFwIHtcblx0cmV0dXJuIGhhc01hcCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBNYXBcbn1cblxuLyojX19QVVJFX18qL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2V0KHRhcmdldDogYW55KTogdGFyZ2V0IGlzIEFueVNldCB7XG5cdHJldHVybiBoYXNTZXQgJiYgdGFyZ2V0IGluc3RhbmNlb2YgU2V0XG59XG4vKiNfX1BVUkVfXyovXG5leHBvcnQgZnVuY3Rpb24gbGF0ZXN0KHN0YXRlOiBJbW1lclN0YXRlKTogYW55IHtcblx0cmV0dXJuIHN0YXRlLmNvcHlfIHx8IHN0YXRlLmJhc2VfXG59XG5cbi8qI19fUFVSRV9fKi9cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93Q29weShiYXNlOiBhbnkpIHtcblx0aWYgKEFycmF5LmlzQXJyYXkoYmFzZSkpIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChiYXNlKVxuXHRjb25zdCBkZXNjcmlwdG9ycyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoYmFzZSlcblx0ZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFIGFzIGFueV1cblx0bGV0IGtleXMgPSBvd25LZXlzKGRlc2NyaXB0b3JzKVxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBrZXk6IGFueSA9IGtleXNbaV1cblx0XHRjb25zdCBkZXNjID0gZGVzY3JpcHRvcnNba2V5XVxuXHRcdGlmIChkZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuXHRcdFx0ZGVzYy53cml0YWJsZSA9IHRydWVcblx0XHRcdGRlc2MuY29uZmlndXJhYmxlID0gdHJ1ZVxuXHRcdH1cblx0XHQvLyBsaWtlIG9iamVjdC5hc3NpZ24sIHdlIHdpbGwgcmVhZCBhbnkgX293bl8sIGdldC9zZXQgYWNjZXNzb3JzLiBUaGlzIGhlbHBzIGluIGRlYWxpbmdcblx0XHQvLyB3aXRoIGxpYnJhcmllcyB0aGF0IHRyYXAgdmFsdWVzLCBsaWtlIG1vYnggb3IgdnVlXG5cdFx0Ly8gdW5saWtlIG9iamVjdC5hc3NpZ24sIG5vbi1lbnVtZXJhYmxlcyB3aWxsIGJlIGNvcGllZCBhcyB3ZWxsXG5cdFx0aWYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KVxuXHRcdFx0ZGVzY3JpcHRvcnNba2V5XSA9IHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSwgLy8gY291bGQgbGl2ZSB3aXRoICEhZGVzYy5zZXQgYXMgd2VsbCBoZXJlLi4uXG5cdFx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdFx0dmFsdWU6IGJhc2Vba2V5XVxuXHRcdFx0fVxuXHR9XG5cdHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlKSwgZGVzY3JpcHRvcnMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmcmVlemUob2JqOiBhbnksIGRlZXA6IGJvb2xlYW4pOiB2b2lkIHtcblx0aWYgKGlzRnJvemVuKG9iaikgfHwgaXNEcmFmdChvYmopIHx8ICFpc0RyYWZ0YWJsZShvYmopKSByZXR1cm5cblx0aWYgKGdldEFyY2h0eXBlKG9iaikgPiAxIC8qIE1hcCBvciBTZXQgKi8pIHtcblx0XHRvYmouc2V0ID0gb2JqLmFkZCA9IG9iai5jbGVhciA9IG9iai5kZWxldGUgPSBkb250TXV0YXRlRnJvemVuQ29sbGVjdGlvbnMgYXMgYW55XG5cdH1cblx0T2JqZWN0LmZyZWV6ZShvYmopXG5cdGlmIChkZWVwKSBlYWNoKG9iaiwgKGtleSwgdmFsdWUpID0+IGZyZWV6ZSh2YWx1ZSwgdHJ1ZSksIHRydWUpXG59XG5cbmZ1bmN0aW9uIGRvbnRNdXRhdGVGcm96ZW5Db2xsZWN0aW9ucygpIHtcblx0ZGllKDIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Zyb3plbihvYmo6IGFueSk6IGJvb2xlYW4ge1xuXHRpZiAob2JqID09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHRydWVcblx0Ly8gU2VlICM2MDAsIElFIGRpZXMgb24gbm9uLW9iamVjdHMgaW4gT2JqZWN0LmlzRnJvemVuXG5cdHJldHVybiBPYmplY3QuaXNGcm96ZW4ob2JqKVxufVxuIiwiaW1wb3J0IHtcblx0U2V0U3RhdGUsXG5cdEltbWVyU2NvcGUsXG5cdFByb3h5T2JqZWN0U3RhdGUsXG5cdFByb3h5QXJyYXlTdGF0ZSxcblx0RVM1T2JqZWN0U3RhdGUsXG5cdEVTNUFycmF5U3RhdGUsXG5cdE1hcFN0YXRlLFxuXHREUkFGVF9TVEFURVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgdHlwZSBPYmplY3Rpc2ggPSBBbnlPYmplY3QgfCBBbnlBcnJheSB8IEFueU1hcCB8IEFueVNldFxuZXhwb3J0IHR5cGUgT2JqZWN0aXNoTm9TZXQgPSBBbnlPYmplY3QgfCBBbnlBcnJheSB8IEFueU1hcFxuXG5leHBvcnQgdHlwZSBBbnlPYmplY3QgPSB7W2tleTogc3RyaW5nXTogYW55fVxuZXhwb3J0IHR5cGUgQW55QXJyYXkgPSBBcnJheTxhbnk+XG5leHBvcnQgdHlwZSBBbnlTZXQgPSBTZXQ8YW55PlxuZXhwb3J0IHR5cGUgQW55TWFwID0gTWFwPGFueSwgYW55PlxuXG5leHBvcnQgY29uc3QgQXJjaHR5cGVPYmplY3QgPSAwXG5leHBvcnQgY29uc3QgQXJjaHR5cGVBcnJheSA9IDFcbmV4cG9ydCBjb25zdCBBcmNodHlwZU1hcCA9IDJcbmV4cG9ydCBjb25zdCBBcmNodHlwZVNldCA9IDNcblxuZXhwb3J0IGNvbnN0IFByb3h5VHlwZVByb3h5T2JqZWN0ID0gMFxuZXhwb3J0IGNvbnN0IFByb3h5VHlwZVByb3h5QXJyYXkgPSAxXG5leHBvcnQgY29uc3QgUHJveHlUeXBlRVM1T2JqZWN0ID0gNFxuZXhwb3J0IGNvbnN0IFByb3h5VHlwZUVTNUFycmF5ID0gNVxuZXhwb3J0IGNvbnN0IFByb3h5VHlwZU1hcCA9IDJcbmV4cG9ydCBjb25zdCBQcm94eVR5cGVTZXQgPSAzXG5cbmV4cG9ydCBpbnRlcmZhY2UgSW1tZXJCYXNlU3RhdGUge1xuXHRwYXJlbnRfPzogSW1tZXJTdGF0ZVxuXHRzY29wZV86IEltbWVyU2NvcGVcblx0bW9kaWZpZWRfOiBib29sZWFuXG5cdGZpbmFsaXplZF86IGJvb2xlYW5cblx0aXNNYW51YWxfOiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEltbWVyU3RhdGUgPVxuXHR8IFByb3h5T2JqZWN0U3RhdGVcblx0fCBQcm94eUFycmF5U3RhdGVcblx0fCBFUzVPYmplY3RTdGF0ZVxuXHR8IEVTNUFycmF5U3RhdGVcblx0fCBNYXBTdGF0ZVxuXHR8IFNldFN0YXRlXG5cbi8vIFRoZSBfaW50ZXJuYWxfIHR5cGUgdXNlZCBmb3IgZHJhZnRzIChub3QgdG8gYmUgY29uZnVzZWQgd2l0aCBEcmFmdCwgd2hpY2ggaXMgcHVibGljIGZhY2luZylcbmV4cG9ydCB0eXBlIERyYWZ0ZWQ8QmFzZSA9IGFueSwgVCBleHRlbmRzIEltbWVyU3RhdGUgPSBJbW1lclN0YXRlPiA9IHtcblx0W0RSQUZUX1NUQVRFXTogVFxufSAmIEJhc2VcbiIsImltcG9ydCB7XG5cdEltbWVyU3RhdGUsXG5cdFBhdGNoLFxuXHRJbW1lclNjb3BlLFxuXHREcmFmdGVkLFxuXHRBbnlPYmplY3QsXG5cdEltbWVyQmFzZVN0YXRlLFxuXHRBbnlNYXAsXG5cdEFueVNldCxcblx0UHJveHlUeXBlRVM1QXJyYXksXG5cdFByb3h5VHlwZUVTNU9iamVjdCxcblx0UHJveHlUeXBlTWFwLFxuXHRQcm94eVR5cGVTZXQsXG5cdGRpZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG4vKiogUGx1Z2luIHV0aWxpdGllcyAqL1xuY29uc3QgcGx1Z2luczoge1xuXHRQYXRjaGVzPzoge1xuXHRcdGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0XHRzdGF0ZTogSW1tZXJTdGF0ZSxcblx0XHRcdGJhc2VQYXRoOiBQYXRjaFBhdGgsXG5cdFx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0XHQpOiB2b2lkXG5cdFx0Z2VuZXJhdGVSZXBsYWNlbWVudFBhdGNoZXNfKFxuXHRcdFx0cm9vdFN0YXRlOiBJbW1lclN0YXRlLFxuXHRcdFx0cmVwbGFjZW1lbnQ6IGFueSxcblx0XHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdCk6IHZvaWRcblx0XHRhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiBQYXRjaFtdKTogVFxuXHR9XG5cdEVTNT86IHtcblx0XHR3aWxsRmluYWxpemVFUzVfKHNjb3BlOiBJbW1lclNjb3BlLCByZXN1bHQ6IGFueSwgaXNSZXBsYWNlZDogYm9vbGVhbik6IHZvaWRcblx0XHRjcmVhdGVFUzVQcm94eV88VD4oXG5cdFx0XHRiYXNlOiBULFxuXHRcdFx0cGFyZW50PzogSW1tZXJTdGF0ZVxuXHRcdCk6IERyYWZ0ZWQ8VCwgRVM1T2JqZWN0U3RhdGUgfCBFUzVBcnJheVN0YXRlPlxuXHRcdGhhc0NoYW5nZXNfKHN0YXRlOiBFUzVBcnJheVN0YXRlIHwgRVM1T2JqZWN0U3RhdGUpOiBib29sZWFuXG5cdH1cblx0TWFwU2V0Pzoge1xuXHRcdHByb3h5TWFwXzxUIGV4dGVuZHMgQW55TWFwPih0YXJnZXQ6IFQsIHBhcmVudD86IEltbWVyU3RhdGUpOiBUXG5cdFx0cHJveHlTZXRfPFQgZXh0ZW5kcyBBbnlTZXQ+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFRcblx0fVxufSA9IHt9XG5cbnR5cGUgUGx1Z2lucyA9IHR5cGVvZiBwbHVnaW5zXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQbHVnaW48SyBleHRlbmRzIGtleW9mIFBsdWdpbnM+KFxuXHRwbHVnaW5LZXk6IEtcbik6IEV4Y2x1ZGU8UGx1Z2luc1tLXSwgdW5kZWZpbmVkPiB7XG5cdGNvbnN0IHBsdWdpbiA9IHBsdWdpbnNbcGx1Z2luS2V5XVxuXHRpZiAoIXBsdWdpbikge1xuXHRcdGRpZShfX0RFVl9fID8gMTggOiAxOSwgcGx1Z2luS2V5KVxuXHR9XG5cdC8vIEB0cy1pZ25vcmVcblx0cmV0dXJuIHBsdWdpblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZFBsdWdpbjxLIGV4dGVuZHMga2V5b2YgUGx1Z2lucz4oXG5cdHBsdWdpbktleTogSyxcblx0aW1wbGVtZW50YXRpb246IFBsdWdpbnNbS11cbik6IHZvaWQge1xuXHRwbHVnaW5zW3BsdWdpbktleV0gPSBpbXBsZW1lbnRhdGlvblxufVxuXG4vKiogRVM1IFBsdWdpbiAqL1xuXG5pbnRlcmZhY2UgRVM1QmFzZVN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHRhc3NpZ25lZF86IHtba2V5OiBzdHJpbmddOiBhbnl9XG5cdHBhcmVudF8/OiBJbW1lclN0YXRlXG5cdHJldm9rZWRfOiBib29sZWFuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRVM1T2JqZWN0U3RhdGUgZXh0ZW5kcyBFUzVCYXNlU3RhdGUge1xuXHR0eXBlXzogdHlwZW9mIFByb3h5VHlwZUVTNU9iamVjdFxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55T2JqZWN0LCBFUzVPYmplY3RTdGF0ZT5cblx0YmFzZV86IEFueU9iamVjdFxuXHRjb3B5XzogQW55T2JqZWN0IHwgbnVsbFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVTNUFycmF5U3RhdGUgZXh0ZW5kcyBFUzVCYXNlU3RhdGUge1xuXHR0eXBlXzogdHlwZW9mIFByb3h5VHlwZUVTNUFycmF5XG5cdGRyYWZ0XzogRHJhZnRlZDxBbnlPYmplY3QsIEVTNUFycmF5U3RhdGU+XG5cdGJhc2VfOiBhbnlcblx0Y29weV86IGFueVxufVxuXG4vKiogTWFwIC8gU2V0IHBsdWdpbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hcFN0YXRlIGV4dGVuZHMgSW1tZXJCYXNlU3RhdGUge1xuXHR0eXBlXzogdHlwZW9mIFByb3h5VHlwZU1hcFxuXHRjb3B5XzogQW55TWFwIHwgdW5kZWZpbmVkXG5cdGFzc2lnbmVkXzogTWFwPGFueSwgYm9vbGVhbj4gfCB1bmRlZmluZWRcblx0YmFzZV86IEFueU1hcFxuXHRyZXZva2VkXzogYm9vbGVhblxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55TWFwLCBNYXBTdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZXRTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0dHlwZV86IHR5cGVvZiBQcm94eVR5cGVTZXRcblx0Y29weV86IEFueVNldCB8IHVuZGVmaW5lZFxuXHRiYXNlXzogQW55U2V0XG5cdGRyYWZ0c186IE1hcDxhbnksIERyYWZ0ZWQ+IC8vIG1hcHMgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIHRoZSBkcmFmdCB2YWx1ZSBpbiB0aGUgbmV3IHNldFxuXHRyZXZva2VkXzogYm9vbGVhblxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55U2V0LCBTZXRTdGF0ZT5cbn1cblxuLyoqIFBhdGNoZXMgcGx1Z2luICovXG5cbmV4cG9ydCB0eXBlIFBhdGNoUGF0aCA9IChzdHJpbmcgfCBudW1iZXIpW11cbiIsImltcG9ydCB7XG5cdFBhdGNoLFxuXHRQYXRjaExpc3RlbmVyLFxuXHREcmFmdGVkLFxuXHRJbW1lcixcblx0RFJBRlRfU1RBVEUsXG5cdEltbWVyU3RhdGUsXG5cdFByb3h5VHlwZVByb3h5T2JqZWN0LFxuXHRQcm94eVR5cGVQcm94eUFycmF5LFxuXHRnZXRQbHVnaW5cbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcbmltcG9ydCB7ZGllfSBmcm9tIFwiLi4vdXRpbHMvZXJyb3JzXCJcblxuLyoqIEVhY2ggc2NvcGUgcmVwcmVzZW50cyBhIGBwcm9kdWNlYCBjYWxsLiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIEltbWVyU2NvcGUge1xuXHRwYXRjaGVzXz86IFBhdGNoW11cblx0aW52ZXJzZVBhdGNoZXNfPzogUGF0Y2hbXVxuXHRjYW5BdXRvRnJlZXplXzogYm9vbGVhblxuXHRkcmFmdHNfOiBhbnlbXVxuXHRwYXJlbnRfPzogSW1tZXJTY29wZVxuXHRwYXRjaExpc3RlbmVyXz86IFBhdGNoTGlzdGVuZXJcblx0aW1tZXJfOiBJbW1lclxuXHR1bmZpbmFsaXplZERyYWZ0c186IG51bWJlclxufVxuXG5sZXQgY3VycmVudFNjb3BlOiBJbW1lclNjb3BlIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoKSB7XG5cdGlmIChfX0RFVl9fICYmICFjdXJyZW50U2NvcGUpIGRpZSgwKVxuXHRyZXR1cm4gY3VycmVudFNjb3BlIVxufVxuXG5mdW5jdGlvbiBjcmVhdGVTY29wZShcblx0cGFyZW50XzogSW1tZXJTY29wZSB8IHVuZGVmaW5lZCxcblx0aW1tZXJfOiBJbW1lclxuKTogSW1tZXJTY29wZSB7XG5cdHJldHVybiB7XG5cdFx0ZHJhZnRzXzogW10sXG5cdFx0cGFyZW50Xyxcblx0XHRpbW1lcl8sXG5cdFx0Ly8gV2hlbmV2ZXIgdGhlIG1vZGlmaWVkIGRyYWZ0IGNvbnRhaW5zIGEgZHJhZnQgZnJvbSBhbm90aGVyIHNjb3BlLCB3ZVxuXHRcdC8vIG5lZWQgdG8gcHJldmVudCBhdXRvLWZyZWV6aW5nIHNvIHRoZSB1bm93bmVkIGRyYWZ0IGNhbiBiZSBmaW5hbGl6ZWQuXG5cdFx0Y2FuQXV0b0ZyZWV6ZV86IHRydWUsXG5cdFx0dW5maW5hbGl6ZWREcmFmdHNfOiAwXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdGNoZXNJblNjb3BlKFxuXHRzY29wZTogSW1tZXJTY29wZSxcblx0cGF0Y2hMaXN0ZW5lcj86IFBhdGNoTGlzdGVuZXJcbikge1xuXHRpZiAocGF0Y2hMaXN0ZW5lcikge1xuXHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikgLy8gYXNzZXJ0IHdlIGhhdmUgdGhlIHBsdWdpblxuXHRcdHNjb3BlLnBhdGNoZXNfID0gW11cblx0XHRzY29wZS5pbnZlcnNlUGF0Y2hlc18gPSBbXVxuXHRcdHNjb3BlLnBhdGNoTGlzdGVuZXJfID0gcGF0Y2hMaXN0ZW5lclxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXZva2VTY29wZShzY29wZTogSW1tZXJTY29wZSkge1xuXHRsZWF2ZVNjb3BlKHNjb3BlKVxuXHRzY29wZS5kcmFmdHNfLmZvckVhY2gocmV2b2tlRHJhZnQpXG5cdC8vIEB0cy1pZ25vcmVcblx0c2NvcGUuZHJhZnRzXyA9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxlYXZlU2NvcGUoc2NvcGU6IEltbWVyU2NvcGUpIHtcblx0aWYgKHNjb3BlID09PSBjdXJyZW50U2NvcGUpIHtcblx0XHRjdXJyZW50U2NvcGUgPSBzY29wZS5wYXJlbnRfXG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVudGVyU2NvcGUoaW1tZXI6IEltbWVyKSB7XG5cdHJldHVybiAoY3VycmVudFNjb3BlID0gY3JlYXRlU2NvcGUoY3VycmVudFNjb3BlLCBpbW1lcikpXG59XG5cbmZ1bmN0aW9uIHJldm9rZURyYWZ0KGRyYWZ0OiBEcmFmdGVkKSB7XG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdXG5cdGlmIChcblx0XHRzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlUHJveHlPYmplY3QgfHxcblx0XHRzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlUHJveHlBcnJheVxuXHQpXG5cdFx0c3RhdGUucmV2b2tlXygpXG5cdGVsc2Ugc3RhdGUucmV2b2tlZF8gPSB0cnVlXG59XG4iLCJpbXBvcnQge1xuXHRJbW1lclNjb3BlLFxuXHREUkFGVF9TVEFURSxcblx0aXNEcmFmdGFibGUsXG5cdE5PVEhJTkcsXG5cdFBhdGNoUGF0aCxcblx0ZWFjaCxcblx0aGFzLFxuXHRmcmVlemUsXG5cdEltbWVyU3RhdGUsXG5cdGlzRHJhZnQsXG5cdFNldFN0YXRlLFxuXHRzZXQsXG5cdFByb3h5VHlwZUVTNU9iamVjdCxcblx0UHJveHlUeXBlRVM1QXJyYXksXG5cdFByb3h5VHlwZVNldCxcblx0Z2V0UGx1Z2luLFxuXHRkaWUsXG5cdHJldm9rZVNjb3BlLFxuXHRpc0Zyb3plbixcblx0c2hhbGxvd0NvcHlcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHQocmVzdWx0OiBhbnksIHNjb3BlOiBJbW1lclNjb3BlKSB7XG5cdHNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA9IHNjb3BlLmRyYWZ0c18ubGVuZ3RoXG5cdGNvbnN0IGJhc2VEcmFmdCA9IHNjb3BlLmRyYWZ0c18hWzBdXG5cdGNvbnN0IGlzUmVwbGFjZWQgPSByZXN1bHQgIT09IHVuZGVmaW5lZCAmJiByZXN1bHQgIT09IGJhc2VEcmFmdFxuXHRpZiAoIXNjb3BlLmltbWVyXy51c2VQcm94aWVzXylcblx0XHRnZXRQbHVnaW4oXCJFUzVcIikud2lsbEZpbmFsaXplRVM1XyhzY29wZSwgcmVzdWx0LCBpc1JlcGxhY2VkKVxuXHRpZiAoaXNSZXBsYWNlZCkge1xuXHRcdGlmIChiYXNlRHJhZnRbRFJBRlRfU1RBVEVdLm1vZGlmaWVkXykge1xuXHRcdFx0cmV2b2tlU2NvcGUoc2NvcGUpXG5cdFx0XHRkaWUoNClcblx0XHR9XG5cdFx0aWYgKGlzRHJhZnRhYmxlKHJlc3VsdCkpIHtcblx0XHRcdC8vIEZpbmFsaXplIHRoZSByZXN1bHQgaW4gY2FzZSBpdCBjb250YWlucyAob3IgaXMpIGEgc3Vic2V0IG9mIHRoZSBkcmFmdC5cblx0XHRcdHJlc3VsdCA9IGZpbmFsaXplKHNjb3BlLCByZXN1bHQpXG5cdFx0XHRpZiAoIXNjb3BlLnBhcmVudF8pIG1heWJlRnJlZXplKHNjb3BlLCByZXN1bHQpXG5cdFx0fVxuXHRcdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdFx0Z2V0UGx1Z2luKFwiUGF0Y2hlc1wiKS5nZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG5cdFx0XHRcdGJhc2VEcmFmdFtEUkFGVF9TVEFURV0sXG5cdFx0XHRcdHJlc3VsdCxcblx0XHRcdFx0c2NvcGUucGF0Y2hlc18sXG5cdFx0XHRcdHNjb3BlLmludmVyc2VQYXRjaGVzXyFcblx0XHRcdClcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gRmluYWxpemUgdGhlIGJhc2UgZHJhZnQuXG5cdFx0cmVzdWx0ID0gZmluYWxpemUoc2NvcGUsIGJhc2VEcmFmdCwgW10pXG5cdH1cblx0cmV2b2tlU2NvcGUoc2NvcGUpXG5cdGlmIChzY29wZS5wYXRjaGVzXykge1xuXHRcdHNjb3BlLnBhdGNoTGlzdGVuZXJfIShzY29wZS5wYXRjaGVzXywgc2NvcGUuaW52ZXJzZVBhdGNoZXNfISlcblx0fVxuXHRyZXR1cm4gcmVzdWx0ICE9PSBOT1RISU5HID8gcmVzdWx0IDogdW5kZWZpbmVkXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplKHJvb3RTY29wZTogSW1tZXJTY29wZSwgdmFsdWU6IGFueSwgcGF0aD86IFBhdGNoUGF0aCkge1xuXHQvLyBEb24ndCByZWN1cnNlIGluIHRobyByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmVzXG5cdGlmIChpc0Zyb3plbih2YWx1ZSkpIHJldHVybiB2YWx1ZVxuXG5cdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gdmFsdWVbRFJBRlRfU1RBVEVdXG5cdC8vIEEgcGxhaW4gb2JqZWN0LCBtaWdodCBuZWVkIGZyZWV6aW5nLCBtaWdodCBjb250YWluIGRyYWZ0c1xuXHRpZiAoIXN0YXRlKSB7XG5cdFx0ZWFjaChcblx0XHRcdHZhbHVlLFxuXHRcdFx0KGtleSwgY2hpbGRWYWx1ZSkgPT5cblx0XHRcdFx0ZmluYWxpemVQcm9wZXJ0eShyb290U2NvcGUsIHN0YXRlLCB2YWx1ZSwga2V5LCBjaGlsZFZhbHVlLCBwYXRoKSxcblx0XHRcdHRydWUgLy8gU2VlICM1OTAsIGRvbid0IHJlY3Vyc2UgaW50byBub24tZW51bWFyYWJsZSBvZiBub24gZHJhZnRlZCBvYmplY3RzXG5cdFx0KVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9XG5cdC8vIE5ldmVyIGZpbmFsaXplIGRyYWZ0cyBvd25lZCBieSBhbm90aGVyIHNjb3BlLlxuXHRpZiAoc3RhdGUuc2NvcGVfICE9PSByb290U2NvcGUpIHJldHVybiB2YWx1ZVxuXHQvLyBVbm1vZGlmaWVkIGRyYWZ0LCByZXR1cm4gdGhlIChmcm96ZW4pIG9yaWdpbmFsXG5cdGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG5cdFx0bWF5YmVGcmVlemUocm9vdFNjb3BlLCBzdGF0ZS5iYXNlXywgdHJ1ZSlcblx0XHRyZXR1cm4gc3RhdGUuYmFzZV9cblx0fVxuXHQvLyBOb3QgZmluYWxpemVkIHlldCwgbGV0J3MgZG8gdGhhdCBub3dcblx0aWYgKCFzdGF0ZS5maW5hbGl6ZWRfKSB7XG5cdFx0c3RhdGUuZmluYWxpemVkXyA9IHRydWVcblx0XHRzdGF0ZS5zY29wZV8udW5maW5hbGl6ZWREcmFmdHNfLS1cblx0XHRjb25zdCByZXN1bHQgPVxuXHRcdFx0Ly8gRm9yIEVTNSwgY3JlYXRlIGEgZ29vZCBjb3B5IGZyb20gdGhlIGRyYWZ0IGZpcnN0LCB3aXRoIGFkZGVkIGtleXMgYW5kIHdpdGhvdXQgZGVsZXRlZCBrZXlzLlxuXHRcdFx0c3RhdGUudHlwZV8gPT09IFByb3h5VHlwZUVTNU9iamVjdCB8fCBzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlRVM1QXJyYXlcblx0XHRcdFx0PyAoc3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5kcmFmdF8pKVxuXHRcdFx0XHQ6IHN0YXRlLmNvcHlfXG5cdFx0Ly8gRmluYWxpemUgYWxsIGNoaWxkcmVuIG9mIHRoZSBjb3B5XG5cdFx0Ly8gRm9yIHNldHMgd2UgY2xvbmUgYmVmb3JlIGl0ZXJhdGluZywgb3RoZXJ3aXNlIHdlIGNhbiBnZXQgaW4gZW5kbGVzcyBsb29wIGR1ZSB0byBtb2RpZnlpbmcgZHVyaW5nIGl0ZXJhdGlvbiwgc2VlICM2Mjhcblx0XHQvLyBBbHRob3VnaCB0aGUgb3JpZ2luYWwgdGVzdCBjYXNlIGRvZXNuJ3Qgc2VlbSB2YWxpZCBhbnl3YXksIHNvIGlmIHRoaXMgaW4gdGhlIHdheSB3ZSBjYW4gdHVybiB0aGUgbmV4dCBsaW5lXG5cdFx0Ly8gYmFjayB0byBlYWNoKHJlc3VsdCwgLi4uLilcblx0XHRlYWNoKFxuXHRcdFx0c3RhdGUudHlwZV8gPT09IFByb3h5VHlwZVNldCA/IG5ldyBTZXQocmVzdWx0KSA6IHJlc3VsdCxcblx0XHRcdChrZXksIGNoaWxkVmFsdWUpID0+XG5cdFx0XHRcdGZpbmFsaXplUHJvcGVydHkocm9vdFNjb3BlLCBzdGF0ZSwgcmVzdWx0LCBrZXksIGNoaWxkVmFsdWUsIHBhdGgpXG5cdFx0KVxuXHRcdC8vIGV2ZXJ5dGhpbmcgaW5zaWRlIGlzIGZyb3plbiwgd2UgY2FuIGZyZWV6ZSBoZXJlXG5cdFx0bWF5YmVGcmVlemUocm9vdFNjb3BlLCByZXN1bHQsIGZhbHNlKVxuXHRcdC8vIGZpcnN0IHRpbWUgZmluYWxpemluZywgbGV0J3MgY3JlYXRlIHRob3NlIHBhdGNoZXNcblx0XHRpZiAocGF0aCAmJiByb290U2NvcGUucGF0Y2hlc18pIHtcblx0XHRcdGdldFBsdWdpbihcIlBhdGNoZXNcIikuZ2VuZXJhdGVQYXRjaGVzXyhcblx0XHRcdFx0c3RhdGUsXG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdHJvb3RTY29wZS5wYXRjaGVzXyxcblx0XHRcdFx0cm9vdFNjb3BlLmludmVyc2VQYXRjaGVzXyFcblx0XHRcdClcblx0XHR9XG5cdH1cblx0cmV0dXJuIHN0YXRlLmNvcHlfXG59XG5cbmZ1bmN0aW9uIGZpbmFsaXplUHJvcGVydHkoXG5cdHJvb3RTY29wZTogSW1tZXJTY29wZSxcblx0cGFyZW50U3RhdGU6IHVuZGVmaW5lZCB8IEltbWVyU3RhdGUsXG5cdHRhcmdldE9iamVjdDogYW55LFxuXHRwcm9wOiBzdHJpbmcgfCBudW1iZXIsXG5cdGNoaWxkVmFsdWU6IGFueSxcblx0cm9vdFBhdGg/OiBQYXRjaFBhdGhcbikge1xuXHRpZiAoX19ERVZfXyAmJiBjaGlsZFZhbHVlID09PSB0YXJnZXRPYmplY3QpIGRpZSg1KVxuXHRpZiAoaXNEcmFmdChjaGlsZFZhbHVlKSkge1xuXHRcdGNvbnN0IHBhdGggPVxuXHRcdFx0cm9vdFBhdGggJiZcblx0XHRcdHBhcmVudFN0YXRlICYmXG5cdFx0XHRwYXJlbnRTdGF0ZSEudHlwZV8gIT09IFByb3h5VHlwZVNldCAmJiAvLyBTZXQgb2JqZWN0cyBhcmUgYXRvbWljIHNpbmNlIHRoZXkgaGF2ZSBubyBrZXlzLlxuXHRcdFx0IWhhcygocGFyZW50U3RhdGUgYXMgRXhjbHVkZTxJbW1lclN0YXRlLCBTZXRTdGF0ZT4pLmFzc2lnbmVkXyEsIHByb3ApIC8vIFNraXAgZGVlcCBwYXRjaGVzIGZvciBhc3NpZ25lZCBrZXlzLlxuXHRcdFx0XHQ/IHJvb3RQYXRoIS5jb25jYXQocHJvcClcblx0XHRcdFx0OiB1bmRlZmluZWRcblx0XHQvLyBEcmFmdHMgb3duZWQgYnkgYHNjb3BlYCBhcmUgZmluYWxpemVkIGhlcmUuXG5cdFx0Y29uc3QgcmVzID0gZmluYWxpemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlLCBwYXRoKVxuXHRcdHNldCh0YXJnZXRPYmplY3QsIHByb3AsIHJlcylcblx0XHQvLyBEcmFmdHMgZnJvbSBhbm90aGVyIHNjb3BlIG11c3QgcHJldmVudGVkIHRvIGJlIGZyb3plblxuXHRcdC8vIGlmIHdlIGdvdCBhIGRyYWZ0IGJhY2sgZnJvbSBmaW5hbGl6ZSwgd2UncmUgaW4gYSBuZXN0ZWQgcHJvZHVjZSBhbmQgc2hvdWxkbid0IGZyZWV6ZVxuXHRcdGlmIChpc0RyYWZ0KHJlcykpIHtcblx0XHRcdHJvb3RTY29wZS5jYW5BdXRvRnJlZXplXyA9IGZhbHNlXG5cdFx0fSBlbHNlIHJldHVyblxuXHR9XG5cdC8vIFNlYXJjaCBuZXcgb2JqZWN0cyBmb3IgdW5maW5hbGl6ZWQgZHJhZnRzLiBGcm96ZW4gb2JqZWN0cyBzaG91bGQgbmV2ZXIgY29udGFpbiBkcmFmdHMuXG5cdGlmIChpc0RyYWZ0YWJsZShjaGlsZFZhbHVlKSAmJiAhaXNGcm96ZW4oY2hpbGRWYWx1ZSkpIHtcblx0XHRpZiAoIXJvb3RTY29wZS5pbW1lcl8uYXV0b0ZyZWV6ZV8gJiYgcm9vdFNjb3BlLnVuZmluYWxpemVkRHJhZnRzXyA8IDEpIHtcblx0XHRcdC8vIG9wdGltaXphdGlvbjogaWYgYW4gb2JqZWN0IGlzIG5vdCBhIGRyYWZ0LCBhbmQgd2UgZG9uJ3QgaGF2ZSB0b1xuXHRcdFx0Ly8gZGVlcGZyZWV6ZSBldmVyeXRoaW5nLCBhbmQgd2UgYXJlIHN1cmUgdGhhdCBubyBkcmFmdHMgYXJlIGxlZnQgaW4gdGhlIHJlbWFpbmluZyBvYmplY3Rcblx0XHRcdC8vIGNhdXNlIHdlIHNhdyBhbmQgZmluYWxpemVkIGFsbCBkcmFmdHMgYWxyZWFkeTsgd2UgY2FuIHN0b3AgdmlzaXRpbmcgdGhlIHJlc3Qgb2YgdGhlIHRyZWUuXG5cdFx0XHQvLyBUaGlzIGJlbmVmaXRzIGVzcGVjaWFsbHkgYWRkaW5nIGxhcmdlIGRhdGEgdHJlZSdzIHdpdGhvdXQgZnVydGhlciBwcm9jZXNzaW5nLlxuXHRcdFx0Ly8gU2VlIGFkZC1kYXRhLmpzIHBlcmYgdGVzdFxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXHRcdGZpbmFsaXplKHJvb3RTY29wZSwgY2hpbGRWYWx1ZSlcblx0XHQvLyBpbW1lciBkZWVwIGZyZWV6ZXMgcGxhaW4gb2JqZWN0cywgc28gaWYgdGhlcmUgaXMgbm8gcGFyZW50IHN0YXRlLCB3ZSBmcmVlemUgYXMgd2VsbFxuXHRcdGlmICghcGFyZW50U3RhdGUgfHwgIXBhcmVudFN0YXRlLnNjb3BlXy5wYXJlbnRfKVxuXHRcdFx0bWF5YmVGcmVlemUocm9vdFNjb3BlLCBjaGlsZFZhbHVlKVxuXHR9XG59XG5cbmZ1bmN0aW9uIG1heWJlRnJlZXplKHNjb3BlOiBJbW1lclNjb3BlLCB2YWx1ZTogYW55LCBkZWVwID0gZmFsc2UpIHtcblx0aWYgKHNjb3BlLmltbWVyXy5hdXRvRnJlZXplXyAmJiBzY29wZS5jYW5BdXRvRnJlZXplXykge1xuXHRcdGZyZWV6ZSh2YWx1ZSwgZGVlcClcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0ZWFjaCxcblx0aGFzLFxuXHRpcyxcblx0aXNEcmFmdGFibGUsXG5cdHNoYWxsb3dDb3B5LFxuXHRsYXRlc3QsXG5cdEltbWVyQmFzZVN0YXRlLFxuXHRJbW1lclN0YXRlLFxuXHREcmFmdGVkLFxuXHRBbnlPYmplY3QsXG5cdEFueUFycmF5LFxuXHRPYmplY3Rpc2gsXG5cdGdldEN1cnJlbnRTY29wZSxcblx0RFJBRlRfU1RBVEUsXG5cdGRpZSxcblx0Y3JlYXRlUHJveHksXG5cdFByb3h5VHlwZVByb3h5T2JqZWN0LFxuXHRQcm94eVR5cGVQcm94eUFycmF5XG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbmludGVyZmFjZSBQcm94eUJhc2VTdGF0ZSBleHRlbmRzIEltbWVyQmFzZVN0YXRlIHtcblx0YXNzaWduZWRfOiB7XG5cdFx0W3Byb3BlcnR5OiBzdHJpbmddOiBib29sZWFuXG5cdH1cblx0cGFyZW50Xz86IEltbWVyU3RhdGVcblx0cmV2b2tlXygpOiB2b2lkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJveHlPYmplY3RTdGF0ZSBleHRlbmRzIFByb3h5QmFzZVN0YXRlIHtcblx0dHlwZV86IHR5cGVvZiBQcm94eVR5cGVQcm94eU9iamVjdFxuXHRiYXNlXzogYW55XG5cdGNvcHlfOiBhbnlcblx0ZHJhZnRfOiBEcmFmdGVkPEFueU9iamVjdCwgUHJveHlPYmplY3RTdGF0ZT5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcm94eUFycmF5U3RhdGUgZXh0ZW5kcyBQcm94eUJhc2VTdGF0ZSB7XG5cdHR5cGVfOiB0eXBlb2YgUHJveHlUeXBlUHJveHlBcnJheVxuXHRiYXNlXzogQW55QXJyYXlcblx0Y29weV86IEFueUFycmF5IHwgbnVsbFxuXHRkcmFmdF86IERyYWZ0ZWQ8QW55QXJyYXksIFByb3h5QXJyYXlTdGF0ZT5cbn1cblxudHlwZSBQcm94eVN0YXRlID0gUHJveHlPYmplY3RTdGF0ZSB8IFByb3h5QXJyYXlTdGF0ZVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgZHJhZnQgb2YgdGhlIGBiYXNlYCBvYmplY3QuXG4gKlxuICogVGhlIHNlY29uZCBhcmd1bWVudCBpcyB0aGUgcGFyZW50IGRyYWZ0LXN0YXRlICh1c2VkIGludGVybmFsbHkpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJveHlQcm94eTxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0YmFzZTogVCxcblx0cGFyZW50PzogSW1tZXJTdGF0ZVxuKTogRHJhZnRlZDxULCBQcm94eVN0YXRlPiB7XG5cdGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGJhc2UpXG5cdGNvbnN0IHN0YXRlOiBQcm94eVN0YXRlID0ge1xuXHRcdHR5cGVfOiBpc0FycmF5ID8gUHJveHlUeXBlUHJveHlBcnJheSA6IChQcm94eVR5cGVQcm94eU9iamVjdCBhcyBhbnkpLFxuXHRcdC8vIFRyYWNrIHdoaWNoIHByb2R1Y2UgY2FsbCB0aGlzIGlzIGFzc29jaWF0ZWQgd2l0aC5cblx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0Ly8gVHJ1ZSBmb3IgYm90aCBzaGFsbG93IGFuZCBkZWVwIGNoYW5nZXMuXG5cdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHQvLyBVc2VkIGR1cmluZyBmaW5hbGl6YXRpb24uXG5cdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0Ly8gVHJhY2sgd2hpY2ggcHJvcGVydGllcyBoYXZlIGJlZW4gYXNzaWduZWQgKHRydWUpIG9yIGRlbGV0ZWQgKGZhbHNlKS5cblx0XHRhc3NpZ25lZF86IHt9LFxuXHRcdC8vIFRoZSBwYXJlbnQgZHJhZnQgc3RhdGUuXG5cdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdC8vIFRoZSBiYXNlIHN0YXRlLlxuXHRcdGJhc2VfOiBiYXNlLFxuXHRcdC8vIFRoZSBiYXNlIHByb3h5LlxuXHRcdGRyYWZ0XzogbnVsbCBhcyBhbnksIC8vIHNldCBiZWxvd1xuXHRcdC8vIFRoZSBiYXNlIGNvcHkgd2l0aCBhbnkgdXBkYXRlZCB2YWx1ZXMuXG5cdFx0Y29weV86IG51bGwsXG5cdFx0Ly8gQ2FsbGVkIGJ5IHRoZSBgcHJvZHVjZWAgZnVuY3Rpb24uXG5cdFx0cmV2b2tlXzogbnVsbCBhcyBhbnksXG5cdFx0aXNNYW51YWxfOiBmYWxzZVxuXHR9XG5cblx0Ly8gdGhlIHRyYXBzIG11c3QgdGFyZ2V0IHNvbWV0aGluZywgYSBiaXQgbGlrZSB0aGUgJ3JlYWwnIGJhc2UuXG5cdC8vIGJ1dCBhbHNvLCB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGV0ZXJtaW5lIGZyb20gdGhlIHRhcmdldCB3aGF0IHRoZSByZWxldmFudCBzdGF0ZSBpc1xuXHQvLyAodG8gYXZvaWQgY3JlYXRpbmcgdHJhcHMgcGVyIGluc3RhbmNlIHRvIGNhcHR1cmUgdGhlIHN0YXRlIGluIGNsb3N1cmUsXG5cdC8vIGFuZCB0byBhdm9pZCBjcmVhdGluZyB3ZWlyZCBoaWRkZW4gcHJvcGVydGllcyBhcyB3ZWxsKVxuXHQvLyBTbyB0aGUgdHJpY2sgaXMgdG8gdXNlICdzdGF0ZScgYXMgdGhlIGFjdHVhbCAndGFyZ2V0JyEgKGFuZCBtYWtlIHN1cmUgd2UgaW50ZXJjZXB0IGV2ZXJ5dGhpbmcpXG5cdC8vIE5vdGUgdGhhdCBpbiB0aGUgY2FzZSBvZiBhbiBhcnJheSwgd2UgcHV0IHRoZSBzdGF0ZSBpbiBhbiBhcnJheSB0byBoYXZlIGJldHRlciBSZWZsZWN0IGRlZmF1bHRzIG9vdGJcblx0bGV0IHRhcmdldDogVCA9IHN0YXRlIGFzIGFueVxuXHRsZXQgdHJhcHM6IFByb3h5SGFuZGxlcjxvYmplY3QgfCBBcnJheTxhbnk+PiA9IG9iamVjdFRyYXBzXG5cdGlmIChpc0FycmF5KSB7XG5cdFx0dGFyZ2V0ID0gW3N0YXRlXSBhcyBhbnlcblx0XHR0cmFwcyA9IGFycmF5VHJhcHNcblx0fVxuXG5cdGNvbnN0IHtyZXZva2UsIHByb3h5fSA9IFByb3h5LnJldm9jYWJsZSh0YXJnZXQsIHRyYXBzKVxuXHRzdGF0ZS5kcmFmdF8gPSBwcm94eSBhcyBhbnlcblx0c3RhdGUucmV2b2tlXyA9IHJldm9rZVxuXHRyZXR1cm4gcHJveHkgYXMgYW55XG59XG5cbi8qKlxuICogT2JqZWN0IGRyYWZ0c1xuICovXG5leHBvcnQgY29uc3Qgb2JqZWN0VHJhcHM6IFByb3h5SGFuZGxlcjxQcm94eVN0YXRlPiA9IHtcblx0Z2V0KHN0YXRlLCBwcm9wKSB7XG5cdFx0aWYgKHByb3AgPT09IERSQUZUX1NUQVRFKSByZXR1cm4gc3RhdGVcblxuXHRcdGNvbnN0IHNvdXJjZSA9IGxhdGVzdChzdGF0ZSlcblx0XHRpZiAoIWhhcyhzb3VyY2UsIHByb3ApKSB7XG5cdFx0XHQvLyBub24tZXhpc3Rpbmcgb3Igbm9uLW93biBwcm9wZXJ0eS4uLlxuXHRcdFx0cmV0dXJuIHJlYWRQcm9wRnJvbVByb3RvKHN0YXRlLCBzb3VyY2UsIHByb3ApXG5cdFx0fVxuXHRcdGNvbnN0IHZhbHVlID0gc291cmNlW3Byb3BdXG5cdFx0aWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuXHRcdFx0cmV0dXJuIHZhbHVlXG5cdFx0fVxuXHRcdC8vIENoZWNrIGZvciBleGlzdGluZyBkcmFmdCBpbiBtb2RpZmllZCBzdGF0ZS5cblx0XHQvLyBBc3NpZ25lZCB2YWx1ZXMgYXJlIG5ldmVyIGRyYWZ0ZWQuIFRoaXMgY2F0Y2hlcyBhbnkgZHJhZnRzIHdlIGNyZWF0ZWQsIHRvby5cblx0XHRpZiAodmFsdWUgPT09IHBlZWsoc3RhdGUuYmFzZV8sIHByb3ApKSB7XG5cdFx0XHRwcmVwYXJlQ29weShzdGF0ZSlcblx0XHRcdHJldHVybiAoc3RhdGUuY29weV8hW3Byb3AgYXMgYW55XSA9IGNyZWF0ZVByb3h5KFxuXHRcdFx0XHRzdGF0ZS5zY29wZV8uaW1tZXJfLFxuXHRcdFx0XHR2YWx1ZSxcblx0XHRcdFx0c3RhdGVcblx0XHRcdCkpXG5cdFx0fVxuXHRcdHJldHVybiB2YWx1ZVxuXHR9LFxuXHRoYXMoc3RhdGUsIHByb3ApIHtcblx0XHRyZXR1cm4gcHJvcCBpbiBsYXRlc3Qoc3RhdGUpXG5cdH0sXG5cdG93bktleXMoc3RhdGUpIHtcblx0XHRyZXR1cm4gUmVmbGVjdC5vd25LZXlzKGxhdGVzdChzdGF0ZSkpXG5cdH0sXG5cdHNldChcblx0XHRzdGF0ZTogUHJveHlPYmplY3RTdGF0ZSxcblx0XHRwcm9wOiBzdHJpbmcgLyogc3RyaWN0bHkgbm90LCBidXQgaGVscHMgVFMgKi8sXG5cdFx0dmFsdWVcblx0KSB7XG5cdFx0Y29uc3QgZGVzYyA9IGdldERlc2NyaXB0b3JGcm9tUHJvdG8obGF0ZXN0KHN0YXRlKSwgcHJvcClcblx0XHRpZiAoZGVzYz8uc2V0KSB7XG5cdFx0XHQvLyBzcGVjaWFsIGNhc2U6IGlmIHRoaXMgd3JpdGUgaXMgY2FwdHVyZWQgYnkgYSBzZXR0ZXIsIHdlIGhhdmVcblx0XHRcdC8vIHRvIHRyaWdnZXIgaXQgd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0XG5cdFx0XHRkZXNjLnNldC5jYWxsKHN0YXRlLmRyYWZ0XywgdmFsdWUpXG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH1cblx0XHRpZiAoIXN0YXRlLm1vZGlmaWVkXykge1xuXHRcdFx0Ly8gdGhlIGxhc3QgY2hlY2sgaXMgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggc2V0dGluZyBhIG5vbi1leGlzdGlnIHRvIHVuZGVmaW5lZCAod2hpY2ggaXMgYSBjaGFuZ2UpXG5cdFx0XHQvLyBmcm9tIHNldHRpbmcgYW4gZXhpc3RpbmcgcHJvcGVydHkgd2l0aCB2YWx1ZSB1bmRlZmluZWQgdG8gdW5kZWZpbmVkICh3aGljaCBpcyBub3QgYSBjaGFuZ2UpXG5cdFx0XHRjb25zdCBjdXJyZW50ID0gcGVlayhsYXRlc3Qoc3RhdGUpLCBwcm9wKVxuXHRcdFx0Ly8gc3BlY2lhbCBjYXNlLCBpZiB3ZSBhc3NpZ25pbmcgdGhlIG9yaWdpbmFsIHZhbHVlIHRvIGEgZHJhZnQsIHdlIGNhbiBpZ25vcmUgdGhlIGFzc2lnbm1lbnRcblx0XHRcdGNvbnN0IGN1cnJlbnRTdGF0ZTogUHJveHlPYmplY3RTdGF0ZSA9IGN1cnJlbnQ/LltEUkFGVF9TVEFURV1cblx0XHRcdGlmIChjdXJyZW50U3RhdGUgJiYgY3VycmVudFN0YXRlLmJhc2VfID09PSB2YWx1ZSkge1xuXHRcdFx0XHRzdGF0ZS5jb3B5XyFbcHJvcF0gPSB2YWx1ZVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzKHZhbHVlLCBjdXJyZW50KSAmJiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBoYXMoc3RhdGUuYmFzZV8sIHByb3ApKSlcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdHByZXBhcmVDb3B5KHN0YXRlKVxuXHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0fVxuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRzdGF0ZS5jb3B5XyFbcHJvcF0gPSB2YWx1ZVxuXHRcdHN0YXRlLmFzc2lnbmVkX1twcm9wXSA9IHRydWVcblx0XHRyZXR1cm4gdHJ1ZVxuXHR9LFxuXHRkZWxldGVQcm9wZXJ0eShzdGF0ZSwgcHJvcDogc3RyaW5nKSB7XG5cdFx0Ly8gVGhlIGB1bmRlZmluZWRgIGNoZWNrIGlzIGEgZmFzdCBwYXRoIGZvciBwcmUtZXhpc3Rpbmcga2V5cy5cblx0XHRpZiAocGVlayhzdGF0ZS5iYXNlXywgcHJvcCkgIT09IHVuZGVmaW5lZCB8fCBwcm9wIGluIHN0YXRlLmJhc2VfKSB7XG5cdFx0XHRzdGF0ZS5hc3NpZ25lZF9bcHJvcF0gPSBmYWxzZVxuXHRcdFx0cHJlcGFyZUNvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgYW4gb3JpZ2luYWxseSBub3QgYXNzaWduZWQgcHJvcGVydHkgd2FzIGRlbGV0ZWRcblx0XHRcdGRlbGV0ZSBzdGF0ZS5hc3NpZ25lZF9bcHJvcF1cblx0XHR9XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdGlmIChzdGF0ZS5jb3B5XykgZGVsZXRlIHN0YXRlLmNvcHlfW3Byb3BdXG5cdFx0cmV0dXJuIHRydWVcblx0fSxcblx0Ly8gTm90ZTogV2UgbmV2ZXIgY29lcmNlIGBkZXNjLnZhbHVlYCBpbnRvIGFuIEltbWVyIGRyYWZ0LCBiZWNhdXNlIHdlIGNhbid0IG1ha2Vcblx0Ly8gdGhlIHNhbWUgZ3VhcmFudGVlIGluIEVTNSBtb2RlLlxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc3RhdGUsIHByb3ApIHtcblx0XHRjb25zdCBvd25lciA9IGxhdGVzdChzdGF0ZSlcblx0XHRjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob3duZXIsIHByb3ApXG5cdFx0aWYgKCFkZXNjKSByZXR1cm4gZGVzY1xuXHRcdHJldHVybiB7XG5cdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogc3RhdGUudHlwZV8gIT09IFByb3h5VHlwZVByb3h5QXJyYXkgfHwgcHJvcCAhPT0gXCJsZW5ndGhcIixcblx0XHRcdGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZSxcblx0XHRcdHZhbHVlOiBvd25lcltwcm9wXVxuXHRcdH1cblx0fSxcblx0ZGVmaW5lUHJvcGVydHkoKSB7XG5cdFx0ZGllKDExKVxuXHR9LFxuXHRnZXRQcm90b3R5cGVPZihzdGF0ZSkge1xuXHRcdHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc3RhdGUuYmFzZV8pXG5cdH0sXG5cdHNldFByb3RvdHlwZU9mKCkge1xuXHRcdGRpZSgxMilcblx0fVxufVxuXG4vKipcbiAqIEFycmF5IGRyYWZ0c1xuICovXG5cbmNvbnN0IGFycmF5VHJhcHM6IFByb3h5SGFuZGxlcjxbUHJveHlBcnJheVN0YXRlXT4gPSB7fVxuZWFjaChvYmplY3RUcmFwcywgKGtleSwgZm4pID0+IHtcblx0Ly8gQHRzLWlnbm9yZVxuXHRhcnJheVRyYXBzW2tleV0gPSBmdW5jdGlvbigpIHtcblx0XHRhcmd1bWVudHNbMF0gPSBhcmd1bWVudHNbMF1bMF1cblx0XHRyZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXHR9XG59KVxuYXJyYXlUcmFwcy5kZWxldGVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHN0YXRlLCBwcm9wKSB7XG5cdGlmIChfX0RFVl9fICYmIGlzTmFOKHBhcnNlSW50KHByb3AgYXMgYW55KSkpIGRpZSgxMylcblx0cmV0dXJuIG9iamVjdFRyYXBzLmRlbGV0ZVByb3BlcnR5IS5jYWxsKHRoaXMsIHN0YXRlWzBdLCBwcm9wKVxufVxuYXJyYXlUcmFwcy5zZXQgPSBmdW5jdGlvbihzdGF0ZSwgcHJvcCwgdmFsdWUpIHtcblx0aWYgKF9fREVWX18gJiYgcHJvcCAhPT0gXCJsZW5ndGhcIiAmJiBpc05hTihwYXJzZUludChwcm9wIGFzIGFueSkpKSBkaWUoMTQpXG5cdHJldHVybiBvYmplY3RUcmFwcy5zZXQhLmNhbGwodGhpcywgc3RhdGVbMF0sIHByb3AsIHZhbHVlLCBzdGF0ZVswXSlcbn1cblxuLy8gQWNjZXNzIGEgcHJvcGVydHkgd2l0aG91dCBjcmVhdGluZyBhbiBJbW1lciBkcmFmdC5cbmZ1bmN0aW9uIHBlZWsoZHJhZnQ6IERyYWZ0ZWQsIHByb3A6IFByb3BlcnR5S2V5KSB7XG5cdGNvbnN0IHN0YXRlID0gZHJhZnRbRFJBRlRfU1RBVEVdXG5cdGNvbnN0IHNvdXJjZSA9IHN0YXRlID8gbGF0ZXN0KHN0YXRlKSA6IGRyYWZ0XG5cdHJldHVybiBzb3VyY2VbcHJvcF1cbn1cblxuZnVuY3Rpb24gcmVhZFByb3BGcm9tUHJvdG8oc3RhdGU6IEltbWVyU3RhdGUsIHNvdXJjZTogYW55LCBwcm9wOiBQcm9wZXJ0eUtleSkge1xuXHRjb25zdCBkZXNjID0gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhzb3VyY2UsIHByb3ApXG5cdHJldHVybiBkZXNjXG5cdFx0PyBgdmFsdWVgIGluIGRlc2Ncblx0XHRcdD8gZGVzYy52YWx1ZVxuXHRcdFx0OiAvLyBUaGlzIGlzIGEgdmVyeSBzcGVjaWFsIGNhc2UsIGlmIHRoZSBwcm9wIGlzIGEgZ2V0dGVyIGRlZmluZWQgYnkgdGhlXG5cdFx0XHQgIC8vIHByb3RvdHlwZSwgd2Ugc2hvdWxkIGludm9rZSBpdCB3aXRoIHRoZSBkcmFmdCBhcyBjb250ZXh0IVxuXHRcdFx0ICBkZXNjLmdldD8uY2FsbChzdGF0ZS5kcmFmdF8pXG5cdFx0OiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gZ2V0RGVzY3JpcHRvckZyb21Qcm90byhcblx0c291cmNlOiBhbnksXG5cdHByb3A6IFByb3BlcnR5S2V5XG4pOiBQcm9wZXJ0eURlc2NyaXB0b3IgfCB1bmRlZmluZWQge1xuXHQvLyAnaW4nIGNoZWNrcyBwcm90byFcblx0aWYgKCEocHJvcCBpbiBzb3VyY2UpKSByZXR1cm4gdW5kZWZpbmVkXG5cdGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpXG5cdHdoaWxlIChwcm90bykge1xuXHRcdGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBwcm9wKVxuXHRcdGlmIChkZXNjKSByZXR1cm4gZGVzY1xuXHRcdHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKVxuXHR9XG5cdHJldHVybiB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtDaGFuZ2VkKHN0YXRlOiBJbW1lclN0YXRlKSB7XG5cdGlmICghc3RhdGUubW9kaWZpZWRfKSB7XG5cdFx0c3RhdGUubW9kaWZpZWRfID0gdHJ1ZVxuXHRcdGlmIChzdGF0ZS5wYXJlbnRfKSB7XG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZS5wYXJlbnRfKVxuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUNvcHkoc3RhdGU6IHtiYXNlXzogYW55OyBjb3B5XzogYW55fSkge1xuXHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0c3RhdGUuY29weV8gPSBzaGFsbG93Q29weShzdGF0ZS5iYXNlXylcblx0fVxufVxuIiwiaW1wb3J0IHtcblx0SVByb2R1Y2VXaXRoUGF0Y2hlcyxcblx0SVByb2R1Y2UsXG5cdEltbWVyU3RhdGUsXG5cdERyYWZ0ZWQsXG5cdGlzRHJhZnRhYmxlLFxuXHRwcm9jZXNzUmVzdWx0LFxuXHRQYXRjaCxcblx0T2JqZWN0aXNoLFxuXHREUkFGVF9TVEFURSxcblx0RHJhZnQsXG5cdFBhdGNoTGlzdGVuZXIsXG5cdGlzRHJhZnQsXG5cdGlzTWFwLFxuXHRpc1NldCxcblx0Y3JlYXRlUHJveHlQcm94eSxcblx0Z2V0UGx1Z2luLFxuXHRkaWUsXG5cdGhhc1Byb3hpZXMsXG5cdGlzTWluaWZpZWQsXG5cdGVudGVyU2NvcGUsXG5cdHJldm9rZVNjb3BlLFxuXHRsZWF2ZVNjb3BlLFxuXHR1c2VQYXRjaGVzSW5TY29wZSxcblx0Z2V0Q3VycmVudFNjb3BlLFxuXHROT1RISU5HLFxuXHRmcmVlemUsXG5cdGN1cnJlbnRcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuaW50ZXJmYWNlIFByb2R1Y2Vyc0ZucyB7XG5cdHByb2R1Y2U6IElQcm9kdWNlXG5cdHByb2R1Y2VXaXRoUGF0Y2hlczogSVByb2R1Y2VXaXRoUGF0Y2hlc1xufVxuXG5leHBvcnQgY2xhc3MgSW1tZXIgaW1wbGVtZW50cyBQcm9kdWNlcnNGbnMge1xuXHR1c2VQcm94aWVzXzogYm9vbGVhbiA9IGhhc1Byb3hpZXNcblxuXHRhdXRvRnJlZXplXzogYm9vbGVhbiA9IF9fREVWX18gPyB0cnVlIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIDogIWlzTWluaWZpZWRcblxuXHRjb25zdHJ1Y3Rvcihjb25maWc/OiB7dXNlUHJveGllcz86IGJvb2xlYW47IGF1dG9GcmVlemU/OiBib29sZWFufSkge1xuXHRcdGlmICh0eXBlb2YgY29uZmlnPy51c2VQcm94aWVzID09PSBcImJvb2xlYW5cIilcblx0XHRcdHRoaXMuc2V0VXNlUHJveGllcyhjb25maWchLnVzZVByb3hpZXMpXG5cdFx0aWYgKHR5cGVvZiBjb25maWc/LmF1dG9GcmVlemUgPT09IFwiYm9vbGVhblwiKVxuXHRcdFx0dGhpcy5zZXRBdXRvRnJlZXplKGNvbmZpZyEuYXV0b0ZyZWV6ZSlcblx0XHR0aGlzLnByb2R1Y2UgPSB0aGlzLnByb2R1Y2UuYmluZCh0aGlzKVxuXHRcdHRoaXMucHJvZHVjZVdpdGhQYXRjaGVzID0gdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZCh0aGlzKVxuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHJvZHVjZWAgZnVuY3Rpb24gdGFrZXMgYSB2YWx1ZSBhbmQgYSBcInJlY2lwZSBmdW5jdGlvblwiICh3aG9zZVxuXHQgKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcblx0ICogZnJlZSB0byBtdXRhdGUgaXRzIGZpcnN0IGFyZ3VtZW50IGhvd2V2ZXIgaXQgd2FudHMuIEFsbCBtdXRhdGlvbnMgYXJlXG5cdCAqIG9ubHkgZXZlciBhcHBsaWVkIHRvIGEgX19jb3B5X18gb2YgdGhlIGJhc2Ugc3RhdGUuXG5cdCAqXG5cdCAqIFBhc3Mgb25seSBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIFwiY3VycmllZCBwcm9kdWNlclwiIHdoaWNoIHJlbGlldmVzIHlvdVxuXHQgKiBmcm9tIHBhc3NpbmcgdGhlIHJlY2lwZSBmdW5jdGlvbiBldmVyeSB0aW1lLlxuXHQgKlxuXHQgKiBPbmx5IHBsYWluIG9iamVjdHMgYW5kIGFycmF5cyBhcmUgbWFkZSBtdXRhYmxlLiBBbGwgb3RoZXIgb2JqZWN0cyBhcmVcblx0ICogY29uc2lkZXJlZCB1bmNvcHlhYmxlLlxuXHQgKlxuXHQgKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIF9fYm91bmRfXyB0byBpdHMgYEltbWVyYCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm9kdWNlciAtIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgYSBwcm94eSBvZiB0aGUgYmFzZSBzdGF0ZSBhcyBmaXJzdCBhcmd1bWVudCBhbmQgd2hpY2ggY2FuIGJlIGZyZWVseSBtb2RpZmllZFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwYXRjaExpc3RlbmVyIC0gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB0aGUgcGF0Y2hlcyBwcm9kdWNlZCBoZXJlXG5cdCAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuXHQgKi9cblx0cHJvZHVjZShiYXNlOiBhbnksIHJlY2lwZT86IGFueSwgcGF0Y2hMaXN0ZW5lcj86IGFueSkge1xuXHRcdC8vIGN1cnJpZWQgaW52b2NhdGlvblxuXHRcdGlmICh0eXBlb2YgYmFzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0Y29uc3QgZGVmYXVsdEJhc2UgPSByZWNpcGVcblx0XHRcdHJlY2lwZSA9IGJhc2VcblxuXHRcdFx0Y29uc3Qgc2VsZiA9IHRoaXNcblx0XHRcdHJldHVybiBmdW5jdGlvbiBjdXJyaWVkUHJvZHVjZShcblx0XHRcdFx0dGhpczogYW55LFxuXHRcdFx0XHRiYXNlID0gZGVmYXVsdEJhc2UsXG5cdFx0XHRcdC4uLmFyZ3M6IGFueVtdXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHNlbGYucHJvZHVjZShiYXNlLCAoZHJhZnQ6IERyYWZ0ZWQpID0+IHJlY2lwZS5jYWxsKHRoaXMsIGRyYWZ0LCAuLi5hcmdzKSkgLy8gcHJldHRpZXItaWdub3JlXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiByZWNpcGUgIT09IFwiZnVuY3Rpb25cIikgZGllKDYpXG5cdFx0aWYgKHBhdGNoTGlzdGVuZXIgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcGF0Y2hMaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0ZGllKDcpXG5cblx0XHRsZXQgcmVzdWx0XG5cblx0XHQvLyBPbmx5IHBsYWluIG9iamVjdHMsIGFycmF5cywgYW5kIFwiaW1tZXJhYmxlIGNsYXNzZXNcIiBhcmUgZHJhZnRlZC5cblx0XHRpZiAoaXNEcmFmdGFibGUoYmFzZSkpIHtcblx0XHRcdGNvbnN0IHNjb3BlID0gZW50ZXJTY29wZSh0aGlzKVxuXHRcdFx0Y29uc3QgcHJveHkgPSBjcmVhdGVQcm94eSh0aGlzLCBiYXNlLCB1bmRlZmluZWQpXG5cdFx0XHRsZXQgaGFzRXJyb3IgPSB0cnVlXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXN1bHQgPSByZWNpcGUocHJveHkpXG5cdFx0XHRcdGhhc0Vycm9yID0gZmFsc2Vcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdC8vIGZpbmFsbHkgaW5zdGVhZCBvZiBjYXRjaCArIHJldGhyb3cgYmV0dGVyIHByZXNlcnZlcyBvcmlnaW5hbCBzdGFja1xuXHRcdFx0XHRpZiAoaGFzRXJyb3IpIHJldm9rZVNjb3BlKHNjb3BlKVxuXHRcdFx0XHRlbHNlIGxlYXZlU2NvcGUoc2NvcGUpXG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0LnRoZW4oXG5cdFx0XHRcdFx0cmVzdWx0ID0+IHtcblx0XHRcdFx0XHRcdHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKVxuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSlcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGVycm9yID0+IHtcblx0XHRcdFx0XHRcdHJldm9rZVNjb3BlKHNjb3BlKVxuXHRcdFx0XHRcdFx0dGhyb3cgZXJyb3Jcblx0XHRcdFx0XHR9XG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKVxuXHRcdFx0cmV0dXJuIHByb2Nlc3NSZXN1bHQocmVzdWx0LCBzY29wZSlcblx0XHR9IGVsc2UgaWYgKCFiYXNlIHx8IHR5cGVvZiBiYXNlICE9PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRyZXN1bHQgPSByZWNpcGUoYmFzZSlcblx0XHRcdGlmIChyZXN1bHQgPT09IE5PVEhJTkcpIHJldHVybiB1bmRlZmluZWRcblx0XHRcdGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgcmVzdWx0ID0gYmFzZVxuXHRcdFx0aWYgKHRoaXMuYXV0b0ZyZWV6ZV8pIGZyZWV6ZShyZXN1bHQsIHRydWUpXG5cdFx0XHRyZXR1cm4gcmVzdWx0XG5cdFx0fSBlbHNlIGRpZSgyMSwgYmFzZSlcblx0fVxuXG5cdHByb2R1Y2VXaXRoUGF0Y2hlcyhhcmcxOiBhbnksIGFyZzI/OiBhbnksIGFyZzM/OiBhbnkpOiBhbnkge1xuXHRcdGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRyZXR1cm4gKHN0YXRlOiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PlxuXHRcdFx0XHR0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcyhzdGF0ZSwgKGRyYWZ0OiBhbnkpID0+IGFyZzEoZHJhZnQsIC4uLmFyZ3MpKVxuXHRcdH1cblxuXHRcdGxldCBwYXRjaGVzOiBQYXRjaFtdLCBpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHRcdGNvbnN0IG5leHRTdGF0ZSA9IHRoaXMucHJvZHVjZShhcmcxLCBhcmcyLCAocDogUGF0Y2hbXSwgaXA6IFBhdGNoW10pID0+IHtcblx0XHRcdHBhdGNoZXMgPSBwXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcyA9IGlwXG5cdFx0fSlcblx0XHRyZXR1cm4gW25leHRTdGF0ZSwgcGF0Y2hlcyEsIGludmVyc2VQYXRjaGVzIV1cblx0fVxuXG5cdGNyZWF0ZURyYWZ0PFQgZXh0ZW5kcyBPYmplY3Rpc2g+KGJhc2U6IFQpOiBEcmFmdDxUPiB7XG5cdFx0aWYgKCFpc0RyYWZ0YWJsZShiYXNlKSkgZGllKDgpXG5cdFx0aWYgKGlzRHJhZnQoYmFzZSkpIGJhc2UgPSBjdXJyZW50KGJhc2UpXG5cdFx0Y29uc3Qgc2NvcGUgPSBlbnRlclNjb3BlKHRoaXMpXG5cdFx0Y29uc3QgcHJveHkgPSBjcmVhdGVQcm94eSh0aGlzLCBiYXNlLCB1bmRlZmluZWQpXG5cdFx0cHJveHlbRFJBRlRfU1RBVEVdLmlzTWFudWFsXyA9IHRydWVcblx0XHRsZWF2ZVNjb3BlKHNjb3BlKVxuXHRcdHJldHVybiBwcm94eSBhcyBhbnlcblx0fVxuXG5cdGZpbmlzaERyYWZ0PEQgZXh0ZW5kcyBEcmFmdDxhbnk+Pihcblx0XHRkcmFmdDogRCxcblx0XHRwYXRjaExpc3RlbmVyPzogUGF0Y2hMaXN0ZW5lclxuXHQpOiBEIGV4dGVuZHMgRHJhZnQ8aW5mZXIgVD4gPyBUIDogbmV2ZXIge1xuXHRcdGNvbnN0IHN0YXRlOiBJbW1lclN0YXRlID0gZHJhZnQgJiYgKGRyYWZ0IGFzIGFueSlbRFJBRlRfU1RBVEVdXG5cdFx0aWYgKF9fREVWX18pIHtcblx0XHRcdGlmICghc3RhdGUgfHwgIXN0YXRlLmlzTWFudWFsXykgZGllKDkpXG5cdFx0XHRpZiAoc3RhdGUuZmluYWxpemVkXykgZGllKDEwKVxuXHRcdH1cblx0XHRjb25zdCB7c2NvcGVfOiBzY29wZX0gPSBzdGF0ZVxuXHRcdHVzZVBhdGNoZXNJblNjb3BlKHNjb3BlLCBwYXRjaExpc3RlbmVyKVxuXHRcdHJldHVybiBwcm9jZXNzUmVzdWx0KHVuZGVmaW5lZCwgc2NvcGUpXG5cdH1cblxuXHQvKipcblx0ICogUGFzcyB0cnVlIHRvIGF1dG9tYXRpY2FsbHkgZnJlZXplIGFsbCBjb3BpZXMgY3JlYXRlZCBieSBJbW1lci5cblx0ICpcblx0ICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uLlxuXHQgKi9cblx0c2V0QXV0b0ZyZWV6ZSh2YWx1ZTogYm9vbGVhbikge1xuXHRcdHRoaXMuYXV0b0ZyZWV6ZV8gPSB2YWx1ZVxuXHR9XG5cblx0LyoqXG5cdCAqIFBhc3MgdHJ1ZSB0byB1c2UgdGhlIEVTMjAxNSBgUHJveHlgIGNsYXNzIHdoZW4gY3JlYXRpbmcgZHJhZnRzLCB3aGljaCBpc1xuXHQgKiBhbHdheXMgZmFzdGVyIHRoYW4gdXNpbmcgRVM1IHByb3hpZXMuXG5cdCAqXG5cdCAqIEJ5IGRlZmF1bHQsIGZlYXR1cmUgZGV0ZWN0aW9uIGlzIHVzZWQsIHNvIGNhbGxpbmcgdGhpcyBpcyByYXJlbHkgbmVjZXNzYXJ5LlxuXHQgKi9cblx0c2V0VXNlUHJveGllcyh2YWx1ZTogYm9vbGVhbikge1xuXHRcdGlmICh2YWx1ZSAmJiAhaGFzUHJveGllcykge1xuXHRcdFx0ZGllKDIwKVxuXHRcdH1cblx0XHR0aGlzLnVzZVByb3hpZXNfID0gdmFsdWVcblx0fVxuXG5cdGFwcGx5UGF0Y2hlcyhiYXNlOiBPYmplY3Rpc2gsIHBhdGNoZXM6IFBhdGNoW10pIHtcblx0XHQvLyBJZiBhIHBhdGNoIHJlcGxhY2VzIHRoZSBlbnRpcmUgc3RhdGUsIHRha2UgdGhhdCByZXBsYWNlbWVudCBhcyBiYXNlXG5cdFx0Ly8gYmVmb3JlIGFwcGx5aW5nIHBhdGNoZXNcblx0XHRsZXQgaTogbnVtYmVyXG5cdFx0Zm9yIChpID0gcGF0Y2hlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3QgcGF0Y2ggPSBwYXRjaGVzW2ldXG5cdFx0XHRpZiAocGF0Y2gucGF0aC5sZW5ndGggPT09IDAgJiYgcGF0Y2gub3AgPT09IFwicmVwbGFjZVwiKSB7XG5cdFx0XHRcdGJhc2UgPSBwYXRjaC52YWx1ZVxuXHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IGFwcGx5UGF0Y2hlc0ltcGwgPSBnZXRQbHVnaW4oXCJQYXRjaGVzXCIpLmFwcGx5UGF0Y2hlc19cblx0XHRpZiAoaXNEcmFmdChiYXNlKSkge1xuXHRcdFx0Ly8gTi5COiBuZXZlciBoaXRzIGlmIHNvbWUgcGF0Y2ggYSByZXBsYWNlbWVudCwgcGF0Y2hlcyBhcmUgbmV2ZXIgZHJhZnRzXG5cdFx0XHRyZXR1cm4gYXBwbHlQYXRjaGVzSW1wbChiYXNlLCBwYXRjaGVzKVxuXHRcdH1cblx0XHQvLyBPdGhlcndpc2UsIHByb2R1Y2UgYSBjb3B5IG9mIHRoZSBiYXNlIHN0YXRlLlxuXHRcdHJldHVybiB0aGlzLnByb2R1Y2UoYmFzZSwgKGRyYWZ0OiBEcmFmdGVkKSA9PlxuXHRcdFx0YXBwbHlQYXRjaGVzSW1wbChkcmFmdCwgcGF0Y2hlcy5zbGljZShpICsgMSkpXG5cdFx0KVxuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eTxUIGV4dGVuZHMgT2JqZWN0aXNoPihcblx0aW1tZXI6IEltbWVyLFxuXHR2YWx1ZTogVCxcblx0cGFyZW50PzogSW1tZXJTdGF0ZVxuKTogRHJhZnRlZDxULCBJbW1lclN0YXRlPiB7XG5cdC8vIHByZWNvbmRpdGlvbjogY3JlYXRlUHJveHkgc2hvdWxkIGJlIGd1YXJkZWQgYnkgaXNEcmFmdGFibGUsIHNvIHdlIGtub3cgd2UgY2FuIHNhZmVseSBkcmFmdFxuXHRjb25zdCBkcmFmdDogRHJhZnRlZCA9IGlzTWFwKHZhbHVlKVxuXHRcdD8gZ2V0UGx1Z2luKFwiTWFwU2V0XCIpLnByb3h5TWFwXyh2YWx1ZSwgcGFyZW50KVxuXHRcdDogaXNTZXQodmFsdWUpXG5cdFx0PyBnZXRQbHVnaW4oXCJNYXBTZXRcIikucHJveHlTZXRfKHZhbHVlLCBwYXJlbnQpXG5cdFx0OiBpbW1lci51c2VQcm94aWVzX1xuXHRcdD8gY3JlYXRlUHJveHlQcm94eSh2YWx1ZSwgcGFyZW50KVxuXHRcdDogZ2V0UGx1Z2luKFwiRVM1XCIpLmNyZWF0ZUVTNVByb3h5Xyh2YWx1ZSwgcGFyZW50KVxuXG5cdGNvbnN0IHNjb3BlID0gcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpXG5cdHNjb3BlLmRyYWZ0c18ucHVzaChkcmFmdClcblx0cmV0dXJuIGRyYWZ0XG59XG4iLCJpbXBvcnQge1xuXHRkaWUsXG5cdGlzRHJhZnQsXG5cdHNoYWxsb3dDb3B5LFxuXHRlYWNoLFxuXHREUkFGVF9TVEFURSxcblx0Z2V0LFxuXHRzZXQsXG5cdEltbWVyU3RhdGUsXG5cdGlzRHJhZnRhYmxlLFxuXHRBcmNodHlwZU1hcCxcblx0QXJjaHR5cGVTZXQsXG5cdGdldEFyY2h0eXBlLFxuXHRnZXRQbHVnaW5cbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuLyoqIFRha2VzIGEgc25hcHNob3Qgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBkcmFmdCBhbmQgZmluYWxpemVzIGl0IChidXQgd2l0aG91dCBmcmVlemluZykuIFRoaXMgaXMgYSBncmVhdCB1dGlsaXR5IHRvIHByaW50IHRoZSBjdXJyZW50IHN0YXRlIGR1cmluZyBkZWJ1Z2dpbmcgKG5vIFByb3hpZXMgaW4gdGhlIHdheSkuIFRoZSBvdXRwdXQgb2YgY3VycmVudCBjYW4gYWxzbyBiZSBzYWZlbHkgbGVha2VkIG91dHNpZGUgdGhlIHByb2R1Y2VyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGN1cnJlbnQ8VD4odmFsdWU6IFQpOiBUXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudCh2YWx1ZTogYW55KTogYW55IHtcblx0aWYgKCFpc0RyYWZ0KHZhbHVlKSkgZGllKDIyLCB2YWx1ZSlcblx0cmV0dXJuIGN1cnJlbnRJbXBsKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBjdXJyZW50SW1wbCh2YWx1ZTogYW55KTogYW55IHtcblx0aWYgKCFpc0RyYWZ0YWJsZSh2YWx1ZSkpIHJldHVybiB2YWx1ZVxuXHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSB8IHVuZGVmaW5lZCA9IHZhbHVlW0RSQUZUX1NUQVRFXVxuXHRsZXQgY29weTogYW55XG5cdGNvbnN0IGFyY2hUeXBlID0gZ2V0QXJjaHR5cGUodmFsdWUpXG5cdGlmIChzdGF0ZSkge1xuXHRcdGlmIChcblx0XHRcdCFzdGF0ZS5tb2RpZmllZF8gJiZcblx0XHRcdChzdGF0ZS50eXBlXyA8IDQgfHwgIWdldFBsdWdpbihcIkVTNVwiKS5oYXNDaGFuZ2VzXyhzdGF0ZSBhcyBhbnkpKVxuXHRcdClcblx0XHRcdHJldHVybiBzdGF0ZS5iYXNlX1xuXHRcdC8vIE9wdGltaXphdGlvbjogYXZvaWQgZ2VuZXJhdGluZyBuZXcgZHJhZnRzIGR1cmluZyBjb3B5aW5nXG5cdFx0c3RhdGUuZmluYWxpemVkXyA9IHRydWVcblx0XHRjb3B5ID0gY29weUhlbHBlcih2YWx1ZSwgYXJjaFR5cGUpXG5cdFx0c3RhdGUuZmluYWxpemVkXyA9IGZhbHNlXG5cdH0gZWxzZSB7XG5cdFx0Y29weSA9IGNvcHlIZWxwZXIodmFsdWUsIGFyY2hUeXBlKVxuXHR9XG5cblx0ZWFjaChjb3B5LCAoa2V5LCBjaGlsZFZhbHVlKSA9PiB7XG5cdFx0aWYgKHN0YXRlICYmIGdldChzdGF0ZS5iYXNlXywga2V5KSA9PT0gY2hpbGRWYWx1ZSkgcmV0dXJuIC8vIG5vIG5lZWQgdG8gY29weSBvciBzZWFyY2ggaW4gc29tZXRoaW5nIHRoYXQgZGlkbid0IGNoYW5nZVxuXHRcdHNldChjb3B5LCBrZXksIGN1cnJlbnRJbXBsKGNoaWxkVmFsdWUpKVxuXHR9KVxuXHQvLyBJbiB0aGUgZnV0dXJlLCB3ZSBtaWdodCBjb25zaWRlciBmcmVlemluZyBoZXJlLCBiYXNlZCBvbiB0aGUgY3VycmVudCBzZXR0aW5nc1xuXHRyZXR1cm4gYXJjaFR5cGUgPT09IEFyY2h0eXBlU2V0ID8gbmV3IFNldChjb3B5KSA6IGNvcHlcbn1cblxuZnVuY3Rpb24gY29weUhlbHBlcih2YWx1ZTogYW55LCBhcmNoVHlwZTogbnVtYmVyKTogYW55IHtcblx0Ly8gY3JlYXRlcyBhIHNoYWxsb3cgY29weSwgZXZlbiBpZiBpdCBpcyBhIG1hcCBvciBzZXRcblx0c3dpdGNoIChhcmNoVHlwZSkge1xuXHRcdGNhc2UgQXJjaHR5cGVNYXA6XG5cdFx0XHRyZXR1cm4gbmV3IE1hcCh2YWx1ZSlcblx0XHRjYXNlIEFyY2h0eXBlU2V0OlxuXHRcdFx0Ly8gU2V0IHdpbGwgYmUgY2xvbmVkIGFzIGFycmF5IHRlbXBvcmFyaWx5LCBzbyB0aGF0IHdlIGNhbiByZXBsYWNlIGluZGl2aWR1YWwgaXRlbXNcblx0XHRcdHJldHVybiBBcnJheS5mcm9tKHZhbHVlKVxuXHR9XG5cdHJldHVybiBzaGFsbG93Q29weSh2YWx1ZSlcbn1cbiIsImltcG9ydCB7XG5cdEltbWVyU3RhdGUsXG5cdERyYWZ0ZWQsXG5cdEVTNUFycmF5U3RhdGUsXG5cdEVTNU9iamVjdFN0YXRlLFxuXHRlYWNoLFxuXHRoYXMsXG5cdGlzRHJhZnQsXG5cdGxhdGVzdCxcblx0RFJBRlRfU1RBVEUsXG5cdGlzLFxuXHRsb2FkUGx1Z2luLFxuXHRJbW1lclNjb3BlLFxuXHRQcm94eVR5cGVFUzVBcnJheSxcblx0UHJveHlUeXBlRVM1T2JqZWN0LFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdGRpZSxcblx0bWFya0NoYW5nZWQsXG5cdG9iamVjdFRyYXBzLFxuXHRvd25LZXlzLFxuXHRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzXG59IGZyb20gXCIuLi9pbnRlcm5hbFwiXG5cbnR5cGUgRVM1U3RhdGUgPSBFUzVBcnJheVN0YXRlIHwgRVM1T2JqZWN0U3RhdGVcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUVTNSgpIHtcblx0ZnVuY3Rpb24gd2lsbEZpbmFsaXplRVM1Xyhcblx0XHRzY29wZTogSW1tZXJTY29wZSxcblx0XHRyZXN1bHQ6IGFueSxcblx0XHRpc1JlcGxhY2VkOiBib29sZWFuXG5cdCkge1xuXHRcdGlmICghaXNSZXBsYWNlZCkge1xuXHRcdFx0aWYgKHNjb3BlLnBhdGNoZXNfKSB7XG5cdFx0XHRcdG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoc2NvcGUuZHJhZnRzXyFbMF0pXG5cdFx0XHR9XG5cdFx0XHQvLyBUaGlzIGlzIGZhc3RlciB3aGVuIHdlIGRvbid0IGNhcmUgYWJvdXQgd2hpY2ggYXR0cmlidXRlcyBjaGFuZ2VkLlxuXHRcdFx0bWFya0NoYW5nZXNTd2VlcChzY29wZS5kcmFmdHNfKVxuXHRcdH1cblx0XHQvLyBXaGVuIGEgY2hpbGQgZHJhZnQgaXMgcmV0dXJuZWQsIGxvb2sgZm9yIGNoYW5nZXMuXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHRpc0RyYWZ0KHJlc3VsdCkgJiZcblx0XHRcdChyZXN1bHRbRFJBRlRfU1RBVEVdIGFzIEVTNVN0YXRlKS5zY29wZV8gPT09IHNjb3BlXG5cdFx0KSB7XG5cdFx0XHRtYXJrQ2hhbmdlc1N3ZWVwKHNjb3BlLmRyYWZ0c18pXG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRVM1RHJhZnQoaXNBcnJheTogYm9vbGVhbiwgYmFzZTogYW55KSB7XG5cdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdGNvbnN0IGRyYWZ0ID0gbmV3IEFycmF5KGJhc2UubGVuZ3RoKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIFwiXCIgKyBpLCBwcm94eVByb3BlcnR5KGksIHRydWUpKVxuXHRcdFx0cmV0dXJuIGRyYWZ0XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGRlc2NyaXB0b3JzID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhiYXNlKVxuXHRcdFx0ZGVsZXRlIGRlc2NyaXB0b3JzW0RSQUZUX1NUQVRFIGFzIGFueV1cblx0XHRcdGNvbnN0IGtleXMgPSBvd25LZXlzKGRlc2NyaXB0b3JzKVxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IGtleTogYW55ID0ga2V5c1tpXVxuXHRcdFx0XHRkZXNjcmlwdG9yc1trZXldID0gcHJveHlQcm9wZXJ0eShcblx0XHRcdFx0XHRrZXksXG5cdFx0XHRcdFx0aXNBcnJheSB8fCAhIWRlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZVxuXHRcdFx0XHQpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YoYmFzZSksIGRlc2NyaXB0b3JzKVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVTNVByb3h5XzxUPihcblx0XHRiYXNlOiBULFxuXHRcdHBhcmVudD86IEltbWVyU3RhdGVcblx0KTogRHJhZnRlZDxULCBFUzVPYmplY3RTdGF0ZSB8IEVTNUFycmF5U3RhdGU+IHtcblx0XHRjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShiYXNlKVxuXHRcdGNvbnN0IGRyYWZ0ID0gY3JlYXRlRVM1RHJhZnQoaXNBcnJheSwgYmFzZSlcblxuXHRcdGNvbnN0IHN0YXRlOiBFUzVPYmplY3RTdGF0ZSB8IEVTNUFycmF5U3RhdGUgPSB7XG5cdFx0XHR0eXBlXzogaXNBcnJheSA/IFByb3h5VHlwZUVTNUFycmF5IDogKFByb3h5VHlwZUVTNU9iamVjdCBhcyBhbnkpLFxuXHRcdFx0c2NvcGVfOiBwYXJlbnQgPyBwYXJlbnQuc2NvcGVfIDogZ2V0Q3VycmVudFNjb3BlKCksXG5cdFx0XHRtb2RpZmllZF86IGZhbHNlLFxuXHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRhc3NpZ25lZF86IHt9LFxuXHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0Ly8gYmFzZSBpcyB0aGUgb2JqZWN0IHdlIGFyZSBkcmFmdGluZ1xuXHRcdFx0YmFzZV86IGJhc2UsXG5cdFx0XHQvLyBkcmFmdCBpcyB0aGUgZHJhZnQgb2JqZWN0IGl0c2VsZiwgdGhhdCB0cmFwcyBhbGwgcmVhZHMgYW5kIHJlYWRzIGZyb20gZWl0aGVyIHRoZSBiYXNlIChpZiB1bm1vZGlmaWVkKSBvciBjb3B5IChpZiBtb2RpZmllZClcblx0XHRcdGRyYWZ0XzogZHJhZnQsXG5cdFx0XHRjb3B5XzogbnVsbCxcblx0XHRcdHJldm9rZWRfOiBmYWxzZSxcblx0XHRcdGlzTWFudWFsXzogZmFsc2Vcblx0XHR9XG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZHJhZnQsIERSQUZUX1NUQVRFLCB7XG5cdFx0XHR2YWx1ZTogc3RhdGUsXG5cdFx0XHQvLyBlbnVtZXJhYmxlOiBmYWxzZSA8LSB0aGUgZGVmYXVsdFxuXHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHR9KVxuXHRcdHJldHVybiBkcmFmdFxuXHR9XG5cblx0Ly8gcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIHJlY3ljbGVkIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBjcmVhdGUgYSBnZXQgYW5kIHNldCBjbG9zdXJlIHBlciBwcm9wZXJ0eSxcblx0Ly8gYnV0IHNoYXJlIHRoZW0gYWxsIGluc3RlYWRcblx0Y29uc3QgZGVzY3JpcHRvcnM6IHtbcHJvcDogc3RyaW5nXTogUHJvcGVydHlEZXNjcmlwdG9yfSA9IHt9XG5cblx0ZnVuY3Rpb24gcHJveHlQcm9wZXJ0eShcblx0XHRwcm9wOiBzdHJpbmcgfCBudW1iZXIsXG5cdFx0ZW51bWVyYWJsZTogYm9vbGVhblxuXHQpOiBQcm9wZXJ0eURlc2NyaXB0b3Ige1xuXHRcdGxldCBkZXNjID0gZGVzY3JpcHRvcnNbcHJvcF1cblx0XHRpZiAoZGVzYykge1xuXHRcdFx0ZGVzYy5lbnVtZXJhYmxlID0gZW51bWVyYWJsZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZXNjcmlwdG9yc1twcm9wXSA9IGRlc2MgPSB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0ZW51bWVyYWJsZSxcblx0XHRcdFx0Z2V0KHRoaXM6IGFueSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRyZXR1cm4gb2JqZWN0VHJhcHMuZ2V0KHN0YXRlLCBwcm9wKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodGhpczogYW55LCB2YWx1ZSkge1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdFx0XHRpZiAoX19ERVZfXykgYXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0XHRvYmplY3RUcmFwcy5zZXQoc3RhdGUsIHByb3AsIHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXNjXG5cdH1cblxuXHQvLyBUaGlzIGxvb2tzIGV4cGVuc2l2ZSwgYnV0IG9ubHkgcHJveGllcyBhcmUgdmlzaXRlZCwgYW5kIG9ubHkgb2JqZWN0cyB3aXRob3V0IGtub3duIGNoYW5nZXMgYXJlIHNjYW5uZWQuXG5cdGZ1bmN0aW9uIG1hcmtDaGFuZ2VzU3dlZXAoZHJhZnRzOiBEcmFmdGVkPGFueSwgSW1tZXJTdGF0ZT5bXSkge1xuXHRcdC8vIFRoZSBuYXR1cmFsIG9yZGVyIG9mIGRyYWZ0cyBpbiB0aGUgYHNjb3BlYCBhcnJheSBpcyBiYXNlZCBvbiB3aGVuIHRoZXlcblx0XHQvLyB3ZXJlIGFjY2Vzc2VkLiBCeSBwcm9jZXNzaW5nIGRyYWZ0cyBpbiByZXZlcnNlIG5hdHVyYWwgb3JkZXIsIHdlIGhhdmUgYVxuXHRcdC8vIGJldHRlciBjaGFuY2Ugb2YgcHJvY2Vzc2luZyBsZWFmIG5vZGVzIGZpcnN0LiBXaGVuIGEgbGVhZiBub2RlIGlzIGtub3duIHRvXG5cdFx0Ly8gaGF2ZSBjaGFuZ2VkLCB3ZSBjYW4gYXZvaWQgYW55IHRyYXZlcnNhbCBvZiBpdHMgYW5jZXN0b3Igbm9kZXMuXG5cdFx0Zm9yIChsZXQgaSA9IGRyYWZ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IEVTNVN0YXRlID0gZHJhZnRzW2ldW0RSQUZUX1NUQVRFXVxuXHRcdFx0aWYgKCFzdGF0ZS5tb2RpZmllZF8pIHtcblx0XHRcdFx0c3dpdGNoIChzdGF0ZS50eXBlXykge1xuXHRcdFx0XHRcdGNhc2UgUHJveHlUeXBlRVM1QXJyYXk6XG5cdFx0XHRcdFx0XHRpZiAoaGFzQXJyYXlDaGFuZ2VzKHN0YXRlKSkgbWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdGNhc2UgUHJveHlUeXBlRVM1T2JqZWN0OlxuXHRcdFx0XHRcdFx0aWYgKGhhc09iamVjdENoYW5nZXMoc3RhdGUpKSBtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KG9iamVjdDogYW55KSB7XG5cdFx0aWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gXCJvYmplY3RcIikgcmV0dXJuXG5cdFx0Y29uc3Qgc3RhdGU6IEVTNVN0YXRlIHwgdW5kZWZpbmVkID0gb2JqZWN0W0RSQUZUX1NUQVRFXVxuXHRcdGlmICghc3RhdGUpIHJldHVyblxuXHRcdGNvbnN0IHtiYXNlXywgZHJhZnRfLCBhc3NpZ25lZF8sIHR5cGVffSA9IHN0YXRlXG5cdFx0aWYgKHR5cGVfID09PSBQcm94eVR5cGVFUzVPYmplY3QpIHtcblx0XHRcdC8vIExvb2sgZm9yIGFkZGVkIGtleXMuXG5cdFx0XHQvLyBwcm9iYWJseSB0aGVyZSBpcyBhIGZhc3RlciB3YXkgdG8gZGV0ZWN0IGNoYW5nZXMsIGFzIHN3ZWVwICsgcmVjdXJzZSBzZWVtcyB0byBkbyBzb21lXG5cdFx0XHQvLyB1bm5lY2Vzc2FyeSB3b3JrLlxuXHRcdFx0Ly8gYWxzbzogcHJvYmFibHkgd2UgY2FuIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiB3ZSBkZXRlY3QgaGVyZSwgdG8gc3BlZWQgdXAgdHJlZSBmaW5hbGl6YXRpb24hXG5cdFx0XHRlYWNoKGRyYWZ0Xywga2V5ID0+IHtcblx0XHRcdFx0aWYgKChrZXkgYXMgYW55KSA9PT0gRFJBRlRfU1RBVEUpIHJldHVyblxuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoKGJhc2VfIGFzIGFueSlba2V5XSA9PT0gdW5kZWZpbmVkICYmICFoYXMoYmFzZV8sIGtleSkpIHtcblx0XHRcdFx0XHRhc3NpZ25lZF9ba2V5XSA9IHRydWVcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fSBlbHNlIGlmICghYXNzaWduZWRfW2tleV0pIHtcblx0XHRcdFx0XHQvLyBPbmx5IHVudG91Y2hlZCBwcm9wZXJ0aWVzIHRyaWdnZXIgcmVjdXJzaW9uLlxuXHRcdFx0XHRcdG1hcmtDaGFuZ2VzUmVjdXJzaXZlbHkoZHJhZnRfW2tleV0pXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0XHQvLyBMb29rIGZvciByZW1vdmVkIGtleXMuXG5cdFx0XHRlYWNoKGJhc2VfLCBrZXkgPT4ge1xuXHRcdFx0XHQvLyBUaGUgYHVuZGVmaW5lZGAgY2hlY2sgaXMgYSBmYXN0IHBhdGggZm9yIHByZS1leGlzdGluZyBrZXlzLlxuXHRcdFx0XHRpZiAoZHJhZnRfW2tleV0gPT09IHVuZGVmaW5lZCAmJiAhaGFzKGRyYWZ0Xywga2V5KSkge1xuXHRcdFx0XHRcdGFzc2lnbmVkX1trZXldID0gZmFsc2Vcblx0XHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9IGVsc2UgaWYgKHR5cGVfID09PSBQcm94eVR5cGVFUzVBcnJheSkge1xuXHRcdFx0aWYgKGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSBhcyBFUzVBcnJheVN0YXRlKSkge1xuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0YXNzaWduZWRfLmxlbmd0aCA9IHRydWVcblx0XHRcdH1cblxuXHRcdFx0aWYgKGRyYWZ0Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IGRyYWZ0Xy5sZW5ndGg7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykgYXNzaWduZWRfW2ldID0gZmFsc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAobGV0IGkgPSBiYXNlXy5sZW5ndGg7IGkgPCBkcmFmdF8ubGVuZ3RoOyBpKyspIGFzc2lnbmVkX1tpXSA9IHRydWVcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWluaW11bSBjb3VudCBpcyBlbm91Z2gsIHRoZSBvdGhlciBwYXJ0cyBoYXMgYmVlbiBwcm9jZXNzZWQuXG5cdFx0XHRjb25zdCBtaW4gPSBNYXRoLm1pbihkcmFmdF8ubGVuZ3RoLCBiYXNlXy5sZW5ndGgpXG5cblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbWluOyBpKyspIHtcblx0XHRcdFx0Ly8gT25seSB1bnRvdWNoZWQgaW5kaWNlcyB0cmlnZ2VyIHJlY3Vyc2lvbi5cblx0XHRcdFx0aWYgKGFzc2lnbmVkX1tpXSA9PT0gdW5kZWZpbmVkKSBtYXJrQ2hhbmdlc1JlY3Vyc2l2ZWx5KGRyYWZ0X1tpXSlcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYXNPYmplY3RDaGFuZ2VzKHN0YXRlOiBFUzVPYmplY3RTdGF0ZSkge1xuXHRcdGNvbnN0IHtiYXNlXywgZHJhZnRffSA9IHN0YXRlXG5cblx0XHQvLyBTZWFyY2ggZm9yIGFkZGVkIGtleXMgYW5kIGNoYW5nZWQga2V5cy4gU3RhcnQgYXQgdGhlIGJhY2ssIGJlY2F1c2Vcblx0XHQvLyBub24tbnVtZXJpYyBrZXlzIGFyZSBvcmRlcmVkIGJ5IHRpbWUgb2YgZGVmaW5pdGlvbiBvbiB0aGUgb2JqZWN0LlxuXHRcdGNvbnN0IGtleXMgPSBvd25LZXlzKGRyYWZ0Xylcblx0XHRmb3IgKGxldCBpID0ga2V5cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0Y29uc3Qga2V5OiBhbnkgPSBrZXlzW2ldXG5cdFx0XHRpZiAoa2V5ID09PSBEUkFGVF9TVEFURSkgY29udGludWVcblx0XHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VfW2tleV1cblx0XHRcdC8vIFRoZSBgdW5kZWZpbmVkYCBjaGVjayBpcyBhIGZhc3QgcGF0aCBmb3IgcHJlLWV4aXN0aW5nIGtleXMuXG5cdFx0XHRpZiAoYmFzZVZhbHVlID09PSB1bmRlZmluZWQgJiYgIWhhcyhiYXNlXywga2V5KSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gT25jZSBhIGJhc2Uga2V5IGlzIGRlbGV0ZWQsIGZ1dHVyZSBjaGFuZ2VzIGdvIHVuZGV0ZWN0ZWQsIGJlY2F1c2UgaXRzXG5cdFx0XHQvLyBkZXNjcmlwdG9yIGlzIGVyYXNlZC4gVGhpcyBicmFuY2ggZGV0ZWN0cyBhbnkgbWlzc2VkIGNoYW5nZXMuXG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBkcmFmdF9ba2V5XVxuXHRcdFx0XHRjb25zdCBzdGF0ZTogSW1tZXJTdGF0ZSA9IHZhbHVlICYmIHZhbHVlW0RSQUZUX1NUQVRFXVxuXHRcdFx0XHRpZiAoc3RhdGUgPyBzdGF0ZS5iYXNlXyAhPT0gYmFzZVZhbHVlIDogIWlzKHZhbHVlLCBiYXNlVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEF0IHRoaXMgcG9pbnQsIG5vIGtleXMgd2VyZSBhZGRlZCBvciBjaGFuZ2VkLlxuXHRcdC8vIENvbXBhcmUga2V5IGNvdW50IHRvIGRldGVybWluZSBpZiBrZXlzIHdlcmUgZGVsZXRlZC5cblx0XHRjb25zdCBiYXNlSXNEcmFmdCA9ICEhYmFzZV9bRFJBRlRfU1RBVEUgYXMgYW55XVxuXHRcdHJldHVybiBrZXlzLmxlbmd0aCAhPT0gb3duS2V5cyhiYXNlXykubGVuZ3RoICsgKGJhc2VJc0RyYWZ0ID8gMCA6IDEpIC8vICsgMSB0byBjb3JyZWN0IGZvciBEUkFGVF9TVEFURVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFzQXJyYXlDaGFuZ2VzKHN0YXRlOiBFUzVBcnJheVN0YXRlKSB7XG5cdFx0Y29uc3Qge2RyYWZ0X30gPSBzdGF0ZVxuXHRcdGlmIChkcmFmdF8ubGVuZ3RoICE9PSBzdGF0ZS5iYXNlXy5sZW5ndGgpIHJldHVybiB0cnVlXG5cdFx0Ly8gU2VlICMxMTZcblx0XHQvLyBJZiB3ZSBmaXJzdCBzaG9ydGVuIHRoZSBsZW5ndGgsIG91ciBhcnJheSBpbnRlcmNlcHRvcnMgd2lsbCBiZSByZW1vdmVkLlxuXHRcdC8vIElmIGFmdGVyIHRoYXQgbmV3IGl0ZW1zIGFyZSBhZGRlZCwgcmVzdWx0IGluIHRoZSBzYW1lIG9yaWdpbmFsIGxlbmd0aCxcblx0XHQvLyB0aG9zZSBsYXN0IGl0ZW1zIHdpbGwgaGF2ZSBubyBpbnRlcmNlcHRpbmcgcHJvcGVydHkuXG5cdFx0Ly8gU28gaWYgdGhlcmUgaXMgbm8gb3duIGRlc2NyaXB0b3Igb24gdGhlIGxhc3QgcG9zaXRpb24sIHdlIGtub3cgdGhhdCBpdGVtcyB3ZXJlIHJlbW92ZWQgYW5kIGFkZGVkXG5cdFx0Ly8gTi5CLjogc3BsaWNlLCB1bnNoaWZ0LCBldGMgb25seSBzaGlmdCB2YWx1ZXMgYXJvdW5kLCBidXQgbm90IHByb3AgZGVzY3JpcHRvcnMsIHNvIHdlIG9ubHkgaGF2ZSB0byBjaGVja1xuXHRcdC8vIHRoZSBsYXN0IG9uZVxuXHRcdGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFxuXHRcdFx0ZHJhZnRfLFxuXHRcdFx0ZHJhZnRfLmxlbmd0aCAtIDFcblx0XHQpXG5cdFx0Ly8gZGVzY3JpcHRvciBjYW4gYmUgbnVsbCwgYnV0IG9ubHkgZm9yIG5ld2x5IGNyZWF0ZWQgc3BhcnNlIGFycmF5cywgZWcuIG5ldyBBcnJheSgxMClcblx0XHRpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5nZXQpIHJldHVybiB0cnVlXG5cdFx0Ly8gRm9yIGFsbCBvdGhlciBjYXNlcywgd2UgZG9uJ3QgaGF2ZSB0byBjb21wYXJlLCBhcyB0aGV5IHdvdWxkIGhhdmUgYmVlbiBwaWNrZWQgdXAgYnkgdGhlIGluZGV4IHNldHRlcnNcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXG5cdGZ1bmN0aW9uIGhhc0NoYW5nZXNfKHN0YXRlOiBFUzVTdGF0ZSkge1xuXHRcdHJldHVybiBzdGF0ZS50eXBlXyA9PT0gUHJveHlUeXBlRVM1T2JqZWN0XG5cdFx0XHQ/IGhhc09iamVjdENoYW5nZXMoc3RhdGUpXG5cdFx0XHQ6IGhhc0FycmF5Q2hhbmdlcyhzdGF0ZSlcblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZTogYW55IC8qRVM1U3RhdGUgfCBNYXBTdGF0ZSB8IFNldFN0YXRlKi8pIHtcblx0XHRpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSlcblx0fVxuXG5cdGxvYWRQbHVnaW4oXCJFUzVcIiwge1xuXHRcdGNyZWF0ZUVTNVByb3h5Xyxcblx0XHR3aWxsRmluYWxpemVFUzVfLFxuXHRcdGhhc0NoYW5nZXNfXG5cdH0pXG59XG4iLCJpbXBvcnQge1xuXHRJbW1lclN0YXRlLFxuXHRQYXRjaCxcblx0U2V0U3RhdGUsXG5cdEVTNUFycmF5U3RhdGUsXG5cdFByb3h5QXJyYXlTdGF0ZSxcblx0TWFwU3RhdGUsXG5cdEVTNU9iamVjdFN0YXRlLFxuXHRQcm94eU9iamVjdFN0YXRlLFxuXHRQYXRjaFBhdGgsXG5cdGdldCxcblx0ZWFjaCxcblx0aGFzLFxuXHRnZXRBcmNodHlwZSxcblx0aXNTZXQsXG5cdGlzTWFwLFxuXHRsb2FkUGx1Z2luLFxuXHRQcm94eVR5cGVQcm94eU9iamVjdCxcblx0UHJveHlUeXBlRVM1T2JqZWN0LFxuXHRQcm94eVR5cGVNYXAsXG5cdFByb3h5VHlwZUVTNUFycmF5LFxuXHRQcm94eVR5cGVQcm94eUFycmF5LFxuXHRQcm94eVR5cGVTZXQsXG5cdEFyY2h0eXBlTWFwLFxuXHRBcmNodHlwZVNldCxcblx0QXJjaHR5cGVBcnJheSxcblx0ZGllLFxuXHRpc0RyYWZ0LFxuXHRpc0RyYWZ0YWJsZVxufSBmcm9tIFwiLi4vaW50ZXJuYWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlUGF0Y2hlcygpIHtcblx0Y29uc3QgUkVQTEFDRSA9IFwicmVwbGFjZVwiXG5cdGNvbnN0IEFERCA9IFwiYWRkXCJcblx0Y29uc3QgUkVNT1ZFID0gXCJyZW1vdmVcIlxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc18oXG5cdFx0c3RhdGU6IEltbWVyU3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCk6IHZvaWQge1xuXHRcdHN3aXRjaCAoc3RhdGUudHlwZV8pIHtcblx0XHRcdGNhc2UgUHJveHlUeXBlUHJveHlPYmplY3Q6XG5cdFx0XHRjYXNlIFByb3h5VHlwZUVTNU9iamVjdDpcblx0XHRcdGNhc2UgUHJveHlUeXBlTWFwOlxuXHRcdFx0XHRyZXR1cm4gZ2VuZXJhdGVQYXRjaGVzRnJvbUFzc2lnbmVkKFxuXHRcdFx0XHRcdHN0YXRlLFxuXHRcdFx0XHRcdGJhc2VQYXRoLFxuXHRcdFx0XHRcdHBhdGNoZXMsXG5cdFx0XHRcdFx0aW52ZXJzZVBhdGNoZXNcblx0XHRcdFx0KVxuXHRcdFx0Y2FzZSBQcm94eVR5cGVFUzVBcnJheTpcblx0XHRcdGNhc2UgUHJveHlUeXBlUHJveHlBcnJheTpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlQXJyYXlQYXRjaGVzKHN0YXRlLCBiYXNlUGF0aCwgcGF0Y2hlcywgaW52ZXJzZVBhdGNoZXMpXG5cdFx0XHRjYXNlIFByb3h5VHlwZVNldDpcblx0XHRcdFx0cmV0dXJuIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRcdFx0XHQoc3RhdGUgYXMgYW55KSBhcyBTZXRTdGF0ZSxcblx0XHRcdFx0XHRiYXNlUGF0aCxcblx0XHRcdFx0XHRwYXRjaGVzLFxuXHRcdFx0XHRcdGludmVyc2VQYXRjaGVzXG5cdFx0XHRcdClcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZUFycmF5UGF0Y2hlcyhcblx0XHRzdGF0ZTogRVM1QXJyYXlTdGF0ZSB8IFByb3h5QXJyYXlTdGF0ZSxcblx0XHRiYXNlUGF0aDogUGF0Y2hQYXRoLFxuXHRcdHBhdGNoZXM6IFBhdGNoW10sXG5cdFx0aW52ZXJzZVBhdGNoZXM6IFBhdGNoW11cblx0KSB7XG5cdFx0bGV0IHtiYXNlXywgYXNzaWduZWRffSA9IHN0YXRlXG5cdFx0bGV0IGNvcHlfID0gc3RhdGUuY29weV8hXG5cblx0XHQvLyBSZWR1Y2UgY29tcGxleGl0eSBieSBlbnN1cmluZyBgYmFzZWAgaXMgbmV2ZXIgbG9uZ2VyLlxuXHRcdGlmIChjb3B5Xy5sZW5ndGggPCBiYXNlXy5sZW5ndGgpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdDtbYmFzZV8sIGNvcHlfXSA9IFtjb3B5XywgYmFzZV9dXG5cdFx0XHQ7W3BhdGNoZXMsIGludmVyc2VQYXRjaGVzXSA9IFtpbnZlcnNlUGF0Y2hlcywgcGF0Y2hlc11cblx0XHR9XG5cblx0XHQvLyBQcm9jZXNzIHJlcGxhY2VkIGluZGljZXMuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBiYXNlXy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFzc2lnbmVkX1tpXSAmJiBjb3B5X1tpXSAhPT0gYmFzZV9baV0pIHtcblx0XHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChbaV0pXG5cdFx0XHRcdHBhdGNoZXMucHVzaCh7XG5cdFx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHQvLyBOZWVkIHRvIG1heWJlIGNsb25lIGl0LCBhcyBpdCBjYW4gaW4gZmFjdCBiZSB0aGUgb3JpZ2luYWwgdmFsdWVcblx0XHRcdFx0XHQvLyBkdWUgdG8gdGhlIGJhc2UvY29weSBpbnZlcnNpb24gYXQgdGhlIHN0YXJ0IG9mIHRoaXMgZnVuY3Rpb25cblx0XHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGludmVyc2VQYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRVBMQUNFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKGJhc2VfW2ldKVxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByb2Nlc3MgYWRkZWQgaW5kaWNlcy5cblx0XHRmb3IgKGxldCBpID0gYmFzZV8ubGVuZ3RoOyBpIDwgY29weV8ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0cGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IEFERCxcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0Ly8gTmVlZCB0byBtYXliZSBjbG9uZSBpdCwgYXMgaXQgY2FuIGluIGZhY3QgYmUgdGhlIG9yaWdpbmFsIHZhbHVlXG5cdFx0XHRcdC8vIGR1ZSB0byB0aGUgYmFzZS9jb3B5IGludmVyc2lvbiBhdCB0aGUgc3RhcnQgb2YgdGhpcyBmdW5jdGlvblxuXHRcdFx0XHR2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQoY29weV9baV0pXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRpZiAoYmFzZV8ubGVuZ3RoIDwgY29weV8ubGVuZ3RoKSB7XG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKHtcblx0XHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRcdHBhdGg6IGJhc2VQYXRoLmNvbmNhdChbXCJsZW5ndGhcIl0pLFxuXHRcdFx0XHR2YWx1ZTogYmFzZV8ubGVuZ3RoXG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdC8vIFRoaXMgaXMgdXNlZCBmb3IgYm90aCBNYXAgb2JqZWN0cyBhbmQgbm9ybWFsIG9iamVjdHMuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlUGF0Y2hlc0Zyb21Bc3NpZ25lZChcblx0XHRzdGF0ZTogTWFwU3RhdGUgfCBFUzVPYmplY3RTdGF0ZSB8IFByb3h5T2JqZWN0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGNvbnN0IHtiYXNlXywgY29weV99ID0gc3RhdGVcblx0XHRlYWNoKHN0YXRlLmFzc2lnbmVkXyEsIChrZXksIGFzc2lnbmVkVmFsdWUpID0+IHtcblx0XHRcdGNvbnN0IG9yaWdWYWx1ZSA9IGdldChiYXNlXywga2V5KVxuXHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoY29weV8hLCBrZXkpXG5cdFx0XHRjb25zdCBvcCA9ICFhc3NpZ25lZFZhbHVlID8gUkVNT1ZFIDogaGFzKGJhc2VfLCBrZXkpID8gUkVQTEFDRSA6IEFERFxuXHRcdFx0aWYgKG9yaWdWYWx1ZSA9PT0gdmFsdWUgJiYgb3AgPT09IFJFUExBQ0UpIHJldHVyblxuXHRcdFx0Y29uc3QgcGF0aCA9IGJhc2VQYXRoLmNvbmNhdChrZXkgYXMgYW55KVxuXHRcdFx0cGF0Y2hlcy5wdXNoKG9wID09PSBSRU1PVkUgPyB7b3AsIHBhdGh9IDoge29wLCBwYXRoLCB2YWx1ZX0pXG5cdFx0XHRpbnZlcnNlUGF0Y2hlcy5wdXNoKFxuXHRcdFx0XHRvcCA9PT0gQUREXG5cdFx0XHRcdFx0PyB7b3A6IFJFTU9WRSwgcGF0aH1cblx0XHRcdFx0XHQ6IG9wID09PSBSRU1PVkVcblx0XHRcdFx0XHQ/IHtvcDogQURELCBwYXRoLCB2YWx1ZTogY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQob3JpZ1ZhbHVlKX1cblx0XHRcdFx0XHQ6IHtvcDogUkVQTEFDRSwgcGF0aCwgdmFsdWU6IGNsb25lUGF0Y2hWYWx1ZUlmTmVlZGVkKG9yaWdWYWx1ZSl9XG5cdFx0XHQpXG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGdlbmVyYXRlU2V0UGF0Y2hlcyhcblx0XHRzdGF0ZTogU2V0U3RhdGUsXG5cdFx0YmFzZVBhdGg6IFBhdGNoUGF0aCxcblx0XHRwYXRjaGVzOiBQYXRjaFtdLFxuXHRcdGludmVyc2VQYXRjaGVzOiBQYXRjaFtdXG5cdCkge1xuXHRcdGxldCB7YmFzZV8sIGNvcHlffSA9IHN0YXRlXG5cblx0XHRsZXQgaSA9IDBcblx0XHRiYXNlXy5mb3JFYWNoKCh2YWx1ZTogYW55KSA9PiB7XG5cdFx0XHRpZiAoIWNvcHlfIS5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBSRU1PVkUsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogQURELFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdFx0aSA9IDBcblx0XHRjb3B5XyEuZm9yRWFjaCgodmFsdWU6IGFueSkgPT4ge1xuXHRcdFx0aWYgKCFiYXNlXy5oYXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSBiYXNlUGF0aC5jb25jYXQoW2ldKVxuXHRcdFx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0XHRcdG9wOiBBREQsXG5cdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHR2YWx1ZVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRpbnZlcnNlUGF0Y2hlcy51bnNoaWZ0KHtcblx0XHRcdFx0XHRvcDogUkVNT1ZFLFxuXHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0dmFsdWVcblx0XHRcdFx0fSlcblx0XHRcdH1cblx0XHRcdGkrK1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBnZW5lcmF0ZVJlcGxhY2VtZW50UGF0Y2hlc18oXG5cdFx0cm9vdFN0YXRlOiBJbW1lclN0YXRlLFxuXHRcdHJlcGxhY2VtZW50OiBhbnksXG5cdFx0cGF0Y2hlczogUGF0Y2hbXSxcblx0XHRpbnZlcnNlUGF0Y2hlczogUGF0Y2hbXVxuXHQpOiB2b2lkIHtcblx0XHRwYXRjaGVzLnB1c2goe1xuXHRcdFx0b3A6IFJFUExBQ0UsXG5cdFx0XHRwYXRoOiBbXSxcblx0XHRcdHZhbHVlOiByZXBsYWNlbWVudFxuXHRcdH0pXG5cdFx0aW52ZXJzZVBhdGNoZXMucHVzaCh7XG5cdFx0XHRvcDogUkVQTEFDRSxcblx0XHRcdHBhdGg6IFtdLFxuXHRcdFx0dmFsdWU6IHJvb3RTdGF0ZS5iYXNlX1xuXHRcdH0pXG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseVBhdGNoZXNfPFQ+KGRyYWZ0OiBULCBwYXRjaGVzOiBQYXRjaFtdKTogVCB7XG5cdFx0cGF0Y2hlcy5mb3JFYWNoKHBhdGNoID0+IHtcblx0XHRcdGNvbnN0IHtwYXRoLCBvcH0gPSBwYXRjaFxuXG5cdFx0XHRsZXQgYmFzZTogYW55ID0gZHJhZnRcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcblx0XHRcdFx0YmFzZSA9IGdldChiYXNlLCBwYXRoW2ldKVxuXHRcdFx0XHRpZiAodHlwZW9mIGJhc2UgIT09IFwib2JqZWN0XCIpIGRpZSgxNSwgcGF0aC5qb2luKFwiL1wiKSlcblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHlwZSA9IGdldEFyY2h0eXBlKGJhc2UpXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUocGF0Y2gudmFsdWUpIC8vIHVzZWQgdG8gY2xvbmUgcGF0Y2ggdG8gZW5zdXJlIG9yaWdpbmFsIHBhdGNoIGlzIG5vdCBtb2RpZmllZCwgc2VlICM0MTFcblx0XHRcdGNvbnN0IGtleSA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVxuXHRcdFx0c3dpdGNoIChvcCkge1xuXHRcdFx0XHRjYXNlIFJFUExBQ0U6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlTWFwOlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zZXQoa2V5LCB2YWx1ZSlcblx0XHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlU2V0OlxuXHRcdFx0XHRcdFx0XHRkaWUoMTYpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHQvLyBpZiB2YWx1ZSBpcyBhbiBvYmplY3QsIHRoZW4gaXQncyBhc3NpZ25lZCBieSByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdFx0Ly8gaW4gdGhlIGZvbGxvd2luZyBhZGQgb3IgcmVtb3ZlIG9wcywgdGhlIHZhbHVlIGZpZWxkIGluc2lkZSB0aGUgcGF0Y2ggd2lsbCBhbHNvIGJlIG1vZGlmeWVkXG5cdFx0XHRcdFx0XHRcdC8vIHNvIHdlIHVzZSB2YWx1ZSBmcm9tIHRoZSBjbG9uZWQgcGF0Y2hcblx0XHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKGJhc2Vba2V5XSA9IHZhbHVlKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBBREQ6XG5cdFx0XHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlQXJyYXk6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLnNwbGljZShrZXkgYXMgYW55LCAwLCB2YWx1ZSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGVNYXA6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLnNldChrZXksIHZhbHVlKVxuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZVNldDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGJhc2UuYWRkKHZhbHVlKVxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChiYXNlW2tleV0gPSB2YWx1ZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdGNhc2UgUkVNT1ZFOlxuXHRcdFx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0XHRcdFx0Y2FzZSBBcmNodHlwZUFycmF5OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5zcGxpY2Uoa2V5IGFzIGFueSwgMSlcblx0XHRcdFx0XHRcdGNhc2UgQXJjaHR5cGVNYXA6XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiYXNlLmRlbGV0ZShrZXkpXG5cdFx0XHRcdFx0XHRjYXNlIEFyY2h0eXBlU2V0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmFzZS5kZWxldGUocGF0Y2gudmFsdWUpXG5cdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZGVsZXRlIGJhc2Vba2V5XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRkaWUoMTcsIG9wKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRyZXR1cm4gZHJhZnRcblx0fVxuXG5cdC8vIG9wdGltaXplOiB0aGlzIGlzIHF1aXRlIGEgcGVyZm9ybWFuY2UgaGl0LCBjYW4gd2UgZGV0ZWN0IGludGVsbGlnZW50bHkgd2hlbiBpdCBpcyBuZWVkZWQ/XG5cdC8vIEUuZy4gYXV0by1kcmFmdCB3aGVuIG5ldyBvYmplY3RzIGZyb20gb3V0c2lkZSBhcmUgYXNzaWduZWQgYW5kIG1vZGlmaWVkP1xuXHQvLyAoU2VlIGZhaWxpbmcgdGVzdCB3aGVuIGRlZXBDbG9uZSBqdXN0IHJldHVybnMgb2JqKVxuXHRmdW5jdGlvbiBkZWVwQ2xvbmVQYXRjaFZhbHVlPFQ+KG9iajogVCk6IFRcblx0ZnVuY3Rpb24gZGVlcENsb25lUGF0Y2hWYWx1ZShvYmo6IGFueSkge1xuXHRcdGlmICghaXNEcmFmdGFibGUob2JqKSkgcmV0dXJuIG9ialxuXHRcdGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpXG5cdFx0aWYgKGlzTWFwKG9iaikpXG5cdFx0XHRyZXR1cm4gbmV3IE1hcChcblx0XHRcdFx0QXJyYXkuZnJvbShvYmouZW50cmllcygpKS5tYXAoKFtrLCB2XSkgPT4gW2ssIGRlZXBDbG9uZVBhdGNoVmFsdWUodildKVxuXHRcdFx0KVxuXHRcdGlmIChpc1NldChvYmopKSByZXR1cm4gbmV3IFNldChBcnJheS5mcm9tKG9iaikubWFwKGRlZXBDbG9uZVBhdGNoVmFsdWUpKVxuXHRcdGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSBjbG9uZWRba2V5XSA9IGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqW2tleV0pXG5cdFx0cmV0dXJuIGNsb25lZFxuXHR9XG5cblx0ZnVuY3Rpb24gY2xvbmVQYXRjaFZhbHVlSWZOZWVkZWQ8VD4ob2JqOiBUKTogVCB7XG5cdFx0aWYgKGlzRHJhZnQob2JqKSkge1xuXHRcdFx0cmV0dXJuIGRlZXBDbG9uZVBhdGNoVmFsdWUob2JqKVxuXHRcdH0gZWxzZSByZXR1cm4gb2JqXG5cdH1cblxuXHRsb2FkUGx1Z2luKFwiUGF0Y2hlc1wiLCB7XG5cdFx0YXBwbHlQYXRjaGVzXyxcblx0XHRnZW5lcmF0ZVBhdGNoZXNfLFxuXHRcdGdlbmVyYXRlUmVwbGFjZW1lbnRQYXRjaGVzX1xuXHR9KVxufVxuIiwiLy8gdHlwZXMgb25seSFcbmltcG9ydCB7XG5cdEltbWVyU3RhdGUsXG5cdEFueU1hcCxcblx0QW55U2V0LFxuXHRNYXBTdGF0ZSxcblx0U2V0U3RhdGUsXG5cdERSQUZUX1NUQVRFLFxuXHRnZXRDdXJyZW50U2NvcGUsXG5cdGxhdGVzdCxcblx0aXRlcmF0b3JTeW1ib2wsXG5cdGlzRHJhZnRhYmxlLFxuXHRjcmVhdGVQcm94eSxcblx0bG9hZFBsdWdpbixcblx0bWFya0NoYW5nZWQsXG5cdFByb3h5VHlwZU1hcCxcblx0UHJveHlUeXBlU2V0LFxuXHRkaWUsXG5cdGVhY2hcbn0gZnJvbSBcIi4uL2ludGVybmFsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZU1hcFNldCgpIHtcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0dmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkOiBhbnksIGI6IGFueSk6IGFueSB7XG5cdFx0ZXh0ZW5kU3RhdGljcyA9XG5cdFx0XHRPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0XHRcdCh7X19wcm90b19fOiBbXX0gaW5zdGFuY2VvZiBBcnJheSAmJlxuXHRcdFx0XHRmdW5jdGlvbihkLCBiKSB7XG5cdFx0XHRcdFx0ZC5fX3Byb3RvX18gPSBiXG5cdFx0XHRcdH0pIHx8XG5cdFx0XHRmdW5jdGlvbihkLCBiKSB7XG5cdFx0XHRcdGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdXG5cdFx0XHR9XG5cdFx0cmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYilcblx0fVxuXG5cdC8vIFVnbHkgaGFjayB0byByZXNvbHZlICM1MDIgYW5kIGluaGVyaXQgYnVpbHQgaW4gTWFwIC8gU2V0XG5cdGZ1bmN0aW9uIF9fZXh0ZW5kcyhkOiBhbnksIGI6IGFueSk6IGFueSB7XG5cdFx0ZXh0ZW5kU3RhdGljcyhkLCBiKVxuXHRcdGZ1bmN0aW9uIF9fKHRoaXM6IGFueSk6IGFueSB7XG5cdFx0XHR0aGlzLmNvbnN0cnVjdG9yID0gZFxuXHRcdH1cblx0XHRkLnByb3RvdHlwZSA9XG5cdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHQoKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlKSwgbmV3IF9fKCkpXG5cdH1cblxuXHRjb25zdCBEcmFmdE1hcCA9IChmdW5jdGlvbihfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoRHJhZnRNYXAsIF9zdXBlcilcblx0XHQvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblx0XHRmdW5jdGlvbiBEcmFmdE1hcCh0aGlzOiBhbnksIHRhcmdldDogQW55TWFwLCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogYW55IHtcblx0XHRcdHRoaXNbRFJBRlRfU1RBVEVdID0ge1xuXHRcdFx0XHR0eXBlXzogUHJveHlUeXBlTWFwLFxuXHRcdFx0XHRwYXJlbnRfOiBwYXJlbnQsXG5cdFx0XHRcdHNjb3BlXzogcGFyZW50ID8gcGFyZW50LnNjb3BlXyA6IGdldEN1cnJlbnRTY29wZSgpISxcblx0XHRcdFx0bW9kaWZpZWRfOiBmYWxzZSxcblx0XHRcdFx0ZmluYWxpemVkXzogZmFsc2UsXG5cdFx0XHRcdGNvcHlfOiB1bmRlZmluZWQsXG5cdFx0XHRcdGFzc2lnbmVkXzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMgYXMgYW55LFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlLFxuXHRcdFx0XHRyZXZva2VkXzogZmFsc2Vcblx0XHRcdH0gYXMgTWFwU3RhdGVcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXHRcdGNvbnN0IHAgPSBEcmFmdE1hcC5wcm90b3R5cGVcblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwLCBcInNpemVcIiwge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuc2l6ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gZW51bWVyYWJsZTogZmFsc2UsXG5cdFx0XHQvLyBjb25maWd1cmFibGU6IHRydWVcblx0XHR9KVxuXG5cdFx0cC5oYXMgPSBmdW5jdGlvbihrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkuaGFzKGtleSlcblx0XHR9XG5cblx0XHRwLnNldCA9IGZ1bmN0aW9uKGtleTogYW55LCB2YWx1ZTogYW55KSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKCFsYXRlc3Qoc3RhdGUpLmhhcyhrZXkpIHx8IGxhdGVzdChzdGF0ZSkuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG5cdFx0XHRcdHByZXBhcmVNYXBDb3B5KHN0YXRlKVxuXHRcdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdFx0c3RhdGUuYXNzaWduZWRfIS5zZXQoa2V5LCB0cnVlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuc2V0KGtleSwgdmFsdWUpXG5cdFx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgdHJ1ZSlcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0cC5kZWxldGUgPSBmdW5jdGlvbihrZXk6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0aWYgKCF0aGlzLmhhcyhrZXkpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzdGF0ZTogTWFwU3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRtYXJrQ2hhbmdlZChzdGF0ZSlcblx0XHRcdHN0YXRlLmFzc2lnbmVkXyEuc2V0KGtleSwgZmFsc2UpXG5cdFx0XHRzdGF0ZS5jb3B5XyEuZGVsZXRlKGtleSlcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fVxuXG5cdFx0cC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGlmIChsYXRlc3Qoc3RhdGUpLnNpemUpIHtcblx0XHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKClcblx0XHRcdFx0ZWFjaChzdGF0ZS5iYXNlXywga2V5ID0+IHtcblx0XHRcdFx0XHRzdGF0ZS5hc3NpZ25lZF8hLnNldChrZXksIGZhbHNlKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuY2xlYXIoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHAuZm9yRWFjaCA9IGZ1bmN0aW9uKFxuXHRcdFx0Y2I6ICh2YWx1ZTogYW55LCBrZXk6IGFueSwgc2VsZjogYW55KSA9PiB2b2lkLFxuXHRcdFx0dGhpc0FyZz86IGFueVxuXHRcdCkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGxhdGVzdChzdGF0ZSkuZm9yRWFjaCgoX3ZhbHVlOiBhbnksIGtleTogYW55LCBfbWFwOiBhbnkpID0+IHtcblx0XHRcdFx0Y2IuY2FsbCh0aGlzQXJnLCB0aGlzLmdldChrZXkpLCBrZXksIHRoaXMpXG5cdFx0XHR9KVxuXHRcdH1cblxuXHRcdHAuZ2V0ID0gZnVuY3Rpb24oa2V5OiBhbnkpOiBhbnkge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IE1hcFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdGNvbnN0IHZhbHVlID0gbGF0ZXN0KHN0YXRlKS5nZXQoa2V5KVxuXHRcdFx0aWYgKHN0YXRlLmZpbmFsaXplZF8gfHwgIWlzRHJhZnRhYmxlKHZhbHVlKSkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVcblx0XHRcdH1cblx0XHRcdGlmICh2YWx1ZSAhPT0gc3RhdGUuYmFzZV8uZ2V0KGtleSkpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlIC8vIGVpdGhlciBhbHJlYWR5IGRyYWZ0ZWQgb3IgcmVhc3NpZ25lZFxuXHRcdFx0fVxuXHRcdFx0Ly8gZGVzcGl0ZSB3aGF0IGl0IGxvb2tzLCB0aGlzIGNyZWF0ZXMgYSBkcmFmdCBvbmx5IG9uY2UsIHNlZSBhYm92ZSBjb25kaXRpb25cblx0XHRcdGNvbnN0IGRyYWZ0ID0gY3JlYXRlUHJveHkoc3RhdGUuc2NvcGVfLmltbWVyXywgdmFsdWUsIHN0YXRlKVxuXHRcdFx0cHJlcGFyZU1hcENvcHkoc3RhdGUpXG5cdFx0XHRzdGF0ZS5jb3B5XyEuc2V0KGtleSwgZHJhZnQpXG5cdFx0XHRyZXR1cm4gZHJhZnRcblx0XHR9XG5cblx0XHRwLmtleXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0cmV0dXJuIGxhdGVzdCh0aGlzW0RSQUZUX1NUQVRFXSkua2V5cygpXG5cdFx0fVxuXG5cdFx0cC52YWx1ZXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0W2l0ZXJhdG9yU3ltYm9sXTogKCkgPT4gdGhpcy52YWx1ZXMoKSxcblx0XHRcdFx0bmV4dDogKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcblx0XHRcdFx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXHRcdFx0XHRcdGlmIChyLmRvbmUpIHJldHVybiByXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSB0aGlzLmdldChyLnZhbHVlKVxuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRkb25lOiBmYWxzZSxcblx0XHRcdFx0XHRcdHZhbHVlXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGFzIGFueVxuXHRcdH1cblxuXHRcdHAuZW50cmllcyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8W2FueSwgYW55XT4ge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLmtleXMoKVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0W2l0ZXJhdG9yU3ltYm9sXTogKCkgPT4gdGhpcy5lbnRyaWVzKCksXG5cdFx0XHRcdG5leHQ6ICgpID0+IHtcblx0XHRcdFx0XHRjb25zdCByID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHRcdFx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblx0XHRcdFx0XHRpZiAoci5kb25lKSByZXR1cm4gclxuXHRcdFx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5nZXQoci52YWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0ZG9uZTogZmFsc2UsXG5cdFx0XHRcdFx0XHR2YWx1ZTogW3IudmFsdWUsIHZhbHVlXVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBhcyBhbnlcblx0XHR9XG5cblx0XHRwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZW50cmllcygpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIERyYWZ0TWFwXG5cdH0pKE1hcClcblxuXHRmdW5jdGlvbiBwcm94eU1hcF88VCBleHRlbmRzIEFueU1hcD4odGFyZ2V0OiBULCBwYXJlbnQ/OiBJbW1lclN0YXRlKTogVCB7XG5cdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdHJldHVybiBuZXcgRHJhZnRNYXAodGFyZ2V0LCBwYXJlbnQpXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVwYXJlTWFwQ29weShzdGF0ZTogTWFwU3RhdGUpIHtcblx0XHRpZiAoIXN0YXRlLmNvcHlfKSB7XG5cdFx0XHRzdGF0ZS5hc3NpZ25lZF8gPSBuZXcgTWFwKClcblx0XHRcdHN0YXRlLmNvcHlfID0gbmV3IE1hcChzdGF0ZS5iYXNlXylcblx0XHR9XG5cdH1cblxuXHRjb25zdCBEcmFmdFNldCA9IChmdW5jdGlvbihfc3VwZXIpIHtcblx0XHRfX2V4dGVuZHMoRHJhZnRTZXQsIF9zdXBlcilcblx0XHQvLyBDcmVhdGUgY2xhc3MgbWFudWFsbHksIGNhdXNlICM1MDJcblx0XHRmdW5jdGlvbiBEcmFmdFNldCh0aGlzOiBhbnksIHRhcmdldDogQW55U2V0LCBwYXJlbnQ/OiBJbW1lclN0YXRlKSB7XG5cdFx0XHR0aGlzW0RSQUZUX1NUQVRFXSA9IHtcblx0XHRcdFx0dHlwZV86IFByb3h5VHlwZVNldCxcblx0XHRcdFx0cGFyZW50XzogcGFyZW50LFxuXHRcdFx0XHRzY29wZV86IHBhcmVudCA/IHBhcmVudC5zY29wZV8gOiBnZXRDdXJyZW50U2NvcGUoKSEsXG5cdFx0XHRcdG1vZGlmaWVkXzogZmFsc2UsXG5cdFx0XHRcdGZpbmFsaXplZF86IGZhbHNlLFxuXHRcdFx0XHRjb3B5XzogdW5kZWZpbmVkLFxuXHRcdFx0XHRiYXNlXzogdGFyZ2V0LFxuXHRcdFx0XHRkcmFmdF86IHRoaXMsXG5cdFx0XHRcdGRyYWZ0c186IG5ldyBNYXAoKSxcblx0XHRcdFx0cmV2b2tlZF86IGZhbHNlLFxuXHRcdFx0XHRpc01hbnVhbF86IGZhbHNlXG5cdFx0XHR9IGFzIFNldFN0YXRlXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHRjb25zdCBwID0gRHJhZnRTZXQucHJvdG90eXBlXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocCwgXCJzaXplXCIsIHtcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBsYXRlc3QodGhpc1tEUkFGVF9TVEFURV0pLnNpemVcblx0XHRcdH1cblx0XHRcdC8vIGVudW1lcmFibGU6IHRydWUsXG5cdFx0fSlcblxuXHRcdHAuaGFzID0gZnVuY3Rpb24odmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdC8vIGJpdCBvZiB0cmlja2VyeSBoZXJlLCB0byBiZSBhYmxlIHRvIHJlY29nbml6ZSBib3RoIHRoZSB2YWx1ZSwgYW5kIHRoZSBkcmFmdCBvZiBpdHMgdmFsdWVcblx0XHRcdGlmICghc3RhdGUuY29weV8pIHtcblx0XHRcdFx0cmV0dXJuIHN0YXRlLmJhc2VfLmhhcyh2YWx1ZSlcblx0XHRcdH1cblx0XHRcdGlmIChzdGF0ZS5jb3B5Xy5oYXModmFsdWUpKSByZXR1cm4gdHJ1ZVxuXHRcdFx0aWYgKHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKSAmJiBzdGF0ZS5jb3B5Xy5oYXMoc3RhdGUuZHJhZnRzXy5nZXQodmFsdWUpKSlcblx0XHRcdFx0cmV0dXJuIHRydWVcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblxuXHRcdHAuYWRkID0gZnVuY3Rpb24odmFsdWU6IGFueSk6IGFueSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKHZhbHVlKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHRwLmRlbGV0ZSA9IGZ1bmN0aW9uKHZhbHVlOiBhbnkpOiBhbnkge1xuXHRcdFx0aWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHN0YXRlOiBTZXRTdGF0ZSA9IHRoaXNbRFJBRlRfU1RBVEVdXG5cdFx0XHRhc3NlcnRVbnJldm9rZWQoc3RhdGUpXG5cdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdG1hcmtDaGFuZ2VkKHN0YXRlKVxuXHRcdFx0cmV0dXJuIChcblx0XHRcdFx0c3RhdGUuY29weV8hLmRlbGV0ZSh2YWx1ZSkgfHxcblx0XHRcdFx0KHN0YXRlLmRyYWZ0c18uaGFzKHZhbHVlKVxuXHRcdFx0XHRcdD8gc3RhdGUuY29weV8hLmRlbGV0ZShzdGF0ZS5kcmFmdHNfLmdldCh2YWx1ZSkpXG5cdFx0XHRcdFx0OiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmYWxzZSlcblx0XHRcdClcblx0XHR9XG5cblx0XHRwLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0aWYgKGxhdGVzdChzdGF0ZSkuc2l6ZSkge1xuXHRcdFx0XHRwcmVwYXJlU2V0Q29weShzdGF0ZSlcblx0XHRcdFx0bWFya0NoYW5nZWQoc3RhdGUpXG5cdFx0XHRcdHN0YXRlLmNvcHlfIS5jbGVhcigpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cC52YWx1ZXMgPSBmdW5jdGlvbigpOiBJdGVyYWJsZUl0ZXJhdG9yPGFueT4ge1xuXHRcdFx0Y29uc3Qgc3RhdGU6IFNldFN0YXRlID0gdGhpc1tEUkFGVF9TVEFURV1cblx0XHRcdGFzc2VydFVucmV2b2tlZChzdGF0ZSlcblx0XHRcdHByZXBhcmVTZXRDb3B5KHN0YXRlKVxuXHRcdFx0cmV0dXJuIHN0YXRlLmNvcHlfIS52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHAuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMoKTogSXRlcmFibGVJdGVyYXRvcjxbYW55LCBhbnldPiB7XG5cdFx0XHRjb25zdCBzdGF0ZTogU2V0U3RhdGUgPSB0aGlzW0RSQUZUX1NUQVRFXVxuXHRcdFx0YXNzZXJ0VW5yZXZva2VkKHN0YXRlKVxuXHRcdFx0cHJlcGFyZVNldENvcHkoc3RhdGUpXG5cdFx0XHRyZXR1cm4gc3RhdGUuY29weV8hLmVudHJpZXMoKVxuXHRcdH1cblxuXHRcdHAua2V5cyA9IGZ1bmN0aW9uKCk6IEl0ZXJhYmxlSXRlcmF0b3I8YW55PiB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHBbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy52YWx1ZXMoKVxuXHRcdH1cblxuXHRcdHAuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goY2I6IGFueSwgdGhpc0FyZz86IGFueSkge1xuXHRcdFx0Y29uc3QgaXRlcmF0b3IgPSB0aGlzLnZhbHVlcygpXG5cdFx0XHRsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpXG5cdFx0XHR3aGlsZSAoIXJlc3VsdC5kb25lKSB7XG5cdFx0XHRcdGNiLmNhbGwodGhpc0FyZywgcmVzdWx0LnZhbHVlLCByZXN1bHQudmFsdWUsIHRoaXMpXG5cdFx0XHRcdHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBEcmFmdFNldFxuXHR9KShTZXQpXG5cblx0ZnVuY3Rpb24gcHJveHlTZXRfPFQgZXh0ZW5kcyBBbnlTZXQ+KHRhcmdldDogVCwgcGFyZW50PzogSW1tZXJTdGF0ZSk6IFQge1xuXHRcdC8vIEB0cy1pZ25vcmVcblx0XHRyZXR1cm4gbmV3IERyYWZ0U2V0KHRhcmdldCwgcGFyZW50KVxuXHR9XG5cblx0ZnVuY3Rpb24gcHJlcGFyZVNldENvcHkoc3RhdGU6IFNldFN0YXRlKSB7XG5cdFx0aWYgKCFzdGF0ZS5jb3B5Xykge1xuXHRcdFx0Ly8gY3JlYXRlIGRyYWZ0cyBmb3IgYWxsIGVudHJpZXMgdG8gcHJlc2VydmUgaW5zZXJ0aW9uIG9yZGVyXG5cdFx0XHRzdGF0ZS5jb3B5XyA9IG5ldyBTZXQoKVxuXHRcdFx0c3RhdGUuYmFzZV8uZm9yRWFjaCh2YWx1ZSA9PiB7XG5cdFx0XHRcdGlmIChpc0RyYWZ0YWJsZSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRjb25zdCBkcmFmdCA9IGNyZWF0ZVByb3h5KHN0YXRlLnNjb3BlXy5pbW1lcl8sIHZhbHVlLCBzdGF0ZSlcblx0XHRcdFx0XHRzdGF0ZS5kcmFmdHNfLnNldCh2YWx1ZSwgZHJhZnQpXG5cdFx0XHRcdFx0c3RhdGUuY29weV8hLmFkZChkcmFmdClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0ZS5jb3B5XyEuYWRkKHZhbHVlKVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFzc2VydFVucmV2b2tlZChzdGF0ZTogYW55IC8qRVM1U3RhdGUgfCBNYXBTdGF0ZSB8IFNldFN0YXRlKi8pIHtcblx0XHRpZiAoc3RhdGUucmV2b2tlZF8pIGRpZSgzLCBKU09OLnN0cmluZ2lmeShsYXRlc3Qoc3RhdGUpKSlcblx0fVxuXG5cdGxvYWRQbHVnaW4oXCJNYXBTZXRcIiwge3Byb3h5TWFwXywgcHJveHlTZXRffSlcbn1cbiIsImltcG9ydCB7ZW5hYmxlRVM1fSBmcm9tIFwiLi9lczVcIlxuaW1wb3J0IHtlbmFibGVNYXBTZXR9IGZyb20gXCIuL21hcHNldFwiXG5pbXBvcnQge2VuYWJsZVBhdGNoZXN9IGZyb20gXCIuL3BhdGNoZXNcIlxuXG5leHBvcnQgZnVuY3Rpb24gZW5hYmxlQWxsUGx1Z2lucygpIHtcblx0ZW5hYmxlRVM1KClcblx0ZW5hYmxlTWFwU2V0KClcblx0ZW5hYmxlUGF0Y2hlcygpXG59XG4iLCJpbXBvcnQge1xuXHRJUHJvZHVjZSxcblx0SVByb2R1Y2VXaXRoUGF0Y2hlcyxcblx0SW1tZXIsXG5cdERyYWZ0LFxuXHRJbW11dGFibGVcbn0gZnJvbSBcIi4vaW50ZXJuYWxcIlxuXG5leHBvcnQge1xuXHREcmFmdCxcblx0SW1tdXRhYmxlLFxuXHRQYXRjaCxcblx0UGF0Y2hMaXN0ZW5lcixcblx0b3JpZ2luYWwsXG5cdGN1cnJlbnQsXG5cdGlzRHJhZnQsXG5cdGlzRHJhZnRhYmxlLFxuXHROT1RISU5HIGFzIG5vdGhpbmcsXG5cdERSQUZUQUJMRSBhcyBpbW1lcmFibGVcbn0gZnJvbSBcIi4vaW50ZXJuYWxcIlxuXG5jb25zdCBpbW1lciA9IG5ldyBJbW1lcigpXG5cbi8qKlxuICogVGhlIGBwcm9kdWNlYCBmdW5jdGlvbiB0YWtlcyBhIHZhbHVlIGFuZCBhIFwicmVjaXBlIGZ1bmN0aW9uXCIgKHdob3NlXG4gKiByZXR1cm4gdmFsdWUgb2Z0ZW4gZGVwZW5kcyBvbiB0aGUgYmFzZSBzdGF0ZSkuIFRoZSByZWNpcGUgZnVuY3Rpb24gaXNcbiAqIGZyZWUgdG8gbXV0YXRlIGl0cyBmaXJzdCBhcmd1bWVudCBob3dldmVyIGl0IHdhbnRzLiBBbGwgbXV0YXRpb25zIGFyZVxuICogb25seSBldmVyIGFwcGxpZWQgdG8gYSBfX2NvcHlfXyBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAqXG4gKiBQYXNzIG9ubHkgYSBmdW5jdGlvbiB0byBjcmVhdGUgYSBcImN1cnJpZWQgcHJvZHVjZXJcIiB3aGljaCByZWxpZXZlcyB5b3VcbiAqIGZyb20gcGFzc2luZyB0aGUgcmVjaXBlIGZ1bmN0aW9uIGV2ZXJ5IHRpbWUuXG4gKlxuICogT25seSBwbGFpbiBvYmplY3RzIGFuZCBhcnJheXMgYXJlIG1hZGUgbXV0YWJsZS4gQWxsIG90aGVyIG9iamVjdHMgYXJlXG4gKiBjb25zaWRlcmVkIHVuY29weWFibGUuXG4gKlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBpcyBfX2JvdW5kX18gdG8gaXRzIGBJbW1lcmAgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHthbnl9IGJhc2UgLSB0aGUgaW5pdGlhbCBzdGF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvZHVjZXIgLSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcHJveHkgb2YgdGhlIGJhc2Ugc3RhdGUgYXMgZmlyc3QgYXJndW1lbnQgYW5kIHdoaWNoIGNhbiBiZSBmcmVlbHkgbW9kaWZpZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBhdGNoTGlzdGVuZXIgLSBvcHRpb25hbCBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHRoZSBwYXRjaGVzIHByb2R1Y2VkIGhlcmVcbiAqIEByZXR1cm5zIHthbnl9IGEgbmV3IHN0YXRlLCBvciB0aGUgaW5pdGlhbCBzdGF0ZSBpZiBub3RoaW5nIHdhcyBtb2RpZmllZFxuICovXG5leHBvcnQgY29uc3QgcHJvZHVjZTogSVByb2R1Y2UgPSBpbW1lci5wcm9kdWNlXG5leHBvcnQgZGVmYXVsdCBwcm9kdWNlXG5cbi8qKlxuICogTGlrZSBgcHJvZHVjZWAsIGJ1dCBgcHJvZHVjZVdpdGhQYXRjaGVzYCBhbHdheXMgcmV0dXJucyBhIHR1cGxlXG4gKiBbbmV4dFN0YXRlLCBwYXRjaGVzLCBpbnZlcnNlUGF0Y2hlc10gKGluc3RlYWQgb2YganVzdCB0aGUgbmV4dCBzdGF0ZSlcbiAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y2VXaXRoUGF0Y2hlczogSVByb2R1Y2VXaXRoUGF0Y2hlcyA9IGltbWVyLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKFxuXHRpbW1lclxuKVxuXG4vKipcbiAqIFBhc3MgdHJ1ZSB0byBhdXRvbWF0aWNhbGx5IGZyZWV6ZSBhbGwgY29waWVzIGNyZWF0ZWQgYnkgSW1tZXIuXG4gKlxuICogQnkgZGVmYXVsdCwgYXV0by1mcmVlemluZyBpcyBkaXNhYmxlZCBpbiBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgY29uc3Qgc2V0QXV0b0ZyZWV6ZSA9IGltbWVyLnNldEF1dG9GcmVlemUuYmluZChpbW1lcilcblxuLyoqXG4gKiBQYXNzIHRydWUgdG8gdXNlIHRoZSBFUzIwMTUgYFByb3h5YCBjbGFzcyB3aGVuIGNyZWF0aW5nIGRyYWZ0cywgd2hpY2ggaXNcbiAqIGFsd2F5cyBmYXN0ZXIgdGhhbiB1c2luZyBFUzUgcHJveGllcy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBmZWF0dXJlIGRldGVjdGlvbiBpcyB1c2VkLCBzbyBjYWxsaW5nIHRoaXMgaXMgcmFyZWx5IG5lY2Vzc2FyeS5cbiAqL1xuZXhwb3J0IGNvbnN0IHNldFVzZVByb3hpZXMgPSBpbW1lci5zZXRVc2VQcm94aWVzLmJpbmQoaW1tZXIpXG5cbi8qKlxuICogQXBwbHkgYW4gYXJyYXkgb2YgSW1tZXIgcGF0Y2hlcyB0byB0aGUgZmlyc3QgYXJndW1lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHByb2R1Y2VyLCB3aGljaCBtZWFucyBjb3B5LW9uLXdyaXRlIGlzIGluIGVmZmVjdC5cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5UGF0Y2hlcyA9IGltbWVyLmFwcGx5UGF0Y2hlcy5iaW5kKGltbWVyKVxuXG4vKipcbiAqIENyZWF0ZSBhbiBJbW1lciBkcmFmdCBmcm9tIHRoZSBnaXZlbiBiYXNlIHN0YXRlLCB3aGljaCBtYXkgYmUgYSBkcmFmdCBpdHNlbGYuXG4gKiBUaGUgZHJhZnQgY2FuIGJlIG1vZGlmaWVkIHVudGlsIHlvdSBmaW5hbGl6ZSBpdCB3aXRoIHRoZSBgZmluaXNoRHJhZnRgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRHJhZnQgPSBpbW1lci5jcmVhdGVEcmFmdC5iaW5kKGltbWVyKVxuXG4vKipcbiAqIEZpbmFsaXplIGFuIEltbWVyIGRyYWZ0IGZyb20gYSBgY3JlYXRlRHJhZnRgIGNhbGwsIHJldHVybmluZyB0aGUgYmFzZSBzdGF0ZVxuICogKGlmIG5vIGNoYW5nZXMgd2VyZSBtYWRlKSBvciBhIG1vZGlmaWVkIGNvcHkuIFRoZSBkcmFmdCBtdXN0ICpub3QqIGJlXG4gKiBtdXRhdGVkIGFmdGVyd2FyZHMuXG4gKlxuICogUGFzcyBhIGZ1bmN0aW9uIGFzIHRoZSAybmQgYXJndW1lbnQgdG8gZ2VuZXJhdGUgSW1tZXIgcGF0Y2hlcyBiYXNlZCBvbiB0aGVcbiAqIGNoYW5nZXMgdGhhdCB3ZXJlIG1hZGUuXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5pc2hEcmFmdCA9IGltbWVyLmZpbmlzaERyYWZ0LmJpbmQoaW1tZXIpXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSBhIG5vLW9wLCBidXQgY2FuIGJlIHVzZWQgdG8gY2FzdCBhbiBpbW11dGFibGUgdHlwZVxuICogdG8gYW4gZHJhZnQgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjYXN0RHJhZnQ8VD4odmFsdWU6IFQpOiBEcmFmdDxUPiB7XG5cdHJldHVybiB2YWx1ZSBhcyBhbnlcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGFjdHVhbGx5IGEgbm8tb3AsIGJ1dCBjYW4gYmUgdXNlZCB0byBjYXN0IGEgbXV0YWJsZSB0eXBlXG4gKiB0byBhbiBpbW11dGFibGUgdHlwZSBhbmQgbWFrZSBUeXBlU2NyaXB0IGhhcHB5XG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3RJbW11dGFibGU8VD4odmFsdWU6IFQpOiBJbW11dGFibGU8VD4ge1xuXHRyZXR1cm4gdmFsdWUgYXMgYW55XG59XG5cbmV4cG9ydCB7SW1tZXJ9XG5cbmV4cG9ydCB7ZW5hYmxlRVM1fSBmcm9tIFwiLi9wbHVnaW5zL2VzNVwiXG5leHBvcnQge2VuYWJsZVBhdGNoZXN9IGZyb20gXCIuL3BsdWdpbnMvcGF0Y2hlc1wiXG5leHBvcnQge2VuYWJsZU1hcFNldH0gZnJvbSBcIi4vcGx1Z2lucy9tYXBzZXRcIlxuZXhwb3J0IHtlbmFibGVBbGxQbHVnaW5zfSBmcm9tIFwiLi9wbHVnaW5zL2FsbFwiXG4iLCIvLyBTaG91bGQgYmUgbm8gaW1wb3J0cyBoZXJlIVxuXG4vLyBTb21lIHRoaW5ncyB0aGF0IHNob3VsZCBiZSBldmFsdWF0ZWQgYmVmb3JlIGFsbCBlbHNlLi4uXG5cbi8vIFdlIG9ubHkgd2FudCB0byBrbm93IGlmIG5vbi1wb2x5ZmlsbGVkIHN5bWJvbHMgYXJlIGF2YWlsYWJsZVxuY29uc3QgaGFzU3ltYm9sID1cblx0dHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgU3ltYm9sKFwieFwiKSA9PT0gXCJzeW1ib2xcIlxuZXhwb3J0IGNvbnN0IGhhc01hcCA9IHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCJcbmV4cG9ydCBjb25zdCBoYXNTZXQgPSB0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiXG5leHBvcnQgY29uc3QgaGFzUHJveGllcyA9XG5cdHR5cGVvZiBQcm94eSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHR0eXBlb2YgUHJveHkucmV2b2NhYmxlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBtaW5pKCkge31cbmV4cG9ydCBjb25zdCBpc01pbmlmaWVkID0gbWluaS5uYW1lICE9PSBcIm1pbmlcIlxuXG4vKipcbiAqIFRoZSBzZW50aW5lbCB2YWx1ZSByZXR1cm5lZCBieSBwcm9kdWNlcnMgdG8gcmVwbGFjZSB0aGUgZHJhZnQgd2l0aCB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBOT1RISU5HOiBOb3RoaW5nID0gaGFzU3ltYm9sXG5cdD8gU3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIilcblx0OiAoe1tcImltbWVyLW5vdGhpbmdcIl06IHRydWV9IGFzIGFueSlcblxuLyoqXG4gKiBUbyBsZXQgSW1tZXIgdHJlYXQgeW91ciBjbGFzcyBpbnN0YW5jZXMgYXMgcGxhaW4gaW1tdXRhYmxlIG9iamVjdHNcbiAqIChhbGJlaXQgd2l0aCBhIGN1c3RvbSBwcm90b3R5cGUpLCB5b3UgbXVzdCBkZWZpbmUgZWl0aGVyIGFuIGluc3RhbmNlIHByb3BlcnR5XG4gKiBvciBhIHN0YXRpYyBwcm9wZXJ0eSBvbiBlYWNoIG9mIHlvdXIgY3VzdG9tIGNsYXNzZXMuXG4gKlxuICogT3RoZXJ3aXNlLCB5b3VyIGNsYXNzIGluc3RhbmNlIHdpbGwgbmV2ZXIgYmUgZHJhZnRlZCwgd2hpY2ggbWVhbnMgaXQgd29uJ3QgYmVcbiAqIHNhZmUgdG8gbXV0YXRlIGluIGEgcHJvZHVjZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0IGNvbnN0IERSQUZUQUJMRTogdW5pcXVlIHN5bWJvbCA9IGhhc1N5bWJvbFxuXHQ/IFN5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIilcblx0OiAoXCJfXyRpbW1lcl9kcmFmdGFibGVcIiBhcyBhbnkpXG5cbmV4cG9ydCBjb25zdCBEUkFGVF9TVEFURTogdW5pcXVlIHN5bWJvbCA9IGhhc1N5bWJvbFxuXHQ/IFN5bWJvbC5mb3IoXCJpbW1lci1zdGF0ZVwiKVxuXHQ6IChcIl9fJGltbWVyX3N0YXRlXCIgYXMgYW55KVxuXG4vLyBFdmVuIGEgcG9seWZpbGxlZCBTeW1ib2wgbWlnaHQgcHJvdmlkZSBTeW1ib2wuaXRlcmF0b3JcbmV4cG9ydCBjb25zdCBpdGVyYXRvclN5bWJvbDogdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9XG5cdCh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fCAoXCJAQGl0ZXJhdG9yXCIgYXMgYW55KVxuXG4vKiogVXNlIGEgY2xhc3MgdHlwZSBmb3IgYG5vdGhpbmdgIHNvIGl0cyB0eXBlIGlzIHVuaXF1ZSAqL1xuZXhwb3J0IGNsYXNzIE5vdGhpbmcge1xuXHQvLyBUaGlzIGxldHMgdXMgZG8gYEV4Y2x1ZGU8VCwgTm90aGluZz5gXG5cdC8vIEB0cy1pZ25vcmVcblx0cHJpdmF0ZSBfITogdW5pcXVlIHN5bWJvbFxufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICdNaW5pZmllZCBleGNlcHRpb24gb2NjdXJyZWQ7IHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCAnICtcbiAgICAgICAgJ2ZvciB0aGUgZnVsbCBlcnJvciBtZXNzYWdlIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuJ1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107IH0pXG4gICAgICApO1xuICAgICAgZXJyb3IubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICB9XG5cbiAgICBlcnJvci5mcmFtZXNUb1BvcCA9IDE7IC8vIHdlIGRvbid0IGNhcmUgYWJvdXQgaW52YXJpYW50J3Mgb3duIGZyYW1lXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IHZhciBSZWFjdFJlZHV4Q29udGV4dCA9XG4vKiNfX1BVUkVfXyovXG5SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSZWFjdFJlZHV4Q29udGV4dC5kaXNwbGF5TmFtZSA9ICdSZWFjdFJlZHV4Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgUmVhY3RSZWR1eENvbnRleHQ7IiwiaW1wb3J0IFJlYWN0LCB7IHVzZU1lbW8sIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vQ29udGV4dCc7XG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5cbmZ1bmN0aW9uIFByb3ZpZGVyKF9yZWYpIHtcbiAgdmFyIHN0b3JlID0gX3JlZi5zdG9yZSxcbiAgICAgIGNvbnRleHQgPSBfcmVmLmNvbnRleHQsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYuY2hpbGRyZW47XG4gIHZhciBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbihzdG9yZSk7XG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBzdWJzY3JpcHRpb24ubm90aWZ5TmVzdGVkU3VicztcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcmU6IHN0b3JlLFxuICAgICAgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb25cbiAgICB9O1xuICB9LCBbc3RvcmVdKTtcbiAgdmFyIHByZXZpb3VzU3RhdGUgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgfSwgW3N0b3JlXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IGNvbnRleHRWYWx1ZS5zdWJzY3JpcHRpb247XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuXG4gICAgaWYgKHByZXZpb3VzU3RhdGUgIT09IHN0b3JlLmdldFN0YXRlKCkpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi50cnlVbnN1YnNjcmliZSgpO1xuICAgICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBudWxsO1xuICAgIH07XG4gIH0sIFtjb250ZXh0VmFsdWUsIHByZXZpb3VzU3RhdGVdKTtcbiAgdmFyIENvbnRleHQgPSBjb250ZXh0IHx8IFJlYWN0UmVkdXhDb250ZXh0O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFByb3ZpZGVyLnByb3BUeXBlcyA9IHtcbiAgICBzdG9yZTogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICAgIGRpc3BhdGNoOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgICAgZ2V0U3RhdGU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KSxcbiAgICBjb250ZXh0OiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb3ZpZGVyOyIsImltcG9ydCBfZXh0ZW5kcyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kc1wiO1xuaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgaG9pc3RTdGF0aWNzIGZyb20gJ2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVJlZHVjZXIgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc1ZhbGlkRWxlbWVudFR5cGUsIGlzQ29udGV4dENvbnN1bWVyIH0gZnJvbSAncmVhY3QtaXMnO1xuaW1wb3J0IFN1YnNjcmlwdGlvbiBmcm9tICcuLi91dGlscy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uL3V0aWxzL3VzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuL0NvbnRleHQnOyAvLyBEZWZpbmUgc29tZSBjb25zdGFudCBhcnJheXMganVzdCB0byBhdm9pZCByZS1jcmVhdGluZyB0aGVzZVxuXG52YXIgRU1QVFlfQVJSQVkgPSBbXTtcbnZhciBOT19TVUJTQ1JJUFRJT05fQVJSQVkgPSBbbnVsbCwgbnVsbF07XG5cbnZhciBzdHJpbmdpZnlDb21wb25lbnQgPSBmdW5jdGlvbiBzdHJpbmdpZnlDb21wb25lbnQoQ29tcCkge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShDb21wKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZyhDb21wKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RvcmVTdGF0ZVVwZGF0ZXNSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgdmFyIHVwZGF0ZUNvdW50ID0gc3RhdGVbMV07XG4gIHJldHVybiBbYWN0aW9uLnBheWxvYWQsIHVwZGF0ZUNvdW50ICsgMV07XG59XG5cbmZ1bmN0aW9uIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhlZmZlY3RGdW5jLCBlZmZlY3RBcmdzLCBkZXBlbmRlbmNpZXMpIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVmZmVjdEZ1bmMuYXBwbHkodm9pZCAwLCBlZmZlY3RBcmdzKTtcbiAgfSwgZGVwZW5kZW5jaWVzKTtcbn1cblxuZnVuY3Rpb24gY2FwdHVyZVdyYXBwZXJQcm9wcyhsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIHdyYXBwZXJQcm9wcywgYWN0dWFsQ2hpbGRQcm9wcywgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3Vicykge1xuICAvLyBXZSB3YW50IHRvIGNhcHR1cmUgdGhlIHdyYXBwZXIgcHJvcHMgYW5kIGNoaWxkIHByb3BzIHdlIHVzZWQgZm9yIGxhdGVyIGNvbXBhcmlzb25zXG4gIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCA9IHdyYXBwZXJQcm9wcztcbiAgbGFzdENoaWxkUHJvcHMuY3VycmVudCA9IGFjdHVhbENoaWxkUHJvcHM7XG4gIHJlbmRlcklzU2NoZWR1bGVkLmN1cnJlbnQgPSBmYWxzZTsgLy8gSWYgdGhlIHJlbmRlciB3YXMgZnJvbSBhIHN0b3JlIHVwZGF0ZSwgY2xlYXIgb3V0IHRoYXQgcmVmZXJlbmNlIGFuZCBjYXNjYWRlIHRoZSBzdWJzY3JpYmVyIHVwZGF0ZVxuXG4gIGlmIChjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQpIHtcbiAgICBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQgPSBudWxsO1xuICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVVcGRhdGVzKHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlcywgc3RvcmUsIHN1YnNjcmlwdGlvbiwgY2hpbGRQcm9wc1NlbGVjdG9yLCBsYXN0V3JhcHBlclByb3BzLCBsYXN0Q2hpbGRQcm9wcywgcmVuZGVySXNTY2hlZHVsZWQsIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUsIG5vdGlmeU5lc3RlZFN1YnMsIGZvcmNlQ29tcG9uZW50VXBkYXRlRGlzcGF0Y2gpIHtcbiAgLy8gSWYgd2UncmUgbm90IHN1YnNjcmliZWQgdG8gdGhlIHN0b3JlLCBub3RoaW5nIHRvIGRvIGhlcmVcbiAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybjsgLy8gQ2FwdHVyZSB2YWx1ZXMgZm9yIGNoZWNraW5nIGlmIGFuZCB3aGVuIHRoaXMgY29tcG9uZW50IHVubW91bnRzXG5cbiAgdmFyIGRpZFVuc3Vic2NyaWJlID0gZmFsc2U7XG4gIHZhciBsYXN0VGhyb3duRXJyb3IgPSBudWxsOyAvLyBXZSdsbCBydW4gdGhpcyBjYWxsYmFjayBldmVyeSB0aW1lIGEgc3RvcmUgc3Vic2NyaXB0aW9uIHVwZGF0ZSBwcm9wYWdhdGVzIHRvIHRoaXMgY29tcG9uZW50XG5cbiAgdmFyIGNoZWNrRm9yVXBkYXRlcyA9IGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICBpZiAoZGlkVW5zdWJzY3JpYmUpIHtcbiAgICAgIC8vIERvbid0IHJ1biBzdGFsZSBsaXN0ZW5lcnMuXG4gICAgICAvLyBSZWR1eCBkb2Vzbid0IGd1YXJhbnRlZSB1bnN1YnNjcmlwdGlvbnMgaGFwcGVuIHVudGlsIG5leHQgZGlzcGF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxhdGVzdFN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHZhciBuZXdDaGlsZFByb3BzLCBlcnJvcjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBBY3R1YWxseSBydW4gdGhlIHNlbGVjdG9yIHdpdGggdGhlIG1vc3QgcmVjZW50IHN0b3JlIHN0YXRlIGFuZCB3cmFwcGVyIHByb3BzXG4gICAgICAvLyB0byBkZXRlcm1pbmUgd2hhdCB0aGUgY2hpbGQgcHJvcHMgc2hvdWxkIGJlXG4gICAgICBuZXdDaGlsZFByb3BzID0gY2hpbGRQcm9wc1NlbGVjdG9yKGxhdGVzdFN0b3JlU3RhdGUsIGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IgPSBlO1xuICAgICAgbGFzdFRocm93bkVycm9yID0gZTtcbiAgICB9XG5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBsYXN0VGhyb3duRXJyb3IgPSBudWxsO1xuICAgIH0gLy8gSWYgdGhlIGNoaWxkIHByb3BzIGhhdmVuJ3QgY2hhbmdlZCwgbm90aGluZyB0byBkbyBoZXJlIC0gY2FzY2FkZSB0aGUgc3Vic2NyaXB0aW9uIHVwZGF0ZVxuXG5cbiAgICBpZiAobmV3Q2hpbGRQcm9wcyA9PT0gbGFzdENoaWxkUHJvcHMuY3VycmVudCkge1xuICAgICAgaWYgKCFyZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50KSB7XG4gICAgICAgIG5vdGlmeU5lc3RlZFN1YnMoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2F2ZSByZWZlcmVuY2VzIHRvIHRoZSBuZXcgY2hpbGQgcHJvcHMuICBOb3RlIHRoYXQgd2UgdHJhY2sgdGhlIFwiY2hpbGQgcHJvcHMgZnJvbSBzdG9yZSB1cGRhdGVcIlxuICAgICAgLy8gYXMgYSByZWYgaW5zdGVhZCBvZiBhIHVzZVN0YXRlL3VzZVJlZHVjZXIgYmVjYXVzZSB3ZSBuZWVkIGEgd2F5IHRvIGRldGVybWluZSBpZiB0aGF0IHZhbHVlIGhhc1xuICAgICAgLy8gYmVlbiBwcm9jZXNzZWQuICBJZiB0aGlzIHdlbnQgaW50byB1c2VTdGF0ZS91c2VSZWR1Y2VyLCB3ZSBjb3VsZG4ndCBjbGVhciBvdXQgdGhlIHZhbHVlIHdpdGhvdXRcbiAgICAgIC8vIGZvcmNpbmcgYW5vdGhlciByZS1yZW5kZXIsIHdoaWNoIHdlIGRvbid0IHdhbnQuXG4gICAgICBsYXN0Q2hpbGRQcm9wcy5jdXJyZW50ID0gbmV3Q2hpbGRQcm9wcztcbiAgICAgIGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCA9IG5ld0NoaWxkUHJvcHM7XG4gICAgICByZW5kZXJJc1NjaGVkdWxlZC5jdXJyZW50ID0gdHJ1ZTsgLy8gSWYgdGhlIGNoaWxkIHByb3BzIF9kaWRfIGNoYW5nZSAob3Igd2UgY2F1Z2h0IGFuIGVycm9yKSwgdGhpcyB3cmFwcGVyIGNvbXBvbmVudCBuZWVkcyB0byByZS1yZW5kZXJcblxuICAgICAgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaCh7XG4gICAgICAgIHR5cGU6ICdTVE9SRV9VUERBVEVEJyxcbiAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07IC8vIEFjdHVhbGx5IHN1YnNjcmliZSB0byB0aGUgbmVhcmVzdCBjb25uZWN0ZWQgYW5jZXN0b3IgKG9yIHN0b3JlKVxuXG5cbiAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gIHN1YnNjcmlwdGlvbi50cnlTdWJzY3JpYmUoKTsgLy8gUHVsbCBkYXRhIGZyb20gdGhlIHN0b3JlIGFmdGVyIGZpcnN0IHJlbmRlciBpbiBjYXNlIHRoZSBzdG9yZSBoYXNcbiAgLy8gY2hhbmdlZCBzaW5jZSB3ZSBiZWdhbi5cblxuICBjaGVja0ZvclVwZGF0ZXMoKTtcblxuICB2YXIgdW5zdWJzY3JpYmVXcmFwcGVyID0gZnVuY3Rpb24gdW5zdWJzY3JpYmVXcmFwcGVyKCkge1xuICAgIGRpZFVuc3Vic2NyaWJlID0gdHJ1ZTtcbiAgICBzdWJzY3JpcHRpb24udHJ5VW5zdWJzY3JpYmUoKTtcbiAgICBzdWJzY3JpcHRpb24ub25TdGF0ZUNoYW5nZSA9IG51bGw7XG5cbiAgICBpZiAobGFzdFRocm93bkVycm9yKSB7XG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoYXQgd2UgY2F1Z2h0IGFuIGVycm9yIGR1ZSB0byBhIGJhZCBtYXBTdGF0ZSBmdW5jdGlvbiwgYnV0IHRoZVxuICAgICAgLy8gcGFyZW50IHJlLXJlbmRlcmVkIHdpdGhvdXQgdGhpcyBjb21wb25lbnQgYW5kIHdlJ3JlIGFib3V0IHRvIHVubW91bnQuXG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gYXMgbG9uZyBhcyB3ZSBkbyB0b3AtZG93biBzdWJzY3JpcHRpb25zIGNvcnJlY3RseSwgYnV0XG4gICAgICAvLyBpZiB3ZSBldmVyIGRvIHRob3NlIHdyb25nLCB0aGlzIHRocm93IHdpbGwgc3VyZmFjZSB0aGUgZXJyb3IgaW4gb3VyIHRlc3RzLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aHJvdyB0aGUgZXJyb3IgZnJvbSBoZXJlIHNvIGl0IGRvZXNuJ3QgZ2V0IGxvc3QuXG4gICAgICB0aHJvdyBsYXN0VGhyb3duRXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1bnN1YnNjcmliZVdyYXBwZXI7XG59XG5cbnZhciBpbml0U3RhdGVVcGRhdGVzID0gZnVuY3Rpb24gaW5pdFN0YXRlVXBkYXRlcygpIHtcbiAgcmV0dXJuIFtudWxsLCAwXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbm5lY3RBZHZhbmNlZChcbi8qXHJcbiAgc2VsZWN0b3JGYWN0b3J5IGlzIGEgZnVuYyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciByZXR1cm5pbmcgdGhlIHNlbGVjdG9yIGZ1bmN0aW9uIHVzZWQgdG9cclxuICBjb21wdXRlIG5ldyBwcm9wcyBmcm9tIHN0YXRlLCBwcm9wcywgYW5kIGRpc3BhdGNoLiBGb3IgZXhhbXBsZTpcclxuICAgICAgZXhwb3J0IGRlZmF1bHQgY29ubmVjdEFkdmFuY2VkKChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKHN0YXRlLCBwcm9wcykgPT4gKHtcclxuICAgICAgdGhpbmc6IHN0YXRlLnRoaW5nc1twcm9wcy50aGluZ0lkXSxcclxuICAgICAgc2F2ZVRoaW5nOiBmaWVsZHMgPT4gZGlzcGF0Y2goYWN0aW9uQ3JlYXRvcnMuc2F2ZVRoaW5nKHByb3BzLnRoaW5nSWQsIGZpZWxkcykpLFxyXG4gICAgfSkpKFlvdXJDb21wb25lbnQpXHJcbiAgICBBY2Nlc3MgdG8gZGlzcGF0Y2ggaXMgcHJvdmlkZWQgdG8gdGhlIGZhY3Rvcnkgc28gc2VsZWN0b3JGYWN0b3JpZXMgY2FuIGJpbmQgYWN0aW9uQ3JlYXRvcnNcclxuICBvdXRzaWRlIG9mIHRoZWlyIHNlbGVjdG9yIGFzIGFuIG9wdGltaXphdGlvbi4gT3B0aW9ucyBwYXNzZWQgdG8gY29ubmVjdEFkdmFuY2VkIGFyZSBwYXNzZWQgdG9cclxuICB0aGUgc2VsZWN0b3JGYWN0b3J5LCBhbG9uZyB3aXRoIGRpc3BsYXlOYW1lIGFuZCBXcmFwcGVkQ29tcG9uZW50LCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gICAgTm90ZSB0aGF0IHNlbGVjdG9yRmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgYWxsIGNhY2hpbmcvbWVtb2l6YXRpb24gb2YgaW5ib3VuZCBhbmQgb3V0Ym91bmRcclxuICBwcm9wcy4gRG8gbm90IHVzZSBjb25uZWN0QWR2YW5jZWQgZGlyZWN0bHkgd2l0aG91dCBtZW1vaXppbmcgcmVzdWx0cyBiZXR3ZWVuIGNhbGxzIHRvIHlvdXJcclxuICBzZWxlY3Rvciwgb3RoZXJ3aXNlIHRoZSBDb25uZWN0IGNvbXBvbmVudCB3aWxsIHJlLXJlbmRlciBvbiBldmVyeSBzdGF0ZSBvciBwcm9wcyBjaGFuZ2UuXHJcbiovXG5zZWxlY3RvckZhY3RvcnksIC8vIG9wdGlvbnMgb2JqZWN0OlxuX3JlZikge1xuICBpZiAoX3JlZiA9PT0gdm9pZCAwKSB7XG4gICAgX3JlZiA9IHt9O1xuICB9XG5cbiAgdmFyIF9yZWYyID0gX3JlZixcbiAgICAgIF9yZWYyJGdldERpc3BsYXlOYW1lID0gX3JlZjIuZ2V0RGlzcGxheU5hbWUsXG4gICAgICBnZXREaXNwbGF5TmFtZSA9IF9yZWYyJGdldERpc3BsYXlOYW1lID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBcIkNvbm5lY3RBZHZhbmNlZChcIiArIG5hbWUgKyBcIilcIjtcbiAgfSA6IF9yZWYyJGdldERpc3BsYXlOYW1lLFxuICAgICAgX3JlZjIkbWV0aG9kTmFtZSA9IF9yZWYyLm1ldGhvZE5hbWUsXG4gICAgICBtZXRob2ROYW1lID0gX3JlZjIkbWV0aG9kTmFtZSA9PT0gdm9pZCAwID8gJ2Nvbm5lY3RBZHZhbmNlZCcgOiBfcmVmMiRtZXRob2ROYW1lLFxuICAgICAgX3JlZjIkcmVuZGVyQ291bnRQcm9wID0gX3JlZjIucmVuZGVyQ291bnRQcm9wLFxuICAgICAgcmVuZGVyQ291bnRQcm9wID0gX3JlZjIkcmVuZGVyQ291bnRQcm9wID09PSB2b2lkIDAgPyB1bmRlZmluZWQgOiBfcmVmMiRyZW5kZXJDb3VudFByb3AsXG4gICAgICBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPSBfcmVmMi5zaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMgPSBfcmVmMiRzaG91bGRIYW5kbGVTdGEgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRzaG91bGRIYW5kbGVTdGEsXG4gICAgICBfcmVmMiRzdG9yZUtleSA9IF9yZWYyLnN0b3JlS2V5LFxuICAgICAgc3RvcmVLZXkgPSBfcmVmMiRzdG9yZUtleSA9PT0gdm9pZCAwID8gJ3N0b3JlJyA6IF9yZWYyJHN0b3JlS2V5LFxuICAgICAgX3JlZjIkd2l0aFJlZiA9IF9yZWYyLndpdGhSZWYsXG4gICAgICB3aXRoUmVmID0gX3JlZjIkd2l0aFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiR3aXRoUmVmLFxuICAgICAgX3JlZjIkZm9yd2FyZFJlZiA9IF9yZWYyLmZvcndhcmRSZWYsXG4gICAgICBmb3J3YXJkUmVmID0gX3JlZjIkZm9yd2FyZFJlZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRmb3J3YXJkUmVmLFxuICAgICAgX3JlZjIkY29udGV4dCA9IF9yZWYyLmNvbnRleHQsXG4gICAgICBjb250ZXh0ID0gX3JlZjIkY29udGV4dCA9PT0gdm9pZCAwID8gUmVhY3RSZWR1eENvbnRleHQgOiBfcmVmMiRjb250ZXh0LFxuICAgICAgY29ubmVjdE9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiZ2V0RGlzcGxheU5hbWVcIiwgXCJtZXRob2ROYW1lXCIsIFwicmVuZGVyQ291bnRQcm9wXCIsIFwic2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzXCIsIFwic3RvcmVLZXlcIiwgXCJ3aXRoUmVmXCIsIFwiZm9yd2FyZFJlZlwiLCBcImNvbnRleHRcIl0pO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKHJlbmRlckNvdW50UHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZW5kZXJDb3VudFByb3AgaXMgcmVtb3ZlZC4gcmVuZGVyIGNvdW50aW5nIGlzIGJ1aWx0IGludG8gdGhlIGxhdGVzdCBSZWFjdCBEZXYgVG9vbHMgcHJvZmlsaW5nIGV4dGVuc2lvblwiKTtcbiAgICB9XG5cbiAgICBpZiAod2l0aFJlZikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3aXRoUmVmIGlzIHJlbW92ZWQuIFRvIGFjY2VzcyB0aGUgd3JhcHBlZCBpbnN0YW5jZSwgdXNlIGEgcmVmIG9uIHRoZSBjb25uZWN0ZWQgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgdmFyIGN1c3RvbVN0b3JlV2FybmluZ01lc3NhZ2UgPSAnVG8gdXNlIGEgY3VzdG9tIFJlZHV4IHN0b3JlIGZvciBzcGVjaWZpYyBjb21wb25lbnRzLCBjcmVhdGUgYSBjdXN0b20gUmVhY3QgY29udGV4dCB3aXRoICcgKyBcIlJlYWN0LmNyZWF0ZUNvbnRleHQoKSwgYW5kIHBhc3MgdGhlIGNvbnRleHQgb2JqZWN0IHRvIFJlYWN0IFJlZHV4J3MgUHJvdmlkZXIgYW5kIHNwZWNpZmljIGNvbXBvbmVudHNcIiArICcgbGlrZTogPFByb3ZpZGVyIGNvbnRleHQ9e015Q29udGV4dH0+PENvbm5lY3RlZENvbXBvbmVudCBjb250ZXh0PXtNeUNvbnRleHR9IC8+PC9Qcm92aWRlcj4uICcgKyAnWW91IG1heSBhbHNvIHBhc3MgYSB7Y29udGV4dCA6IE15Q29udGV4dH0gb3B0aW9uIHRvIGNvbm5lY3QnO1xuXG4gICAgaWYgKHN0b3JlS2V5ICE9PSAnc3RvcmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0b3JlS2V5IGhhcyBiZWVuIHJlbW92ZWQgYW5kIGRvZXMgbm90IGRvIGFueXRoaW5nLiAnICsgY3VzdG9tU3RvcmVXYXJuaW5nTWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIENvbnRleHQgPSBjb250ZXh0O1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcFdpdGhDb25uZWN0KFdyYXBwZWRDb21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhaXNWYWxpZEVsZW1lbnRUeXBlKFdyYXBwZWRDb21wb25lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgY29tcG9uZW50IHRvIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBcIiArIChtZXRob2ROYW1lICsgXCIuIEluc3RlYWQgcmVjZWl2ZWQgXCIgKyBzdHJpbmdpZnlDb21wb25lbnQoV3JhcHBlZENvbXBvbmVudCkpKTtcbiAgICB9XG5cbiAgICB2YXIgd3JhcHBlZENvbXBvbmVudE5hbWUgPSBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZSh3cmFwcGVkQ29tcG9uZW50TmFtZSk7XG5cbiAgICB2YXIgc2VsZWN0b3JGYWN0b3J5T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBjb25uZWN0T3B0aW9ucywge1xuICAgICAgZ2V0RGlzcGxheU5hbWU6IGdldERpc3BsYXlOYW1lLFxuICAgICAgbWV0aG9kTmFtZTogbWV0aG9kTmFtZSxcbiAgICAgIHJlbmRlckNvdW50UHJvcDogcmVuZGVyQ291bnRQcm9wLFxuICAgICAgc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzOiBzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMsXG4gICAgICBzdG9yZUtleTogc3RvcmVLZXksXG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICB3cmFwcGVkQ29tcG9uZW50TmFtZTogd3JhcHBlZENvbXBvbmVudE5hbWUsXG4gICAgICBXcmFwcGVkQ29tcG9uZW50OiBXcmFwcGVkQ29tcG9uZW50XG4gICAgfSk7XG5cbiAgICB2YXIgcHVyZSA9IGNvbm5lY3RPcHRpb25zLnB1cmU7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDaGlsZFNlbGVjdG9yKHN0b3JlKSB7XG4gICAgICByZXR1cm4gc2VsZWN0b3JGYWN0b3J5KHN0b3JlLmRpc3BhdGNoLCBzZWxlY3RvckZhY3RvcnlPcHRpb25zKTtcbiAgICB9IC8vIElmIHdlIGFyZW4ndCBydW5uaW5nIGluIFwicHVyZVwiIG1vZGUsIHdlIGRvbid0IHdhbnQgdG8gbWVtb2l6ZSB2YWx1ZXMuXG4gICAgLy8gVG8gYXZvaWQgY29uZGl0aW9uYWxseSBjYWxsaW5nIGhvb2tzLCB3ZSBmYWxsIGJhY2sgdG8gYSB0aW55IHdyYXBwZXJcbiAgICAvLyB0aGF0IGp1c3QgZXhlY3V0ZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGltbWVkaWF0ZWx5LlxuXG5cbiAgICB2YXIgdXNlUHVyZU9ubHlNZW1vID0gcHVyZSA/IHVzZU1lbW8gOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDb25uZWN0RnVuY3Rpb24ocHJvcHMpIHtcbiAgICAgIHZhciBfdXNlTWVtbyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBEaXN0aW5ndWlzaCBiZXR3ZWVuIGFjdHVhbCBcImRhdGFcIiBwcm9wcyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSB3cmFwcGVyIGNvbXBvbmVudCxcbiAgICAgICAgLy8gYW5kIHZhbHVlcyBuZWVkZWQgdG8gY29udHJvbCBiZWhhdmlvciAoZm9yd2FyZGVkIHJlZnMsIGFsdGVybmF0ZSBjb250ZXh0IGluc3RhbmNlcykuXG4gICAgICAgIC8vIFRvIG1haW50YWluIHRoZSB3cmFwcGVyUHJvcHMgb2JqZWN0IHJlZmVyZW5jZSwgbWVtb2l6ZSB0aGlzIGRlc3RydWN0dXJpbmcuXG4gICAgICAgIHZhciByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gcHJvcHMucmVhY3RSZWR1eEZvcndhcmRlZFJlZixcbiAgICAgICAgICAgIHdyYXBwZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBbXCJyZWFjdFJlZHV4Rm9yd2FyZGVkUmVmXCJdKTtcblxuICAgICAgICByZXR1cm4gW3Byb3BzLmNvbnRleHQsIHJlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIHdyYXBwZXJQcm9wc107XG4gICAgICB9LCBbcHJvcHNdKSxcbiAgICAgICAgICBwcm9wc0NvbnRleHQgPSBfdXNlTWVtb1swXSxcbiAgICAgICAgICByZWFjdFJlZHV4Rm9yd2FyZGVkUmVmID0gX3VzZU1lbW9bMV0sXG4gICAgICAgICAgd3JhcHBlclByb3BzID0gX3VzZU1lbW9bMl07XG5cbiAgICAgIHZhciBDb250ZXh0VG9Vc2UgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVXNlcnMgbWF5IG9wdGlvbmFsbHkgcGFzcyBpbiBhIGN1c3RvbSBjb250ZXh0IGluc3RhbmNlIHRvIHVzZSBpbnN0ZWFkIG9mIG91ciBSZWFjdFJlZHV4Q29udGV4dC5cbiAgICAgICAgLy8gTWVtb2l6ZSB0aGUgY2hlY2sgdGhhdCBkZXRlcm1pbmVzIHdoaWNoIGNvbnRleHQgaW5zdGFuY2Ugd2Ugc2hvdWxkIHVzZS5cbiAgICAgICAgcmV0dXJuIHByb3BzQ29udGV4dCAmJiBwcm9wc0NvbnRleHQuQ29uc3VtZXIgJiYgaXNDb250ZXh0Q29uc3VtZXIoUmVhY3QuY3JlYXRlRWxlbWVudChwcm9wc0NvbnRleHQuQ29uc3VtZXIsIG51bGwpKSA/IHByb3BzQ29udGV4dCA6IENvbnRleHQ7XG4gICAgICB9LCBbcHJvcHNDb250ZXh0LCBDb250ZXh0XSk7IC8vIFJldHJpZXZlIHRoZSBzdG9yZSBhbmQgYW5jZXN0b3Igc3Vic2NyaXB0aW9uIHZpYSBjb250ZXh0LCBpZiBhdmFpbGFibGVcblxuICAgICAgdmFyIGNvbnRleHRWYWx1ZSA9IHVzZUNvbnRleHQoQ29udGV4dFRvVXNlKTsgLy8gVGhlIHN0b3JlIF9tdXN0XyBleGlzdCBhcyBlaXRoZXIgYSBwcm9wIG9yIGluIGNvbnRleHQuXG4gICAgICAvLyBXZSdsbCBjaGVjayB0byBzZWUgaWYgaXQgX2xvb2tzXyBsaWtlIGEgUmVkdXggc3RvcmUgZmlyc3QuXG4gICAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBwYXNzIHRocm91Z2ggYSBgc3RvcmVgIHByb3AgdGhhdCBpcyBqdXN0IGEgcGxhaW4gdmFsdWUuXG5cbiAgICAgIHZhciBkaWRTdG9yZUNvbWVGcm9tUHJvcHMgPSBCb29sZWFuKHByb3BzLnN0b3JlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmdldFN0YXRlKSAmJiBCb29sZWFuKHByb3BzLnN0b3JlLmRpc3BhdGNoKTtcbiAgICAgIHZhciBkaWRTdG9yZUNvbWVGcm9tQ29udGV4dCA9IEJvb2xlYW4oY29udGV4dFZhbHVlKSAmJiBCb29sZWFuKGNvbnRleHRWYWx1ZS5zdG9yZSk7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFkaWRTdG9yZUNvbWVGcm9tUHJvcHMgJiYgIWRpZFN0b3JlQ29tZUZyb21Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIFxcXCJzdG9yZVxcXCIgaW4gdGhlIGNvbnRleHQgb2YgXCIgKyAoXCJcXFwiXCIgKyBkaXNwbGF5TmFtZSArIFwiXFxcIi4gRWl0aGVyIHdyYXAgdGhlIHJvb3QgY29tcG9uZW50IGluIGEgPFByb3ZpZGVyPiwgXCIpICsgXCJvciBwYXNzIGEgY3VzdG9tIFJlYWN0IGNvbnRleHQgcHJvdmlkZXIgdG8gPFByb3ZpZGVyPiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgXCIgKyAoXCJSZWFjdCBjb250ZXh0IGNvbnN1bWVyIHRvIFwiICsgZGlzcGxheU5hbWUgKyBcIiBpbiBjb25uZWN0IG9wdGlvbnMuXCIpKTtcbiAgICAgIH0gLy8gQmFzZWQgb24gdGhlIHByZXZpb3VzIGNoZWNrLCBvbmUgb2YgdGhlc2UgbXVzdCBiZSB0cnVlXG5cblxuICAgICAgdmFyIHN0b3JlID0gZGlkU3RvcmVDb21lRnJvbVByb3BzID8gcHJvcHMuc3RvcmUgOiBjb250ZXh0VmFsdWUuc3RvcmU7XG4gICAgICB2YXIgY2hpbGRQcm9wc1NlbGVjdG9yID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZCBwcm9wcyBzZWxlY3RvciBuZWVkcyB0aGUgc3RvcmUgcmVmZXJlbmNlIGFzIGFuIGlucHV0LlxuICAgICAgICAvLyBSZS1jcmVhdGUgdGhpcyBzZWxlY3RvciB3aGVuZXZlciB0aGUgc3RvcmUgY2hhbmdlcy5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkU2VsZWN0b3Ioc3RvcmUpO1xuICAgICAgfSwgW3N0b3JlXSk7XG5cbiAgICAgIHZhciBfdXNlTWVtbzIgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFzaG91bGRIYW5kbGVTdGF0ZUNoYW5nZXMpIHJldHVybiBOT19TVUJTQ1JJUFRJT05fQVJSQVk7IC8vIFRoaXMgU3Vic2NyaXB0aW9uJ3Mgc291cmNlIHNob3VsZCBtYXRjaCB3aGVyZSBzdG9yZSBjYW1lIGZyb206IHByb3BzIHZzLiBjb250ZXh0LiBBIGNvbXBvbmVudFxuICAgICAgICAvLyBjb25uZWN0ZWQgdG8gdGhlIHN0b3JlIHZpYSBwcm9wcyBzaG91bGRuJ3QgdXNlIHN1YnNjcmlwdGlvbiBmcm9tIGNvbnRleHQsIG9yIHZpY2UgdmVyc2EuXG5cbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oc3RvcmUsIGRpZFN0b3JlQ29tZUZyb21Qcm9wcyA/IG51bGwgOiBjb250ZXh0VmFsdWUuc3Vic2NyaXB0aW9uKTsgLy8gYG5vdGlmeU5lc3RlZFN1YnNgIGlzIGR1cGxpY2F0ZWQgdG8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRoZSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGluXG4gICAgICAgIC8vIHRoZSBtaWRkbGUgb2YgdGhlIG5vdGlmaWNhdGlvbiBsb29wLCB3aGVyZSBgc3Vic2NyaXB0aW9uYCB3aWxsIHRoZW4gYmUgbnVsbC4gVGhpcyBjYW5cbiAgICAgICAgLy8gcHJvYmFibHkgYmUgYXZvaWRlZCBpZiBTdWJzY3JpcHRpb24ncyBsaXN0ZW5lcnMgbG9naWMgaXMgY2hhbmdlZCB0byBub3QgY2FsbCBsaXN0ZW5lcnNcbiAgICAgICAgLy8gdGhhdCBoYXZlIGJlZW4gdW5zdWJzY3JpYmVkIGluIHRoZSAgbWlkZGxlIG9mIHRoZSBub3RpZmljYXRpb24gbG9vcC5cblxuICAgICAgICB2YXIgbm90aWZ5TmVzdGVkU3VicyA9IHN1YnNjcmlwdGlvbi5ub3RpZnlOZXN0ZWRTdWJzLmJpbmQoc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgcmV0dXJuIFtzdWJzY3JpcHRpb24sIG5vdGlmeU5lc3RlZFN1YnNdO1xuICAgICAgfSwgW3N0b3JlLCBkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZV0pLFxuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF91c2VNZW1vMlswXSxcbiAgICAgICAgICBub3RpZnlOZXN0ZWRTdWJzID0gX3VzZU1lbW8yWzFdOyAvLyBEZXRlcm1pbmUgd2hhdCB7c3RvcmUsIHN1YnNjcmlwdGlvbn0gdmFsdWUgc2hvdWxkIGJlIHB1dCBpbnRvIG5lc3RlZCBjb250ZXh0LCBpZiBuZWNlc3NhcnksXG4gICAgICAvLyBhbmQgbWVtb2l6ZSB0aGF0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbnRleHQgdXBkYXRlcy5cblxuXG4gICAgICB2YXIgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlkU3RvcmVDb21lRnJvbVByb3BzKSB7XG4gICAgICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgZGlyZWN0bHkgc3Vic2NyaWJlZCB0byBhIHN0b3JlIGZyb20gcHJvcHMuXG4gICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCBkZXNjZW5kYW50cyByZWFkaW5nIGZyb20gdGhpcyBzdG9yZSAtIHBhc3MgZG93biB3aGF0ZXZlclxuICAgICAgICAgIC8vIHRoZSBleGlzdGluZyBjb250ZXh0IHZhbHVlIGlzIGZyb20gdGhlIG5lYXJlc3QgY29ubmVjdGVkIGFuY2VzdG9yLlxuICAgICAgICAgIHJldHVybiBjb250ZXh0VmFsdWU7XG4gICAgICAgIH0gLy8gT3RoZXJ3aXNlLCBwdXQgdGhpcyBjb21wb25lbnQncyBzdWJzY3JpcHRpb24gaW5zdGFuY2UgaW50byBjb250ZXh0LCBzbyB0aGF0XG4gICAgICAgIC8vIGNvbm5lY3RlZCBkZXNjZW5kYW50cyB3b24ndCB1cGRhdGUgdW50aWwgYWZ0ZXIgdGhpcyBjb21wb25lbnQgaXMgZG9uZVxuXG5cbiAgICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBjb250ZXh0VmFsdWUsIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0sIFtkaWRTdG9yZUNvbWVGcm9tUHJvcHMsIGNvbnRleHRWYWx1ZSwgc3Vic2NyaXB0aW9uXSk7IC8vIFdlIG5lZWQgdG8gZm9yY2UgdGhpcyB3cmFwcGVyIGNvbXBvbmVudCB0byByZS1yZW5kZXIgd2hlbmV2ZXIgYSBSZWR1eCBzdG9yZSB1cGRhdGVcbiAgICAgIC8vIGNhdXNlcyBhIGNoYW5nZSB0byB0aGUgY2FsY3VsYXRlZCBjaGlsZCBjb21wb25lbnQgcHJvcHMgKG9yIHdlIGNhdWdodCBhbiBlcnJvciBpbiBtYXBTdGF0ZSlcblxuICAgICAgdmFyIF91c2VSZWR1Y2VyID0gdXNlUmVkdWNlcihzdG9yZVN0YXRlVXBkYXRlc1JlZHVjZXIsIEVNUFRZX0FSUkFZLCBpbml0U3RhdGVVcGRhdGVzKSxcbiAgICAgICAgICBfdXNlUmVkdWNlciQgPSBfdXNlUmVkdWNlclswXSxcbiAgICAgICAgICBwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0ID0gX3VzZVJlZHVjZXIkWzBdLFxuICAgICAgICAgIGZvcmNlQ29tcG9uZW50VXBkYXRlRGlzcGF0Y2ggPSBfdXNlUmVkdWNlclsxXTsgLy8gUHJvcGFnYXRlIGFueSBtYXBTdGF0ZS9tYXBEaXNwYXRjaCBlcnJvcnMgdXB3YXJkc1xuXG5cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlVXBkYXRlUmVzdWx0ICYmIHByZXZpb3VzU3RhdGVVcGRhdGVSZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgcHJldmlvdXNTdGF0ZVVwZGF0ZVJlc3VsdC5lcnJvcjtcbiAgICAgIH0gLy8gU2V0IHVwIHJlZnMgdG8gY29vcmRpbmF0ZSB2YWx1ZXMgYmV0d2VlbiB0aGUgc3Vic2NyaXB0aW9uIGVmZmVjdCBhbmQgdGhlIHJlbmRlciBsb2dpY1xuXG5cbiAgICAgIHZhciBsYXN0Q2hpbGRQcm9wcyA9IHVzZVJlZigpO1xuICAgICAgdmFyIGxhc3RXcmFwcGVyUHJvcHMgPSB1c2VSZWYod3JhcHBlclByb3BzKTtcbiAgICAgIHZhciBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlID0gdXNlUmVmKCk7XG4gICAgICB2YXIgcmVuZGVySXNTY2hlZHVsZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgdmFyIGFjdHVhbENoaWxkUHJvcHMgPSB1c2VQdXJlT25seU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUcmlja3kgbG9naWMgaGVyZTpcbiAgICAgICAgLy8gLSBUaGlzIHJlbmRlciBtYXkgaGF2ZSBiZWVuIHRyaWdnZXJlZCBieSBhIFJlZHV4IHN0b3JlIHVwZGF0ZSB0aGF0IHByb2R1Y2VkIG5ldyBjaGlsZCBwcm9wc1xuICAgICAgICAvLyAtIEhvd2V2ZXIsIHdlIG1heSBoYXZlIGdvdHRlbiBuZXcgd3JhcHBlciBwcm9wcyBhZnRlciB0aGF0XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbmV3IGNoaWxkIHByb3BzLCBhbmQgdGhlIHNhbWUgd3JhcHBlciBwcm9wcywgd2Uga25vdyB3ZSBzaG91bGQgdXNlIHRoZSBuZXcgY2hpbGQgcHJvcHMgYXMtaXMuXG4gICAgICAgIC8vIEJ1dCwgaWYgd2UgaGF2ZSBuZXcgd3JhcHBlciBwcm9wcywgdGhvc2UgbWlnaHQgY2hhbmdlIHRoZSBjaGlsZCBwcm9wcywgc28gd2UgaGF2ZSB0byByZWNhbGN1bGF0ZSB0aGluZ3MuXG4gICAgICAgIC8vIFNvLCB3ZSdsbCB1c2UgdGhlIGNoaWxkIHByb3BzIGZyb20gc3RvcmUgdXBkYXRlIG9ubHkgaWYgdGhlIHdyYXBwZXIgcHJvcHMgYXJlIHRoZSBzYW1lIGFzIGxhc3QgdGltZS5cbiAgICAgICAgaWYgKGNoaWxkUHJvcHNGcm9tU3RvcmVVcGRhdGUuY3VycmVudCAmJiB3cmFwcGVyUHJvcHMgPT09IGxhc3RXcmFwcGVyUHJvcHMuY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLmN1cnJlbnQ7XG4gICAgICAgIH0gLy8gVE9ETyBXZSdyZSByZWFkaW5nIHRoZSBzdG9yZSBkaXJlY3RseSBpbiByZW5kZXIoKSBoZXJlLiBCYWQgaWRlYT9cbiAgICAgICAgLy8gVGhpcyB3aWxsIGxpa2VseSBjYXVzZSBCYWQgVGhpbmdzIChUTSkgdG8gaGFwcGVuIGluIENvbmN1cnJlbnQgTW9kZS5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGRvIHRoaXMgYmVjYXVzZSBvbiByZW5kZXJzIF9ub3RfIGNhdXNlZCBieSBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRoZSBsYXRlc3Qgc3RvcmUgc3RhdGVcbiAgICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoYXQgdGhlIGNoaWxkIHByb3BzIHNob3VsZCBiZS5cblxuXG4gICAgICAgIHJldHVybiBjaGlsZFByb3BzU2VsZWN0b3Ioc3RvcmUuZ2V0U3RhdGUoKSwgd3JhcHBlclByb3BzKTtcbiAgICAgIH0sIFtzdG9yZSwgcHJldmlvdXNTdGF0ZVVwZGF0ZVJlc3VsdCwgd3JhcHBlclByb3BzXSk7IC8vIFdlIG5lZWQgdGhpcyB0byBleGVjdXRlIHN5bmNocm9ub3VzbHkgZXZlcnkgdGltZSB3ZSByZS1yZW5kZXIuIEhvd2V2ZXIsIFJlYWN0IHdhcm5zXG4gICAgICAvLyBhYm91dCB1c2VMYXlvdXRFZmZlY3QgaW4gU1NSLCBzbyB3ZSB0cnkgdG8gZGV0ZWN0IGVudmlyb25tZW50IGFuZCBmYWxsIGJhY2sgdG9cbiAgICAgIC8vIGp1c3QgdXNlRWZmZWN0IGluc3RlYWQgdG8gYXZvaWQgdGhlIHdhcm5pbmcsIHNpbmNlIG5laXRoZXIgd2lsbCBydW4gYW55d2F5LlxuXG4gICAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0V2l0aEFyZ3MoY2FwdHVyZVdyYXBwZXJQcm9wcywgW2xhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgd3JhcHBlclByb3BzLCBhY3R1YWxDaGlsZFByb3BzLCBjaGlsZFByb3BzRnJvbVN0b3JlVXBkYXRlLCBub3RpZnlOZXN0ZWRTdWJzXSk7IC8vIE91ciByZS1zdWJzY3JpYmUgbG9naWMgb25seSBydW5zIHdoZW4gdGhlIHN0b3JlL3N1YnNjcmlwdGlvbiBzZXR1cCBjaGFuZ2VzXG5cbiAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RXaXRoQXJncyhzdWJzY3JpYmVVcGRhdGVzLCBbc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzLCBzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3IsIGxhc3RXcmFwcGVyUHJvcHMsIGxhc3RDaGlsZFByb3BzLCByZW5kZXJJc1NjaGVkdWxlZCwgY2hpbGRQcm9wc0Zyb21TdG9yZVVwZGF0ZSwgbm90aWZ5TmVzdGVkU3VicywgZm9yY2VDb21wb25lbnRVcGRhdGVEaXNwYXRjaF0sIFtzdG9yZSwgc3Vic2NyaXB0aW9uLCBjaGlsZFByb3BzU2VsZWN0b3JdKTsgLy8gTm93IHRoYXQgYWxsIHRoYXQncyBkb25lLCB3ZSBjYW4gZmluYWxseSB0cnkgdG8gYWN0dWFsbHkgcmVuZGVyIHRoZSBjaGlsZCBjb21wb25lbnQuXG4gICAgICAvLyBXZSBtZW1vaXplIHRoZSBlbGVtZW50cyBmb3IgdGhlIHJlbmRlcmVkIGNoaWxkIGNvbXBvbmVudCBhcyBhbiBvcHRpbWl6YXRpb24uXG5cbiAgICAgIHZhciByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgX2V4dGVuZHMoe30sIGFjdHVhbENoaWxkUHJvcHMsIHtcbiAgICAgICAgICByZWY6IHJlYWN0UmVkdXhGb3J3YXJkZWRSZWZcbiAgICAgICAgfSkpO1xuICAgICAgfSwgW3JlYWN0UmVkdXhGb3J3YXJkZWRSZWYsIFdyYXBwZWRDb21wb25lbnQsIGFjdHVhbENoaWxkUHJvcHNdKTsgLy8gSWYgUmVhY3Qgc2VlcyB0aGUgZXhhY3Qgc2FtZSBlbGVtZW50IHJlZmVyZW5jZSBhcyBsYXN0IHRpbWUsIGl0IGJhaWxzIG91dCBvZiByZS1yZW5kZXJpbmdcbiAgICAgIC8vIHRoYXQgY2hpbGQsIHNhbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gUmVhY3QubWVtbygpIG9yIHJldHVybmVkIGZhbHNlIGZyb20gc2hvdWxkQ29tcG9uZW50VXBkYXRlLlxuXG4gICAgICB2YXIgcmVuZGVyZWRDaGlsZCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2hvdWxkSGFuZGxlU3RhdGVDaGFuZ2VzKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBjb21wb25lbnQgaXMgc3Vic2NyaWJlZCB0byBzdG9yZSB1cGRhdGVzLCB3ZSBuZWVkIHRvIHBhc3MgaXRzIG93blxuICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiBpbnN0YW5jZSBkb3duIHRvIG91ciBkZXNjZW5kYW50cy4gVGhhdCBtZWFucyByZW5kZXJpbmcgdGhlIHNhbWVcbiAgICAgICAgICAvLyBDb250ZXh0IGluc3RhbmNlLCBhbmQgcHV0dGluZyBhIGRpZmZlcmVudCB2YWx1ZSBpbnRvIHRoZSBjb250ZXh0LlxuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRUb1VzZS5Qcm92aWRlciwge1xuICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRkZW5Db250ZXh0VmFsdWVcbiAgICAgICAgICB9LCByZW5kZXJlZFdyYXBwZWRDb21wb25lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudDtcbiAgICAgIH0sIFtDb250ZXh0VG9Vc2UsIHJlbmRlcmVkV3JhcHBlZENvbXBvbmVudCwgb3ZlcnJpZGRlbkNvbnRleHRWYWx1ZV0pO1xuICAgICAgcmV0dXJuIHJlbmRlcmVkQ2hpbGQ7XG4gICAgfSAvLyBJZiB3ZSdyZSBpbiBcInB1cmVcIiBtb2RlLCBlbnN1cmUgb3VyIHdyYXBwZXIgY29tcG9uZW50IG9ubHkgcmUtcmVuZGVycyB3aGVuIGluY29taW5nIHByb3BzIGhhdmUgY2hhbmdlZC5cblxuXG4gICAgdmFyIENvbm5lY3QgPSBwdXJlID8gUmVhY3QubWVtbyhDb25uZWN0RnVuY3Rpb24pIDogQ29ubmVjdEZ1bmN0aW9uO1xuICAgIENvbm5lY3QuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgQ29ubmVjdC5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuXG4gICAgaWYgKGZvcndhcmRSZWYpIHtcbiAgICAgIHZhciBmb3J3YXJkZWQgPSBSZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIGZvcndhcmRDb25uZWN0UmVmKHByb3BzLCByZWYpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdCwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICAgICAgcmVhY3RSZWR1eEZvcndhcmRlZFJlZjogcmVmXG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgICAgZm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICBmb3J3YXJkZWQuV3JhcHBlZENvbXBvbmVudCA9IFdyYXBwZWRDb21wb25lbnQ7XG4gICAgICByZXR1cm4gaG9pc3RTdGF0aWNzKGZvcndhcmRlZCwgV3JhcHBlZENvbXBvbmVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhvaXN0U3RhdGljcyhDb25uZWN0LCBXcmFwcGVkQ29tcG9uZW50KTtcbiAgfTtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuLi9jb21wb25lbnRzL2Nvbm5lY3RBZHZhbmNlZCc7XG5pbXBvcnQgc2hhbGxvd0VxdWFsIGZyb20gJy4uL3V0aWxzL3NoYWxsb3dFcXVhbCc7XG5pbXBvcnQgZGVmYXVsdE1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcERpc3BhdGNoVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyBmcm9tICcuL21hcFN0YXRlVG9Qcm9wcyc7XG5pbXBvcnQgZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgZnJvbSAnLi9tZXJnZVByb3BzJztcbmltcG9ydCBkZWZhdWx0U2VsZWN0b3JGYWN0b3J5IGZyb20gJy4vc2VsZWN0b3JGYWN0b3J5Jztcbi8qXHJcbiAgY29ubmVjdCBpcyBhIGZhY2FkZSBvdmVyIGNvbm5lY3RBZHZhbmNlZC4gSXQgdHVybnMgaXRzIGFyZ3MgaW50byBhIGNvbXBhdGlibGVcclxuICBzZWxlY3RvckZhY3RvcnksIHdoaWNoIGhhcyB0aGUgc2lnbmF0dXJlOlxyXG5cclxuICAgIChkaXNwYXRjaCwgb3B0aW9ucykgPT4gKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSA9PiBuZXh0RmluYWxQcm9wc1xyXG4gIFxyXG4gIGNvbm5lY3QgcGFzc2VzIGl0cyBhcmdzIHRvIGNvbm5lY3RBZHZhbmNlZCBhcyBvcHRpb25zLCB3aGljaCB3aWxsIGluIHR1cm4gcGFzcyB0aGVtIHRvXHJcbiAgc2VsZWN0b3JGYWN0b3J5IGVhY2ggdGltZSBhIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIGlzIGluc3RhbnRpYXRlZCBvciBob3QgcmVsb2FkZWQuXHJcblxyXG4gIHNlbGVjdG9yRmFjdG9yeSByZXR1cm5zIGEgZmluYWwgcHJvcHMgc2VsZWN0b3IgZnJvbSBpdHMgbWFwU3RhdGVUb1Byb3BzLFxyXG4gIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHNGYWN0b3JpZXMsIG1lcmdlUHJvcHMsXHJcbiAgbWVyZ2VQcm9wc0ZhY3RvcmllcywgYW5kIHB1cmUgYXJncy5cclxuXHJcbiAgVGhlIHJlc3VsdGluZyBmaW5hbCBwcm9wcyBzZWxlY3RvciBpcyBjYWxsZWQgYnkgdGhlIENvbm5lY3QgY29tcG9uZW50IGluc3RhbmNlIHdoZW5ldmVyXHJcbiAgaXQgcmVjZWl2ZXMgbmV3IHByb3BzIG9yIHN0b3JlIHN0YXRlLlxyXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goYXJnLCBmYWN0b3JpZXMsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IGZhY3Rvcmllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciByZXN1bHQgPSBmYWN0b3JpZXNbaV0oYXJnKTtcbiAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkaXNwYXRjaCwgb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgb2YgdHlwZSBcIiArIHR5cGVvZiBhcmcgKyBcIiBmb3IgXCIgKyBuYW1lICsgXCIgYXJndW1lbnQgd2hlbiBjb25uZWN0aW5nIGNvbXBvbmVudCBcIiArIG9wdGlvbnMud3JhcHBlZENvbXBvbmVudE5hbWUgKyBcIi5cIik7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmljdEVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59IC8vIGNyZWF0ZUNvbm5lY3Qgd2l0aCBkZWZhdWx0IGFyZ3MgYnVpbGRzIHRoZSAnb2ZmaWNpYWwnIGNvbm5lY3QgYmVoYXZpb3IuIENhbGxpbmcgaXQgd2l0aFxuLy8gZGlmZmVyZW50IG9wdGlvbnMgb3BlbnMgdXAgc29tZSB0ZXN0aW5nIGFuZCBleHRlbnNpYmlsaXR5IHNjZW5hcmlvc1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0KF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBfcmVmJGNvbm5lY3RIT0MgPSBfcmVmLmNvbm5lY3RIT0MsXG4gICAgICBjb25uZWN0SE9DID0gX3JlZiRjb25uZWN0SE9DID09PSB2b2lkIDAgPyBjb25uZWN0QWR2YW5jZWQgOiBfcmVmJGNvbm5lY3RIT0MsXG4gICAgICBfcmVmJG1hcFN0YXRlVG9Qcm9wc0YgPSBfcmVmLm1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyxcbiAgICAgIG1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWFwU3RhdGVUb1Byb3BzRiA9PT0gdm9pZCAwID8gZGVmYXVsdE1hcFN0YXRlVG9Qcm9wc0ZhY3RvcmllcyA6IF9yZWYkbWFwU3RhdGVUb1Byb3BzRixcbiAgICAgIF9yZWYkbWFwRGlzcGF0Y2hUb1BybyA9IF9yZWYubWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzLFxuICAgICAgbWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzID0gX3JlZiRtYXBEaXNwYXRjaFRvUHJvID09PSB2b2lkIDAgPyBkZWZhdWx0TWFwRGlzcGF0Y2hUb1Byb3BzRmFjdG9yaWVzIDogX3JlZiRtYXBEaXNwYXRjaFRvUHJvLFxuICAgICAgX3JlZiRtZXJnZVByb3BzRmFjdG9yID0gX3JlZi5tZXJnZVByb3BzRmFjdG9yaWVzLFxuICAgICAgbWVyZ2VQcm9wc0ZhY3RvcmllcyA9IF9yZWYkbWVyZ2VQcm9wc0ZhY3RvciA9PT0gdm9pZCAwID8gZGVmYXVsdE1lcmdlUHJvcHNGYWN0b3JpZXMgOiBfcmVmJG1lcmdlUHJvcHNGYWN0b3IsXG4gICAgICBfcmVmJHNlbGVjdG9yRmFjdG9yeSA9IF9yZWYuc2VsZWN0b3JGYWN0b3J5LFxuICAgICAgc2VsZWN0b3JGYWN0b3J5ID0gX3JlZiRzZWxlY3RvckZhY3RvcnkgPT09IHZvaWQgMCA/IGRlZmF1bHRTZWxlY3RvckZhY3RvcnkgOiBfcmVmJHNlbGVjdG9yRmFjdG9yeTtcblxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdChtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgX3JlZjIpIHtcbiAgICBpZiAoX3JlZjIgPT09IHZvaWQgMCkge1xuICAgICAgX3JlZjIgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3JlZjMgPSBfcmVmMixcbiAgICAgICAgX3JlZjMkcHVyZSA9IF9yZWYzLnB1cmUsXG4gICAgICAgIHB1cmUgPSBfcmVmMyRwdXJlID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZjMkcHVyZSxcbiAgICAgICAgX3JlZjMkYXJlU3RhdGVzRXF1YWwgPSBfcmVmMy5hcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgYXJlU3RhdGVzRXF1YWwgPSBfcmVmMyRhcmVTdGF0ZXNFcXVhbCA9PT0gdm9pZCAwID8gc3RyaWN0RXF1YWwgOiBfcmVmMyRhcmVTdGF0ZXNFcXVhbCxcbiAgICAgICAgX3JlZjMkYXJlT3duUHJvcHNFcXVhID0gX3JlZjMuYXJlT3duUHJvcHNFcXVhbCxcbiAgICAgICAgYXJlT3duUHJvcHNFcXVhbCA9IF9yZWYzJGFyZU93blByb3BzRXF1YSA9PT0gdm9pZCAwID8gc2hhbGxvd0VxdWFsIDogX3JlZjMkYXJlT3duUHJvcHNFcXVhLFxuICAgICAgICBfcmVmMyRhcmVTdGF0ZVByb3BzRXEgPSBfcmVmMy5hcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICAgIGFyZVN0YXRlUHJvcHNFcXVhbCA9IF9yZWYzJGFyZVN0YXRlUHJvcHNFcSA9PT0gdm9pZCAwID8gc2hhbGxvd0VxdWFsIDogX3JlZjMkYXJlU3RhdGVQcm9wc0VxLFxuICAgICAgICBfcmVmMyRhcmVNZXJnZWRQcm9wc0UgPSBfcmVmMy5hcmVNZXJnZWRQcm9wc0VxdWFsLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZjMkYXJlTWVyZ2VkUHJvcHNFID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfcmVmMyRhcmVNZXJnZWRQcm9wc0UsXG4gICAgICAgIGV4dHJhT3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYzLCBbXCJwdXJlXCIsIFwiYXJlU3RhdGVzRXF1YWxcIiwgXCJhcmVPd25Qcm9wc0VxdWFsXCIsIFwiYXJlU3RhdGVQcm9wc0VxdWFsXCIsIFwiYXJlTWVyZ2VkUHJvcHNFcXVhbFwiXSk7XG5cbiAgICB2YXIgaW5pdE1hcFN0YXRlVG9Qcm9wcyA9IG1hdGNoKG1hcFN0YXRlVG9Qcm9wcywgbWFwU3RhdGVUb1Byb3BzRmFjdG9yaWVzLCAnbWFwU3RhdGVUb1Byb3BzJyk7XG4gICAgdmFyIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBtYXRjaChtYXBEaXNwYXRjaFRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wc0ZhY3RvcmllcywgJ21hcERpc3BhdGNoVG9Qcm9wcycpO1xuICAgIHZhciBpbml0TWVyZ2VQcm9wcyA9IG1hdGNoKG1lcmdlUHJvcHMsIG1lcmdlUHJvcHNGYWN0b3JpZXMsICdtZXJnZVByb3BzJyk7XG4gICAgcmV0dXJuIGNvbm5lY3RIT0Moc2VsZWN0b3JGYWN0b3J5LCBfZXh0ZW5kcyh7XG4gICAgICAvLyB1c2VkIGluIGVycm9yIG1lc3NhZ2VzXG4gICAgICBtZXRob2ROYW1lOiAnY29ubmVjdCcsXG4gICAgICAvLyB1c2VkIHRvIGNvbXB1dGUgQ29ubmVjdCdzIGRpc3BsYXlOYW1lIGZyb20gdGhlIHdyYXBwZWQgY29tcG9uZW50J3MgZGlzcGxheU5hbWUuXG4gICAgICBnZXREaXNwbGF5TmFtZTogZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gXCJDb25uZWN0KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSxcbiAgICAgIC8vIGlmIG1hcFN0YXRlVG9Qcm9wcyBpcyBmYWxzeSwgdGhlIENvbm5lY3QgY29tcG9uZW50IGRvZXNuJ3Qgc3Vic2NyaWJlIHRvIHN0b3JlIHN0YXRlIGNoYW5nZXNcbiAgICAgIHNob3VsZEhhbmRsZVN0YXRlQ2hhbmdlczogQm9vbGVhbihtYXBTdGF0ZVRvUHJvcHMpLFxuICAgICAgLy8gcGFzc2VkIHRocm91Z2ggdG8gc2VsZWN0b3JGYWN0b3J5XG4gICAgICBpbml0TWFwU3RhdGVUb1Byb3BzOiBpbml0TWFwU3RhdGVUb1Byb3BzLFxuICAgICAgaW5pdE1hcERpc3BhdGNoVG9Qcm9wczogaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyxcbiAgICAgIGluaXRNZXJnZVByb3BzOiBpbml0TWVyZ2VQcm9wcyxcbiAgICAgIHB1cmU6IHB1cmUsXG4gICAgICBhcmVTdGF0ZXNFcXVhbDogYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsOiBhcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsOiBhcmVTdGF0ZVByb3BzRXF1YWwsXG4gICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsOiBhcmVNZXJnZWRQcm9wc0VxdWFsXG4gICAgfSwgZXh0cmFPcHRpb25zKSk7XG4gIH07XG59XG5leHBvcnQgZGVmYXVsdFxuLyojX19QVVJFX18qL1xuY3JlYXRlQ29ubmVjdCgpOyIsImltcG9ydCB7IGJpbmRBY3Rpb25DcmVhdG9ycyB9IGZyb20gJ3JlZHV4JztcbmltcG9ydCB7IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQsIHdyYXBNYXBUb1Byb3BzRnVuYyB9IGZyb20gJy4vd3JhcE1hcFRvUHJvcHMnO1xuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc0Z1bmN0aW9uKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gdHlwZW9mIG1hcERpc3BhdGNoVG9Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXBNYXBUb1Byb3BzRnVuYyhtYXBEaXNwYXRjaFRvUHJvcHMsICdtYXBEaXNwYXRjaFRvUHJvcHMnKSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNNaXNzaW5nKG1hcERpc3BhdGNoVG9Qcm9wcykge1xuICByZXR1cm4gIW1hcERpc3BhdGNoVG9Qcm9wcyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpc3BhdGNoOiBkaXNwYXRjaFxuICAgIH07XG4gIH0pIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdChtYXBEaXNwYXRjaFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcERpc3BhdGNoVG9Qcm9wcyAmJiB0eXBlb2YgbWFwRGlzcGF0Y2hUb1Byb3BzID09PSAnb2JqZWN0JyA/IHdyYXBNYXBUb1Byb3BzQ29uc3RhbnQoZnVuY3Rpb24gKGRpc3BhdGNoKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9ycyhtYXBEaXNwYXRjaFRvUHJvcHMsIGRpc3BhdGNoKTtcbiAgfSkgOiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZGVmYXVsdCBbd2hlbk1hcERpc3BhdGNoVG9Qcm9wc0lzRnVuY3Rpb24sIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc01pc3NpbmcsIHdoZW5NYXBEaXNwYXRjaFRvUHJvcHNJc09iamVjdF07IiwiaW1wb3J0IHsgd3JhcE1hcFRvUHJvcHNDb25zdGFudCwgd3JhcE1hcFRvUHJvcHNGdW5jIH0gZnJvbSAnLi93cmFwTWFwVG9Qcm9wcyc7XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1hcFN0YXRlVG9Qcm9wc0lzRnVuY3Rpb24obWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiB0eXBlb2YgbWFwU3RhdGVUb1Byb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1hcFRvUHJvcHNGdW5jKG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NYXBTdGF0ZVRvUHJvcHNJc01pc3NpbmcobWFwU3RhdGVUb1Byb3BzKSB7XG4gIHJldHVybiAhbWFwU3RhdGVUb1Byb3BzID8gd3JhcE1hcFRvUHJvcHNDb25zdGFudChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9KSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWFwU3RhdGVUb1Byb3BzSXNGdW5jdGlvbiwgd2hlbk1hcFN0YXRlVG9Qcm9wc0lzTWlzc2luZ107IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgdmVyaWZ5UGxhaW5PYmplY3QgZnJvbSAnLi4vdXRpbHMvdmVyaWZ5UGxhaW5PYmplY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRNZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb3duUHJvcHMsIHt9LCBzdGF0ZVByb3BzLCB7fSwgZGlzcGF0Y2hQcm9wcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGluaXRNZXJnZVByb3BzUHJveHkoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lLFxuICAgICAgICBwdXJlID0gX3JlZi5wdXJlLFxuICAgICAgICBhcmVNZXJnZWRQcm9wc0VxdWFsID0gX3JlZi5hcmVNZXJnZWRQcm9wc0VxdWFsO1xuICAgIHZhciBoYXNSdW5PbmNlID0gZmFsc2U7XG4gICAgdmFyIG1lcmdlZFByb3BzO1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZVByb3BzUHJveHkoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpIHtcbiAgICAgIHZhciBuZXh0TWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcblxuICAgICAgaWYgKGhhc1J1bk9uY2UpIHtcbiAgICAgICAgaWYgKCFwdXJlIHx8ICFhcmVNZXJnZWRQcm9wc0VxdWFsKG5leHRNZXJnZWRQcm9wcywgbWVyZ2VkUHJvcHMpKSBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhc1J1bk9uY2UgPSB0cnVlO1xuICAgICAgICBtZXJnZWRQcm9wcyA9IG5leHRNZXJnZWRQcm9wcztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KG1lcmdlZFByb3BzLCBkaXNwbGF5TmFtZSwgJ21lcmdlUHJvcHMnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICAgIH07XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gd2hlbk1lcmdlUHJvcHNJc0Z1bmN0aW9uKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBtZXJnZVByb3BzID09PSAnZnVuY3Rpb24nID8gd3JhcE1lcmdlUHJvcHNGdW5jKG1lcmdlUHJvcHMpIDogdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkKG1lcmdlUHJvcHMpIHtcbiAgcmV0dXJuICFtZXJnZVByb3BzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWVyZ2VQcm9wcztcbiAgfSA6IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBkZWZhdWx0IFt3aGVuTWVyZ2VQcm9wc0lzRnVuY3Rpb24sIHdoZW5NZXJnZVByb3BzSXNPbWl0dGVkXTsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCB2ZXJpZnlTdWJzZWxlY3RvcnMgZnJvbSAnLi92ZXJpZnlTdWJzZWxlY3RvcnMnO1xuZXhwb3J0IGZ1bmN0aW9uIGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpbXB1cmVGaW5hbFByb3BzU2VsZWN0b3Ioc3RhdGUsIG93blByb3BzKSB7XG4gICAgcmV0dXJuIG1lcmdlUHJvcHMobWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyksIG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpLCBvd25Qcm9wcyk7XG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBfcmVmKSB7XG4gIHZhciBhcmVTdGF0ZXNFcXVhbCA9IF9yZWYuYXJlU3RhdGVzRXF1YWwsXG4gICAgICBhcmVPd25Qcm9wc0VxdWFsID0gX3JlZi5hcmVPd25Qcm9wc0VxdWFsLFxuICAgICAgYXJlU3RhdGVQcm9wc0VxdWFsID0gX3JlZi5hcmVTdGF0ZVByb3BzRXF1YWw7XG4gIHZhciBoYXNSdW5BdExlYXN0T25jZSA9IGZhbHNlO1xuICB2YXIgc3RhdGU7XG4gIHZhciBvd25Qcm9wcztcbiAgdmFyIHN0YXRlUHJvcHM7XG4gIHZhciBkaXNwYXRjaFByb3BzO1xuICB2YXIgbWVyZ2VkUHJvcHM7XG5cbiAgZnVuY3Rpb24gaGFuZGxlRmlyc3RDYWxsKGZpcnN0U3RhdGUsIGZpcnN0T3duUHJvcHMpIHtcbiAgICBzdGF0ZSA9IGZpcnN0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBmaXJzdE93blByb3BzO1xuICAgIHN0YXRlUHJvcHMgPSBtYXBTdGF0ZVRvUHJvcHMoc3RhdGUsIG93blByb3BzKTtcbiAgICBkaXNwYXRjaFByb3BzID0gbWFwRGlzcGF0Y2hUb1Byb3BzKGRpc3BhdGNoLCBvd25Qcm9wcyk7XG4gICAgbWVyZ2VkUHJvcHMgPSBtZXJnZVByb3BzKHN0YXRlUHJvcHMsIGRpc3BhdGNoUHJvcHMsIG93blByb3BzKTtcbiAgICBoYXNSdW5BdExlYXN0T25jZSA9IHRydWU7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHNBbmROZXdTdGF0ZSgpIHtcbiAgICBzdGF0ZVByb3BzID0gbWFwU3RhdGVUb1Byb3BzKHN0YXRlLCBvd25Qcm9wcyk7XG4gICAgaWYgKG1hcERpc3BhdGNoVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgZGlzcGF0Y2hQcm9wcyA9IG1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3duUHJvcHMpO1xuICAgIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTmV3UHJvcHMoKSB7XG4gICAgaWYgKG1hcFN0YXRlVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcykgc3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIGlmIChtYXBEaXNwYXRjaFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMpIGRpc3BhdGNoUHJvcHMgPSBtYXBEaXNwYXRjaFRvUHJvcHMoZGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICBtZXJnZWRQcm9wcyA9IG1lcmdlUHJvcHMoc3RhdGVQcm9wcywgZGlzcGF0Y2hQcm9wcywgb3duUHJvcHMpO1xuICAgIHJldHVybiBtZXJnZWRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU5ld1N0YXRlKCkge1xuICAgIHZhciBuZXh0U3RhdGVQcm9wcyA9IG1hcFN0YXRlVG9Qcm9wcyhzdGF0ZSwgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZVByb3BzQ2hhbmdlZCA9ICFhcmVTdGF0ZVByb3BzRXF1YWwobmV4dFN0YXRlUHJvcHMsIHN0YXRlUHJvcHMpO1xuICAgIHN0YXRlUHJvcHMgPSBuZXh0U3RhdGVQcm9wcztcbiAgICBpZiAoc3RhdGVQcm9wc0NoYW5nZWQpIG1lcmdlZFByb3BzID0gbWVyZ2VQcm9wcyhzdGF0ZVByb3BzLCBkaXNwYXRjaFByb3BzLCBvd25Qcm9wcyk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlU3Vic2VxdWVudENhbGxzKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKSB7XG4gICAgdmFyIHByb3BzQ2hhbmdlZCA9ICFhcmVPd25Qcm9wc0VxdWFsKG5leHRPd25Qcm9wcywgb3duUHJvcHMpO1xuICAgIHZhciBzdGF0ZUNoYW5nZWQgPSAhYXJlU3RhdGVzRXF1YWwobmV4dFN0YXRlLCBzdGF0ZSk7XG4gICAgc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgb3duUHJvcHMgPSBuZXh0T3duUHJvcHM7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCAmJiBzdGF0ZUNoYW5nZWQpIHJldHVybiBoYW5kbGVOZXdQcm9wc0FuZE5ld1N0YXRlKCk7XG4gICAgaWYgKHByb3BzQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1Byb3BzKCk7XG4gICAgaWYgKHN0YXRlQ2hhbmdlZCkgcmV0dXJuIGhhbmRsZU5ld1N0YXRlKCk7XG4gICAgcmV0dXJuIG1lcmdlZFByb3BzO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHB1cmVGaW5hbFByb3BzU2VsZWN0b3IobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIHtcbiAgICByZXR1cm4gaGFzUnVuQXRMZWFzdE9uY2UgPyBoYW5kbGVTdWJzZXF1ZW50Q2FsbHMobmV4dFN0YXRlLCBuZXh0T3duUHJvcHMpIDogaGFuZGxlRmlyc3RDYWxsKG5leHRTdGF0ZSwgbmV4dE93blByb3BzKTtcbiAgfTtcbn0gLy8gVE9ETzogQWRkIG1vcmUgY29tbWVudHNcbi8vIElmIHB1cmUgaXMgdHJ1ZSwgdGhlIHNlbGVjdG9yIHJldHVybmVkIGJ5IHNlbGVjdG9yRmFjdG9yeSB3aWxsIG1lbW9pemUgaXRzIHJlc3VsdHMsXG4vLyBhbGxvd2luZyBjb25uZWN0QWR2YW5jZWQncyBzaG91bGRDb21wb25lbnRVcGRhdGUgdG8gcmV0dXJuIGZhbHNlIGlmIGZpbmFsXG4vLyBwcm9wcyBoYXZlIG5vdCBjaGFuZ2VkLiBJZiBmYWxzZSwgdGhlIHNlbGVjdG9yIHdpbGwgYWx3YXlzIHJldHVybiBhIG5ld1xuLy8gb2JqZWN0IGFuZCBzaG91bGRDb21wb25lbnRVcGRhdGUgd2lsbCBhbHdheXMgcmV0dXJuIHRydWUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbmFsUHJvcHNTZWxlY3RvckZhY3RvcnkoZGlzcGF0Y2gsIF9yZWYyKSB7XG4gIHZhciBpbml0TWFwU3RhdGVUb1Byb3BzID0gX3JlZjIuaW5pdE1hcFN0YXRlVG9Qcm9wcyxcbiAgICAgIGluaXRNYXBEaXNwYXRjaFRvUHJvcHMgPSBfcmVmMi5pbml0TWFwRGlzcGF0Y2hUb1Byb3BzLFxuICAgICAgaW5pdE1lcmdlUHJvcHMgPSBfcmVmMi5pbml0TWVyZ2VQcm9wcyxcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmMiwgW1wiaW5pdE1hcFN0YXRlVG9Qcm9wc1wiLCBcImluaXRNYXBEaXNwYXRjaFRvUHJvcHNcIiwgXCJpbml0TWVyZ2VQcm9wc1wiXSk7XG5cbiAgdmFyIG1hcFN0YXRlVG9Qcm9wcyA9IGluaXRNYXBTdGF0ZVRvUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuICB2YXIgbWFwRGlzcGF0Y2hUb1Byb3BzID0gaW5pdE1hcERpc3BhdGNoVG9Qcm9wcyhkaXNwYXRjaCwgb3B0aW9ucyk7XG4gIHZhciBtZXJnZVByb3BzID0gaW5pdE1lcmdlUHJvcHMoZGlzcGF0Y2gsIG9wdGlvbnMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmVyaWZ5U3Vic2VsZWN0b3JzKG1hcFN0YXRlVG9Qcm9wcywgbWFwRGlzcGF0Y2hUb1Byb3BzLCBtZXJnZVByb3BzLCBvcHRpb25zLmRpc3BsYXlOYW1lKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RvckZhY3RvcnkgPSBvcHRpb25zLnB1cmUgPyBwdXJlRmluYWxQcm9wc1NlbGVjdG9yRmFjdG9yeSA6IGltcHVyZUZpbmFsUHJvcHNTZWxlY3RvckZhY3Rvcnk7XG4gIHJldHVybiBzZWxlY3RvckZhY3RvcnkobWFwU3RhdGVUb1Byb3BzLCBtYXBEaXNwYXRjaFRvUHJvcHMsIG1lcmdlUHJvcHMsIGRpc3BhdGNoLCBvcHRpb25zKTtcbn0iLCJpbXBvcnQgd2FybmluZyBmcm9tICcuLi91dGlscy93YXJuaW5nJztcblxuZnVuY3Rpb24gdmVyaWZ5KHNlbGVjdG9yLCBtZXRob2ROYW1lLCBkaXNwbGF5TmFtZSkge1xuICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgaW4gXCIgKyBkaXNwbGF5TmFtZSArIFwiLlwiKTtcbiAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAnbWFwU3RhdGVUb1Byb3BzJyB8fCBtZXRob2ROYW1lID09PSAnbWFwRGlzcGF0Y2hUb1Byb3BzJykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlbGVjdG9yLCAnZGVwZW5kc09uT3duUHJvcHMnKSkge1xuICAgICAgd2FybmluZyhcIlRoZSBzZWxlY3RvciBmb3IgXCIgKyBtZXRob2ROYW1lICsgXCIgb2YgXCIgKyBkaXNwbGF5TmFtZSArIFwiIGRpZCBub3Qgc3BlY2lmeSBhIHZhbHVlIGZvciBkZXBlbmRzT25Pd25Qcm9wcy5cIik7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHZlcmlmeVN1YnNlbGVjdG9ycyhtYXBTdGF0ZVRvUHJvcHMsIG1hcERpc3BhdGNoVG9Qcm9wcywgbWVyZ2VQcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmVyaWZ5KG1hcFN0YXRlVG9Qcm9wcywgJ21hcFN0YXRlVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1hcERpc3BhdGNoVG9Qcm9wcywgJ21hcERpc3BhdGNoVG9Qcm9wcycsIGRpc3BsYXlOYW1lKTtcbiAgdmVyaWZ5KG1lcmdlUHJvcHMsICdtZXJnZVByb3BzJywgZGlzcGxheU5hbWUpO1xufSIsImltcG9ydCB2ZXJpZnlQbGFpbk9iamVjdCBmcm9tICcuLi91dGlscy92ZXJpZnlQbGFpbk9iamVjdCc7XG5leHBvcnQgZnVuY3Rpb24gd3JhcE1hcFRvUHJvcHNDb25zdGFudChnZXRDb25zdGFudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdENvbnN0YW50U2VsZWN0b3IoZGlzcGF0Y2gsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29uc3RhbnQgPSBnZXRDb25zdGFudChkaXNwYXRjaCwgb3B0aW9ucyk7XG5cbiAgICBmdW5jdGlvbiBjb25zdGFudFNlbGVjdG9yKCkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50O1xuICAgIH1cblxuICAgIGNvbnN0YW50U2VsZWN0b3IuZGVwZW5kc09uT3duUHJvcHMgPSBmYWxzZTtcbiAgICByZXR1cm4gY29uc3RhbnRTZWxlY3RvcjtcbiAgfTtcbn0gLy8gZGVwZW5kc09uT3duUHJvcHMgaXMgdXNlZCBieSBjcmVhdGVNYXBUb1Byb3BzUHJveHkgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGFzcyBwcm9wcyBhcyBhcmdzXG4vLyB0byB0aGUgbWFwVG9Qcm9wcyBmdW5jdGlvbiBiZWluZyB3cmFwcGVkLiBJdCBpcyBhbHNvIHVzZWQgYnkgbWFrZVB1cmVQcm9wc1NlbGVjdG9yIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBtYXBUb1Byb3BzIG5lZWRzIHRvIGJlIGludm9rZWQgd2hlbiBwcm9wcyBoYXZlIGNoYW5nZWQuXG4vL1xuLy8gQSBsZW5ndGggb2Ygb25lIHNpZ25hbHMgdGhhdCBtYXBUb1Byb3BzIGRvZXMgbm90IGRlcGVuZCBvbiBwcm9wcyBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuLy8gQSBsZW5ndGggb2YgemVybyBpcyBhc3N1bWVkIHRvIG1lYW4gbWFwVG9Qcm9wcyBpcyBnZXR0aW5nIGFyZ3MgdmlhIGFyZ3VtZW50cyBvciAuLi5hcmdzIGFuZFxuLy8gdGhlcmVmb3JlIG5vdCByZXBvcnRpbmcgaXRzIGxlbmd0aCBhY2N1cmF0ZWx5Li5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpIHtcbiAgcmV0dXJuIG1hcFRvUHJvcHMuZGVwZW5kc09uT3duUHJvcHMgIT09IG51bGwgJiYgbWFwVG9Qcm9wcy5kZXBlbmRzT25Pd25Qcm9wcyAhPT0gdW5kZWZpbmVkID8gQm9vbGVhbihtYXBUb1Byb3BzLmRlcGVuZHNPbk93blByb3BzKSA6IG1hcFRvUHJvcHMubGVuZ3RoICE9PSAxO1xufSAvLyBVc2VkIGJ5IHdoZW5NYXBTdGF0ZVRvUHJvcHNJc0Z1bmN0aW9uIGFuZCB3aGVuTWFwRGlzcGF0Y2hUb1Byb3BzSXNGdW5jdGlvbixcbi8vIHRoaXMgZnVuY3Rpb24gd3JhcHMgbWFwVG9Qcm9wcyBpbiBhIHByb3h5IGZ1bmN0aW9uIHdoaWNoIGRvZXMgc2V2ZXJhbCB0aGluZ3M6XG4vL1xuLy8gICogRGV0ZWN0cyB3aGV0aGVyIHRoZSBtYXBUb1Byb3BzIGZ1bmN0aW9uIGJlaW5nIGNhbGxlZCBkZXBlbmRzIG9uIHByb3BzLCB3aGljaFxuLy8gICAgaXMgdXNlZCBieSBzZWxlY3RvckZhY3RvcnkgdG8gZGVjaWRlIGlmIGl0IHNob3VsZCByZWludm9rZSBvbiBwcm9wcyBjaGFuZ2VzLlxuLy9cbi8vICAqIE9uIGZpcnN0IGNhbGwsIGhhbmRsZXMgbWFwVG9Qcm9wcyBpZiByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24sIGFuZCB0cmVhdHMgdGhhdFxuLy8gICAgbmV3IGZ1bmN0aW9uIGFzIHRoZSB0cnVlIG1hcFRvUHJvcHMgZm9yIHN1YnNlcXVlbnQgY2FsbHMuXG4vL1xuLy8gICogT24gZmlyc3QgY2FsbCwgdmVyaWZpZXMgdGhlIGZpcnN0IHJlc3VsdCBpcyBhIHBsYWluIG9iamVjdCwgaW4gb3JkZXIgdG8gd2FyblxuLy8gICAgdGhlIGRldmVsb3BlciB0aGF0IHRoZWlyIG1hcFRvUHJvcHMgZnVuY3Rpb24gaXMgbm90IHJldHVybmluZyBhIHZhbGlkIHJlc3VsdC5cbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTWFwVG9Qcm9wc0Z1bmMobWFwVG9Qcm9wcywgbWV0aG9kTmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24gaW5pdFByb3h5U2VsZWN0b3IoZGlzcGF0Y2gsIF9yZWYpIHtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBfcmVmLmRpc3BsYXlOYW1lO1xuXG4gICAgdmFyIHByb3h5ID0gZnVuY3Rpb24gbWFwVG9Qcm9wc1Byb3h5KHN0YXRlT3JEaXNwYXRjaCwgb3duUHJvcHMpIHtcbiAgICAgIHJldHVybiBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA/IHByb3h5Lm1hcFRvUHJvcHMoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykgOiBwcm94eS5tYXBUb1Byb3BzKHN0YXRlT3JEaXNwYXRjaCk7XG4gICAgfTsgLy8gYWxsb3cgZGV0ZWN0RmFjdG9yeUFuZFZlcmlmeSB0byBnZXQgb3duUHJvcHNcblxuXG4gICAgcHJveHkuZGVwZW5kc09uT3duUHJvcHMgPSB0cnVlO1xuXG4gICAgcHJveHkubWFwVG9Qcm9wcyA9IGZ1bmN0aW9uIGRldGVjdEZhY3RvcnlBbmRWZXJpZnkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcykge1xuICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IG1hcFRvUHJvcHM7XG4gICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKG1hcFRvUHJvcHMpO1xuICAgICAgdmFyIHByb3BzID0gcHJveHkoc3RhdGVPckRpc3BhdGNoLCBvd25Qcm9wcyk7XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJveHkubWFwVG9Qcm9wcyA9IHByb3BzO1xuICAgICAgICBwcm94eS5kZXBlbmRzT25Pd25Qcm9wcyA9IGdldERlcGVuZHNPbk93blByb3BzKHByb3BzKTtcbiAgICAgICAgcHJvcHMgPSBwcm94eShzdGF0ZU9yRGlzcGF0Y2gsIG93blByb3BzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHZlcmlmeVBsYWluT2JqZWN0KHByb3BzLCBkaXNwbGF5TmFtZSwgbWV0aG9kTmFtZSk7XG4gICAgICByZXR1cm4gcHJvcHM7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm94eTtcbiAgfTtcbn0iLCJpbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VTdG9yZSBhcyB1c2VEZWZhdWx0U3RvcmUsIGNyZWF0ZVN0b3JlSG9vayB9IGZyb20gJy4vdXNlU3RvcmUnO1xuLyoqXHJcbiAqIEhvb2sgZmFjdG9yeSwgd2hpY2ggY3JlYXRlcyBhIGB1c2VEaXNwYXRjaGAgaG9vayBib3VuZCB0byBhIGdpdmVuIGNvbnRleHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhY3QuQ29udGV4dH0gW2NvbnRleHQ9UmVhY3RSZWR1eENvbnRleHRdIENvbnRleHQgcGFzc2VkIHRvIHlvdXIgYDxQcm92aWRlcj5gLlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgYHVzZURpc3BhdGNoYCBob29rIGJvdW5kIHRvIHRoZSBzcGVjaWZpZWQgY29udGV4dC5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEaXNwYXRjaEhvb2soY29udGV4dCkge1xuICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgY29udGV4dCA9IFJlYWN0UmVkdXhDb250ZXh0O1xuICB9XG5cbiAgdmFyIHVzZVN0b3JlID0gY29udGV4dCA9PT0gUmVhY3RSZWR1eENvbnRleHQgPyB1c2VEZWZhdWx0U3RvcmUgOiBjcmVhdGVTdG9yZUhvb2soY29udGV4dCk7XG4gIHJldHVybiBmdW5jdGlvbiB1c2VEaXNwYXRjaCgpIHtcbiAgICB2YXIgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaDtcbiAgfTtcbn1cbi8qKlxyXG4gKiBBIGhvb2sgdG8gYWNjZXNzIHRoZSByZWR1eCBgZGlzcGF0Y2hgIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7YW55fGZ1bmN0aW9ufSByZWR1eCBzdG9yZSdzIGBkaXNwYXRjaGAgZnVuY3Rpb25cclxuICpcclxuICogQGV4YW1wbGVcclxuICpcclxuICogaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZURpc3BhdGNoIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xyXG4gKiAgIGNvbnN0IGRpc3BhdGNoID0gdXNlRGlzcGF0Y2goKVxyXG4gKiAgIGNvbnN0IGluY3JlYXNlQ291bnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IGRpc3BhdGNoKHsgdHlwZTogJ2luY3JlYXNlLWNvdW50ZXInIH0pLCBbXSlcclxuICogICByZXR1cm4gKFxyXG4gKiAgICAgPGRpdj5cclxuICogICAgICAgPHNwYW4+e3ZhbHVlfTwvc3Bhbj5cclxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtpbmNyZWFzZUNvdW50ZXJ9PkluY3JlYXNlIGNvdW50ZXI8L2J1dHRvbj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgIClcclxuICogfVxyXG4gKi9cblxuZXhwb3J0IHZhciB1c2VEaXNwYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5jcmVhdGVEaXNwYXRjaEhvb2soKTsiLCJpbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUmVhY3RSZWR1eENvbnRleHQgfSBmcm9tICcuLi9jb21wb25lbnRzL0NvbnRleHQnO1xuLyoqXHJcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgLiBUaGlzIGlzIGEgbG93LWxldmVsXHJcbiAqIGhvb2sgdGhhdCB5b3Ugc2hvdWxkIHVzdWFsbHkgbm90IG5lZWQgdG8gY2FsbCBkaXJlY3RseS5cclxuICpcclxuICogQHJldHVybnMge2FueX0gdGhlIHZhbHVlIG9mIHRoZSBgUmVhY3RSZWR1eENvbnRleHRgXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqXHJcbiAqIGltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcclxuICogaW1wb3J0IHsgdXNlUmVkdXhDb250ZXh0IH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKHsgdmFsdWUgfSkgPT4ge1xyXG4gKiAgIGNvbnN0IHsgc3RvcmUgfSA9IHVzZVJlZHV4Q29udGV4dCgpXHJcbiAqICAgcmV0dXJuIDxkaXY+e3N0b3JlLmdldFN0YXRlKCl9PC9kaXY+XHJcbiAqIH1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1eENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0VmFsdWUgPSB1c2VDb250ZXh0KFJlYWN0UmVkdXhDb250ZXh0KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhY29udGV4dFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgZmluZCByZWFjdC1yZWR1eCBjb250ZXh0IHZhbHVlOyBwbGVhc2UgZW5zdXJlIHRoZSBjb21wb25lbnQgaXMgd3JhcHBlZCBpbiBhIDxQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0VmFsdWU7XG59IiwiaW1wb3J0IHsgdXNlUmVkdWNlciwgdXNlUmVmLCB1c2VNZW1vLCB1c2VDb250ZXh0LCB1c2VEZWJ1Z1ZhbHVlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlUmVkdXhDb250ZXh0IGFzIHVzZURlZmF1bHRSZWR1eENvbnRleHQgfSBmcm9tICcuL3VzZVJlZHV4Q29udGV4dCc7XG5pbXBvcnQgU3Vic2NyaXB0aW9uIGZyb20gJy4uL3V0aWxzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5cbnZhciByZWZFcXVhbGl0eSA9IGZ1bmN0aW9uIHJlZkVxdWFsaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG5mdW5jdGlvbiB1c2VTZWxlY3RvcldpdGhTdG9yZUFuZFN1YnNjcmlwdGlvbihzZWxlY3RvciwgZXF1YWxpdHlGbiwgc3RvcmUsIGNvbnRleHRTdWIpIHtcbiAgdmFyIF91c2VSZWR1Y2VyID0gdXNlUmVkdWNlcihmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzICsgMTtcbiAgfSwgMCksXG4gICAgICBmb3JjZVJlbmRlciA9IF91c2VSZWR1Y2VyWzFdO1xuXG4gIHZhciBzdWJzY3JpcHRpb24gPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbihzdG9yZSwgY29udGV4dFN1Yik7XG4gIH0sIFtzdG9yZSwgY29udGV4dFN1Yl0pO1xuICB2YXIgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvciA9IHVzZVJlZigpO1xuICB2YXIgbGF0ZXN0U2VsZWN0b3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFN0b3JlU3RhdGUgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdGVkU3RhdGUgPSB1c2VSZWYoKTtcbiAgdmFyIHN0b3JlU3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICB2YXIgc2VsZWN0ZWRTdGF0ZTtcblxuICB0cnkge1xuICAgIGlmIChzZWxlY3RvciAhPT0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudCB8fCBzdG9yZVN0YXRlICE9PSBsYXRlc3RTdG9yZVN0YXRlLmN1cnJlbnQgfHwgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gc2VsZWN0b3Ioc3RvcmVTdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBlcnIubWVzc2FnZSArPSBcIlxcblRoZSBlcnJvciBtYXkgYmUgY29ycmVsYXRlZCB3aXRoIHRoaXMgcHJldmlvdXMgZXJyb3I6XFxuXCIgKyBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2sgKyBcIlxcblxcblwiO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTdG9yZVN0YXRlLmN1cnJlbnQgPSBzdG9yZVN0YXRlO1xuICAgIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCA9IHNlbGVjdGVkU3RhdGU7XG4gICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY2hlY2tGb3JVcGRhdGVzKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG5ld1NlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3Rvci5jdXJyZW50KHN0b3JlLmdldFN0YXRlKCkpO1xuXG4gICAgICAgIGlmIChlcXVhbGl0eUZuKG5ld1NlbGVjdGVkU3RhdGUsIGxhdGVzdFNlbGVjdGVkU3RhdGUuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBuZXdTZWxlY3RlZFN0YXRlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIHdlIGlnbm9yZSBhbGwgZXJyb3JzIGhlcmUsIHNpbmNlIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBpcyByZS1yZW5kZXJlZCwgdGhlIHNlbGVjdG9ycyBhcmUgY2FsbGVkIGFnYWluLCBhbmRcbiAgICAgICAgLy8gd2lsbCB0aHJvdyBhZ2FpbiwgaWYgbmVpdGhlciBwcm9wcyBub3Igc3RvcmUgc3RhdGVcbiAgICAgICAgLy8gY2hhbmdlZFxuICAgICAgICBsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQgPSBlcnI7XG4gICAgICB9XG5cbiAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgfVxuXG4gICAgc3Vic2NyaXB0aW9uLm9uU3RhdGVDaGFuZ2UgPSBjaGVja0ZvclVwZGF0ZXM7XG4gICAgc3Vic2NyaXB0aW9uLnRyeVN1YnNjcmliZSgpO1xuICAgIGNoZWNrRm9yVXBkYXRlcygpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uLnRyeVVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW3N0b3JlLCBzdWJzY3JpcHRpb25dKTtcbiAgcmV0dXJuIHNlbGVjdGVkU3RhdGU7XG59XG4vKipcclxuICogSG9vayBmYWN0b3J5LCB3aGljaCBjcmVhdGVzIGEgYHVzZVNlbGVjdG9yYCBob29rIGJvdW5kIHRvIGEgZ2l2ZW4gY29udGV4dC5cclxuICpcclxuICogQHBhcmFtIHtSZWFjdC5Db250ZXh0fSBbY29udGV4dD1SZWFjdFJlZHV4Q29udGV4dF0gQ29udGV4dCBwYXNzZWQgdG8geW91ciBgPFByb3ZpZGVyPmAuXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBgdXNlU2VsZWN0b3JgIGhvb2sgYm91bmQgdG8gdGhlIHNwZWNpZmllZCBjb250ZXh0LlxyXG4gKi9cblxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2VsZWN0b3JIb29rKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dDtcbiAgfVxuXG4gIHZhciB1c2VSZWR1eENvbnRleHQgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRSZWR1eENvbnRleHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTZWxlY3RvcihzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgIGlmIChlcXVhbGl0eUZuID09PSB2b2lkIDApIHtcbiAgICAgIGVxdWFsaXR5Rm4gPSByZWZFcXVhbGl0eTtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhc2VsZWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYSBzZWxlY3RvciB0byB1c2VTZWxlY3RvclwiKTtcbiAgICB9XG5cbiAgICB2YXIgX3VzZVJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dCgpLFxuICAgICAgICBzdG9yZSA9IF91c2VSZWR1eENvbnRleHQuc3RvcmUsXG4gICAgICAgIGNvbnRleHRTdWIgPSBfdXNlUmVkdXhDb250ZXh0LnN1YnNjcmlwdGlvbjtcblxuICAgIHZhciBzZWxlY3RlZFN0YXRlID0gdXNlU2VsZWN0b3JXaXRoU3RvcmVBbmRTdWJzY3JpcHRpb24oc2VsZWN0b3IsIGVxdWFsaXR5Rm4sIHN0b3JlLCBjb250ZXh0U3ViKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xuICB9O1xufVxuLyoqXHJcbiAqIEEgaG9vayB0byBhY2Nlc3MgdGhlIHJlZHV4IHN0b3JlJ3Mgc3RhdGUuIFRoaXMgaG9vayB0YWtlcyBhIHNlbGVjdG9yIGZ1bmN0aW9uXHJcbiAqIGFzIGFuIGFyZ3VtZW50LiBUaGUgc2VsZWN0b3IgaXMgY2FsbGVkIHdpdGggdGhlIHN0b3JlIHN0YXRlLlxyXG4gKlxyXG4gKiBUaGlzIGhvb2sgdGFrZXMgYW4gb3B0aW9uYWwgZXF1YWxpdHkgY29tcGFyaXNvbiBmdW5jdGlvbiBhcyB0aGUgc2Vjb25kIHBhcmFtZXRlclxyXG4gKiB0aGF0IGFsbG93cyB5b3UgdG8gY3VzdG9taXplIHRoZSB3YXkgdGhlIHNlbGVjdGVkIHN0YXRlIGlzIGNvbXBhcmVkIHRvIGRldGVybWluZVxyXG4gKiB3aGV0aGVyIHRoZSBjb21wb25lbnQgbmVlZHMgdG8gYmUgcmUtcmVuZGVyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNlbGVjdG9yIHRoZSBzZWxlY3RvciBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZXF1YWxpdHlGbiB0aGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5XHJcbiAqXHJcbiAqIEByZXR1cm5zIHthbnl9IHRoZSBzZWxlY3RlZCBzdGF0ZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZVNlbGVjdG9yIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBDb3VudGVyQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IGNvdW50ZXIgPSB1c2VTZWxlY3RvcihzdGF0ZSA9PiBzdGF0ZS5jb3VudGVyKVxyXG4gKiAgIHJldHVybiA8ZGl2Pntjb3VudGVyfTwvZGl2PlxyXG4gKiB9XHJcbiAqL1xuXG5leHBvcnQgdmFyIHVzZVNlbGVjdG9yID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVNlbGVjdG9ySG9vaygpOyIsImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBSZWFjdFJlZHV4Q29udGV4dCB9IGZyb20gJy4uL2NvbXBvbmVudHMvQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VSZWR1eENvbnRleHQgYXMgdXNlRGVmYXVsdFJlZHV4Q29udGV4dCB9IGZyb20gJy4vdXNlUmVkdXhDb250ZXh0Jztcbi8qKlxyXG4gKiBIb29rIGZhY3RvcnksIHdoaWNoIGNyZWF0ZXMgYSBgdXNlU3RvcmVgIGhvb2sgYm91bmQgdG8gYSBnaXZlbiBjb250ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWN0LkNvbnRleHR9IFtjb250ZXh0PVJlYWN0UmVkdXhDb250ZXh0XSBDb250ZXh0IHBhc3NlZCB0byB5b3VyIGA8UHJvdmlkZXI+YC5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGB1c2VTdG9yZWAgaG9vayBib3VuZCB0byB0aGUgc3BlY2lmaWVkIGNvbnRleHQuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RvcmVIb29rKGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkge1xuICAgIGNvbnRleHQgPSBSZWFjdFJlZHV4Q29udGV4dDtcbiAgfVxuXG4gIHZhciB1c2VSZWR1eENvbnRleHQgPSBjb250ZXh0ID09PSBSZWFjdFJlZHV4Q29udGV4dCA/IHVzZURlZmF1bHRSZWR1eENvbnRleHQgOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoY29udGV4dCk7XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgICB2YXIgX3VzZVJlZHV4Q29udGV4dCA9IHVzZVJlZHV4Q29udGV4dCgpLFxuICAgICAgICBzdG9yZSA9IF91c2VSZWR1eENvbnRleHQuc3RvcmU7XG5cbiAgICByZXR1cm4gc3RvcmU7XG4gIH07XG59XG4vKipcclxuICogQSBob29rIHRvIGFjY2VzcyB0aGUgcmVkdXggc3RvcmUuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHthbnl9IHRoZSByZWR1eCBzdG9yZVxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKlxyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXHJcbiAqIGltcG9ydCB7IHVzZVN0b3JlIH0gZnJvbSAncmVhY3QtcmVkdXgnXHJcbiAqXHJcbiAqIGV4cG9ydCBjb25zdCBFeGFtcGxlQ29tcG9uZW50ID0gKCkgPT4ge1xyXG4gKiAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUoKVxyXG4gKiAgIHJldHVybiA8ZGl2PntzdG9yZS5nZXRTdGF0ZSgpfTwvZGl2PlxyXG4gKiB9XHJcbiAqL1xuXG5leHBvcnQgdmFyIHVzZVN0b3JlID1cbi8qI19fUFVSRV9fKi9cbmNyZWF0ZVN0b3JlSG9vaygpOyIsImltcG9ydCBQcm92aWRlciBmcm9tICcuL2NvbXBvbmVudHMvUHJvdmlkZXInO1xuaW1wb3J0IGNvbm5lY3RBZHZhbmNlZCBmcm9tICcuL2NvbXBvbmVudHMvY29ubmVjdEFkdmFuY2VkJztcbmltcG9ydCB7IFJlYWN0UmVkdXhDb250ZXh0IH0gZnJvbSAnLi9jb21wb25lbnRzL0NvbnRleHQnO1xuaW1wb3J0IGNvbm5lY3QgZnJvbSAnLi9jb25uZWN0L2Nvbm5lY3QnO1xuaW1wb3J0IHsgdXNlRGlzcGF0Y2gsIGNyZWF0ZURpc3BhdGNoSG9vayB9IGZyb20gJy4vaG9va3MvdXNlRGlzcGF0Y2gnO1xuaW1wb3J0IHsgdXNlU2VsZWN0b3IsIGNyZWF0ZVNlbGVjdG9ySG9vayB9IGZyb20gJy4vaG9va3MvdXNlU2VsZWN0b3InO1xuaW1wb3J0IHsgdXNlU3RvcmUsIGNyZWF0ZVN0b3JlSG9vayB9IGZyb20gJy4vaG9va3MvdXNlU3RvcmUnO1xuaW1wb3J0IHsgc2V0QmF0Y2ggfSBmcm9tICcuL3V0aWxzL2JhdGNoJztcbmltcG9ydCB7IHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIGFzIGJhdGNoIH0gZnJvbSAnLi91dGlscy9yZWFjdEJhdGNoZWRVcGRhdGVzJztcbmltcG9ydCBzaGFsbG93RXF1YWwgZnJvbSAnLi91dGlscy9zaGFsbG93RXF1YWwnO1xuc2V0QmF0Y2goYmF0Y2gpO1xuZXhwb3J0IHsgUHJvdmlkZXIsIGNvbm5lY3RBZHZhbmNlZCwgUmVhY3RSZWR1eENvbnRleHQsIGNvbm5lY3QsIGJhdGNoLCB1c2VEaXNwYXRjaCwgY3JlYXRlRGlzcGF0Y2hIb29rLCB1c2VTZWxlY3RvciwgY3JlYXRlU2VsZWN0b3JIb29rLCB1c2VTdG9yZSwgY3JlYXRlU3RvcmVIb29rLCBzaGFsbG93RXF1YWwgfTsiLCJpbXBvcnQgeyBnZXRCYXRjaCB9IGZyb20gJy4vYmF0Y2gnOyAvLyBlbmNhcHN1bGF0ZXMgdGhlIHN1YnNjcmlwdGlvbiBsb2dpYyBmb3IgY29ubmVjdGluZyBhIGNvbXBvbmVudCB0byB0aGUgcmVkdXggc3RvcmUsIGFzXG4vLyB3ZWxsIGFzIG5lc3Rpbmcgc3Vic2NyaXB0aW9ucyBvZiBkZXNjZW5kYW50IGNvbXBvbmVudHMsIHNvIHRoYXQgd2UgY2FuIGVuc3VyZSB0aGVcbi8vIGFuY2VzdG9yIGNvbXBvbmVudHMgcmUtcmVuZGVyIGJlZm9yZSBkZXNjZW5kYW50c1xuXG52YXIgbnVsbExpc3RlbmVycyA9IHtcbiAgbm90aWZ5OiBmdW5jdGlvbiBub3RpZnkoKSB7fVxufTtcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXJDb2xsZWN0aW9uKCkge1xuICB2YXIgYmF0Y2ggPSBnZXRCYXRjaCgpO1xuICB2YXIgZmlyc3QgPSBudWxsO1xuICB2YXIgbGFzdCA9IG51bGw7XG4gIHJldHVybiB7XG4gICAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgZmlyc3QgPSBudWxsO1xuICAgICAgbGFzdCA9IG51bGw7XG4gICAgfSxcbiAgICBub3RpZnk6IGZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICAgIGJhdGNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZmlyc3Q7XG5cbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2soKTtcbiAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gW107XG4gICAgICB2YXIgbGlzdGVuZXIgPSBmaXJzdDtcblxuICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2spIHtcbiAgICAgIHZhciBpc1N1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGFzdCA9IHtcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBwcmV2OiBsYXN0XG4gICAgICB9O1xuXG4gICAgICBpZiAobGlzdGVuZXIucHJldikge1xuICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0ID0gbGlzdGVuZXI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgICAgaWYgKCFpc1N1YnNjcmliZWQgfHwgZmlyc3QgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLm5leHQpIHtcbiAgICAgICAgICBsaXN0ZW5lci5uZXh0LnByZXYgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3QgPSBsaXN0ZW5lci5wcmV2O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3RlbmVyLnByZXYpIHtcbiAgICAgICAgICBsaXN0ZW5lci5wcmV2Lm5leHQgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZpcnN0ID0gbGlzdGVuZXIubmV4dDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBTdWJzY3JpcHRpb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oc3RvcmUsIHBhcmVudFN1Yikge1xuICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gbnVsbDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IG51bGxMaXN0ZW5lcnM7XG4gICAgdGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyID0gdGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyLmJpbmQodGhpcyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3Vic2NyaXB0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkTmVzdGVkU3ViID0gZnVuY3Rpb24gYWRkTmVzdGVkU3ViKGxpc3RlbmVyKSB7XG4gICAgdGhpcy50cnlTdWJzY3JpYmUoKTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgfTtcblxuICBfcHJvdG8ubm90aWZ5TmVzdGVkU3VicyA9IGZ1bmN0aW9uIG5vdGlmeU5lc3RlZFN1YnMoKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMubm90aWZ5KCk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUNoYW5nZVdyYXBwZXIgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2VXcmFwcGVyKCkge1xuICAgIGlmICh0aGlzLm9uU3RhdGVDaGFuZ2UpIHtcbiAgICAgIHRoaXMub25TdGF0ZUNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNTdWJzY3JpYmVkID0gZnVuY3Rpb24gaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMudW5zdWJzY3JpYmUpO1xuICB9O1xuXG4gIF9wcm90by50cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlTdWJzY3JpYmUoKSB7XG4gICAgaWYgKCF0aGlzLnVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlID0gdGhpcy5wYXJlbnRTdWIgPyB0aGlzLnBhcmVudFN1Yi5hZGROZXN0ZWRTdWIodGhpcy5oYW5kbGVDaGFuZ2VXcmFwcGVyKSA6IHRoaXMuc3RvcmUuc3Vic2NyaWJlKHRoaXMuaGFuZGxlQ2hhbmdlV3JhcHBlcik7XG4gICAgICB0aGlzLmxpc3RlbmVycyA9IGNyZWF0ZUxpc3RlbmVyQ29sbGVjdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udHJ5VW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB0cnlVbnN1YnNjcmliZSgpIHtcbiAgICBpZiAodGhpcy51bnN1YnNjcmliZSkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy51bnN1YnNjcmliZSA9IG51bGw7XG4gICAgICB0aGlzLmxpc3RlbmVycy5jbGVhcigpO1xuICAgICAgdGhpcy5saXN0ZW5lcnMgPSBudWxsTGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5leHBvcnQgeyBTdWJzY3JpcHRpb24gYXMgZGVmYXVsdCB9OyIsIi8vIERlZmF1bHQgdG8gYSBkdW1teSBcImJhdGNoXCIgaW1wbGVtZW50YXRpb24gdGhhdCBqdXN0IHJ1bnMgdGhlIGNhbGxiYWNrXG5mdW5jdGlvbiBkZWZhdWx0Tm9vcEJhdGNoKGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKCk7XG59XG5cbnZhciBiYXRjaCA9IGRlZmF1bHROb29wQmF0Y2g7IC8vIEFsbG93IGluamVjdGluZyBhbm90aGVyIGJhdGNoaW5nIGZ1bmN0aW9uIGxhdGVyXG5cbmV4cG9ydCB2YXIgc2V0QmF0Y2ggPSBmdW5jdGlvbiBzZXRCYXRjaChuZXdCYXRjaCkge1xuICByZXR1cm4gYmF0Y2ggPSBuZXdCYXRjaDtcbn07IC8vIFN1cHBseSBhIGdldHRlciBqdXN0IHRvIHNraXAgZGVhbGluZyB3aXRoIEVTTSBiaW5kaW5nc1xuXG5leHBvcnQgdmFyIGdldEJhdGNoID0gZnVuY3Rpb24gZ2V0QmF0Y2goKSB7XG4gIHJldHVybiBiYXRjaDtcbn07IiwiLyoqXHJcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYXJndW1lbnQgYXBwZWFycyB0byBiZSBhIHBsYWluIG9iamVjdC5cclxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gIHZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopO1xuICBpZiAocHJvdG8gPT09IG51bGwpIHJldHVybiB0cnVlO1xuICB2YXIgYmFzZVByb3RvID0gcHJvdG87XG5cbiAgd2hpbGUgKE9iamVjdC5nZXRQcm90b3R5cGVPZihiYXNlUHJvdG8pICE9PSBudWxsKSB7XG4gICAgYmFzZVByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGJhc2VQcm90byk7XG4gIH1cblxuICByZXR1cm4gcHJvdG8gPT09IGJhc2VQcm90bztcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvbm8tdW5yZXNvbHZlZCAqL1xuZXhwb3J0IHsgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgfSBmcm9tICdyZWFjdC1kb20nOyIsImZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgaWYgKHggPT09IHkpIHtcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkgcmV0dXJuIHRydWU7XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7IC8vIFJlYWN0IGN1cnJlbnRseSB0aHJvd3MgYSB3YXJuaW5nIHdoZW4gdXNpbmcgdXNlTGF5b3V0RWZmZWN0IG9uIHRoZSBzZXJ2ZXIuXG4vLyBUbyBnZXQgYXJvdW5kIGl0LCB3ZSBjYW4gY29uZGl0aW9uYWxseSB1c2VFZmZlY3Qgb24gdGhlIHNlcnZlciAobm8tb3ApIGFuZFxuLy8gdXNlTGF5b3V0RWZmZWN0IGluIHRoZSBicm93c2VyLiBXZSBuZWVkIHVzZUxheW91dEVmZmVjdCB0byBlbnN1cmUgdGhlIHN0b3JlXG4vLyBzdWJzY3JpcHRpb24gY2FsbGJhY2sgYWx3YXlzIGhhcyB0aGUgc2VsZWN0b3IgZnJvbSB0aGUgbGF0ZXN0IHJlbmRlciBjb21taXRcbi8vIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGEgc3RvcmUgdXBkYXRlIG1heSBoYXBwZW4gYmV0d2VlbiByZW5kZXIgYW5kIHRoZSBlZmZlY3QsXG4vLyB3aGljaCBtYXkgY2F1c2UgbWlzc2VkIHVwZGF0ZXM7IHdlIGFsc28gbXVzdCBlbnN1cmUgdGhlIHN0b3JlIHN1YnNjcmlwdGlvblxuLy8gaXMgY3JlYXRlZCBzeW5jaHJvbm91c2x5LCBvdGhlcndpc2UgYSBzdG9yZSB1cGRhdGUgbWF5IG9jY3VyIGJlZm9yZSB0aGVcbi8vIHN1YnNjcmlwdGlvbiBpcyBjcmVhdGVkIGFuZCBhbiBpbmNvbnNpc3RlbnQgc3RhdGUgbWF5IGJlIG9ic2VydmVkXG5cbmV4cG9ydCB2YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7IiwiaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pc1BsYWluT2JqZWN0JztcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4vd2FybmluZyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2ZXJpZnlQbGFpbk9iamVjdCh2YWx1ZSwgZGlzcGxheU5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgIHdhcm5pbmcobWV0aG9kTmFtZSArIFwiKCkgaW4gXCIgKyBkaXNwbGF5TmFtZSArIFwiIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkIFwiICsgdmFsdWUgKyBcIi5cIik7XG4gIH1cbn0iLCIvKipcclxuICogUHJpbnRzIGEgd2FybmluZyBpbiB0aGUgY29uc29sZSBpZiBpdCBleGlzdHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSB3YXJuaW5nIG1lc3NhZ2UuXHJcbiAqIEByZXR1cm5zIHt2b2lkfVxyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eSAqL1xuICB9IGNhdGNoIChlKSB7fVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLWVtcHR5ICovXG5cbn0iLCJmdW5jdGlvbiBjcmVhdGVUaHVua01pZGRsZXdhcmUoZXh0cmFBcmd1bWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgZGlzcGF0Y2ggPSBfcmVmLmRpc3BhdGNoLFxuICAgICAgICBnZXRTdGF0ZSA9IF9yZWYuZ2V0U3RhdGU7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBhY3Rpb24oZGlzcGF0Y2gsIGdldFN0YXRlLCBleHRyYUFyZ3VtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0KGFjdGlvbik7XG4gICAgICB9O1xuICAgIH07XG4gIH07XG59XG5cbnZhciB0aHVuayA9IGNyZWF0ZVRodW5rTWlkZGxld2FyZSgpO1xudGh1bmsud2l0aEV4dHJhQXJndW1lbnQgPSBjcmVhdGVUaHVua01pZGRsZXdhcmU7XG5cbmV4cG9ydCBkZWZhdWx0IHRodW5rOyIsImltcG9ydCAkJG9ic2VydmFibGUgZnJvbSAnc3ltYm9sLW9ic2VydmFibGUnO1xuXG4vKipcbiAqIFRoZXNlIGFyZSBwcml2YXRlIGFjdGlvbiB0eXBlcyByZXNlcnZlZCBieSBSZWR1eC5cbiAqIEZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB5b3UgbXVzdCByZXR1cm4gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBJZiB0aGUgY3VycmVudCBzdGF0ZSBpcyB1bmRlZmluZWQsIHlvdSBtdXN0IHJldHVybiB0aGUgaW5pdGlhbCBzdGF0ZS5cbiAqIERvIG5vdCByZWZlcmVuY2UgdGhlc2UgYWN0aW9uIHR5cGVzIGRpcmVjdGx5IGluIHlvdXIgY29kZS5cbiAqL1xudmFyIHJhbmRvbVN0cmluZyA9IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZyg3KS5zcGxpdCgnJykuam9pbignLicpO1xufTtcblxudmFyIEFjdGlvblR5cGVzID0ge1xuICBJTklUOiBcIkBAcmVkdXgvSU5JVFwiICsgcmFuZG9tU3RyaW5nKCksXG4gIFJFUExBQ0U6IFwiQEByZWR1eC9SRVBMQUNFXCIgKyByYW5kb21TdHJpbmcoKSxcbiAgUFJPQkVfVU5LTk9XTl9BQ1RJT046IGZ1bmN0aW9uIFBST0JFX1VOS05PV05fQUNUSU9OKCkge1xuICAgIHJldHVybiBcIkBAcmVkdXgvUFJPQkVfVU5LTk9XTl9BQ1RJT05cIiArIHJhbmRvbVN0cmluZygpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBvYmogVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGFyZ3VtZW50IGFwcGVhcnMgdG8gYmUgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogPT09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3RvID0gb2JqO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUmVkdXggc3RvcmUgdGhhdCBob2xkcyB0aGUgc3RhdGUgdHJlZS5cbiAqIFRoZSBvbmx5IHdheSB0byBjaGFuZ2UgdGhlIGRhdGEgaW4gdGhlIHN0b3JlIGlzIHRvIGNhbGwgYGRpc3BhdGNoKClgIG9uIGl0LlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGEgc2luZ2xlIHN0b3JlIGluIHlvdXIgYXBwLiBUbyBzcGVjaWZ5IGhvdyBkaWZmZXJlbnRcbiAqIHBhcnRzIG9mIHRoZSBzdGF0ZSB0cmVlIHJlc3BvbmQgdG8gYWN0aW9ucywgeW91IG1heSBjb21iaW5lIHNldmVyYWwgcmVkdWNlcnNcbiAqIGludG8gYSBzaW5nbGUgcmVkdWNlciBmdW5jdGlvbiBieSB1c2luZyBgY29tYmluZVJlZHVjZXJzYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWR1Y2VyIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBuZXh0IHN0YXRlIHRyZWUsIGdpdmVuXG4gKiB0aGUgY3VycmVudCBzdGF0ZSB0cmVlIGFuZCB0aGUgYWN0aW9uIHRvIGhhbmRsZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gW3ByZWxvYWRlZFN0YXRlXSBUaGUgaW5pdGlhbCBzdGF0ZS4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGh5ZHJhdGUgdGhlIHN0YXRlIGZyb20gdGhlIHNlcnZlciBpbiB1bml2ZXJzYWwgYXBwcywgb3IgdG8gcmVzdG9yZSBhXG4gKiBwcmV2aW91c2x5IHNlcmlhbGl6ZWQgdXNlciBzZXNzaW9uLlxuICogSWYgeW91IHVzZSBgY29tYmluZVJlZHVjZXJzYCB0byBwcm9kdWNlIHRoZSByb290IHJlZHVjZXIgZnVuY3Rpb24sIHRoaXMgbXVzdCBiZVxuICogYW4gb2JqZWN0IHdpdGggdGhlIHNhbWUgc2hhcGUgYXMgYGNvbWJpbmVSZWR1Y2Vyc2Aga2V5cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZW5oYW5jZXJdIFRoZSBzdG9yZSBlbmhhbmNlci4gWW91IG1heSBvcHRpb25hbGx5IHNwZWNpZnkgaXRcbiAqIHRvIGVuaGFuY2UgdGhlIHN0b3JlIHdpdGggdGhpcmQtcGFydHkgY2FwYWJpbGl0aWVzIHN1Y2ggYXMgbWlkZGxld2FyZSxcbiAqIHRpbWUgdHJhdmVsLCBwZXJzaXN0ZW5jZSwgZXRjLiBUaGUgb25seSBzdG9yZSBlbmhhbmNlciB0aGF0IHNoaXBzIHdpdGggUmVkdXhcbiAqIGlzIGBhcHBseU1pZGRsZXdhcmUoKWAuXG4gKlxuICogQHJldHVybnMge1N0b3JlfSBBIFJlZHV4IHN0b3JlIHRoYXQgbGV0cyB5b3UgcmVhZCB0aGUgc3RhdGUsIGRpc3BhdGNoIGFjdGlvbnNcbiAqIGFuZCBzdWJzY3JpYmUgdG8gY2hhbmdlcy5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTdG9yZShyZWR1Y2VyLCBwcmVsb2FkZWRTdGF0ZSwgZW5oYW5jZXIpIHtcbiAgdmFyIF9yZWYyO1xuXG4gIGlmICh0eXBlb2YgcHJlbG9hZGVkU3RhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGVuaGFuY2VyID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbmhhbmNlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdCBsb29rcyBsaWtlIHlvdSBhcmUgcGFzc2luZyBzZXZlcmFsIHN0b3JlIGVuaGFuY2VycyB0byAnICsgJ2NyZWF0ZVN0b3JlKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCwgY29tcG9zZSB0aGVtICcgKyAndG9nZXRoZXIgdG8gYSBzaW5nbGUgZnVuY3Rpb24uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHByZWxvYWRlZFN0YXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbmhhbmNlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBlbmhhbmNlciA9IHByZWxvYWRlZFN0YXRlO1xuICAgIHByZWxvYWRlZFN0YXRlID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmhhbmNlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIGVuaGFuY2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBlbmhhbmNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIHJldHVybiBlbmhhbmNlcihjcmVhdGVTdG9yZSkocmVkdWNlciwgcHJlbG9hZGVkU3RhdGUpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiByZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgcmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHByZWxvYWRlZFN0YXRlO1xuICB2YXIgY3VycmVudExpc3RlbmVycyA9IFtdO1xuICB2YXIgbmV4dExpc3RlbmVycyA9IGN1cnJlbnRMaXN0ZW5lcnM7XG4gIHZhciBpc0Rpc3BhdGNoaW5nID0gZmFsc2U7XG4gIC8qKlxuICAgKiBUaGlzIG1ha2VzIGEgc2hhbGxvdyBjb3B5IG9mIGN1cnJlbnRMaXN0ZW5lcnMgc28gd2UgY2FuIHVzZVxuICAgKiBuZXh0TGlzdGVuZXJzIGFzIGEgdGVtcG9yYXJ5IGxpc3Qgd2hpbGUgZGlzcGF0Y2hpbmcuXG4gICAqXG4gICAqIFRoaXMgcHJldmVudHMgYW55IGJ1Z3MgYXJvdW5kIGNvbnN1bWVycyBjYWxsaW5nXG4gICAqIHN1YnNjcmliZS91bnN1YnNjcmliZSBpbiB0aGUgbWlkZGxlIG9mIGEgZGlzcGF0Y2guXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGVuc3VyZUNhbk11dGF0ZU5leHRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKG5leHRMaXN0ZW5lcnMgPT09IGN1cnJlbnRMaXN0ZW5lcnMpIHtcbiAgICAgIG5leHRMaXN0ZW5lcnMgPSBjdXJyZW50TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgc3RhdGUgdHJlZSBtYW5hZ2VkIGJ5IHRoZSBzdG9yZS5cbiAgICpcbiAgICogQHJldHVybnMge2FueX0gVGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IGNhbGwgc3RvcmUuZ2V0U3RhdGUoKSB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnVGhlIHJlZHVjZXIgaGFzIGFscmVhZHkgcmVjZWl2ZWQgdGhlIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiAnICsgJ1Bhc3MgaXQgZG93biBmcm9tIHRoZSB0b3AgcmVkdWNlciBpbnN0ZWFkIG9mIHJlYWRpbmcgaXQgZnJvbSB0aGUgc3RvcmUuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgfVxuICAvKipcbiAgICogQWRkcyBhIGNoYW5nZSBsaXN0ZW5lci4gSXQgd2lsbCBiZSBjYWxsZWQgYW55IHRpbWUgYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQsXG4gICAqIGFuZCBzb21lIHBhcnQgb2YgdGhlIHN0YXRlIHRyZWUgbWF5IHBvdGVudGlhbGx5IGhhdmUgY2hhbmdlZC4gWW91IG1heSB0aGVuXG4gICAqIGNhbGwgYGdldFN0YXRlKClgIHRvIHJlYWQgdGhlIGN1cnJlbnQgc3RhdGUgdHJlZSBpbnNpZGUgdGhlIGNhbGxiYWNrLlxuICAgKlxuICAgKiBZb3UgbWF5IGNhbGwgYGRpc3BhdGNoKClgIGZyb20gYSBjaGFuZ2UgbGlzdGVuZXIsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgKiBjYXZlYXRzOlxuICAgKlxuICAgKiAxLiBUaGUgc3Vic2NyaXB0aW9ucyBhcmUgc25hcHNob3R0ZWQganVzdCBiZWZvcmUgZXZlcnkgYGRpc3BhdGNoKClgIGNhbGwuXG4gICAqIElmIHlvdSBzdWJzY3JpYmUgb3IgdW5zdWJzY3JpYmUgd2hpbGUgdGhlIGxpc3RlbmVycyBhcmUgYmVpbmcgaW52b2tlZCwgdGhpc1xuICAgKiB3aWxsIG5vdCBoYXZlIGFueSBlZmZlY3Qgb24gdGhlIGBkaXNwYXRjaCgpYCB0aGF0IGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcy5cbiAgICogSG93ZXZlciwgdGhlIG5leHQgYGRpc3BhdGNoKClgIGNhbGwsIHdoZXRoZXIgbmVzdGVkIG9yIG5vdCwgd2lsbCB1c2UgYSBtb3JlXG4gICAqIHJlY2VudCBzbmFwc2hvdCBvZiB0aGUgc3Vic2NyaXB0aW9uIGxpc3QuXG4gICAqXG4gICAqIDIuIFRoZSBsaXN0ZW5lciBzaG91bGQgbm90IGV4cGVjdCB0byBzZWUgYWxsIHN0YXRlIGNoYW5nZXMsIGFzIHRoZSBzdGF0ZVxuICAgKiBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgYSBuZXN0ZWQgYGRpc3BhdGNoKClgIGJlZm9yZVxuICAgKiB0aGUgbGlzdGVuZXIgaXMgY2FsbGVkLiBJdCBpcywgaG93ZXZlciwgZ3VhcmFudGVlZCB0aGF0IGFsbCBzdWJzY3JpYmVyc1xuICAgKiByZWdpc3RlcmVkIGJlZm9yZSB0aGUgYGRpc3BhdGNoKClgIHN0YXJ0ZWQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgbGF0ZXN0XG4gICAqIHN0YXRlIGJ5IHRoZSB0aW1lIGl0IGV4aXRzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciBBIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgb24gZXZlcnkgZGlzcGF0Y2guXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0byByZW1vdmUgdGhpcyBjaGFuZ2UgbGlzdGVuZXIuXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0aGUgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbWF5IG5vdCBjYWxsIHN0b3JlLnN1YnNjcmliZSgpIHdoaWxlIHRoZSByZWR1Y2VyIGlzIGV4ZWN1dGluZy4gJyArICdJZiB5b3Ugd291bGQgbGlrZSB0byBiZSBub3RpZmllZCBhZnRlciB0aGUgc3RvcmUgaGFzIGJlZW4gdXBkYXRlZCwgc3Vic2NyaWJlIGZyb20gYSAnICsgJ2NvbXBvbmVudCBhbmQgaW52b2tlIHN0b3JlLmdldFN0YXRlKCkgaW4gdGhlIGNhbGxiYWNrIHRvIGFjY2VzcyB0aGUgbGF0ZXN0IHN0YXRlLiAnICsgJ1NlZSBodHRwczovL3JlZHV4LmpzLm9yZy9hcGktcmVmZXJlbmNlL3N0b3JlI3N1YnNjcmliZWxpc3RlbmVyIGZvciBtb3JlIGRldGFpbHMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGlzU3Vic2NyaWJlZCA9IHRydWU7XG4gICAgZW5zdXJlQ2FuTXV0YXRlTmV4dExpc3RlbmVycygpO1xuICAgIG5leHRMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgaWYgKCFpc1N1YnNjcmliZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNEaXNwYXRjaGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtYXkgbm90IHVuc3Vic2NyaWJlIGZyb20gYSBzdG9yZSBsaXN0ZW5lciB3aGlsZSB0aGUgcmVkdWNlciBpcyBleGVjdXRpbmcuICcgKyAnU2VlIGh0dHBzOi8vcmVkdXguanMub3JnL2FwaS1yZWZlcmVuY2Uvc3RvcmUjc3Vic2NyaWJlbGlzdGVuZXIgZm9yIG1vcmUgZGV0YWlscy4nKTtcbiAgICAgIH1cblxuICAgICAgaXNTdWJzY3JpYmVkID0gZmFsc2U7XG4gICAgICBlbnN1cmVDYW5NdXRhdGVOZXh0TGlzdGVuZXJzKCk7XG4gICAgICB2YXIgaW5kZXggPSBuZXh0TGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgbmV4dExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgY3VycmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhbiBhY3Rpb24uIEl0IGlzIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGEgc3RhdGUgY2hhbmdlLlxuICAgKlxuICAgKiBUaGUgYHJlZHVjZXJgIGZ1bmN0aW9uLCB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmUsIHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlXG4gICAqIGN1cnJlbnQgc3RhdGUgdHJlZSBhbmQgdGhlIGdpdmVuIGBhY3Rpb25gLiBJdHMgcmV0dXJuIHZhbHVlIHdpbGxcbiAgICogYmUgY29uc2lkZXJlZCB0aGUgKipuZXh0Kiogc3RhdGUgb2YgdGhlIHRyZWUsIGFuZCB0aGUgY2hhbmdlIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvbmx5IHN1cHBvcnRzIHBsYWluIG9iamVjdCBhY3Rpb25zLiBJZiB5b3Ugd2FudCB0b1xuICAgKiBkaXNwYXRjaCBhIFByb21pc2UsIGFuIE9ic2VydmFibGUsIGEgdGh1bmssIG9yIHNvbWV0aGluZyBlbHNlLCB5b3UgbmVlZCB0b1xuICAgKiB3cmFwIHlvdXIgc3RvcmUgY3JlYXRpbmcgZnVuY3Rpb24gaW50byB0aGUgY29ycmVzcG9uZGluZyBtaWRkbGV3YXJlLiBGb3JcbiAgICogZXhhbXBsZSwgc2VlIHRoZSBkb2N1bWVudGF0aW9uIGZvciB0aGUgYHJlZHV4LXRodW5rYCBwYWNrYWdlLiBFdmVuIHRoZVxuICAgKiBtaWRkbGV3YXJlIHdpbGwgZXZlbnR1YWxseSBkaXNwYXRjaCBwbGFpbiBvYmplY3QgYWN0aW9ucyB1c2luZyB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiBBIHBsYWluIG9iamVjdCByZXByZXNlbnRpbmcg4oCcd2hhdCBjaGFuZ2Vk4oCdLiBJdCBpc1xuICAgKiBhIGdvb2QgaWRlYSB0byBrZWVwIGFjdGlvbnMgc2VyaWFsaXphYmxlIHNvIHlvdSBjYW4gcmVjb3JkIGFuZCByZXBsYXkgdXNlclxuICAgKiBzZXNzaW9ucywgb3IgdXNlIHRoZSB0aW1lIHRyYXZlbGxpbmcgYHJlZHV4LWRldnRvb2xzYC4gQW4gYWN0aW9uIG11c3QgaGF2ZVxuICAgKiBhIGB0eXBlYCBwcm9wZXJ0eSB3aGljaCBtYXkgbm90IGJlIGB1bmRlZmluZWRgLiBJdCBpcyBhIGdvb2QgaWRlYSB0byB1c2VcbiAgICogc3RyaW5nIGNvbnN0YW50cyBmb3IgYWN0aW9uIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBGb3IgY29udmVuaWVuY2UsIHRoZSBzYW1lIGFjdGlvbiBvYmplY3QgeW91IGRpc3BhdGNoZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCwgaWYgeW91IHVzZSBhIGN1c3RvbSBtaWRkbGV3YXJlLCBpdCBtYXkgd3JhcCBgZGlzcGF0Y2goKWAgdG9cbiAgICogcmV0dXJuIHNvbWV0aGluZyBlbHNlIChmb3IgZXhhbXBsZSwgYSBQcm9taXNlIHlvdSBjYW4gYXdhaXQpLlxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKGFjdGlvbikge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjdGlvbnMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiAnICsgJ1VzZSBjdXN0b20gbWlkZGxld2FyZSBmb3IgYXN5bmMgYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbi50eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY3Rpb25zIG1heSBub3QgaGF2ZSBhbiB1bmRlZmluZWQgXCJ0eXBlXCIgcHJvcGVydHkuICcgKyAnSGF2ZSB5b3UgbWlzc3BlbGxlZCBhIGNvbnN0YW50PycpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZHVjZXJzIG1heSBub3QgZGlzcGF0Y2ggYWN0aW9ucy4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaXNEaXNwYXRjaGluZyA9IHRydWU7XG4gICAgICBjdXJyZW50U3RhdGUgPSBjdXJyZW50UmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzRGlzcGF0Y2hpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudExpc3RlbmVycyA9IG5leHRMaXN0ZW5lcnM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWN0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgcmVkdWNlciBjdXJyZW50bHkgdXNlZCBieSB0aGUgc3RvcmUgdG8gY2FsY3VsYXRlIHRoZSBzdGF0ZS5cbiAgICpcbiAgICogWW91IG1pZ2h0IG5lZWQgdGhpcyBpZiB5b3VyIGFwcCBpbXBsZW1lbnRzIGNvZGUgc3BsaXR0aW5nIGFuZCB5b3Ugd2FudCB0b1xuICAgKiBsb2FkIHNvbWUgb2YgdGhlIHJlZHVjZXJzIGR5bmFtaWNhbGx5LiBZb3UgbWlnaHQgYWxzbyBuZWVkIHRoaXMgaWYgeW91XG4gICAqIGltcGxlbWVudCBhIGhvdCByZWxvYWRpbmcgbWVjaGFuaXNtIGZvciBSZWR1eC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dFJlZHVjZXIgVGhlIHJlZHVjZXIgZm9yIHRoZSBzdG9yZSB0byB1c2UgaW5zdGVhZC5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gcmVwbGFjZVJlZHVjZXIobmV4dFJlZHVjZXIpIHtcbiAgICBpZiAodHlwZW9mIG5leHRSZWR1Y2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBuZXh0UmVkdWNlciB0byBiZSBhIGZ1bmN0aW9uLicpO1xuICAgIH1cblxuICAgIGN1cnJlbnRSZWR1Y2VyID0gbmV4dFJlZHVjZXI7IC8vIFRoaXMgYWN0aW9uIGhhcyBhIHNpbWlsaWFyIGVmZmVjdCB0byBBY3Rpb25UeXBlcy5JTklULlxuICAgIC8vIEFueSByZWR1Y2VycyB0aGF0IGV4aXN0ZWQgaW4gYm90aCB0aGUgbmV3IGFuZCBvbGQgcm9vdFJlZHVjZXJcbiAgICAvLyB3aWxsIHJlY2VpdmUgdGhlIHByZXZpb3VzIHN0YXRlLiBUaGlzIGVmZmVjdGl2ZWx5IHBvcHVsYXRlc1xuICAgIC8vIHRoZSBuZXcgc3RhdGUgdHJlZSB3aXRoIGFueSByZWxldmFudCBkYXRhIGZyb20gdGhlIG9sZCBvbmUuXG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiBBY3Rpb25UeXBlcy5SRVBMQUNFXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEludGVyb3BlcmFiaWxpdHkgcG9pbnQgZm9yIG9ic2VydmFibGUvcmVhY3RpdmUgbGlicmFyaWVzLlxuICAgKiBAcmV0dXJucyB7b2JzZXJ2YWJsZX0gQSBtaW5pbWFsIG9ic2VydmFibGUgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGUgb2JzZXJ2YWJsZSBwcm9wb3NhbDpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIG9ic2VydmFibGUoKSB7XG4gICAgdmFyIF9yZWY7XG5cbiAgICB2YXIgb3V0ZXJTdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgcmV0dXJuIF9yZWYgPSB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBtaW5pbWFsIG9ic2VydmFibGUgc3Vic2NyaXB0aW9uIG1ldGhvZC5cbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlciBBbnkgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gb2JzZXJ2ZXIuXG4gICAgICAgKiBUaGUgb2JzZXJ2ZXIgb2JqZWN0IHNob3VsZCBoYXZlIGEgYG5leHRgIG1ldGhvZC5cbiAgICAgICAqIEByZXR1cm5zIHtzdWJzY3JpcHRpb259IEFuIG9iamVjdCB3aXRoIGFuIGB1bnN1YnNjcmliZWAgbWV0aG9kIHRoYXQgY2FuXG4gICAgICAgKiBiZSB1c2VkIHRvIHVuc3Vic2NyaWJlIHRoZSBvYnNlcnZhYmxlIGZyb20gdGhlIHN0b3JlLCBhbmQgcHJldmVudCBmdXJ0aGVyXG4gICAgICAgKiBlbWlzc2lvbiBvZiB2YWx1ZXMgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICAgICAqL1xuICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiBzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYnNlcnZlciAhPT0gJ29iamVjdCcgfHwgb2JzZXJ2ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCB0aGUgb2JzZXJ2ZXIgdG8gYmUgYW4gb2JqZWN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gb2JzZXJ2ZVN0YXRlKCkge1xuICAgICAgICAgIGlmIChvYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5uZXh0KGdldFN0YXRlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9ic2VydmVTdGF0ZSgpO1xuICAgICAgICB2YXIgdW5zdWJzY3JpYmUgPSBvdXRlclN1YnNjcmliZShvYnNlcnZlU3RhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuc3Vic2NyaWJlOiB1bnN1YnNjcmliZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIF9yZWZbJCRvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIF9yZWY7XG4gIH0gLy8gV2hlbiBhIHN0b3JlIGlzIGNyZWF0ZWQsIGFuIFwiSU5JVFwiIGFjdGlvbiBpcyBkaXNwYXRjaGVkIHNvIHRoYXQgZXZlcnlcbiAgLy8gcmVkdWNlciByZXR1cm5zIHRoZWlyIGluaXRpYWwgc3RhdGUuIFRoaXMgZWZmZWN0aXZlbHkgcG9wdWxhdGVzXG4gIC8vIHRoZSBpbml0aWFsIHN0YXRlIHRyZWUuXG5cblxuICBkaXNwYXRjaCh7XG4gICAgdHlwZTogQWN0aW9uVHlwZXMuSU5JVFxuICB9KTtcbiAgcmV0dXJuIF9yZWYyID0ge1xuICAgIGRpc3BhdGNoOiBkaXNwYXRjaCxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICBnZXRTdGF0ZTogZ2V0U3RhdGUsXG4gICAgcmVwbGFjZVJlZHVjZXI6IHJlcGxhY2VSZWR1Y2VyXG4gIH0sIF9yZWYyWyQkb2JzZXJ2YWJsZV0gPSBvYnNlcnZhYmxlLCBfcmVmMjtcbn1cblxuLyoqXG4gKiBQcmludHMgYSB3YXJuaW5nIGluIHRoZSBjb25zb2xlIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBUaGUgd2FybmluZyBtZXNzYWdlLlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHdhcm5pbmcobWVzc2FnZSkge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuXG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IGlmIHlvdSBlbmFibGVcbiAgICAvLyBcImJyZWFrIG9uIGFsbCBleGNlcHRpb25zXCIgaW4geW91ciBjb25zb2xlLFxuICAgIC8vIGl0IHdvdWxkIHBhdXNlIHRoZSBleGVjdXRpb24gYXQgdGhpcyBsaW5lLlxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfSBjYXRjaCAoZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eVxuXG59XG5cbmZ1bmN0aW9uIGdldFVuZGVmaW5lZFN0YXRlRXJyb3JNZXNzYWdlKGtleSwgYWN0aW9uKSB7XG4gIHZhciBhY3Rpb25UeXBlID0gYWN0aW9uICYmIGFjdGlvbi50eXBlO1xuICB2YXIgYWN0aW9uRGVzY3JpcHRpb24gPSBhY3Rpb25UeXBlICYmIFwiYWN0aW9uIFxcXCJcIiArIFN0cmluZyhhY3Rpb25UeXBlKSArIFwiXFxcIlwiIHx8ICdhbiBhY3Rpb24nO1xuICByZXR1cm4gXCJHaXZlbiBcIiArIGFjdGlvbkRlc2NyaXB0aW9uICsgXCIsIHJlZHVjZXIgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZC4gXCIgKyBcIlRvIGlnbm9yZSBhbiBhY3Rpb24sIHlvdSBtdXN0IGV4cGxpY2l0bHkgcmV0dXJuIHRoZSBwcmV2aW91cyBzdGF0ZS4gXCIgKyBcIklmIHlvdSB3YW50IHRoaXMgcmVkdWNlciB0byBob2xkIG5vIHZhbHVlLCB5b3UgY2FuIHJldHVybiBudWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkLlwiO1xufVxuXG5mdW5jdGlvbiBnZXRVbmV4cGVjdGVkU3RhdGVTaGFwZVdhcm5pbmdNZXNzYWdlKGlucHV0U3RhdGUsIHJlZHVjZXJzLCBhY3Rpb24sIHVuZXhwZWN0ZWRLZXlDYWNoZSkge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBhcmd1bWVudE5hbWUgPSBhY3Rpb24gJiYgYWN0aW9uLnR5cGUgPT09IEFjdGlvblR5cGVzLklOSVQgPyAncHJlbG9hZGVkU3RhdGUgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVN0b3JlJyA6ICdwcmV2aW91cyBzdGF0ZSByZWNlaXZlZCBieSB0aGUgcmVkdWNlcic7XG5cbiAgaWYgKHJlZHVjZXJLZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnU3RvcmUgZG9lcyBub3QgaGF2ZSBhIHZhbGlkIHJlZHVjZXIuIE1ha2Ugc3VyZSB0aGUgYXJndW1lbnQgcGFzc2VkICcgKyAndG8gY29tYmluZVJlZHVjZXJzIGlzIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIHJlZHVjZXJzLic7XG4gIH1cblxuICBpZiAoIWlzUGxhaW5PYmplY3QoaW5wdXRTdGF0ZSkpIHtcbiAgICByZXR1cm4gXCJUaGUgXCIgKyBhcmd1bWVudE5hbWUgKyBcIiBoYXMgdW5leHBlY3RlZCB0eXBlIG9mIFxcXCJcIiArIHt9LnRvU3RyaW5nLmNhbGwoaW5wdXRTdGF0ZSkubWF0Y2goL1xccyhbYS16fEEtWl0rKS8pWzFdICsgXCJcXFwiLiBFeHBlY3RlZCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIFwiICsgKFwia2V5czogXFxcIlwiICsgcmVkdWNlcktleXMuam9pbignXCIsIFwiJykgKyBcIlxcXCJcIik7XG4gIH1cblxuICB2YXIgdW5leHBlY3RlZEtleXMgPSBPYmplY3Qua2V5cyhpbnB1dFN0YXRlKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhcmVkdWNlcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdW5leHBlY3RlZEtleUNhY2hlW2tleV07XG4gIH0pO1xuICB1bmV4cGVjdGVkS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICB1bmV4cGVjdGVkS2V5Q2FjaGVba2V5XSA9IHRydWU7XG4gIH0pO1xuICBpZiAoYWN0aW9uICYmIGFjdGlvbi50eXBlID09PSBBY3Rpb25UeXBlcy5SRVBMQUNFKSByZXR1cm47XG5cbiAgaWYgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gXCJVbmV4cGVjdGVkIFwiICsgKHVuZXhwZWN0ZWRLZXlzLmxlbmd0aCA+IDEgPyAna2V5cycgOiAna2V5JykgKyBcIiBcIiArIChcIlxcXCJcIiArIHVuZXhwZWN0ZWRLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiIGZvdW5kIGluIFwiICsgYXJndW1lbnROYW1lICsgXCIuIFwiKSArIFwiRXhwZWN0ZWQgdG8gZmluZCBvbmUgb2YgdGhlIGtub3duIHJlZHVjZXIga2V5cyBpbnN0ZWFkOiBcIiArIChcIlxcXCJcIiArIHJlZHVjZXJLZXlzLmpvaW4oJ1wiLCBcIicpICsgXCJcXFwiLiBVbmV4cGVjdGVkIGtleXMgd2lsbCBiZSBpZ25vcmVkLlwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRSZWR1Y2VyU2hhcGUocmVkdWNlcnMpIHtcbiAgT2JqZWN0LmtleXMocmVkdWNlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciByZWR1Y2VyID0gcmVkdWNlcnNba2V5XTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLklOSVRcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlciBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgcmV0dXJuZWQgdW5kZWZpbmVkIGR1cmluZyBpbml0aWFsaXphdGlvbi4gXCIgKyBcIklmIHRoZSBzdGF0ZSBwYXNzZWQgdG8gdGhlIHJlZHVjZXIgaXMgdW5kZWZpbmVkLCB5b3UgbXVzdCBcIiArIFwiZXhwbGljaXRseSByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUuIFRoZSBpbml0aWFsIHN0YXRlIG1heSBcIiArIFwibm90IGJlIHVuZGVmaW5lZC4gSWYgeW91IGRvbid0IHdhbnQgdG8gc2V0IGEgdmFsdWUgZm9yIHRoaXMgcmVkdWNlciwgXCIgKyBcInlvdSBjYW4gdXNlIG51bGwgaW5zdGVhZCBvZiB1bmRlZmluZWQuXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcih1bmRlZmluZWQsIHtcbiAgICAgIHR5cGU6IEFjdGlvblR5cGVzLlBST0JFX1VOS05PV05fQUNUSU9OKClcbiAgICB9KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlZHVjZXIgXFxcIlwiICsga2V5ICsgXCJcXFwiIHJldHVybmVkIHVuZGVmaW5lZCB3aGVuIHByb2JlZCB3aXRoIGEgcmFuZG9tIHR5cGUuIFwiICsgKFwiRG9uJ3QgdHJ5IHRvIGhhbmRsZSBcIiArIEFjdGlvblR5cGVzLklOSVQgKyBcIiBvciBvdGhlciBhY3Rpb25zIGluIFxcXCJyZWR1eC8qXFxcIiBcIikgKyBcIm5hbWVzcGFjZS4gVGhleSBhcmUgY29uc2lkZXJlZCBwcml2YXRlLiBJbnN0ZWFkLCB5b3UgbXVzdCByZXR1cm4gdGhlIFwiICsgXCJjdXJyZW50IHN0YXRlIGZvciBhbnkgdW5rbm93biBhY3Rpb25zLCB1bmxlc3MgaXQgaXMgdW5kZWZpbmVkLCBcIiArIFwiaW4gd2hpY2ggY2FzZSB5b3UgbXVzdCByZXR1cm4gdGhlIGluaXRpYWwgc3RhdGUsIHJlZ2FyZGxlc3Mgb2YgdGhlIFwiICsgXCJhY3Rpb24gdHlwZS4gVGhlIGluaXRpYWwgc3RhdGUgbWF5IG5vdCBiZSB1bmRlZmluZWQsIGJ1dCBjYW4gYmUgbnVsbC5cIik7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogVHVybnMgYW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgZGlmZmVyZW50IHJlZHVjZXIgZnVuY3Rpb25zLCBpbnRvIGEgc2luZ2xlXG4gKiByZWR1Y2VyIGZ1bmN0aW9uLiBJdCB3aWxsIGNhbGwgZXZlcnkgY2hpbGQgcmVkdWNlciwgYW5kIGdhdGhlciB0aGVpciByZXN1bHRzXG4gKiBpbnRvIGEgc2luZ2xlIHN0YXRlIG9iamVjdCwgd2hvc2Uga2V5cyBjb3JyZXNwb25kIHRvIHRoZSBrZXlzIG9mIHRoZSBwYXNzZWRcbiAqIHJlZHVjZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWR1Y2VycyBBbiBvYmplY3Qgd2hvc2UgdmFsdWVzIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50XG4gKiByZWR1Y2VyIGZ1bmN0aW9ucyB0aGF0IG5lZWQgdG8gYmUgY29tYmluZWQgaW50byBvbmUuIE9uZSBoYW5keSB3YXkgdG8gb2J0YWluXG4gKiBpdCBpcyB0byB1c2UgRVM2IGBpbXBvcnQgKiBhcyByZWR1Y2Vyc2Agc3ludGF4LiBUaGUgcmVkdWNlcnMgbWF5IG5ldmVyIHJldHVyblxuICogdW5kZWZpbmVkIGZvciBhbnkgYWN0aW9uLiBJbnN0ZWFkLCB0aGV5IHNob3VsZCByZXR1cm4gdGhlaXIgaW5pdGlhbCBzdGF0ZVxuICogaWYgdGhlIHN0YXRlIHBhc3NlZCB0byB0aGVtIHdhcyB1bmRlZmluZWQsIGFuZCB0aGUgY3VycmVudCBzdGF0ZSBmb3IgYW55XG4gKiB1bnJlY29nbml6ZWQgYWN0aW9uLlxuICpcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSByZWR1Y2VyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBldmVyeSByZWR1Y2VyIGluc2lkZSB0aGVcbiAqIHBhc3NlZCBvYmplY3QsIGFuZCBidWlsZHMgYSBzdGF0ZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzaGFwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvbWJpbmVSZWR1Y2VycyhyZWR1Y2Vycykge1xuICB2YXIgcmVkdWNlcktleXMgPSBPYmplY3Qua2V5cyhyZWR1Y2Vycyk7XG4gIHZhciBmaW5hbFJlZHVjZXJzID0ge307XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWR1Y2VyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSByZWR1Y2VyS2V5c1tpXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHJlZHVjZXJzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoXCJObyByZWR1Y2VyIHByb3ZpZGVkIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcmVkdWNlcnNba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmluYWxSZWR1Y2Vyc1trZXldID0gcmVkdWNlcnNba2V5XTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmluYWxSZWR1Y2VyS2V5cyA9IE9iamVjdC5rZXlzKGZpbmFsUmVkdWNlcnMpOyAvLyBUaGlzIGlzIHVzZWQgdG8gbWFrZSBzdXJlIHdlIGRvbid0IHdhcm4gYWJvdXQgdGhlIHNhbWVcbiAgLy8ga2V5cyBtdWx0aXBsZSB0aW1lcy5cblxuICB2YXIgdW5leHBlY3RlZEtleUNhY2hlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdW5leHBlY3RlZEtleUNhY2hlID0ge307XG4gIH1cblxuICB2YXIgc2hhcGVBc3NlcnRpb25FcnJvcjtcblxuICB0cnkge1xuICAgIGFzc2VydFJlZHVjZXJTaGFwZShmaW5hbFJlZHVjZXJzKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNoYXBlQXNzZXJ0aW9uRXJyb3IgPSBlO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbWJpbmF0aW9uKHN0YXRlLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoc2hhcGVBc3NlcnRpb25FcnJvcikge1xuICAgICAgdGhyb3cgc2hhcGVBc3NlcnRpb25FcnJvcjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHdhcm5pbmdNZXNzYWdlID0gZ2V0VW5leHBlY3RlZFN0YXRlU2hhcGVXYXJuaW5nTWVzc2FnZShzdGF0ZSwgZmluYWxSZWR1Y2VycywgYWN0aW9uLCB1bmV4cGVjdGVkS2V5Q2FjaGUpO1xuXG4gICAgICBpZiAod2FybmluZ01lc3NhZ2UpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dFN0YXRlID0ge307XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZmluYWxSZWR1Y2VyS2V5cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfa2V5ID0gZmluYWxSZWR1Y2VyS2V5c1tfaV07XG4gICAgICB2YXIgcmVkdWNlciA9IGZpbmFsUmVkdWNlcnNbX2tleV07XG4gICAgICB2YXIgcHJldmlvdXNTdGF0ZUZvcktleSA9IHN0YXRlW19rZXldO1xuICAgICAgdmFyIG5leHRTdGF0ZUZvcktleSA9IHJlZHVjZXIocHJldmlvdXNTdGF0ZUZvcktleSwgYWN0aW9uKTtcblxuICAgICAgaWYgKHR5cGVvZiBuZXh0U3RhdGVGb3JLZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBnZXRVbmRlZmluZWRTdGF0ZUVycm9yTWVzc2FnZShfa2V5LCBhY3Rpb24pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIH1cblxuICAgICAgbmV4dFN0YXRlW19rZXldID0gbmV4dFN0YXRlRm9yS2V5O1xuICAgICAgaGFzQ2hhbmdlZCA9IGhhc0NoYW5nZWQgfHwgbmV4dFN0YXRlRm9yS2V5ICE9PSBwcmV2aW91c1N0YXRlRm9yS2V5O1xuICAgIH1cblxuICAgIGhhc0NoYW5nZWQgPSBoYXNDaGFuZ2VkIHx8IGZpbmFsUmVkdWNlcktleXMubGVuZ3RoICE9PSBPYmplY3Qua2V5cyhzdGF0ZSkubGVuZ3RoO1xuICAgIHJldHVybiBoYXNDaGFuZ2VkID8gbmV4dFN0YXRlIDogc3RhdGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3IsIGRpc3BhdGNoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKGFjdGlvbkNyZWF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH07XG59XG4vKipcbiAqIFR1cm5zIGFuIG9iamVjdCB3aG9zZSB2YWx1ZXMgYXJlIGFjdGlvbiBjcmVhdG9ycywgaW50byBhbiBvYmplY3Qgd2l0aCB0aGVcbiAqIHNhbWUga2V5cywgYnV0IHdpdGggZXZlcnkgZnVuY3Rpb24gd3JhcHBlZCBpbnRvIGEgYGRpc3BhdGNoYCBjYWxsIHNvIHRoZXlcbiAqIG1heSBiZSBpbnZva2VkIGRpcmVjdGx5LiBUaGlzIGlzIGp1c3QgYSBjb252ZW5pZW5jZSBtZXRob2QsIGFzIHlvdSBjYW4gY2FsbFxuICogYHN0b3JlLmRpc3BhdGNoKE15QWN0aW9uQ3JlYXRvcnMuZG9Tb21ldGhpbmcoKSlgIHlvdXJzZWxmIGp1c3QgZmluZS5cbiAqXG4gKiBGb3IgY29udmVuaWVuY2UsIHlvdSBjYW4gYWxzbyBwYXNzIGFuIGFjdGlvbiBjcmVhdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudCxcbiAqIGFuZCBnZXQgYSBkaXNwYXRjaCB3cmFwcGVkIGZ1bmN0aW9uIGluIHJldHVybi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufE9iamVjdH0gYWN0aW9uQ3JlYXRvcnMgQW4gb2JqZWN0IHdob3NlIHZhbHVlcyBhcmUgYWN0aW9uXG4gKiBjcmVhdG9yIGZ1bmN0aW9ucy4gT25lIGhhbmR5IHdheSB0byBvYnRhaW4gaXQgaXMgdG8gdXNlIEVTNiBgaW1wb3J0ICogYXNgXG4gKiBzeW50YXguIFlvdSBtYXkgYWxzbyBwYXNzIGEgc2luZ2xlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIFRoZSBgZGlzcGF0Y2hgIGZ1bmN0aW9uIGF2YWlsYWJsZSBvbiB5b3VyIFJlZHV4XG4gKiBzdG9yZS5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb258T2JqZWN0fSBUaGUgb2JqZWN0IG1pbWlja2luZyB0aGUgb3JpZ2luYWwgb2JqZWN0LCBidXQgd2l0aFxuICogZXZlcnkgYWN0aW9uIGNyZWF0b3Igd3JhcHBlZCBpbnRvIHRoZSBgZGlzcGF0Y2hgIGNhbGwuIElmIHlvdSBwYXNzZWQgYVxuICogZnVuY3Rpb24gYXMgYGFjdGlvbkNyZWF0b3JzYCwgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGFsc28gYmUgYSBzaW5nbGVcbiAqIGZ1bmN0aW9uLlxuICovXG5cblxuZnVuY3Rpb24gYmluZEFjdGlvbkNyZWF0b3JzKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCkge1xuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGJpbmRBY3Rpb25DcmVhdG9yKGFjdGlvbkNyZWF0b3JzLCBkaXNwYXRjaCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGFjdGlvbkNyZWF0b3JzICE9PSAnb2JqZWN0JyB8fCBhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImJpbmRBY3Rpb25DcmVhdG9ycyBleHBlY3RlZCBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbiwgaW5zdGVhZCByZWNlaXZlZCBcIiArIChhY3Rpb25DcmVhdG9ycyA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBhY3Rpb25DcmVhdG9ycykgKyBcIi4gXCIgKyBcIkRpZCB5b3Ugd3JpdGUgXFxcImltcG9ydCBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIiBpbnN0ZWFkIG9mIFxcXCJpbXBvcnQgKiBhcyBBY3Rpb25DcmVhdG9ycyBmcm9tXFxcIj9cIik7XG4gIH1cblxuICB2YXIgYm91bmRBY3Rpb25DcmVhdG9ycyA9IHt9O1xuXG4gIGZvciAodmFyIGtleSBpbiBhY3Rpb25DcmVhdG9ycykge1xuICAgIHZhciBhY3Rpb25DcmVhdG9yID0gYWN0aW9uQ3JlYXRvcnNba2V5XTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uQ3JlYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYm91bmRBY3Rpb25DcmVhdG9yc1trZXldID0gYmluZEFjdGlvbkNyZWF0b3IoYWN0aW9uQ3JlYXRvciwgZGlzcGF0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZEFjdGlvbkNyZWF0b3JzO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIGtleXMucHVzaC5hcHBseShrZXlzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpO1xuICB9XG5cbiAgaWYgKGVudW1lcmFibGVPbmx5KSBrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICB9KTtcbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQ29tcG9zZXMgc2luZ2xlLWFyZ3VtZW50IGZ1bmN0aW9ucyBmcm9tIHJpZ2h0IHRvIGxlZnQuIFRoZSByaWdodG1vc3RcbiAqIGZ1bmN0aW9uIGNhbiB0YWtlIG11bHRpcGxlIGFyZ3VtZW50cyBhcyBpdCBwcm92aWRlcyB0aGUgc2lnbmF0dXJlIGZvclxuICogdGhlIHJlc3VsdGluZyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3MgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIG9idGFpbmVkIGJ5IGNvbXBvc2luZyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zXG4gKiBmcm9tIHJpZ2h0IHRvIGxlZnQuIEZvciBleGFtcGxlLCBjb21wb3NlKGYsIGcsIGgpIGlzIGlkZW50aWNhbCB0byBkb2luZ1xuICogKC4uLmFyZ3MpID0+IGYoZyhoKC4uLmFyZ3MpKSkuXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBmdW5jcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgcmV0dXJuIGFyZztcbiAgICB9O1xuICB9XG5cbiAgaWYgKGZ1bmNzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBmdW5jc1swXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jcy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGEoYi5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzdG9yZSBlbmhhbmNlciB0aGF0IGFwcGxpZXMgbWlkZGxld2FyZSB0byB0aGUgZGlzcGF0Y2ggbWV0aG9kXG4gKiBvZiB0aGUgUmVkdXggc3RvcmUuIFRoaXMgaXMgaGFuZHkgZm9yIGEgdmFyaWV0eSBvZiB0YXNrcywgc3VjaCBhcyBleHByZXNzaW5nXG4gKiBhc3luY2hyb25vdXMgYWN0aW9ucyBpbiBhIGNvbmNpc2UgbWFubmVyLCBvciBsb2dnaW5nIGV2ZXJ5IGFjdGlvbiBwYXlsb2FkLlxuICpcbiAqIFNlZSBgcmVkdXgtdGh1bmtgIHBhY2thZ2UgYXMgYW4gZXhhbXBsZSBvZiB0aGUgUmVkdXggbWlkZGxld2FyZS5cbiAqXG4gKiBCZWNhdXNlIG1pZGRsZXdhcmUgaXMgcG90ZW50aWFsbHkgYXN5bmNocm9ub3VzLCB0aGlzIHNob3VsZCBiZSB0aGUgZmlyc3RcbiAqIHN0b3JlIGVuaGFuY2VyIGluIHRoZSBjb21wb3NpdGlvbiBjaGFpbi5cbiAqXG4gKiBOb3RlIHRoYXQgZWFjaCBtaWRkbGV3YXJlIHdpbGwgYmUgZ2l2ZW4gdGhlIGBkaXNwYXRjaGAgYW5kIGBnZXRTdGF0ZWAgZnVuY3Rpb25zXG4gKiBhcyBuYW1lZCBhcmd1bWVudHMuXG4gKlxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWlkZGxld2FyZXMgVGhlIG1pZGRsZXdhcmUgY2hhaW4gdG8gYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBzdG9yZSBlbmhhbmNlciBhcHBseWluZyB0aGUgbWlkZGxld2FyZS5cbiAqL1xuXG5mdW5jdGlvbiBhcHBseU1pZGRsZXdhcmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtaWRkbGV3YXJlcyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtaWRkbGV3YXJlc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoY3JlYXRlU3RvcmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHN0b3JlID0gY3JlYXRlU3RvcmUuYXBwbHkodm9pZCAwLCBhcmd1bWVudHMpO1xuXG4gICAgICB2YXIgX2Rpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGF0Y2hpbmcgd2hpbGUgY29uc3RydWN0aW5nIHlvdXIgbWlkZGxld2FyZSBpcyBub3QgYWxsb3dlZC4gJyArICdPdGhlciBtaWRkbGV3YXJlIHdvdWxkIG5vdCBiZSBhcHBsaWVkIHRvIHRoaXMgZGlzcGF0Y2guJyk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWlkZGxld2FyZUFQSSA9IHtcbiAgICAgICAgZ2V0U3RhdGU6IHN0b3JlLmdldFN0YXRlLFxuICAgICAgICBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goKSB7XG4gICAgICAgICAgcmV0dXJuIF9kaXNwYXRjaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgY2hhaW4gPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmUobWlkZGxld2FyZUFQSSk7XG4gICAgICB9KTtcbiAgICAgIF9kaXNwYXRjaCA9IGNvbXBvc2UuYXBwbHkodm9pZCAwLCBjaGFpbikoc3RvcmUuZGlzcGF0Y2gpO1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCBzdG9yZSwge1xuICAgICAgICBkaXNwYXRjaDogX2Rpc3BhdGNoXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xufVxuXG4vKlxuICogVGhpcyBpcyBhIGR1bW15IGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHRoZSBmdW5jdGlvbiBuYW1lIGhhcyBiZWVuIGFsdGVyZWQgYnkgbWluaWZpY2F0aW9uLlxuICogSWYgdGhlIGZ1bmN0aW9uIGhhcyBiZWVuIG1pbmlmaWVkIGFuZCBOT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nLCB3YXJuIHRoZSB1c2VyLlxuICovXG5cbmZ1bmN0aW9uIGlzQ3J1c2hlZCgpIHt9XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBpc0NydXNoZWQubmFtZSA9PT0gJ3N0cmluZycgJiYgaXNDcnVzaGVkLm5hbWUgIT09ICdpc0NydXNoZWQnKSB7XG4gIHdhcm5pbmcoJ1lvdSBhcmUgY3VycmVudGx5IHVzaW5nIG1pbmlmaWVkIGNvZGUgb3V0c2lkZSBvZiBOT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIuICcgKyAnVGhpcyBtZWFucyB0aGF0IHlvdSBhcmUgcnVubmluZyBhIHNsb3dlciBkZXZlbG9wbWVudCBidWlsZCBvZiBSZWR1eC4gJyArICdZb3UgY2FuIHVzZSBsb29zZS1lbnZpZnkgKGh0dHBzOi8vZ2l0aHViLmNvbS96ZXJ0b3NoL2xvb3NlLWVudmlmeSkgZm9yIGJyb3dzZXJpZnkgJyArICdvciBzZXR0aW5nIG1vZGUgdG8gcHJvZHVjdGlvbiBpbiB3ZWJwYWNrIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmNlcHRzL21vZGUvKSAnICsgJ3RvIGVuc3VyZSB5b3UgaGF2ZSB0aGUgY29ycmVjdCBjb2RlIGZvciB5b3VyIHByb2R1Y3Rpb24gYnVpbGQuJyk7XG59XG5cbmV4cG9ydCB7IEFjdGlvblR5cGVzIGFzIF9fRE9fTk9UX1VTRV9fQWN0aW9uVHlwZXMsIGFwcGx5TWlkZGxld2FyZSwgYmluZEFjdGlvbkNyZWF0b3JzLCBjb21iaW5lUmVkdWNlcnMsIGNvbXBvc2UsIGNyZWF0ZVN0b3JlIH07XG4iLCJmdW5jdGlvbiBkZWZhdWx0RXF1YWxpdHlDaGVjayhhLCBiKSB7XG4gIHJldHVybiBhID09PSBiO1xufVxuXG5mdW5jdGlvbiBhcmVBcmd1bWVudHNTaGFsbG93bHlFcXVhbChlcXVhbGl0eUNoZWNrLCBwcmV2LCBuZXh0KSB7XG4gIGlmIChwcmV2ID09PSBudWxsIHx8IG5leHQgPT09IG51bGwgfHwgcHJldi5sZW5ndGggIT09IG5leHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRG8gdGhpcyBpbiBhIGZvciBsb29wIChhbmQgbm90IGEgYGZvckVhY2hgIG9yIGFuIGBldmVyeWApIHNvIHdlIGNhbiBkZXRlcm1pbmUgZXF1YWxpdHkgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAgdmFyIGxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFlcXVhbGl0eUNoZWNrKHByZXZbaV0sIG5leHRbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0TWVtb2l6ZShmdW5jKSB7XG4gIHZhciBlcXVhbGl0eUNoZWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBkZWZhdWx0RXF1YWxpdHlDaGVjaztcblxuICB2YXIgbGFzdEFyZ3MgPSBudWxsO1xuICB2YXIgbGFzdFJlc3VsdCA9IG51bGw7XG4gIC8vIHdlIHJlZmVyZW5jZSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgdGhlbSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghYXJlQXJndW1lbnRzU2hhbGxvd2x5RXF1YWwoZXF1YWxpdHlDaGVjaywgbGFzdEFyZ3MsIGFyZ3VtZW50cykpIHtcbiAgICAgIC8vIGFwcGx5IGFyZ3VtZW50cyBpbnN0ZWFkIG9mIHNwcmVhZGluZyBmb3IgcGVyZm9ybWFuY2UuXG4gICAgICBsYXN0UmVzdWx0ID0gZnVuYy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXREZXBlbmRlbmNpZXMoZnVuY3MpIHtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IEFycmF5LmlzQXJyYXkoZnVuY3NbMF0pID8gZnVuY3NbMF0gOiBmdW5jcztcblxuICBpZiAoIWRlcGVuZGVuY2llcy5ldmVyeShmdW5jdGlvbiAoZGVwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkZXAgPT09ICdmdW5jdGlvbic7XG4gIH0pKSB7XG4gICAgdmFyIGRlcGVuZGVuY3lUeXBlcyA9IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBkZXA7XG4gICAgfSkuam9pbignLCAnKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbGVjdG9yIGNyZWF0b3JzIGV4cGVjdCBhbGwgaW5wdXQtc2VsZWN0b3JzIHRvIGJlIGZ1bmN0aW9ucywgJyArICgnaW5zdGVhZCByZWNlaXZlZCB0aGUgZm9sbG93aW5nIHR5cGVzOiBbJyArIGRlcGVuZGVuY3lUeXBlcyArICddJykpO1xuICB9XG5cbiAgcmV0dXJuIGRlcGVuZGVuY2llcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNlbGVjdG9yQ3JlYXRvcihtZW1vaXplKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtZW1vaXplT3B0aW9ucyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtZW1vaXplT3B0aW9uc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgZnVuY3MgPSBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgZnVuY3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgcmVjb21wdXRhdGlvbnMgPSAwO1xuICAgIHZhciByZXN1bHRGdW5jID0gZnVuY3MucG9wKCk7XG4gICAgdmFyIGRlcGVuZGVuY2llcyA9IGdldERlcGVuZGVuY2llcyhmdW5jcyk7XG5cbiAgICB2YXIgbWVtb2l6ZWRSZXN1bHRGdW5jID0gbWVtb2l6ZS5hcHBseSh1bmRlZmluZWQsIFtmdW5jdGlvbiAoKSB7XG4gICAgICByZWNvbXB1dGF0aW9ucysrO1xuICAgICAgLy8gYXBwbHkgYXJndW1lbnRzIGluc3RlYWQgb2Ygc3ByZWFkaW5nIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgIHJldHVybiByZXN1bHRGdW5jLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfV0uY29uY2F0KG1lbW9pemVPcHRpb25zKSk7XG5cbiAgICAvLyBJZiBhIHNlbGVjdG9yIGlzIGNhbGxlZCB3aXRoIHRoZSBleGFjdCBzYW1lIGFyZ3VtZW50cyB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIG91ciBkZXBlbmRlbmNpZXMgYWdhaW4uXG4gICAgdmFyIHNlbGVjdG9yID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICB2YXIgbGVuZ3RoID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgYW5kIG11dGF0ZSBhIGxvY2FsIGxpc3Qgb2YgcGFyYW1zIGZvciBwZXJmb3JtYW5jZS5cbiAgICAgICAgcGFyYW1zLnB1c2goZGVwZW5kZW5jaWVzW2ldLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfVxuXG4gICAgICAvLyBhcHBseSBhcmd1bWVudHMgaW5zdGVhZCBvZiBzcHJlYWRpbmcgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgcmV0dXJuIG1lbW9pemVkUmVzdWx0RnVuYy5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgIH0pO1xuXG4gICAgc2VsZWN0b3IucmVzdWx0RnVuYyA9IHJlc3VsdEZ1bmM7XG4gICAgc2VsZWN0b3IuZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgIHNlbGVjdG9yLnJlY29tcHV0YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlY29tcHV0YXRpb25zO1xuICAgIH07XG4gICAgc2VsZWN0b3IucmVzZXRSZWNvbXB1dGF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZWNvbXB1dGF0aW9ucyA9IDA7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZWN0b3I7XG4gIH07XG59XG5cbmV4cG9ydCB2YXIgY3JlYXRlU2VsZWN0b3IgPSBjcmVhdGVTZWxlY3RvckNyZWF0b3IoZGVmYXVsdE1lbW9pemUpO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU3RydWN0dXJlZFNlbGVjdG9yKHNlbGVjdG9ycykge1xuICB2YXIgc2VsZWN0b3JDcmVhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBjcmVhdGVTZWxlY3RvcjtcblxuICBpZiAodHlwZW9mIHNlbGVjdG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZVN0cnVjdHVyZWRTZWxlY3RvciBleHBlY3RzIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCAnICsgKCd3aGVyZSBlYWNoIHByb3BlcnR5IGlzIGEgc2VsZWN0b3IsIGluc3RlYWQgcmVjZWl2ZWQgYSAnICsgdHlwZW9mIHNlbGVjdG9ycykpO1xuICB9XG4gIHZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMoc2VsZWN0b3JzKTtcbiAgcmV0dXJuIHNlbGVjdG9yQ3JlYXRvcihvYmplY3RLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHNlbGVjdG9yc1trZXldO1xuICB9KSwgZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgdmFsdWVzID0gQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgIHZhbHVlc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXMucmVkdWNlKGZ1bmN0aW9uIChjb21wb3NpdGlvbiwgdmFsdWUsIGluZGV4KSB7XG4gICAgICBjb21wb3NpdGlvbltvYmplY3RLZXlzW2luZGV4XV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9LCB7fSk7XG4gIH0pO1xufSIsImZ1bmN0aW9uIGlzQWJzb2x1dGUocGF0aG5hbWUpIHtcbiAgcmV0dXJuIHBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nO1xufVxuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKClcbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpIHtcbiAgICBsaXN0W2ldID0gbGlzdFtrXTtcbiAgfVxuXG4gIGxpc3QucG9wKCk7XG59XG5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgaGVhdmlseSBvbiBub2RlJ3MgdXJsLnBhcnNlXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUodG8pIHtcbiAgdmFyIGZyb20gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICcnO1xuXG4gIHZhciB0b1BhcnRzID0gdG8gJiYgdG8uc3BsaXQoJy8nKSB8fCBbXTtcbiAgdmFyIGZyb21QYXJ0cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLycpIHx8IFtdO1xuXG4gIHZhciBpc1RvQWJzID0gdG8gJiYgaXNBYnNvbHV0ZSh0byk7XG4gIHZhciBpc0Zyb21BYnMgPSBmcm9tICYmIGlzQWJzb2x1dGUoZnJvbSk7XG4gIHZhciBtdXN0RW5kQWJzID0gaXNUb0FicyB8fCBpc0Zyb21BYnM7XG5cbiAgaWYgKHRvICYmIGlzQWJzb2x1dGUodG8pKSB7XG4gICAgLy8gdG8gaXMgYWJzb2x1dGVcbiAgICBmcm9tUGFydHMgPSB0b1BhcnRzO1xuICB9IGVsc2UgaWYgKHRvUGFydHMubGVuZ3RoKSB7XG4gICAgLy8gdG8gaXMgcmVsYXRpdmUsIGRyb3AgdGhlIGZpbGVuYW1lXG4gICAgZnJvbVBhcnRzLnBvcCgpO1xuICAgIGZyb21QYXJ0cyA9IGZyb21QYXJ0cy5jb25jYXQodG9QYXJ0cyk7XG4gIH1cblxuICBpZiAoIWZyb21QYXJ0cy5sZW5ndGgpIHJldHVybiAnLyc7XG5cbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSB2b2lkIDA7XG4gIGlmIChmcm9tUGFydHMubGVuZ3RoKSB7XG4gICAgdmFyIGxhc3QgPSBmcm9tUGFydHNbZnJvbVBhcnRzLmxlbmd0aCAtIDFdO1xuICAgIGhhc1RyYWlsaW5nU2xhc2ggPSBsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJyB8fCBsYXN0ID09PSAnJztcbiAgfSBlbHNlIHtcbiAgICBoYXNUcmFpbGluZ1NsYXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gZnJvbVBhcnRzLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgcGFydCA9IGZyb21QYXJ0c1tpXTtcblxuICAgIGlmIChwYXJ0ID09PSAnLicpIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgc3BsaWNlT25lKGZyb21QYXJ0cywgaSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNwbGljZU9uZShmcm9tUGFydHMsIGkpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11c3RFbmRBYnMpIGZvciAoOyB1cC0tOyB1cCkge1xuICAgIGZyb21QYXJ0cy51bnNoaWZ0KCcuLicpO1xuICB9aWYgKG11c3RFbmRBYnMgJiYgZnJvbVBhcnRzWzBdICE9PSAnJyAmJiAoIWZyb21QYXJ0c1swXSB8fCAhaXNBYnNvbHV0ZShmcm9tUGFydHNbMF0pKSkgZnJvbVBhcnRzLnVuc2hpZnQoJycpO1xuXG4gIHZhciByZXN1bHQgPSBmcm9tUGFydHMuam9pbignLycpO1xuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIHJlc3VsdC5zdWJzdHIoLTEpICE9PSAnLycpIHJlc3VsdCArPSAnLyc7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVzb2x2ZVBhdGhuYW1lOyIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cbmltcG9ydCBwb255ZmlsbCBmcm9tICcuL3BvbnlmaWxsLmpzJztcblxudmFyIHJvb3Q7XG5cbmlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgcm9vdCA9IHNlbGY7XG59IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSB3aW5kb3c7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBnbG9iYWw7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHJvb3QgPSBtb2R1bGU7XG59IGVsc2Uge1xuICByb290ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbn1cblxudmFyIHJlc3VsdCA9IHBvbnlmaWxsKHJvb3QpO1xuZXhwb3J0IGRlZmF1bHQgcmVzdWx0O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3ltYm9sT2JzZXJ2YWJsZVBvbnlmaWxsKHJvb3QpIHtcblx0dmFyIHJlc3VsdDtcblx0dmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5cdGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0aWYgKFN5bWJvbC5vYnNlcnZhYmxlKSB7XG5cdFx0XHRyZXN1bHQgPSBTeW1ib2wub2JzZXJ2YWJsZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gU3ltYm9sKCdvYnNlcnZhYmxlJyk7XG5cdFx0XHRTeW1ib2wub2JzZXJ2YWJsZSA9IHJlc3VsdDtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0cmVzdWx0ID0gJ0BAb2JzZXJ2YWJsZSc7XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gdmFsdWVFcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYikgJiYgYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgYVR5cGUgPSB0eXBlb2YgYSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYSk7XG4gIHZhciBiVHlwZSA9IHR5cGVvZiBiID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihiKTtcblxuICBpZiAoYVR5cGUgIT09IGJUeXBlKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGFUeXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBhVmFsdWUgPSBhLnZhbHVlT2YoKTtcbiAgICB2YXIgYlZhbHVlID0gYi52YWx1ZU9mKCk7XG5cbiAgICBpZiAoYVZhbHVlICE9PSBhIHx8IGJWYWx1ZSAhPT0gYikgcmV0dXJuIHZhbHVlRXF1YWwoYVZhbHVlLCBiVmFsdWUpO1xuXG4gICAgdmFyIGFLZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgdmFyIGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG5cbiAgICBpZiAoYUtleXMubGVuZ3RoICE9PSBiS2V5cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBhS2V5cy5ldmVyeShmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gdmFsdWVFcXVhbChhW2tleV0sIGJba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlRXF1YWw7IiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBDb21wYW55VHlwZVNsaWNlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTAvMjAvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuaW1wb3J0IHsgY3JlYXRlU2xpY2UsIGNyZWF0ZUFzeW5jVGh1bmsgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCB7IFN5c3RlbUNlbnRlciB9IGZyb20gJy4uL2dsb2JhbCc7XG5cbmV4cG9ydCBjb25zdCBGZXRjaENvbXBhbnlUeXBlcyA9IGNyZWF0ZUFzeW5jVGh1bmsoJ0NvbXBhbnlzL0ZldGNoQ29tcGFueVR5cGVzJywgYXN5bmMgKF8sIHsgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBHZXRDb21wYW55VHlwZXMoKVxufSk7XG5cbmV4cG9ydCBjb25zdCBDb21wYW55VHlwZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdDb21wYW55VHlwZScsXG4gICAgaW5pdGlhbFN0YXRlOiB7XG4gICAgICAgIFN0YXR1czogJ3VuaW50aWF0ZWQnIGFzIFN5c3RlbUNlbnRlci5TdGF0dXMsXG4gICAgICAgIENvbXBhbnlUeXBlOiBbXSBhcyBTeXN0ZW1DZW50ZXIuQ29tcGFueVR5cGVbXSxcbiAgICAgICAgRXJyb3I6IG51bGxcbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuXG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaENvbXBhbnlUeXBlcy5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnaWRsZSc7XG4gICAgICAgICAgICBzdGF0ZS5FcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5Db21wYW55VHlwZS5wdXNoKC4uLmFjdGlvbi5wYXlsb2FkKTtcbiAgICAgICAgICAgIEZldGNoQ29tcGFueVR5cGVzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hDb21wYW55VHlwZXMucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaENvbXBhbnlUeXBlcy5yZWplY3RlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgICAgICBzdGF0ZS5FcnJvciA9IGFjdGlvbi5lcnJvci5tZXNzYWdlO1xuXG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGNvbnN0IHt9ID0gQ29tcGFueVR5cGVTbGljZS5hY3Rpb25zO1xuZXhwb3J0IGRlZmF1bHQgQ29tcGFueVR5cGVTbGljZS5yZWR1Y2VyO1xuZXhwb3J0IGNvbnN0IFNlbGVjdENvbXBhbnlUeXBlcyA9IHN0YXRlID0+IHN0YXRlLkNvbXBhbnlUeXBlLkNvbXBhbnlUeXBlIGFzIFN5c3RlbUNlbnRlci5Db21wYW55VHlwZVtdXG5leHBvcnQgY29uc3QgU2VsZWN0Q29tcGFueVR5cGVzU3RhdHVzID0gc3RhdGUgPT4gc3RhdGUuQ29tcGFueVR5cGUuU3RhdHVzIGFzIFN5c3RlbUNlbnRlci5TdGF0dXNcblxuZnVuY3Rpb24gR2V0Q29tcGFueVR5cGVzKCk6IEpRdWVyeS5qcVhIUjxTeXN0ZW1DZW50ZXIuQ29tcGFueVR5cGVbXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9TeXN0ZW1DZW50ZXIvQ29tcGFueVR5cGVgLFxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgIH0pO1xufVxuXG5cbiIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgQXNzZXRDb25uZWN0aW9uVHlwZVNsaWNlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTEvMDQvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXG5cbmltcG9ydCB7IGNyZWF0ZVNsaWNlLCBjcmVhdGVBc3luY1RodW5rIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgeyBTeXN0ZW1DZW50ZXIsIE9wZW5YREEgfSBmcm9tICcuLi9nbG9iYWwnO1xuXG5leHBvcnQgY29uc3QgRmV0Y2hBc3NldENvbm5lY3Rpb25UeXBlID0gY3JlYXRlQXN5bmNUaHVuaygnQXNzZXRDb25uZWN0aW9uVHlwZS9GZXRjaEFzc2V0Q29ubmVjdGlvblR5cGUnLCBhc3luYyAoXywgeyBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IEdldEFzc2V0Q29ubmVjdGlvblR5cGUoKTtcbn0pO1xuXG5leHBvcnQgY29uc3QgQXNzZXRDb25uZWN0aW9uVHlwZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdBc3NldENvbm5lY3Rpb25UeXBlJyxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgICAgU3RhdHVzOiAndW5pbnRpYXRlZCcsXG4gICAgICAgIEVycm9yOiBudWxsLFxuICAgICAgICBEYXRhOiBbXVxuICAgIH0sXG4gICAgcmVkdWNlcnM6IHtcbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG5cbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoQXNzZXRDb25uZWN0aW9uVHlwZS5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnaWRsZSc7XG4gICAgICAgICAgICBzdGF0ZS5FcnJvciA9IG51bGw7XG4gICAgICAgICAgICBzdGF0ZS5EYXRhID0gYWN0aW9uLnBheWxvYWQ7Ly8uc29ydCgoYSwgYikgPT4gYS5OYW1lIC0gYi5OYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaEFzc2V0Q29ubmVjdGlvblR5cGUucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaEFzc2V0Q29ubmVjdGlvblR5cGUucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnZXJyb3InO1xuICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSBhY3Rpb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgeyB9ID0gQXNzZXRDb25uZWN0aW9uVHlwZVNsaWNlLmFjdGlvbnM7XG5leHBvcnQgZGVmYXVsdCBBc3NldENvbm5lY3Rpb25UeXBlU2xpY2UucmVkdWNlcjtcbmV4cG9ydCBjb25zdCBTZWxlY3RBc3NldENvbm5lY3Rpb25UeXBlcyA9IChzdGF0ZSkgPT4gc3RhdGUuQXNzZXRDb25uZWN0aW9uVHlwZS5EYXRhO1xuZXhwb3J0IGNvbnN0IFNlbGVjdEFzc2V0Q29ubmVjdGlvblR5cGVTdGF0dXMgPSAoc3RhdGUpID0+IHN0YXRlLkFzc2V0Q29ubmVjdGlvblR5cGUuU3RhdHVzO1xuXG5mdW5jdGlvbiBHZXRBc3NldENvbm5lY3Rpb25UeXBlKCk6IEpRdWVyeS5qcVhIUjxPcGVuWERBLkFzc2V0Q29ubmVjdGlvblR5cGVbXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0Fzc2V0Q29ubmVjdGlvblR5cGVgLFxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgIH0pO1xufSIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgQXNzZXRTbGljZS50cyAtIEdidGNcbi8vXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuLy9cbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuLy9cbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXG4vL1xuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIDExLzA0LzIwMjAgLSBCaWxseSBFcm5lc3Rcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxuLy9cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblxuXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgU3lzdGVtQ2VudGVyLCBPcGVuWERBIH0gZnJvbSAnLi4vZ2xvYmFsJztcblxuZXhwb3J0IGNvbnN0IEZldGNoQXNzZXQgPSBjcmVhdGVBc3luY1RodW5rKCdBc3NldC9GZXRjaEFzc2V0JywgYXN5bmMgKF8sIHsgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBHZXRBc3NldCgpO1xufSk7XG5cbmV4cG9ydCBjb25zdCBBc3NldFNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdBc3NldCcsXG4gICAgaW5pdGlhbFN0YXRlOiB7XG4gICAgICAgIFN0YXR1czogJ3VuaW50aWF0ZWQnIGFzIFN5c3RlbUNlbnRlci5TdGF0dXMsXG4gICAgICAgIEVycm9yOiBudWxsLFxuICAgICAgICBEYXRhOiBbXSBhcyBPcGVuWERBLkFzc2V0W11cbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuXG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaEFzc2V0LmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdpZGxlJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLkRhdGEgPSBhY3Rpb24ucGF5bG9hZDsvLy5zb3J0KChhLCBiKSA9PiBhLk5hbWUgLSBiLk5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoQXNzZXQucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaEFzc2V0LnJlamVjdGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2Vycm9yJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gYWN0aW9uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgfSA9IEFzc2V0U2xpY2UuYWN0aW9ucztcbmV4cG9ydCBkZWZhdWx0IEFzc2V0U2xpY2UucmVkdWNlcjtcbmV4cG9ydCBjb25zdCBTZWxlY3RBc3NldHMgPSAoc3RhdGUpID0+IHN0YXRlLkFzc2V0LkRhdGEgYXMgT3BlblhEQS5Bc3NldFtdO1xuZXhwb3J0IGNvbnN0IFNlbGVjdEFzc2V0U3RhdHVzID0gKHN0YXRlKSA9PiBzdGF0ZS5Bc3NldC5TdGF0dXMgYXMgU3lzdGVtQ2VudGVyLlN0YXR1cztcbmV4cG9ydCBjb25zdCBTZWxlY3RBc3NldEtleXNMb3dlckNhc2UgPSAoc3RhdGUpID0+IHN0YXRlLkFzc2V0LkRhdGEubWFwKGEgPT4gYS5Bc3NldEtleS50b0xvd2VyQ2FzZSgpKSBhcyBzdHJpbmdbXTtcblxuZnVuY3Rpb24gR2V0QXNzZXQoKTogSlF1ZXJ5LmpxWEhSPE9wZW5YREEuQXNzZXRbXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0Fzc2V0YCxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICB9KTtcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gIEFzc2V0VHlwZVNsaWNlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTEvMDQvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXG5cbmltcG9ydCB7IGNyZWF0ZVNsaWNlLCBjcmVhdGVBc3luY1RodW5rIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgeyBTeXN0ZW1DZW50ZXIsIE9wZW5YREEgfSBmcm9tICcuLi9nbG9iYWwnO1xuXG5leHBvcnQgY29uc3QgRmV0Y2hBc3NldFR5cGUgPSBjcmVhdGVBc3luY1RodW5rKCdBc3NldFR5cGUvRmV0Y2hBc3NldFR5cGUnLCBhc3luYyAoXywgeyBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IEdldEFzc2V0VHlwZSgpO1xufSk7XG5cbmV4cG9ydCBjb25zdCBBc3NldFR5cGVTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiAnQXNzZXRUeXBlJyxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgICAgU3RhdHVzOiAndW5pbnRpYXRlZCcsXG4gICAgICAgIEVycm9yOiBudWxsLFxuICAgICAgICBEYXRhOiBbXVxuICAgIH0sXG4gICAgcmVkdWNlcnM6IHtcbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG5cbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoQXNzZXRUeXBlLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdpZGxlJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLkRhdGEgPSBhY3Rpb24ucGF5bG9hZDsvLy5zb3J0KChhLCBiKSA9PiBhLk5hbWUgLSBiLk5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoQXNzZXRUeXBlLnBlbmRpbmcsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnbG9hZGluZyc7XG4gICAgICAgIH0pO1xuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hBc3NldFR5cGUucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnZXJyb3InO1xuICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSBhY3Rpb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgeyB9ID0gQXNzZXRUeXBlU2xpY2UuYWN0aW9ucztcbmV4cG9ydCBkZWZhdWx0IEFzc2V0VHlwZVNsaWNlLnJlZHVjZXI7XG5leHBvcnQgY29uc3QgU2VsZWN0QXNzZXRUeXBlcyA9IChzdGF0ZSkgPT4gc3RhdGUuQXNzZXRUeXBlLkRhdGE7XG5leHBvcnQgY29uc3QgU2VsZWN0QXNzZXRUeXBlU3RhdHVzID0gKHN0YXRlKSA9PiBzdGF0ZS5Bc3NldFR5cGUuU3RhdHVzO1xuXG5mdW5jdGlvbiBHZXRBc3NldFR5cGUoKTogSlF1ZXJ5LmpxWEhSPE9wZW5YREEuQXNzZXRUeXBlW10+IHtcbiAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvT3BlblhEQS9Bc3NldFR5cGVgLFxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgIH0pO1xufSIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgTG9jYXRpb25TbGljZS50cyAtIEdidGNcbi8vXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuLy9cbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuLy9cbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXG4vL1xuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIDExLzA0LzIwMjAgLSBCaWxseSBFcm5lc3Rcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxuLy9cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblxuXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgU3lzdGVtQ2VudGVyLCBPcGVuWERBIH0gZnJvbSAnLi4vZ2xvYmFsJztcblxuZXhwb3J0IGNvbnN0IEZldGNoTG9jYXRpb24gPSBjcmVhdGVBc3luY1RodW5rKCdMb2NhdGlvbi9GZXRjaExvY2F0aW9uJywgYXN5bmMgKF8sIHsgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBHZXRMb2NhdGlvbigpO1xufSk7XG5cbmV4cG9ydCBjb25zdCBMb2NhdGlvblNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdMb2NhdGlvbicsXG4gICAgaW5pdGlhbFN0YXRlOiB7XG4gICAgICAgIFN0YXR1czogJ3VuaW50aWF0ZWQnIGFzIFN5c3RlbUNlbnRlci5TdGF0dXMsXG4gICAgICAgIEVycm9yOiBudWxsLFxuICAgICAgICBEYXRhOiBbXSBhcyBPcGVuWERBLkxvY2F0aW9uW11cbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuXG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaExvY2F0aW9uLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdpZGxlJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLkRhdGEgPSBhY3Rpb24ucGF5bG9hZDsvLy5zb3J0KChhLCBiKSA9PiBhLk5hbWUgLSBiLk5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoTG9jYXRpb24ucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaExvY2F0aW9uLnJlamVjdGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2Vycm9yJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gYWN0aW9uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgfSA9IExvY2F0aW9uU2xpY2UuYWN0aW9ucztcbmV4cG9ydCBkZWZhdWx0IExvY2F0aW9uU2xpY2UucmVkdWNlcjtcbmV4cG9ydCBjb25zdCBTZWxlY3RMb2NhdGlvbnMgPSAoc3RhdGUpID0+IHN0YXRlLkxvY2F0aW9uLkRhdGEgYXMgT3BlblhEQS5Mb2NhdGlvbltdO1xuZXhwb3J0IGNvbnN0IFNlbGVjdExvY2F0aW9uU3RhdHVzID0gKHN0YXRlKSA9PiBzdGF0ZS5Mb2NhdGlvbi5TdGF0dXMgYXMgU3lzdGVtQ2VudGVyLlN0YXR1cztcbmV4cG9ydCBjb25zdCBTZWxlY3RMb2NhdGlvbktleXNMb3dlckNhc2UgPSAoc3RhdGUpID0+IHN0YXRlLkxvY2F0aW9uLkRhdGEubWFwKGEgPT4gYS5Mb2NhdGlvbktleS50b0xvd2VyQ2FzZSgpKSBhcyBzdHJpbmdbXTtcblxuZnVuY3Rpb24gR2V0TG9jYXRpb24oKTogSlF1ZXJ5LmpxWEhSPE9wZW5YREEuTG9jYXRpb25bXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL0xvY2F0aW9uYCxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICB9KTtcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gIE1lYXN1cmVtZW50VHlwZVNsaWNlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTEvMDQvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuaW1wb3J0IHsgY3JlYXRlU2xpY2UsIGNyZWF0ZUFzeW5jVGh1bmsgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCB7IFN5c3RlbUNlbnRlciwgT3BlblhEQSB9IGZyb20gJy4uL2dsb2JhbCc7XG5cbmV4cG9ydCBjb25zdCBGZXRjaE1lYXN1cmVtZW50VHlwZSA9IGNyZWF0ZUFzeW5jVGh1bmsoJ01lYXN1cmVtZW50VHlwZS9GZXRjaE1lYXN1cmVtZW50VHlwZScsIGFzeW5jIChfLCB7IGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gYXdhaXQgR2V0TWVhc3VyZW1lbnRUeXBlKCk7XG59KTtcblxuZXhwb3J0IGNvbnN0IE1lYXN1cmVtZW50VHlwZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdNZWFzdXJlbWVudFR5cGUnLFxuICAgIGluaXRpYWxTdGF0ZToge1xuICAgICAgICBTdGF0dXM6ICd1bmludGlhdGVkJyxcbiAgICAgICAgRXJyb3I6IG51bGwsXG4gICAgICAgIERhdGE6IFtdXG4gICAgfSxcbiAgICByZWR1Y2Vyczoge1xuICAgIH0sXG4gICAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcblxuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hNZWFzdXJlbWVudFR5cGUuZnVsZmlsbGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2lkbGUnO1xuICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuRGF0YSA9IGFjdGlvbi5wYXlsb2FkOy8vLnNvcnQoKGEsIGIpID0+IGEuTmFtZSAtIGIuTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hNZWFzdXJlbWVudFR5cGUucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaE1lYXN1cmVtZW50VHlwZS5yZWplY3RlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgICAgICBzdGF0ZS5FcnJvciA9IGFjdGlvbi5lcnJvci5tZXNzYWdlO1xuICAgICAgICB9KTtcblxuICAgIH1cblxufSk7XG5cbmV4cG9ydCBjb25zdCB7IH0gPSBNZWFzdXJlbWVudFR5cGVTbGljZS5hY3Rpb25zO1xuZXhwb3J0IGRlZmF1bHQgTWVhc3VyZW1lbnRUeXBlU2xpY2UucmVkdWNlcjtcbmV4cG9ydCBjb25zdCBTZWxlY3RNZWFzdXJlbWVudFR5cGVzID0gKHN0YXRlKSA9PiBzdGF0ZS5NZWFzdXJlbWVudFR5cGUuRGF0YTtcbmV4cG9ydCBjb25zdCBTZWxlY3RNZWFzdXJlbWVudFR5cGVTdGF0dXMgPSAoc3RhdGUpID0+IHN0YXRlLk1lYXN1cmVtZW50VHlwZS5TdGF0dXM7XG5cbmZ1bmN0aW9uIEdldE1lYXN1cmVtZW50VHlwZSgpOiBKUXVlcnkuanFYSFI8T3BlblhEQS5NZWFzdXJlbWVudFR5cGVbXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL01lYXN1cmVtZW50VHlwZWAsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgfSk7XG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBNZXRlclNsaWNlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTEvMDQvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuXG5cbmltcG9ydCB7IGNyZWF0ZVNsaWNlLCBjcmVhdGVBc3luY1RodW5rIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgeyBTeXN0ZW1DZW50ZXIsIE9wZW5YREEgfSBmcm9tICcuLi9nbG9iYWwnO1xuXG5leHBvcnQgY29uc3QgRmV0Y2hNZXRlciA9IGNyZWF0ZUFzeW5jVGh1bmsoJ01ldGVyL0ZldGNoTWV0ZXInLCBhc3luYyAoXywgeyBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGF3YWl0IEdldE1ldGVyKCk7XG59KTtcblxuZXhwb3J0IGNvbnN0IE1ldGVyU2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gICAgbmFtZTogJ01ldGVyJyxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICAgICAgU3RhdHVzOiAndW5pbnRpYXRlZCcgYXMgU3lzdGVtQ2VudGVyLlN0YXR1cyxcbiAgICAgICAgRXJyb3I6IG51bGwsXG4gICAgICAgIERhdGE6IFtdIGFzIE9wZW5YREEuTWV0ZXJbXVxuICAgIH0sXG4gICAgcmVkdWNlcnM6IHtcbiAgICB9LFxuICAgIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG5cbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoTWV0ZXIuZnVsZmlsbGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2lkbGUnO1xuICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgc3RhdGUuRGF0YSA9IGFjdGlvbi5wYXlsb2FkOy8vLnNvcnQoKGEsIGIpID0+IGEuTmFtZSAtIGIuTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hNZXRlci5wZW5kaW5nLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2xvYWRpbmcnO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoTWV0ZXIucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5TdGF0dXMgPSAnZXJyb3InO1xuICAgICAgICAgICAgc3RhdGUuRXJyb3IgPSBhY3Rpb24uZXJyb3IubWVzc2FnZTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgeyB9ID0gTWV0ZXJTbGljZS5hY3Rpb25zO1xuZXhwb3J0IGRlZmF1bHQgTWV0ZXJTbGljZS5yZWR1Y2VyO1xuZXhwb3J0IGNvbnN0IFNlbGVjdE1ldGVycyA9IChzdGF0ZSkgPT4gc3RhdGUuTWV0ZXIuRGF0YSBhcyBPcGVuWERBLk1ldGVyW107XG5leHBvcnQgY29uc3QgU2VsZWN0TWV0ZXJTdGF0dXMgPSAoc3RhdGUpID0+IHN0YXRlLk1ldGVyLlN0YXR1cyBhcyBTeXN0ZW1DZW50ZXIuU3RhdHVzO1xuZXhwb3J0IGNvbnN0IFNlbGVjdE1ldGVyS2V5c0xvd2VyQ2FzZSA9IChzdGF0ZSkgPT4gc3RhdGUuTWV0ZXIuRGF0YS5tYXAoYSA9PiBhLkFzc2V0S2V5LnRvTG93ZXJDYXNlKCkpIGFzIHN0cmluZ1tdO1xuXG5mdW5jdGlvbiBHZXRNZXRlcigpOiBKUXVlcnkuanFYSFI8T3BlblhEQS5NZXRlcltdPiB7XG4gICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL09wZW5YREEvTWV0ZXJgLFxuICAgICAgICBjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgICBhc3luYzogdHJ1ZVxuICAgIH0pO1xufSIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgUGhhc2VTbGljZS50cyAtIEdidGNcbi8vXG4vLyAgQ29weXJpZ2h0IMKpIDIwMjAsIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZS4gIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4vL1xuLy8gIExpY2Vuc2VkIHRvIHRoZSBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UgKEdQQSkgdW5kZXIgb25lIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiBTZWVcbi8vICB0aGUgTk9USUNFIGZpbGUgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuXG4vLyAgVGhlIEdQQSBsaWNlbnNlcyB0aGlzIGZpbGUgdG8geW91IHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgdGhlIFwiTGljZW5zZVwiOyB5b3UgbWF5IG5vdCB1c2UgdGhpc1xuLy8gIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0OlxuLy9cbi8vICAgICAgaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuLy9cbi8vICBVbmxlc3MgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHRoZSBzdWJqZWN0IHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4vLyAgXCJBUy1JU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gUmVmZXIgdG8gdGhlXG4vLyAgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMuXG4vL1xuLy8gIENvZGUgTW9kaWZpY2F0aW9uIEhpc3Rvcnk6XG4vLyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gIDExLzA0LzIwMjAgLSBCaWxseSBFcm5lc3Rcbi8vICAgICAgIEdlbmVyYXRlZCBvcmlnaW5hbCB2ZXJzaW9uIG9mIHNvdXJjZSBjb2RlLlxuLy9cbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cblxuXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgU3lzdGVtQ2VudGVyLCBPcGVuWERBIH0gZnJvbSAnLi4vZ2xvYmFsJztcblxuZXhwb3J0IGNvbnN0IEZldGNoUGhhc2UgPSBjcmVhdGVBc3luY1RodW5rKCdQaGFzZS9GZXRjaFBoYXNlJywgYXN5bmMgKF8sIHsgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBHZXRQaGFzZSgpO1xufSk7XG5cbmV4cG9ydCBjb25zdCBQaGFzZVNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICAgIG5hbWU6ICdQaGFzZScsXG4gICAgaW5pdGlhbFN0YXRlOiB7XG4gICAgICAgIFN0YXR1czogJ3VuaW50aWF0ZWQnLFxuICAgICAgICBFcnJvcjogbnVsbCxcbiAgICAgICAgRGF0YTogW11cbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuXG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaFBoYXNlLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdpZGxlJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlLkRhdGEgPSBhY3Rpb24ucGF5bG9hZDsvLy5zb3J0KChhLCBiKSA9PiBhLk5hbWUgLSBiLk5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoUGhhc2UucGVuZGluZywgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgICAgIHN0YXRlLlN0YXR1cyA9ICdsb2FkaW5nJztcbiAgICAgICAgfSk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaFBoYXNlLnJlamVjdGVkLCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAgICAgc3RhdGUuU3RhdHVzID0gJ2Vycm9yJztcbiAgICAgICAgICAgIHN0YXRlLkVycm9yID0gYWN0aW9uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgfSA9IFBoYXNlU2xpY2UuYWN0aW9ucztcbmV4cG9ydCBkZWZhdWx0IFBoYXNlU2xpY2UucmVkdWNlcjtcbmV4cG9ydCBjb25zdCBTZWxlY3RQaGFzZXMgPSAoc3RhdGUpID0+IHN0YXRlLlBoYXNlLkRhdGE7XG5leHBvcnQgY29uc3QgU2VsZWN0UGhhc2VTdGF0dXMgPSAoc3RhdGUpID0+IHN0YXRlLlBoYXNlLlN0YXR1cztcblxuZnVuY3Rpb24gR2V0UGhhc2UoKTogSlF1ZXJ5LmpxWEhSPE9wZW5YREEuUGhhc2VbXT4ge1xuICAgIHJldHVybiAkLmFqYXgoe1xuICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICB1cmw6IGAke2hvbWVQYXRofWFwaS9PcGVuWERBL1BoYXNlYCxcbiAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICBjYWNoZTogdHJ1ZSxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICB9KTtcbn0iLCIvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuLy8gIFN0b3JlLnRzIC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAyMCwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMTAvMjAvMjAyMCAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuaW1wb3J0IHsgY29uZmlndXJlU3RvcmUgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcbmltcG9ydCBDb21wYW55VHlwZVJlZHVjZXIgZnJvbSAnLi4vQ29tcGFueS9Db21wYW55VHlwZVNsaWNlJztcbmltcG9ydCBWYWx1ZUxpc3RSZWR1Y2VyIGZyb20gJy4vVmFsdWVMaXN0U2xpY2UnO1xuaW1wb3J0IE1lYXN1cmVtZW50VHlwZVJlZHVjZXIgZnJvbSAnLi9NZWFzdXJlbWVudFR5cGVTbGljZSc7XG5pbXBvcnQgUGhhc2VSZWR1Y2VyIGZyb20gJy4vUGhhc2VTbGljZSc7XG5pbXBvcnQgQXNzZXRUeXBlUmVkdWNlciBmcm9tICcuL0Fzc2V0VHlwZVNsaWNlJztcbmltcG9ydCBBc3NldENvbm5lY3Rpb25UeXBlUmVkdWNlciBmcm9tICcuL0Fzc2V0Q29ubmVjdGlvblR5cGVTbGljZSc7XG5pbXBvcnQgTWV0ZXJSZWR1Y2VyIGZyb20gJy4vTWV0ZXJTbGljZSc7XG5pbXBvcnQgTG9jYXRpb25SZWR1Y2VyIGZyb20gJy4vTG9jYXRpb25TbGljZSc7XG5pbXBvcnQgQXNzZXRSZWR1Y2VyIGZyb20gJy4vQXNzZXRTbGljZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmZpZ3VyZVN0b3JlKHtcbiAgICByZWR1Y2VyOiB7XG4gICAgICAgIENvbXBhbnlUeXBlOiBDb21wYW55VHlwZVJlZHVjZXIsXG4gICAgICAgIFZhbHVlTGlzdDogVmFsdWVMaXN0UmVkdWNlcixcbiAgICAgICAgTWVhc3VyZW1lbnRUeXBlOiBNZWFzdXJlbWVudFR5cGVSZWR1Y2VyLFxuICAgICAgICBQaGFzZTogUGhhc2VSZWR1Y2VyLFxuICAgICAgICBBc3NldFR5cGU6IEFzc2V0VHlwZVJlZHVjZXIsXG4gICAgICAgIEFzc2V0Q29ubmVjdGlvblR5cGU6IEFzc2V0Q29ubmVjdGlvblR5cGVSZWR1Y2VyLFxuICAgICAgICBNZXRlcjogTWV0ZXJSZWR1Y2VyLFxuICAgICAgICBBc3NldDogQXNzZXRSZWR1Y2VyLFxuICAgICAgICBMb2NhdGlvbjogTG9jYXRpb25SZWR1Y2VyLFxuICAgIH1cbn0pOyIsIi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4vLyAgVmFsdWVMaXN0U2xpY2UudHMgLSBHYnRjXG4vL1xuLy8gIENvcHlyaWdodCDCqSAyMDIwLCBHcmlkIFByb3RlY3Rpb24gQWxsaWFuY2UuICBBbGwgUmlnaHRzIFJlc2VydmVkLlxuLy9cbi8vICBMaWNlbnNlZCB0byB0aGUgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlIChHUEEpIHVuZGVyIG9uZSBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gU2VlXG4vLyAgdGhlIE5PVElDRSBmaWxlIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLlxuLy8gIFRoZSBHUEEgbGljZW5zZXMgdGhpcyBmaWxlIHRvIHlvdSB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHRoZSBcIkxpY2Vuc2VcIjsgeW91IG1heSBub3QgdXNlIHRoaXNcbi8vICBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdDpcbi8vXG4vLyAgICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbi8vXG4vLyAgVW5sZXNzIGFncmVlZCB0byBpbiB3cml0aW5nLCB0aGUgc3ViamVjdCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuLy8gIFwiQVMtSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuIFJlZmVyIHRvIHRoZVxuLy8gIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zLlxuLy9cbi8vICBDb2RlIE1vZGlmaWNhdGlvbiBIaXN0b3J5OlxuLy8gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAxMS8wNC8yMDIwIC0gQmlsbHkgRXJuZXN0XG4vLyAgICAgICBHZW5lcmF0ZWQgb3JpZ2luYWwgdmVyc2lvbiBvZiBzb3VyY2UgY29kZS5cbi8vXG4vLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5pbXBvcnQgeyBjcmVhdGVTbGljZSwgY3JlYXRlQXN5bmNUaHVuayB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHsgU3lzdGVtQ2VudGVyIH0gZnJvbSAnLi4vZ2xvYmFsJztcblxuZXhwb3J0IGNvbnN0IEZldGNoVmFsdWVMaXN0ID0gY3JlYXRlQXN5bmNUaHVuaygnVmFsdWVMaXN0L0ZldGNoVmFsdWVMaXN0JywgYXN5bmMgKHZsOiB7Z3JvdXA6IHN0cmluZ30sIHsgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBhd2FpdCBHZXRWYWx1ZUxpc3QodmwuZ3JvdXApO1xufSk7XG5cbmV4cG9ydCBjb25zdCBWYWx1ZUxpc3RTbGljZSA9IGNyZWF0ZVNsaWNlKHtcbiAgICBuYW1lOiAnVmFsdWVMaXN0JyxcbiAgICBpbml0aWFsU3RhdGU6IHtcbiAgICB9LFxuICAgIHJlZHVjZXJzOiB7XG4gICAgfSxcbiAgICBleHRyYVJlZHVjZXJzOiAoYnVpbGRlcikgPT4ge1xuXG4gICAgICAgIGJ1aWxkZXIuYWRkQ2FzZShGZXRjaFZhbHVlTGlzdC5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzOiAndW5pdGlhdGVkJyBhcyBTeXN0ZW1DZW50ZXIuU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBEYXRhOiBbXSBhcyBhbnksXG4gICAgICAgICAgICAgICAgICAgIEVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXS5TdGF0dXMgPSAnaWRsZSc7XG4gICAgICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5hcmcuZ3JvdXBdLkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIHN0YXRlW2FjdGlvbi5tZXRhLmFyZy5ncm91cF0uRGF0YSA9IGFjdGlvbi5wYXlsb2FkLnNvcnQoKGEsIGIpID0+IGEuU29ydE9yZGVyIC0gYi5Tb3J0T3JkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVpbGRlci5hZGRDYXNlKEZldGNoVmFsdWVMaXN0LnBlbmRpbmcsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzOiAndW5pdGlhdGVkJyBhcyBTeXN0ZW1DZW50ZXIuU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBEYXRhOiBbXSBhcyBhbnksXG4gICAgICAgICAgICAgICAgICAgIEVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXS5TdGF0dXMgPSAnbG9hZGluZyc7XG4gICAgICAgIH0pO1xuICAgICAgICBidWlsZGVyLmFkZENhc2UoRmV0Y2hWYWx1ZUxpc3QucmVqZWN0ZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhdGVbYWN0aW9uLm1ldGEuYXJnLmdyb3VwXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgU3RhdHVzOiAndW5pdGlhdGVkJyBhcyBTeXN0ZW1DZW50ZXIuU3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBEYXRhOiBbXSBhcyBhbnksXG4gICAgICAgICAgICAgICAgICAgIEVycm9yOiBudWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5hcmcuZ3JvdXBdLlN0YXR1cyA9ICdlcnJvcic7XG4gICAgICAgICAgICBzdGF0ZVthY3Rpb24ubWV0YS5hcmcuZ3JvdXBdLkVycm9yID0gYWN0aW9uLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH0pO1xuXG4gICAgfVxuXG59KTtcblxuZXhwb3J0IGNvbnN0IHsgfSA9IFZhbHVlTGlzdFNsaWNlLmFjdGlvbnM7XG5leHBvcnQgZGVmYXVsdCBWYWx1ZUxpc3RTbGljZS5yZWR1Y2VyO1xuZXhwb3J0IGNvbnN0IFNlbGVjdFZhbHVlTGlzdCA9IChzdGF0ZSwgZ3JvdXA6IHN0cmluZykgPT4gc3RhdGUuVmFsdWVMaXN0W2dyb3VwXSAhPT0gdW5kZWZpbmVkID8gc3RhdGUuVmFsdWVMaXN0W2dyb3VwXS5EYXRhIDogW10gYXMgU3lzdGVtQ2VudGVyLlZhbHVlTGlzdEl0ZW1bXSA7XG5leHBvcnQgY29uc3QgU2VsZWN0VmFsdWVMaXN0U3RhdHVzID0gKHN0YXRlLCBncm91cDogc3RyaW5nKSA9PiBzdGF0ZS5WYWx1ZUxpc3RbZ3JvdXBdICE9PSB1bmRlZmluZWQgPyBzdGF0ZS5WYWx1ZUxpc3RbZ3JvdXBdLlN0YXR1cyA6ICd1bmludGlhdGVkJyBhcyBTeXN0ZW1DZW50ZXIuU3RhdHVzO1xuXG5mdW5jdGlvbiBHZXRWYWx1ZUxpc3QoZ3JvdXA6IHN0cmluZyk6IEpRdWVyeS5qcVhIUjxTeXN0ZW1DZW50ZXIuVmFsdWVMaXN0SXRlbVtdPiB7XG4gICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgIHVybDogYCR7aG9tZVBhdGh9YXBpL1ZhbHVlTGlzdC9Hcm91cC8ke2dyb3VwfWAsXG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgY2FjaGU6IHRydWUsXG4gICAgICAgIGFzeW5jOiB0cnVlXG4gICAgfSk7XG59IiwiLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vICBTeXN0ZW1DZW50ZXIudHN4IC0gR2J0Y1xuLy9cbi8vICBDb3B5cmlnaHQgwqkgMjAxOSwgR3JpZCBQcm90ZWN0aW9uIEFsbGlhbmNlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbi8vXG4vLyAgTGljZW5zZWQgdG8gdGhlIEdyaWQgUHJvdGVjdGlvbiBBbGxpYW5jZSAoR1BBKSB1bmRlciBvbmUgb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuIFNlZVxuLy8gIHRoZSBOT1RJQ0UgZmlsZSBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC5cbi8vICBUaGUgR1BBIGxpY2Vuc2VzIHRoaXMgZmlsZSB0byB5b3UgdW5kZXIgdGhlIE1JVCBMaWNlbnNlIChNSVQpLCB0aGUgXCJMaWNlbnNlXCI7IHlvdSBtYXkgbm90IHVzZSB0aGlzXG4vLyAgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXQ6XG4vL1xuLy8gICAgICBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4vL1xuLy8gIFVubGVzcyBhZ3JlZWQgdG8gaW4gd3JpdGluZywgdGhlIHN1YmplY3Qgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbi8vICBcIkFTLUlTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiBSZWZlciB0byB0aGVcbi8vICBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucy5cbi8vXG4vLyAgQ29kZSBNb2RpZmljYXRpb24gSGlzdG9yeTpcbi8vICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgMDgvMjIvMjAxOSAtIEJpbGx5IEVybmVzdFxuLy8gICAgICAgR2VuZXJhdGVkIG9yaWdpbmFsIHZlcnNpb24gb2Ygc291cmNlIGNvZGUuXG4vL1xuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IEJyb3dzZXJSb3V0ZXIgYXMgUm91dGVyLCBSb3V0ZSwgTmF2TGluaywgU3dpdGNoIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbmltcG9ydCBxdWVyeVN0cmluZyBmcm9tIFwicXVlcnlzdHJpbmdcIjtcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIlxuaW1wb3J0IHsgU3lzdGVtQ2VudGVyIH0gZnJvbSAnLi9nbG9iYWwnO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgc3RvcmUgZnJvbSAnLi9TdG9yZS9TdG9yZSc7XG5cbi8vaW1wb3J0IEJ5TWV0ZXIgZnJvbSAnLi9NZXRlci9CeU1ldGVyJ1xuLy9pbXBvcnQgQnlMb2NhdGlvbiBmcm9tICcuL0xvY2F0aW9uL0J5TG9jYXRpb24nXG4vL2ltcG9ydCBCeUFzc2V0IGZyb20gJy4vQXNzZXQvQnlBc3NldCdcbi8vaW1wb3J0IEJ5Q3VzdG9tZXIgZnJvbSAnLi9DdXN0b21lci9CeUN1c3RvbWVyJ1xuLy9pbXBvcnQgQnlVc2VyIGZyb20gJy4vVXNlci9CeVVzZXInXG4vL2ltcG9ydCBVc2VyU3RhdGlzdGljcyBmcm9tICcuL1VzZXJTdGF0aXN0aWNzL1VzZXJTdGF0aXN0aWNzJ1xuLy9pbXBvcnQgQ3VzdG9tZXIgZnJvbSAnLi9DdXN0b21lci9DdXN0b21lcidcbi8vaW1wb3J0IFVzZXIgZnJvbSAnLi9Vc2VyL1VzZXInXG4vL2ltcG9ydCBBc3NldCBmcm9tICcuL0Fzc2V0L0Fzc2V0J1xuLy9pbXBvcnQgTmV3TWV0ZXJXaXphcmQgZnJvbSAnLi9OZXdNZXRlcldpemFyZC9OZXdNZXRlcldpemFyZCdcbi8vaW1wb3J0IENvbmZpZ3VyYXRpb25IaXN0b3J5IGZyb20gJy4vQ29uZmlndXJhdGlvbkhpc3RvcnkvQ29uZmlndXJhdGlvbkhpc3RvcnknXG4vL2ltcG9ydCBNZXRlciBmcm9tICcuL01ldGVyL01ldGVyJ1xuLy9pbXBvcnQgTG9jYXRpb24gZnJvbSAnLi9Mb2NhdGlvbi9Mb2NhdGlvbidcbi8vaW1wb3J0IEJ5QXNzZXRHcm91cCBmcm9tICcuL0Fzc2V0R3JvdXBzL0J5QXNzZXRHcm91cCc7XG4vL2ltcG9ydCBBc3NldEdyb3VwIGZyb20gJy4vQXNzZXRHcm91cHMvQXNzZXRncm91cCc7XG4vL2ltcG9ydCBCeUNvbXBhbnkgZnJvbSAnLi9Db21wYW55L0J5Q29tcGFueSc7XG4vL2ltcG9ydCBDb21wYW55IGZyb20gJy4vQ29tcGFueS9Db21wYW55JztcblxuZGVjbGFyZSB2YXIgaG9tZVBhdGg6IHN0cmluZztcbmRlY2xhcmUgdmFyIGNvbnRyb2xsZXJWaWV3UGF0aDogc3RyaW5nO1xuXG5jb25zdCBTeXN0ZW1DZW50ZXI6IFJlYWN0LkZ1bmN0aW9uQ29tcG9uZW50ID0gKHByb3BzOiB7fSkgPT4ge1xuICAgIGNvbnN0IGhpc3RvcnkgPSBjcmVhdGVCcm93c2VySGlzdG9yeSgpO1xuICAgIGNvbnN0IEJ5TWV0ZXIgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKndlYnBhY2tDaHVua05hbWU6IFwiQnlNZXRlclwiKi8nLi9NZXRlci9CeU1ldGVyJykpO1xuICAgIGNvbnN0IEJ5TG9jYXRpb24gPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkJ5TG9jYXRpb25cIiAqLyAnLi9Mb2NhdGlvbi9CeUxvY2F0aW9uJykpO1xuICAgIGNvbnN0IEJ5QXNzZXQgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkJ5QXNzZXRcIiAqLyAnLi9Bc3NldC9CeUFzc2V0JykpO1xuICAgIGNvbnN0IEJ5Q3VzdG9tZXIgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkJ5Q3VzdG9tZXJcIiAqLyAnLi9DdXN0b21lci9CeUN1c3RvbWVyJykpO1xuICAgIGNvbnN0IEJ5VXNlciA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQnlVc2VyXCIgKi8gJy4vVXNlci9CeVVzZXInKSk7XG4gICAgY29uc3QgVXNlclN0YXRpc3RpY3MgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIlVzZXJTdGF0aXN0aWNzXCIgKi8gJy4vVXNlclN0YXRpc3RpY3MvVXNlclN0YXRpc3RpY3MnKSk7XG4gICAgY29uc3QgQ3VzdG9tZXIgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkN1c3RvbWVyXCIgKi8gJy4vQ3VzdG9tZXIvQ3VzdG9tZXInKSk7XG4gICAgY29uc3QgVXNlciA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiVXNlclwiICovICcuL1VzZXIvVXNlcicpKTtcbiAgICBjb25zdCBBc3NldCA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQXNzZXRcIiAqLyAnLi9Bc3NldC9Bc3NldCcpKTtcbiAgICBjb25zdCBOZXdNZXRlcldpemFyZCA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KCAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIk5ld01ldGVyV2l6YXJkXCIgKi8gJy4vTmV3TWV0ZXJXaXphcmQvTmV3TWV0ZXJXaXphcmQnKSk7XG4gICAgY29uc3QgQ29uZmlndXJhdGlvbkhpc3RvcnkgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkNvbmZpZ3VyYXRpb25IaXN0b3J5XCIgKi8gJy4vQ29uZmlndXJhdGlvbkhpc3RvcnkvQ29uZmlndXJhdGlvbkhpc3RvcnknKSk7XG4gICAgY29uc3QgTWV0ZXIgPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIk1ldGVyXCIgKi8gJy4vTWV0ZXIvTWV0ZXInKSk7XG4gICAgY29uc3QgTG9jYXRpb24gPSBSZWFjdC5sYXp5KCgpID0+IGltcG9ydCgvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcIkxvY2F0aW9uXCIgKi8gJy4vTG9jYXRpb24vTG9jYXRpb24nKSk7XG4gICAgY29uc3QgQnlBc3NldEdyb3VwID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJCeUFzc2V0R3JvdXBcIiAqLyAnLi9Bc3NldEdyb3Vwcy9CeUFzc2V0R3JvdXAnKSk7XG4gICAgY29uc3QgQXNzZXRHcm91cCA9IFJlYWN0LmxhenkoKCkgPT4gaW1wb3J0KC8qIHdlYnBhY2tDaHVua05hbWU6IFwiQXNzZXRHcm91cFwiICovICcuL0Fzc2V0R3JvdXBzL0Fzc2V0R3JvdXAnKSk7XG4gICAgY29uc3QgQnlDb21wYW55ID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJCeUNvbXBhbnlcIiAqLyAnLi9Db21wYW55L0J5Q29tcGFueScpKTtcbiAgICBjb25zdCBDb21wYW55ID0gUmVhY3QubGF6eSgoKSA9PiBpbXBvcnQoLyogd2VicGFja0NodW5rTmFtZTogXCJDb21wYW55XCIgKi8gJy4vQ29tcGFueS9Db21wYW55JykpO1xuXG4gICAgY29uc3QgW3JvbGVzLCBzZXRSb2xlc10gPSBSZWFjdC51c2VTdGF0ZTxBcnJheTxTeXN0ZW1DZW50ZXIuU3lzdGVtQ2VuZXRlclNlY3VyaXR5Um9sZU5hbWU+PihbXSk7XG4gICAgY29uc3QgW2lnbm9yZWQsIGZvcmNlVXBkYXRlXSA9IFJlYWN0LnVzZVJlZHVjZXIoeCA9PiB4ICsgMSwgMCk7IC8vIGludGVnZXIgc3RhdGUgZm9yIHJlc2l6ZSByZW5kZXJzXG5cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gZ2V0Um9sZXMoKTtcbiAgICAgICAgaGFuZGxlLmRvbmUocnMgPT4gc2V0Um9sZXMocnMpKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChldnQpID0+IGZvcmNlVXBkYXRlKDEpKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUuYWJvcnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBoYW5kbGUuYWJvcnQoKTtcblxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIChldnQpID0+IHsgfSk7XG4gICAgICAgIH1cblxuICAgIH0sIFtdKTtcblxuICAgIGZ1bmN0aW9uIGdldFJvbGVzKCk6IEpRdWVyeS5qcVhIUjxBcnJheTxTeXN0ZW1DZW50ZXIuU3lzdGVtQ2VuZXRlclNlY3VyaXR5Um9sZU5hbWU+PiB7XG4gICAgICAgcmV0dXJuICQuYWpheCh7XG4gICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgdXJsOiBgJHtob21lUGF0aH1hcGkvU3lzdGVtQ2VudGVyL1NlY3VyaXR5Um9sZXNgLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJyxcbiAgICAgICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGFzeW5jOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhxdWVyeVN0cmluZy5wYXJzZShoaXN0b3J5LmxvY2F0aW9uLnNlYXJjaCkpLmxlbmd0aCA9PSAwKVxuICAgICAgICBoaXN0b3J5LnB1c2goeyBwYXRobmFtZTogaG9tZVBhdGggKyAnaW5kZXguY3NodG1sJywgc2VhcmNoOiAnbmFtZT1NZXRlcnMnLCBzdGF0ZToge30gfSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxSb3V0ZXI+XG4gICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdmJhciBuYXZiYXItZGFyayBmaXhlZC10b3AgYmctZGFyayBmbGV4LW1kLW5vd3JhcCBwLTAgc2hhZG93XCIgc3R5bGU9e3toZWlnaHQ6IDc1fX0+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwiY29sLXNtLTMgY29sLW1kLTIgbXItMFwiIHN0eWxlPXt7dGV4dEFsaWduOidjZW50ZXInfX1ocmVmPVwiaHR0cHM6Ly93d3cuZ3JpZHByb3RlY3Rpb25hbGxpYW5jZS5vcmdcIj48aW1nIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIG1hcmdpbjogLTUgfX0gc3JjPXtcIi4uL0ltYWdlcy9TeXN0ZW1DZW50ZXItVG9wTGVmdC5wbmdcIn0gLz48L2E+XG4gICAgICAgICAgICAgICAgey8qPGlucHV0IGNsYXNzTmFtZT1cImZvcm0tY29udHJvbCBmb3JtLWNvbnRyb2wtZGFyayB3LTEwMFwiIHR5cGU9XCJ0ZXh0XCIgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIiBhcmlhLWxhYmVsPVwiU2VhcmNoXCIvPiovfVxuICAgICAgICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJuYXZiYXItbmF2IHB4LTNcIj5cbiAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtIHRleHQtbm93cmFwXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGhyZWY9XCIjXCI+U2lnbiBvdXQ8L2E+XG4gICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgIDwvbmF2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250YWluZXItZmx1aWRcIiBzdHlsZT17eyB0b3A6IDc1LCAgcG9zaXRpb246ICdhYnNvbHV0ZScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJ2NhbGMoMTAwJSAtIDc1cHgpJywgb3ZlcmZsb3c6ICdoaWRkZW4nIH19PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCIgc3R5bGU9e3toZWlnaHQ6ICcxMDAlJ319PlxuICAgICAgICAgICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cImNvbCBiZy1saWdodCBzaWRlYmFyXCIgc3R5bGU9e3sgbWF4V2lkdGg6IDI1MCB9fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic2lkZWJhci1zdGlja3lcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIG1hcmdpblRvcDogNSwgdGV4dEFsaWduOiAnY2VudGVyJyB9fT48aDM+U3lzdGVtIENlbnRlcjwvaDM+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGhyIC8+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAxMCB9fSBjbGFzc05hbWU9XCJzaWRlYmFyLWhlYWRpbmdcIj5Nb25pdG9ycyBhbmQgQXNzZXRzPC9oNj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgc3R5bGU9e3sgbWFyZ2luTGVmdDogMTAgfX0gY2xhc3NOYW1lPVwibmF2IGZsZXgtY29sdW1uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgaXNBY3RpdmU9eyhtYXRjaCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoID09IGNvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9TWV0ZXJzXCJ9IHRvPXtjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPU1ldGVyc1wifT5NZXRlcnM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgaXNBY3RpdmU9eyhtYXRjaCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoID09IGNvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9TG9jYXRpb25zXCJ9IHRvPXtjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPUxvY2F0aW9uc1wifT5TdWJzdGF0aW9uczwvTmF2TGluaz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Bc3NldHNcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9QXNzZXRzXCJ9PlRyYW5zbWlzc2lvbiBBc3NldHM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgaXNBY3RpdmU9eyhtYXRjaCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoID09IGNvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9QXNzZXRHcm91cHNcIn0gdG89e2NvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9QXNzZXRHcm91cHNcIn0+QXNzZXQgR3JvdXBzPC9OYXZMaW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAxMCB9fSBjbGFzc05hbWU9XCJzaWRlYmFyLWhlYWRpbmdcIj5FeHRlcm5hbCBMaW5rczwvaDY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHN0eWxlPXt7IG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cIm5hdiBmbGV4LWNvbHVtblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPUNvbXBhbmllc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1Db21wYW5pZXNcIn0+Q29tcGFuaWVzPC9OYXZMaW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVBRVmlld0N1c3RvbWVyc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdDdXN0b21lcnNcIn0+UFFWaWV3IEN1c3RvbWVyIEFjY2VzczwvTmF2TGluaz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm5hdi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TmF2TGluayBhY3RpdmVDbGFzc05hbWU9J25hdi1saW5rIGFjdGl2ZScgY2xhc3NOYW1lPVwibmF2LWxpbmtcIiBpc0FjdGl2ZT17KG1hdGNoLCBsb2NhdGlvbikgPT4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggPT0gY29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdTaXRlc1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1QUVZpZXdTaXRlc1wifT5QUVZpZXcgU2l0ZXM8L05hdkxpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxociAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNiBzdHlsZT17e2ZvbnRXZWlnaHQ6ICdib2xkJywgbWFyZ2luTGVmdDogMTB9fSBjbGFzc05hbWU9XCJzaWRlYmFyLWhlYWRpbmdcIiBoaWRkZW49e3JvbGVzLmluZGV4T2YoJ0FkbWluaXN0cmF0b3InKSA8IDB9PlN5c3RlbSBTZXR0aW5nczwvaDY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHN0eWxlPXt7IG1hcmdpbkxlZnQ6IDEwIH19IGNsYXNzTmFtZT1cIm5hdiBmbGV4LWNvbHVtblwiIGhpZGRlbj17cm9sZXMuaW5kZXhPZignQWRtaW5pc3RyYXRvcicpIDwgMH0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJuYXYtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPE5hdkxpbmsgYWN0aXZlQ2xhc3NOYW1lPSduYXYtbGluayBhY3RpdmUnIGNsYXNzTmFtZT1cIm5hdi1saW5rXCIgaXNBY3RpdmU9eyhtYXRjaCwgbG9jYXRpb24pID0+IGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoID09IGNvbnRyb2xsZXJWaWV3UGF0aCArIFwiP25hbWU9VmFsdWVMaXN0c1wifSB0bz17Y29udHJvbGxlclZpZXdQYXRoICsgXCI/bmFtZT1WYWx1ZUxpc3RzXCJ9PlZhbHVlIExpc3RzPC9OYXZMaW5rPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDYgc3R5bGU9e3sgZm9udFdlaWdodDogJ2JvbGQnLCBtYXJnaW5MZWZ0OiAxMCB9fSBjbGFzc05hbWU9XCJzaWRlYmFyLWhlYWRpbmdcIiBoaWRkZW49e3JvbGVzLmluZGV4T2YoJ0FkbWluaXN0cmF0b3InKSA8IDB9PlVzZXIgU2V0dGluZ3M8L2g2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBzdHlsZT17eyBtYXJnaW5MZWZ0OiAxMCB9fSBjbGFzc05hbWU9XCJuYXYgZmxleC1jb2x1bW5cIiBoaWRkZW49e3JvbGVzLmluZGV4T2YoJ0FkbWluaXN0cmF0b3InKSA8IDB9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVVzZXJTdGF0aXN0aWNzXCJ9IHRvPXtjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVVzZXJTdGF0aXN0aWNzXCJ9PlVzZXIgU3RhdGlzdGljczwvTmF2TGluaz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibmF2LWl0ZW1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxOYXZMaW5rIGFjdGl2ZUNsYXNzTmFtZT0nbmF2LWxpbmsgYWN0aXZlJyBjbGFzc05hbWU9XCJuYXYtbGlua1wiIGlzQWN0aXZlPXsobWF0Y2gsIGxvY2F0aW9uKSA9PiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCA9PSBjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVVzZXJzXCJ9IHRvPXtjb250cm9sbGVyVmlld1BhdGggKyBcIj9uYW1lPVVzZXJzXCJ9PlVzZXJzPC9OYXZMaW5rPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIHRleHRBbGlnbjogJ2NlbnRlcicsIHBvc2l0aW9uOidhYnNvbHV0ZScsIGJvdHRvbTogNTAgfX0+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+VmVyc2lvbiB7IHZlcnNpb259PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9uYXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sXCIgc3R5bGU9e3sgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnaW5oZXJpdCcsIHBhZGRpbmc6ICcwIDAgMCAwJywgb3ZlcmZsb3c6ICdoaWRkZW4nIH19PlxuICAgICAgICAgICAgICAgICAgICAgICAgPFJlYWN0LlN1c3BlbnNlIGZhbGxiYWNrPXs8ZGl2PkxvYWRpbmcuLi48L2Rpdj59PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxTd2l0Y2g+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGNoaWxkcmVuPXsoeyBtYXRjaCwgLi4ucmVzdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBxcyA9IHF1ZXJ5U3RyaW5nLnBhcnNlKHJlc3QubG9jYXRpb24uc2VhcmNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHFzWyc/bmFtZSddID09IHVuZGVmaW5lZCB8fCBxc1snP25hbWUnXSA9PSBcIk1ldGVyc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEJ5TWV0ZXIgUm9sZXM9e3JvbGVzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiTG9jYXRpb25zXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlMb2NhdGlvbiBSb2xlcz17cm9sZXN9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJBc3NldHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlBc3NldCBSb2xlcz17cm9sZXN9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiQXNzZXRHcm91cHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlBc3NldEdyb3VwIFJvbGVzPXtyb2xlc30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJVc2Vyc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxCeVVzZXIgUm9sZXM9e3JvbGVzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIkNvbXBhbmllc1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxCeUNvbXBhbnkgUm9sZXM9e3JvbGVzfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIlVzZXJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8VXNlciBVc2VySUQ9e3FzLlVzZXJBY2NvdW50SUQgYXMgc3RyaW5nfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIlVzZXJTdGF0aXN0aWNzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPFVzZXJTdGF0aXN0aWNzIFJvbGVzPXtyb2xlc30gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJNZXRlclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxNZXRlciBNZXRlcklEPXtwYXJzZUludChxcy5NZXRlcklEIGFzIHN0cmluZyl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiTG9jYXRpb25cIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8TG9jYXRpb24gTG9jYXRpb25JRD17cGFyc2VJbnQocXMuTG9jYXRpb25JRCBhcyBzdHJpbmcpfSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxc1snP25hbWUnXSA9PSBcIkFzc2V0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEFzc2V0IEFzc2V0SUQ9e3BhcnNlSW50KHFzLkFzc2V0SUQgYXMgc3RyaW5nKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJBc3NldEdyb3VwXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gPEFzc2V0R3JvdXAgQXNzZXRHcm91cElEPXtwYXJzZUludChxcy5Bc3NldEdyb3VwSUQgYXMgc3RyaW5nKX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJDdXN0b21lclwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDdXN0b21lciBDdXN0b21lcklEPXtwYXJzZUludChxcy5DdXN0b21lcklEIGFzIHN0cmluZyl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiQ29tcGFueVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDb21wYW55IENvbXBhbnlJRD17cGFyc2VJbnQocXMuQ29tcGFueUlEIGFzIHN0cmluZyl9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiUFFWaWV3U2l0ZXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8aWZyYW1lIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH19IHNyYz17aG9tZVBhdGggKyAnUFFWaWV3RGF0YUxvYWRlci5jc2h0bWwnfT48L2lmcmFtZT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocXNbJz9uYW1lJ10gPT0gXCJQUVZpZXdDdXN0b21lcnNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8QnlDdXN0b21lciBSb2xlcz17cm9sZXN9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHFzWyc/bmFtZSddID09IFwiTmV3TWV0ZXJXaXphcmRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8TmV3TWV0ZXJXaXphcmQgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX0gLz5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxSb3V0ZSBjaGlsZHJlbj17KHsgbWF0Y2gsIC4uLnJlc3QgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm9sZXMuaW5kZXhPZignQWRtaW5pc3RyYXRvcicpIDwgMCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHF1ZXJ5U3RyaW5nLnBhcnNlKHJlc3QubG9jYXRpb24uc2VhcmNoKVsnP25hbWUnXSA9PSBcIlZhbHVlTGlzdHNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiA8aWZyYW1lIHN0eWxlPXt7IHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnIH19IHNyYz17aG9tZVBhdGggKyAnVmFsdWVMaXN0R3JvdXBzLmNzaHRtbCd9PjwvaWZyYW1lPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPFJvdXRlIGNoaWxkcmVuPXsoeyBtYXRjaCwgLi4ucmVzdCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb2xlcy5pbmRleE9mKCdBZG1pbmlzdHJhdG9yJykgPCAwICYmIHJvbGVzLmluZGV4T2YoJ1RyYW5zbWlzc2lvbiBTTUUnKSA8IDApIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChxdWVyeVN0cmluZy5wYXJzZShyZXN0LmxvY2F0aW9uLnNlYXJjaClbJz9uYW1lJ10gPT0gXCJDb25maWd1cmF0aW9uSGlzdG9yeVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDxDb25maWd1cmF0aW9uSGlzdG9yeSBNZXRlckNvbmZpZ3VyYXRpb25JRD17cGFyc2VJbnQocXVlcnlTdHJpbmcucGFyc2UocmVzdC5sb2NhdGlvbi5zZWFyY2gpLk1ldGVyQ29uZmlndXJhdGlvbklEIGFzIHN0cmluZyl9IE1ldGVyS2V5PXtxdWVyeVN0cmluZy5wYXJzZShyZXN0LmxvY2F0aW9uLnNlYXJjaCkuTWV0ZXJLZXkgYXMgc3RyaW5nfS8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvU3dpdGNoPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8L1JlYWN0LlN1c3BlbnNlPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvUm91dGVyPlxuICAgIClcbn1cblxuUmVhY3RET00ucmVuZGVyKDxQcm92aWRlciBzdG9yZT17c3RvcmV9PjxTeXN0ZW1DZW50ZXIgLz48L1Byb3ZpZGVyPiwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dpbmRvdycpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZDM7IiwibW9kdWxlLmV4cG9ydHMgPSBSZWFjdDsiLCJtb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NOyIsIm1vZHVsZS5leHBvcnRzID0gUmVhY3RSb3V0ZXJET007Il0sInNvdXJjZVJvb3QiOiIifQ==